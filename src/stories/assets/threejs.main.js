/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "179";
const MOUSE = { ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const AgXToneMapping = 6;
const NeutralToneMapping = 7;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const UnsignedInt5999Type = 35902;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const RED_RGTC1_Format = 36283;
const SIGNED_RED_RGTC1_Format = 36284;
const RED_GREEN_RGTC2_Format = 36285;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const NoColorSpace = "";
const SRGBColorSpace = "srgb";
const LinearSRGBColorSpace = "srgb-linear";
const LinearTransfer = "linear";
const SRGBTransfer = "srgb";
const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;
const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;
const NeverCompare = 512;
const LessCompare = 513;
const EqualCompare = 514;
const LessEqualCompare = 515;
const GreaterCompare = 516;
const NotEqualCompare = 517;
const GreaterEqualCompare = 518;
const AlwaysCompare = 519;
const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const WebGLCoordinateSystem = 2e3;
const WebGPUCoordinateSystem = 2001;
class EventDispatcher {
  /**
   * Adds the given event listener to the given event type.
   *
   * @param {string} type - The type of event to listen to.
   * @param {Function} listener - The function that gets called when the event is fired.
   */
  addEventListener(type, listener) {
    if (this._listeners === void 0) this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  /**
   * Returns `true` if the given event listener has been added to the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to check.
   * @return {boolean} Whether the given event listener has been added to the given event type.
   */
  hasEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners === void 0) return false;
    return (
      listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1
    );
  }
  /**
   * Removes the given event listener from the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to remove.
   */
  removeEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners === void 0) return;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  /**
   * Dispatches an event object.
   *
   * @param {Object} event - The event that gets fired.
   */
  dispatchEvent(event) {
    const listeners = this._listeners;
    if (listeners === void 0) return;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array2 = listenerArray.slice(0);
      for (let i2 = 0, l2 = array2.length; i2 < l2; i2++) {
        array2[i2].call(this, event);
      }
      event.target = null;
    }
  }
}
const _lut = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = (Math.random() * 4294967295) | 0;
  const d1 = (Math.random() * 4294967295) | 0;
  const d2 = (Math.random() * 4294967295) | 0;
  const d3 = (Math.random() * 4294967295) | 0;
  const uuid =
    _lut[d0 & 255] +
    _lut[(d0 >> 8) & 255] +
    _lut[(d0 >> 16) & 255] +
    _lut[(d0 >> 24) & 255] +
    "-" +
    _lut[d1 & 255] +
    _lut[(d1 >> 8) & 255] +
    "-" +
    _lut[((d1 >> 16) & 15) | 64] +
    _lut[(d1 >> 24) & 255] +
    "-" +
    _lut[(d2 & 63) | 128] +
    _lut[(d2 >> 8) & 255] +
    "-" +
    _lut[(d2 >> 16) & 255] +
    _lut[(d2 >> 24) & 255] +
    _lut[d3 & 255] +
    _lut[(d3 >> 8) & 255] +
    _lut[(d3 >> 16) & 255] +
    _lut[(d3 >> 24) & 255];
  return uuid.toLowerCase();
}
function clamp$1(value, min2, max2) {
  return Math.max(min2, Math.min(max2, value));
}
function euclideanModulo(n2, m) {
  return ((n2 % m) + m) % m;
}
function mapLinear(x, a1, a2, b1, b2) {
  return b1 + ((x - a1) * (b2 - b1)) / (a2 - a1);
}
function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
}
function lerp(x, y, t2) {
  return (1 - t2) * x + t2 * y;
}
function damp(x, y, lambda, dt) {
  return lerp(x, y, 1 - Math.exp(-lambda * dt));
}
function pingpong(x, length2 = 1) {
  return length2 - Math.abs(euclideanModulo(x, length2 * 2) - length2);
}
function smoothstep$1(x, min2, max2) {
  if (x <= min2) return 0;
  if (x >= max2) return 1;
  x = (x - min2) / (max2 - min2);
  return x * x * (3 - 2 * x);
}
function smootherstep(x, min2, max2) {
  if (x <= min2) return 0;
  if (x >= max2) return 1;
  x = (x - min2) / (max2 - min2);
  return x * x * x * (x * (x * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range2) {
  return range2 * (0.5 - Math.random());
}
function seededRandom(s2) {
  if (s2 !== void 0) _seed = s2;
  let t2 = (_seed += 1831565813);
  t2 = Math.imul(t2 ^ (t2 >>> 15), t2 | 1);
  t2 ^= t2 + Math.imul(t2 ^ (t2 >>> 7), t2 | 61);
  return ((t2 ^ (t2 >>> 14)) >>> 0) / 4294967296;
}
function degToRad(degrees2) {
  return degrees2 * DEG2RAD;
}
function radToDeg(radians2) {
  return radians2 * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & (value - 1)) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a2, b, c2, order) {
  const cos2 = Math.cos;
  const sin2 = Math.sin;
  const c22 = cos2(b / 2);
  const s2 = sin2(b / 2);
  const c13 = cos2((a2 + c2) / 2);
  const s13 = sin2((a2 + c2) / 2);
  const c1_3 = cos2((a2 - c2) / 2);
  const s1_3 = sin2((a2 - c2) / 2);
  const c3_1 = cos2((c2 - a2) / 2);
  const s3_1 = sin2((c2 - a2) / 2);
  switch (order) {
    case "XYX":
      q.set(c22 * s13, s2 * c1_3, s2 * s1_3, c22 * c13);
      break;
    case "YZY":
      q.set(s2 * s1_3, c22 * s13, s2 * c1_3, c22 * c13);
      break;
    case "ZXZ":
      q.set(s2 * c1_3, s2 * s1_3, c22 * s13, c22 * c13);
      break;
    case "XZX":
      q.set(c22 * s13, s2 * s3_1, s2 * c3_1, c22 * c13);
      break;
    case "YXY":
      q.set(s2 * c3_1, c22 * s13, s2 * s3_1, c22 * c13);
      break;
    case "ZYZ":
      q.set(s2 * s3_1, s2 * c3_1, c22 * s13, c22 * c13);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          order
      );
  }
}
function denormalize(value, array2) {
  switch (array2.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize$1(value, array2) {
  switch (array2.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const MathUtils = {
  DEG2RAD,
  RAD2DEG,
  /**
   * Generate a [UUID]{@link https://en.wikipedia.org/wiki/Universally_unique_identifier}
   * (universally unique identifier).
   *
   * @static
   * @method
   * @return {string} The UUID.
   */
  generateUUID,
  /**
   * Clamps the given value between min and max.
   *
   * @static
   * @method
   * @param {number} value - The value to clamp.
   * @param {number} min - The min value.
   * @param {number} max - The max value.
   * @return {number} The clamped value.
   */
  clamp: clamp$1,
  /**
   * Computes the Euclidean modulo of the given parameters that
   * is `( ( n % m ) + m ) % m`.
   *
   * @static
   * @method
   * @param {number} n - The first parameter.
   * @param {number} m - The second parameter.
   * @return {number} The Euclidean modulo.
   */
  euclideanModulo,
  /**
   * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
   * for the given value.
   *
   * @static
   * @method
   * @param {number} x - The value to be mapped.
   * @param {number} a1 - Minimum value for range A.
   * @param {number} a2 - Maximum value for range A.
   * @param {number} b1 - Minimum value for range B.
   * @param {number} b2 - Maximum value for range B.
   * @return {number} The mapped value.
   */
  mapLinear,
  /**
   * Returns the percentage in the closed interval `[0, 1]` of the given value
   * between the start and end point.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} value - A value between start and end.
   * @return {number} The interpolation factor.
   */
  inverseLerp,
  /**
   * Returns a value linearly interpolated from two known points based on the given interval -
   * `t = 0` will return `x` and `t = 1` will return `y`.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {number} The interpolated value.
   */
  lerp,
  /**
   * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
   * time to maintain frame rate independent movement. For details, see
   * [Frame rate independent damping using lerp]{@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}.
   *
   * @static
   * @method
   * @param {number} x - The current point.
   * @param {number} y - The target point.
   * @param {number} lambda - A higher lambda value will make the movement more sudden,
   * and a lower value will make the movement more gradual.
   * @param {number} dt - Delta time in seconds.
   * @return {number} The interpolated value.
   */
  damp,
  /**
   * Returns a value that alternates between `0` and the given `length` parameter.
   *
   * @static
   * @method
   * @param {number} x - The value to pingpong.
   * @param {number} [length=1] - The positive value the function will pingpong to.
   * @return {number} The alternated value.
   */
  pingpong,
  /**
   * Returns a value in the range `[0,1]` that represents the percentage that `x` has
   * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
   * the `min` and `max`.
   *
   * See [Smoothstep]{@link http://en.wikipedia.org/wiki/Smoothstep} for more details.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smoothstep: smoothstep$1,
  /**
   * A [variation on smoothstep]{@link https://en.wikipedia.org/wiki/Smoothstep#Variations}
   * that has zero 1st and 2nd order derivatives at x=0 and x=1.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smootherstep,
  /**
   * Returns a random integer from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random integer.
   */
  randInt,
  /**
   * Returns a random float from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random float.
   */
  randFloat,
  /**
   * Returns a random integer from `<-range/2, range/2>` interval.
   *
   * @static
   * @method
   * @param {number} range - Defines the value range.
   * @return {number} A random float.
   */
  randFloatSpread,
  /**
   * Returns a deterministic pseudo-random float in the interval `[0, 1]`.
   *
   * @static
   * @method
   * @param {number} [s] - The integer seed.
   * @return {number} A random float.
   */
  seededRandom,
  /**
   * Converts degrees to radians.
   *
   * @static
   * @method
   * @param {number} degrees - A value in degrees.
   * @return {number} The converted value in radians.
   */
  degToRad,
  /**
   * Converts radians to degrees.
   *
   * @static
   * @method
   * @param {number} radians - A value in radians.
   * @return {number} The converted value in degrees.
   */
  radToDeg,
  /**
   * Returns `true` if the given number is a power of two.
   *
   * @static
   * @method
   * @param {number} value - The value to check.
   * @return {boolean} Whether the given number is a power of two or not.
   */
  isPowerOfTwo,
  /**
   * Returns the smallest power of two that is greater than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The smallest power of two that is greater than or equal to the given number.
   */
  ceilPowerOfTwo,
  /**
   * Returns the largest power of two that is less than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The largest power of two that is less than or equal to the given number.
   */
  floorPowerOfTwo,
  /**
   * Sets the given quaternion from the [Intrinsic Proper Euler Angles]{@link https://en.wikipedia.org/wiki/Euler_angles}
   * defined by the given angles and order.
   *
   * Rotations are applied to the axes in the order specified by order:
   * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
   *
   * @static
   * @method
   * @param {Quaternion} q - The quaternion to set.
   * @param {number} a - The rotation applied to the first axis, in radians.
   * @param {number} b - The rotation applied to the second axis, in radians.
   * @param {number} c - The rotation applied to the third axis, in radians.
   * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
   */
  setQuaternionFromProperEuler,
  /**
   * Normalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The float value in the range `[0,1]` to normalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The normalize value.
   */
  normalize: normalize$1,
  /**
   * Denormalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The value to denormalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The denormalize (float) value in the range `[0,1]`.
   */
  denormalize,
};
class Vector2 {
  /**
   * Constructs a new 2D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   */
  constructor(x = 0, y = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }
  /**
   * Alias for {@link Vector2#x}.
   *
   * @type {number}
   */
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  /**
   * Alias for {@link Vector2#y}.
   *
   * @type {number}
   */
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @return {Vector2} A reference to this vector.
   */
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector2} A reference to this vector.
   */
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setX(x) {
    this.x = x;
    return this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setY(y) {
    this.y = y;
    return this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @param {number} value - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @return {number} A vector component value.
   */
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector2} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector2} v - The vector to copy.
   * @return {Vector2} A reference to this vector.
   */
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector2} v - The vector to add.
   * @return {Vector2} A reference to this vector.
   */
  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector2} A reference to this vector.
   */
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    return this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  addVectors(a2, b) {
    this.x = a2.x + b.x;
    this.y = a2.y + b.y;
    return this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector2} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector2} A reference to this vector.
   */
  addScaledVector(v, s2) {
    this.x += v.x * s2;
    this.y += v.y * s2;
    return this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector2} v - The vector to subtract.
   * @return {Vector2} A reference to this vector.
   */
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector2} A reference to this vector.
   */
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    return this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  subVectors(a2, b) {
    this.x = a2.x - b.x;
    this.y = a2.y - b.y;
    return this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector2} v - The vector to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector2} v - The vector to divide.
   * @return {Vector2} A reference to this vector.
   */
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector2} A reference to this vector.
   */
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  /**
   * Multiplies this vector (with an implicit 1 as the 3rd component) by
   * the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {Vector2} A reference to this vector.
   */
  applyMatrix3(m) {
    const x = this.x,
      y = this.y;
    const e2 = m.elements;
    this.x = e2[0] * x + e2[3] * y + e2[6];
    this.y = e2[1] * x + e2[4] * y + e2[7];
    return this;
  }
  /**
   * If this vector's x or y value is greater than the given vector's x or y
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  /**
   * If this vector's x or y value is less than the given vector's x or y
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  /**
   * If this vector's x or y value is greater than the max vector's x or y
   * value, it is replaced by the corresponding value.
   * If this vector's x or y value is less than the min vector's x or y value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector2} min - The minimum x and y values.
   * @param {Vector2} max - The maximum x and y values in the desired range.
   * @return {Vector2} A reference to this vector.
   */
  clamp(min2, max2) {
    this.x = clamp$1(this.x, min2.x, max2.x);
    this.y = clamp$1(this.y, min2.y, max2.y);
    return this;
  }
  /**
   * If this vector's x or y values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x or y values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampScalar(minVal, maxVal) {
    this.x = clamp$1(this.x, minVal, maxVal);
    this.y = clamp$1(this.y, minVal, maxVal);
    return this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampLength(min2, max2) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(
      clamp$1(length2, min2, max2)
    );
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector2} A reference to this vector.
   */
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x and y = -y.
   *
   * @return {Vector2} A reference to this vector.
   */
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the cross product with.
   * @return {number} The result of the cross product.
   */
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Computes the angle in radians of this vector with respect to the positive x-axis.
   *
   * @return {number} The angle in radians.
   */
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector2} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp$1(theta, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector2} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(v) {
    const dx = this.x - v.x,
      dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector2} A reference to this vector.
   */
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector2} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector2} v1 - The first vector.
   * @param {Vector2} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector2} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]` and y
   * value to be `array[ offset + 1 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector2} A reference to this vector.
   */
  fromArray(array2, offset = 0) {
    this.x = array2[offset];
    this.y = array2[offset + 1];
    return this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(array2 = [], offset = 0) {
    array2[offset] = this.x;
    array2[offset + 1] = this.y;
    return array2;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector2} A reference to this vector.
   */
  fromBufferAttribute(attribute2, index) {
    this.x = attribute2.getX(index);
    this.y = attribute2.getY(index);
    return this;
  }
  /**
   * Rotates this vector around the given center by the given angle.
   *
   * @param {Vector2} center - The point around which to rotate.
   * @param {number} angle - The angle to rotate, in radians.
   * @return {Vector2} A reference to this vector.
   */
  rotateAround(center, angle) {
    const c2 = Math.cos(angle),
      s2 = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c2 - y * s2 + center.x;
    this.y = x * s2 + y * c2 + center.y;
    return this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
}
class Quaternion {
  /**
   * Constructs a new quaternion.
   *
   * @param {number} [x=0] - The x value of this quaternion.
   * @param {number} [y=0] - The y value of this quaternion.
   * @param {number} [z=0] - The z value of this quaternion.
   * @param {number} [w=1] - The w value of this quaternion.
   */
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  /**
   * Interpolates between two quaternions via SLERP. This implementation assumes the
   * quaternion data are managed  in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @param {number} t - The interpolation factor in the range `[0,1]`.
   * @see {@link Quaternion#slerp}
   */
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
    let x0 = src0[srcOffset0 + 0],
      y0 = src0[srcOffset0 + 1],
      z0 = src0[srcOffset0 + 2],
      w02 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0],
      y1 = src1[srcOffset1 + 1],
      z1 = src1[srcOffset1 + 2],
      w12 = src1[srcOffset1 + 3];
    if (t2 === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w02;
      return;
    }
    if (t2 === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w12;
      return;
    }
    if (w02 !== w12 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s2 = 1 - t2;
      const cos2 = x0 * x1 + y0 * y1 + z0 * z1 + w02 * w12,
        dir = cos2 >= 0 ? 1 : -1,
        sqrSin = 1 - cos2 * cos2;
      if (sqrSin > Number.EPSILON) {
        const sin2 = Math.sqrt(sqrSin),
          len = Math.atan2(sin2, cos2 * dir);
        s2 = Math.sin(s2 * len) / sin2;
        t2 = Math.sin(t2 * len) / sin2;
      }
      const tDir = t2 * dir;
      x0 = x0 * s2 + x1 * tDir;
      y0 = y0 * s2 + y1 * tDir;
      z0 = z0 * s2 + z1 * tDir;
      w02 = w02 * s2 + w12 * tDir;
      if (s2 === 1 - t2) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w02 * w02);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w02 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w02;
  }
  /**
   * Multiplies two quaternions. This implementation assumes the quaternion data are managed
   * in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @return {Array<number>} The destination array.
   * @see {@link Quaternion#multiplyQuaternions}.
   */
  static multiplyQuaternionsFlat(
    dst,
    dstOffset,
    src0,
    srcOffset0,
    src1,
    srcOffset1
  ) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w02 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w12 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w12 + w02 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w12 + w02 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w12 + w02 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w02 * w12 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  /**
   * The x value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  /**
   * The y value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  /**
   * The z value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  /**
   * The w value of this quaternion.
   *
   * @type {number}
   * @default 1
   */
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  /**
   * Sets the quaternion components.
   *
   * @param {number} x - The x value of this quaternion.
   * @param {number} y - The y value of this quaternion.
   * @param {number} z - The z value of this quaternion.
   * @param {number} w - The w value of this quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  /**
   * Returns a new quaternion with copied values from this instance.
   *
   * @return {Quaternion} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  /**
   * Copies the values of the given quaternion to this instance.
   *
   * @param {Quaternion} quaternion - The quaternion to copy.
   * @return {Quaternion} A reference to this quaternion.
   */
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  /**
   * Sets this quaternion from the rotation specified by the given
   * Euler angles.
   *
   * @param {Euler} euler - The Euler angles.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromEuler(euler, update = true) {
    const x = euler._x,
      y = euler._y,
      z = euler._z,
      order = euler._order;
    const cos2 = Math.cos;
    const sin2 = Math.sin;
    const c1 = cos2(x / 2);
    const c2 = cos2(y / 2);
    const c3 = cos2(z / 2);
    const s1 = sin2(x / 2);
    const s2 = sin2(y / 2);
    const s3 = sin2(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
            order
        );
    }
    if (update === true) this._onChangeCallback();
    return this;
  }
  /**
   * Sets this quaternion from the given axis and angle.
   *
   * @param {Vector3} axis - The normalized axis.
   * @param {number} angle - The angle in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2,
      s2 = Math.sin(halfAngle);
    this._x = axis.x * s2;
    this._y = axis.y * s2;
    this._z = axis.z * s2;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  /**
   * Sets this quaternion from the given rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromRotationMatrix(m) {
    const te = m.elements,
      m11 = te[0],
      m12 = te[4],
      m13 = te[8],
      m21 = te[1],
      m22 = te[5],
      m23 = te[9],
      m31 = te[2],
      m32 = te[6],
      m33 = te[10],
      trace = m11 + m22 + m33;
    if (trace > 0) {
      const s2 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s2;
      this._x = (m32 - m23) * s2;
      this._y = (m13 - m31) * s2;
      this._z = (m21 - m12) * s2;
    } else if (m11 > m22 && m11 > m33) {
      const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s2;
      this._x = 0.25 * s2;
      this._y = (m12 + m21) / s2;
      this._z = (m13 + m31) / s2;
    } else if (m22 > m33) {
      const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s2;
      this._x = (m12 + m21) / s2;
      this._y = 0.25 * s2;
      this._z = (m23 + m32) / s2;
    } else {
      const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s2;
      this._x = (m13 + m31) / s2;
      this._y = (m23 + m32) / s2;
      this._z = 0.25 * s2;
    }
    this._onChangeCallback();
    return this;
  }
  /**
   * Sets this quaternion to the rotation required to rotate the direction vector
   * `vFrom` to the direction vector `vTo`.
   *
   * @param {Vector3} vFrom - The first (normalized) direction vector.
   * @param {Vector3} vTo - The second (normalized) direction vector.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromUnitVectors(vFrom, vTo) {
    let r2 = vFrom.dot(vTo) + 1;
    if (r2 < 1e-8) {
      r2 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r2;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r2;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r2;
    }
    return this.normalize();
  }
  /**
   * Returns the angle between this quaternion and the given one in radians.
   *
   * @param {Quaternion} q - The quaternion to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp$1(this.dot(q), -1, 1)));
  }
  /**
   * Rotates this quaternion by a given angular step to the given quaternion.
   * The method ensures that the final quaternion will not overshoot `q`.
   *
   * @param {Quaternion} q - The target quaternion.
   * @param {number} step - The angular step in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  rotateTowards(q, step2) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t2 = Math.min(1, step2 / angle);
    this.slerp(q, t2);
    return this;
  }
  /**
   * Sets this quaternion to the identity quaternion; that is, to the
   * quaternion that represents "no rotation".
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  identity() {
    return this.set(0, 0, 0, 1);
  }
  /**
   * Inverts this quaternion via {@link Quaternion#conjugate}. The
   * quaternion is assumed to have unit length.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  invert() {
    return this.conjugate();
  }
  /**
   * Returns the rotational conjugate of this quaternion. The conjugate of a
   * quaternion represents the same rotation in the opposite direction about
   * the rotational axis.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  /**
   * Calculates the dot product of this quaternion and the given one.
   *
   * @param {Quaternion} v - The quaternion to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  /**
   * Computes the squared Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector. This can be useful if you are comparing the
   * lengths of two quaternions, as this is a slightly more efficient calculation than
   * {@link Quaternion#length}.
   *
   * @return {number} The squared Euclidean length.
   */
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  /**
   * Computes the Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector.
   *
   * @return {number} The Euclidean length.
   */
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  /**
   * Normalizes this quaternion - that is, calculated the quaternion that performs
   * the same rotation as this one, but has a length equal to `1`.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  normalize() {
    let l2 = this.length();
    if (l2 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l2 = 1 / l2;
      this._x = this._x * l2;
      this._y = this._y * l2;
      this._z = this._z * l2;
      this._w = this._w * l2;
    }
    this._onChangeCallback();
    return this;
  }
  /**
   * Multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  /**
   * Pre-multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  /**
   * Multiplies the given quaternions and stores the result in this instance.
   *
   * @param {Quaternion} a - The first quaternion.
   * @param {Quaternion} b - The second quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiplyQuaternions(a2, b) {
    const qax = a2._x,
      qay = a2._y,
      qaz = a2._z,
      qaw = a2._w;
    const qbx = b._x,
      qby = b._y,
      qbz = b._z,
      qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  /**
   * Performs a spherical linear interpolation between quaternions.
   *
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerp(qb, t2) {
    if (t2 === 0) return this;
    if (t2 === 1) return this.copy(qb);
    const x = this._x,
      y = this._y,
      z = this._z,
      w = this._w;
    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s2 = 1 - t2;
      this._w = s2 * w + t2 * this._w;
      this._x = s2 * x + t2 * this._x;
      this._y = s2 * y + t2 * this._y;
      this._z = s2 * z + t2 * this._z;
      this.normalize();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta,
      ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  /**
   * Performs a spherical linear interpolation between the given quaternions
   * and stores the result in this quaternion.
   *
   * @param {Quaternion} qa - The source quaternion.
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerpQuaternions(qa, qb, t2) {
    return this.copy(qa).slerp(qb, t2);
  }
  /**
   * Sets this quaternion to a uniformly random, normalized quaternion.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  random() {
    const theta1 = 2 * Math.PI * Math.random();
    const theta2 = 2 * Math.PI * Math.random();
    const x0 = Math.random();
    const r1 = Math.sqrt(1 - x0);
    const r2 = Math.sqrt(x0);
    return this.set(
      r1 * Math.sin(theta1),
      r1 * Math.cos(theta1),
      r2 * Math.sin(theta2),
      r2 * Math.cos(theta2)
    );
  }
  /**
   * Returns `true` if this quaternion is equal with the given one.
   *
   * @param {Quaternion} quaternion - The quaternion to test for equality.
   * @return {boolean} Whether this quaternion is equal with the given one.
   */
  equals(quaternion) {
    return (
      quaternion._x === this._x &&
      quaternion._y === this._y &&
      quaternion._z === this._z &&
      quaternion._w === this._w
    );
  }
  /**
   * Sets this quaternion's components from the given array.
   *
   * @param {Array<number>} array - An array holding the quaternion component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromArray(array2, offset = 0) {
    this._x = array2[offset];
    this._y = array2[offset + 1];
    this._z = array2[offset + 2];
    this._w = array2[offset + 3];
    this._onChangeCallback();
    return this;
  }
  /**
   * Writes the components of this quaternion to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The quaternion components.
   */
  toArray(array2 = [], offset = 0) {
    array2[offset] = this._x;
    array2[offset + 1] = this._y;
    array2[offset + 2] = this._z;
    array2[offset + 3] = this._w;
    return array2;
  }
  /**
   * Sets the components of this quaternion from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
   * @param {number} index - The index into the attribute.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromBufferAttribute(attribute2, index) {
    this._x = attribute2.getX(index);
    this._y = attribute2.getY(index);
    this._z = attribute2.getZ(index);
    this._w = attribute2.getW(index);
    this._onChangeCallback();
    return this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the
   * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
   *
   * @return {Array<number>} The serialized quaternion.
   */
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
}
class Vector3 {
  /**
   * Constructs a new 3D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   */
  constructor(x = 0, y = 0, z = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @return {Vector3} A reference to this vector.
   */
  set(x, y, z) {
    if (z === void 0) z = this.z;
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector3} A reference to this vector.
   */
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setX(x) {
    this.x = x;
    return this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setY(y) {
    this.y = y;
    return this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setZ(z) {
    this.z = z;
    return this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @param {number} value - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @return {number} A vector component value.
   */
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector3} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3} v - The vector to copy.
   * @return {Vector3} A reference to this vector.
   */
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector3} v - The vector to add.
   * @return {Vector3} A reference to this vector.
   */
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector3} A reference to this vector.
   */
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    return this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  addVectors(a2, b) {
    this.x = a2.x + b.x;
    this.y = a2.y + b.y;
    this.z = a2.z + b.z;
    return this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector3|Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector3} A reference to this vector.
   */
  addScaledVector(v, s2) {
    this.x += v.x * s2;
    this.y += v.y * s2;
    this.z += v.z * s2;
    return this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector3} v - The vector to subtract.
   * @return {Vector3} A reference to this vector.
   */
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector3} A reference to this vector.
   */
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    return this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  subVectors(a2, b) {
    this.x = a2.x - b.x;
    this.y = a2.y - b.y;
    this.z = a2.z - b.z;
    return this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector3} v - The vector to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  /**
   * Multiplies the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  multiplyVectors(a2, b) {
    this.x = a2.x * b.x;
    this.y = a2.y * b.y;
    this.z = a2.z * b.z;
    return this;
  }
  /**
   * Applies the given Euler rotation to this vector.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Vector3} A reference to this vector.
   */
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  /**
   * Applies a rotation specified by an axis and an angle to this vector.
   *
   * @param {Vector3} axis - A normalized vector representing the rotation axis.
   * @param {number} angle - The angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  /**
   * Multiplies this vector with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix3(m) {
    const x = this.x,
      y = this.y,
      z = this.z;
    const e2 = m.elements;
    this.x = e2[0] * x + e2[3] * y + e2[6] * z;
    this.y = e2[1] * x + e2[4] * y + e2[7] * z;
    this.z = e2[2] * x + e2[5] * y + e2[8] * z;
    return this;
  }
  /**
   * Multiplies this vector by the given normal matrix and normalizes
   * the result.
   *
   * @param {Matrix3} m - The normal matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  /**
   * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
   * divides by perspective.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix4(m) {
    const x = this.x,
      y = this.y,
      z = this.z;
    const e2 = m.elements;
    const w = 1 / (e2[3] * x + e2[7] * y + e2[11] * z + e2[15]);
    this.x = (e2[0] * x + e2[4] * y + e2[8] * z + e2[12]) * w;
    this.y = (e2[1] * x + e2[5] * y + e2[9] * z + e2[13]) * w;
    this.z = (e2[2] * x + e2[6] * y + e2[10] * z + e2[14]) * w;
    return this;
  }
  /**
   * Applies the given Quaternion to this vector.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Vector3} A reference to this vector.
   */
  applyQuaternion(q) {
    const vx = this.x,
      vy = this.y,
      vz = this.z;
    const qx = q.x,
      qy = q.y,
      qz = q.z,
      qw = q.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this.x = vx + qw * tx + qy * tz - qz * ty;
    this.y = vy + qw * ty + qz * tx - qx * tz;
    this.z = vz + qw * tz + qx * ty - qy * tx;
    return this;
  }
  /**
   * Projects this vector from world space into the camera's normalized
   * device coordinate (NDC) space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  project(camera2) {
    return this.applyMatrix4(camera2.matrixWorldInverse).applyMatrix4(
      camera2.projectionMatrix
    );
  }
  /**
   * Unprojects this vector from the camera's normalized device coordinate (NDC)
   * space into world space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  unproject(camera2) {
    return this.applyMatrix4(camera2.projectionMatrixInverse).applyMatrix4(
      camera2.matrixWorld
    );
  }
  /**
   * Transforms the direction of this vector by a matrix (the upper left 3 x 3
   * subset of the given 4x4 matrix and then normalizes the result.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Vector3} A reference to this vector.
   */
  transformDirection(m) {
    const x = this.x,
      y = this.y,
      z = this.z;
    const e2 = m.elements;
    this.x = e2[0] * x + e2[4] * y + e2[8] * z;
    this.y = e2[1] * x + e2[5] * y + e2[9] * z;
    this.z = e2[2] * x + e2[6] * y + e2[10] * z;
    return this.normalize();
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector3} v - The vector to divide.
   * @return {Vector3} A reference to this vector.
   */
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector3} A reference to this vector.
   */
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  /**
   * If this vector's x, y or z value is greater than the given vector's x, y or z
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  /**
   * If this vector's x, y or z value is less than the given vector's x, y or z
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  /**
   * If this vector's x, y or z value is greater than the max vector's x, y or z
   * value, it is replaced by the corresponding value.
   * If this vector's x, y or z value is less than the min vector's x, y or z value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector3} min - The minimum x, y and z values.
   * @param {Vector3} max - The maximum x, y and z values in the desired range.
   * @return {Vector3} A reference to this vector.
   */
  clamp(min2, max2) {
    this.x = clamp$1(this.x, min2.x, max2.x);
    this.y = clamp$1(this.y, min2.y, max2.y);
    this.z = clamp$1(this.z, min2.z, max2.z);
    return this;
  }
  /**
   * If this vector's x, y or z values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y or z values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampScalar(minVal, maxVal) {
    this.x = clamp$1(this.x, minVal, maxVal);
    this.y = clamp$1(this.y, minVal, maxVal);
    this.z = clamp$1(this.z, minVal, maxVal);
    return this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampLength(min2, max2) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(
      clamp$1(length2, min2, max2)
    );
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector3} A reference to this vector.
   */
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
   *
   * @return {Vector3} A reference to this vector.
   */
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  // TODO lengthSquared?
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector3} A reference to this vector.
   */
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector3} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector3} v1 - The first vector.
   * @param {Vector3} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the cross product with.
   * @return {Vector3} The result of the cross product.
   */
  cross(v) {
    return this.crossVectors(this, v);
  }
  /**
   * Calculates the cross product of the given vectors and stores the result
   * in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  crossVectors(a2, b) {
    const ax = a2.x,
      ay = a2.y,
      az = a2.z;
    const bx = b.x,
      by = b.y,
      bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  /**
   * Projects this vector onto the given one.
   *
   * @param {Vector3} v - The vector to project to.
   * @return {Vector3} A reference to this vector.
   */
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  /**
   * Projects this vector onto a plane by subtracting this
   * vector projected onto the plane's normal from this vector.
   *
   * @param {Vector3} planeNormal - The plane normal.
   * @return {Vector3} A reference to this vector.
   */
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  /**
   * Reflects this vector off a plane orthogonal to the given normal vector.
   *
   * @param {Vector3} normal - The (normalized) normal vector.
   * @return {Vector3} A reference to this vector.
   */
  reflect(normal2) {
    return this.sub(
      _vector$c.copy(normal2).multiplyScalar(2 * this.dot(normal2))
    );
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector3} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp$1(theta, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector3} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(v) {
    const dx = this.x - v.x,
      dy = this.y - v.y,
      dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(v) {
    return (
      Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z)
    );
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {Spherical} s - The spherical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromSpherical(s2) {
    return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The phi angle in radians.
   * @param {number} theta - The theta angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {Cylindrical} c - The cylindrical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindrical(c2) {
    return this.setFromCylindricalCoords(c2.radius, c2.theta, c2.y);
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} theta - The theta angle in radians.
   * @param {number} y - The y value.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixPosition(m) {
    const e2 = m.elements;
    this.x = e2[12];
    this.y = e2[13];
    this.z = e2[14];
    return this;
  }
  /**
   * Sets the vector components to the scale elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  /**
   * Sets the vector components from the given Euler angles.
   *
   * @param {Euler} e - The Euler angles to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromEuler(e2) {
    this.x = e2._x;
    this.y = e2._y;
    this.z = e2._z;
    return this;
  }
  /**
   * Sets the vector components from the RGB components of the
   * given color.
   *
   * @param {Color} c - The color to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromColor(c2) {
    this.x = c2.r;
    this.y = c2.g;
    this.z = c2.b;
    return this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector3} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
   * and z value to be `array[ offset + 2 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector3} A reference to this vector.
   */
  fromArray(array2, offset = 0) {
    this.x = array2[offset];
    this.y = array2[offset + 1];
    this.z = array2[offset + 2];
    return this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(array2 = [], offset = 0) {
    array2[offset] = this.x;
    array2[offset + 1] = this.y;
    array2[offset + 2] = this.z;
    return array2;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector3} A reference to this vector.
   */
  fromBufferAttribute(attribute2, index) {
    this.x = attribute2.getX(index);
    this.y = attribute2.getY(index);
    this.z = attribute2.getZ(index);
    return this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  /**
   * Sets this vector to a uniformly random point on a unit sphere.
   *
   * @return {Vector3} A reference to this vector.
   */
  randomDirection() {
    const theta = Math.random() * Math.PI * 2;
    const u2 = Math.random() * 2 - 1;
    const c2 = Math.sqrt(1 - u2 * u2);
    this.x = c2 * Math.cos(theta);
    this.y = u2;
    this.z = c2 * Math.sin(theta);
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
}
const _vector$c = /* @__PURE__ */ new Vector3();
const _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Matrix3 {
  /**
   * Constructs a new 3x3 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   */
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @return {Matrix3} A reference to this matrix.
   */
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  /**
   * Sets this matrix to the 3x3 identity matrix.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix3} m - The matrix to copy.
   * @return {Matrix3} A reference to this matrix.
   */
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix3} A reference to this matrix.
   */
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  /**
   * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }
  /**
   * Post-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  /**
   * Pre-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  /**
   * Multiples the given 3x3 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix3} a - The first matrix.
   * @param {Matrix3} b - The second matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyMatrices(a2, b) {
    const ae = a2.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
      a12 = ae[3],
      a13 = ae[6];
    const a21 = ae[1],
      a22 = ae[4],
      a23 = ae[7];
    const a31 = ae[2],
      a32 = ae[5],
      a33 = ae[8];
    const b11 = be[0],
      b12 = be[3],
      b13 = be[6];
    const b21 = be[1],
      b22 = be[4],
      b23 = be[7];
    const b31 = be[2],
      b32 = be[5],
      b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyScalar(s2) {
    const te = this.elements;
    te[0] *= s2;
    te[3] *= s2;
    te[6] *= s2;
    te[1] *= s2;
    te[4] *= s2;
    te[7] *= s2;
    te[2] *= s2;
    te[5] *= s2;
    te[8] *= s2;
    return this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const te = this.elements;
    const a2 = te[0],
      b = te[1],
      c2 = te[2],
      d2 = te[3],
      e2 = te[4],
      f = te[5],
      g2 = te[6],
      h2 = te[7],
      i2 = te[8];
    return (
      a2 * e2 * i2 -
      a2 * f * h2 -
      b * d2 * i2 +
      b * f * g2 +
      c2 * d2 * h2 -
      c2 * e2 * g2
    );
  }
  /**
   * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  invert() {
    const te = this.elements,
      n11 = te[0],
      n21 = te[1],
      n31 = te[2],
      n12 = te[3],
      n22 = te[4],
      n32 = te[5],
      n13 = te[6],
      n23 = te[7],
      n33 = te[8],
      t11 = n33 * n22 - n32 * n23,
      t12 = n32 * n13 - n33 * n12,
      t13 = n23 * n12 - n22 * n13,
      det2 = n11 * t11 + n21 * t12 + n31 * t13;
    if (det2 === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det2;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  transpose() {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }
  /**
   * Computes the normal matrix which is the inverse transpose of the upper
   * left 3x3 portion of the given 4x4 matrix.
   *
   * @param {Matrix4} matrix4 - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  /**
   * Transposes this matrix into the supplied array, and returns itself unchanged.
   *
   * @param {Array<number>} r - An array to store the transposed matrix elements.
   * @return {Matrix3} A reference to this matrix.
   */
  transposeIntoArray(r2) {
    const m = this.elements;
    r2[0] = m[0];
    r2[1] = m[3];
    r2[2] = m[6];
    r2[3] = m[1];
    r2[4] = m[4];
    r2[5] = m[7];
    r2[6] = m[2];
    r2[7] = m[5];
    r2[8] = m[8];
    return this;
  }
  /**
   * Sets the UV transform matrix from offset, repeat, rotation, and center.
   *
   * @param {number} tx - Offset x.
   * @param {number} ty - Offset y.
   * @param {number} sx - Repeat x.
   * @param {number} sy - Repeat y.
   * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
   * @param {number} cx - Center x of rotation.
   * @param {number} cy - Center y of rotation
   * @return {Matrix3} A reference to this matrix.
   */
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c2 = Math.cos(rotation);
    const s2 = Math.sin(rotation);
    this.set(
      sx * c2,
      sx * s2,
      -sx * (c2 * cx + s2 * cy) + cx + tx,
      -sy * s2,
      sy * c2,
      -sy * (-s2 * cx + c2 * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Scales this matrix with the given scalar values.
   *
   * @param {number} sx - The amount to scale in the X axis.
   * @param {number} sy - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  /**
   * Rotates this matrix by the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  /**
   * Translates this matrix by the given scalar values.
   *
   * @param {number} tx - The amount to translate in the X axis.
   * @param {number} ty - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  // for 2D Transforms
  /**
   * Sets this matrix as a 2D translation transform.
   *
   * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeTranslation(x, y) {
    if (x.isVector2) {
      this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);
    } else {
      this.set(1, 0, x, 0, 1, y, 0, 0, 1);
    }
    return this;
  }
  /**
   * Sets this matrix as a 2D rotational transformation.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  makeRotation(theta) {
    const c2 = Math.cos(theta);
    const s2 = Math.sin(theta);
    this.set(c2, -s2, 0, s2, c2, 0, 0, 0, 1);
    return this;
  }
  /**
   * Sets this matrix as a 2D scale transform.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeScale(x, y) {
    this.set(x, 0, 0, 0, y, 0, 0, 0, 1);
    return this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix3} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i2 = 0; i2 < 9; i2++) {
      if (te[i2] !== me[i2]) return false;
    }
    return true;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix3} A reference to this matrix.
   */
  fromArray(array2, offset = 0) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.elements[i2] = array2[i2 + offset];
    }
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(array2 = [], offset = 0) {
    const te = this.elements;
    array2[offset] = te[0];
    array2[offset + 1] = te[1];
    array2[offset + 2] = te[2];
    array2[offset + 3] = te[3];
    array2[offset + 4] = te[4];
    array2[offset + 5] = te[5];
    array2[offset + 6] = te[6];
    array2[offset + 7] = te[7];
    array2[offset + 8] = te[8];
    return array2;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix3} A clone of this instance.
   */
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const _m3 = /* @__PURE__ */ new Matrix3();
function arrayNeedsUint32(array2) {
  for (let i2 = array2.length - 1; i2 >= 0; --i2) {
    if (array2[i2] >= 65535) return true;
  }
  return false;
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
const _cache$2 = {};
function warnOnce(message) {
  if (message in _cache$2) return;
  _cache$2[message] = true;
  console.warn(message);
}
const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
);
const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
function createColorManagement() {
  const ColorManagement2 = {
    enabled: true,
    workingColorSpace: LinearSRGBColorSpace,
    /**
     * Implementations of supported color spaces.
     *
     * Required:
     *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
     *	- whitePoint: reference white [ x y ]
     *	- transfer: transfer function (pre-defined)
     *	- toXYZ: Matrix3 RGB to XYZ transform
     *	- fromXYZ: Matrix3 XYZ to RGB transform
     *	- luminanceCoefficients: RGB luminance coefficients
     *
     * Optional:
     *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
     *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
     *
     * Reference:
     * - https://www.russellcottrell.com/photo/matrixCalculator.htm
     */
    spaces: {},
    convert: function (color2, sourceColorSpace, targetColorSpace) {
      if (
        this.enabled === false ||
        sourceColorSpace === targetColorSpace ||
        !sourceColorSpace ||
        !targetColorSpace
      ) {
        return color2;
      }
      if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {
        color2.r = SRGBToLinear(color2.r);
        color2.g = SRGBToLinear(color2.g);
        color2.b = SRGBToLinear(color2.b);
      }
      if (
        this.spaces[sourceColorSpace].primaries !==
        this.spaces[targetColorSpace].primaries
      ) {
        color2.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);
        color2.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);
      }
      if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {
        color2.r = LinearToSRGB(color2.r);
        color2.g = LinearToSRGB(color2.g);
        color2.b = LinearToSRGB(color2.b);
      }
      return color2;
    },
    workingToColorSpace: function (color2, targetColorSpace) {
      return this.convert(color2, this.workingColorSpace, targetColorSpace);
    },
    colorSpaceToWorking: function (color2, sourceColorSpace) {
      return this.convert(color2, sourceColorSpace, this.workingColorSpace);
    },
    getPrimaries: function (colorSpace) {
      return this.spaces[colorSpace].primaries;
    },
    getTransfer: function (colorSpace) {
      if (colorSpace === NoColorSpace) return LinearTransfer;
      return this.spaces[colorSpace].transfer;
    },
    getLuminanceCoefficients: function (
      target,
      colorSpace = this.workingColorSpace
    ) {
      return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);
    },
    define: function (colorSpaces) {
      Object.assign(this.spaces, colorSpaces);
    },
    // Internal APIs
    _getMatrix: function (targetMatrix, sourceColorSpace, targetColorSpace) {
      return targetMatrix
        .copy(this.spaces[sourceColorSpace].toXYZ)
        .multiply(this.spaces[targetColorSpace].fromXYZ);
    },
    _getDrawingBufferColorSpace: function (colorSpace) {
      return this.spaces[colorSpace].outputColorSpaceConfig
        .drawingBufferColorSpace;
    },
    _getUnpackColorSpace: function (colorSpace = this.workingColorSpace) {
      return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;
    },
    // Deprecated
    fromWorkingColorSpace: function (color2, targetColorSpace) {
      warnOnce(
        "THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."
      );
      return ColorManagement2.workingToColorSpace(color2, targetColorSpace);
    },
    toWorkingColorSpace: function (color2, sourceColorSpace) {
      warnOnce(
        "THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."
      );
      return ColorManagement2.colorSpaceToWorking(color2, sourceColorSpace);
    },
  };
  const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];
  const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];
  const D65 = [0.3127, 0.329];
  ColorManagement2.define({
    [LinearSRGBColorSpace]: {
      primaries: REC709_PRIMARIES,
      whitePoint: D65,
      transfer: LinearTransfer,
      toXYZ: LINEAR_REC709_TO_XYZ,
      fromXYZ: XYZ_TO_LINEAR_REC709,
      luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
      workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
      outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace },
    },
    [SRGBColorSpace]: {
      primaries: REC709_PRIMARIES,
      whitePoint: D65,
      transfer: SRGBTransfer,
      toXYZ: LINEAR_REC709_TO_XYZ,
      fromXYZ: XYZ_TO_LINEAR_REC709,
      luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
      outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace },
    },
  });
  return ColorManagement2;
}
const ColorManagement = /* @__PURE__ */ createColorManagement();
function SRGBToLinear(c2) {
  return c2 < 0.04045
    ? c2 * 0.0773993808
    : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
  return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
let _canvas;
class ImageUtils {
  /**
   * Returns a data URI containing a representation of the given image.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
   * @param {string} [type='image/png'] - Indicates the image format.
   * @return {string} The data URI.
   */
  static getDataURL(image, type = "image/png") {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement === "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0) _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context2 = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context2.putImageData(image, 0, 0);
      } else {
        context2.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    return canvas.toDataURL(type);
  }
  /**
   * Converts the given sRGB image data to linear color space.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
   * @return {HTMLCanvasElement|Object} The converted image.
   */
  static sRGBToLinear(image) {
    if (
      (typeof HTMLImageElement !== "undefined" &&
        image instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement !== "undefined" &&
        image instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap)
    ) {
      const canvas = createElementNS("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context2 = canvas.getContext("2d");
      context2.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context2.getImageData(0, 0, image.width, image.height);
      const data = imageData.data;
      for (let i2 = 0; i2 < data.length; i2++) {
        data[i2] = SRGBToLinear(data[i2] / 255) * 255;
      }
      context2.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image.data) {
      const data = image.data.slice(0);
      for (let i2 = 0; i2 < data.length; i2++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);
        } else {
          data[i2] = SRGBToLinear(data[i2]);
        }
      }
      return {
        data,
        width: image.width,
        height: image.height,
      };
    } else {
      console.warn(
        "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
      );
      return image;
    }
  }
}
let _sourceId = 0;
class Source {
  /**
   * Constructs a new video texture.
   *
   * @param {any} [data=null] - The data definition of a texture.
   */
  constructor(data = null) {
    this.isSource = true;
    Object.defineProperty(this, "id", { value: _sourceId++ });
    this.uuid = generateUUID();
    this.data = data;
    this.dataReady = true;
    this.version = 0;
  }
  /**
   * Returns the dimensions of the source into the given target vector.
   *
   * @param {(Vector2|Vector3)} target - The target object the result is written into.
   * @return {(Vector2|Vector3)} The dimensions of the source.
   */
  getSize(target) {
    const data = this.data;
    if (data instanceof HTMLVideoElement) {
      target.set(data.videoWidth, data.videoHeight, 0);
    } else if (data instanceof VideoFrame) {
      target.set(data.displayHeight, data.displayWidth, 0);
    } else if (data !== null) {
      target.set(data.width, data.height, data.depth || 0);
    } else {
      target.set(0, 0, 0);
    }
    return target;
  }
  /**
   * When the property is set to `true`, the engine allocates the memory
   * for the texture (if necessary) and triggers the actual texture upload
   * to the GPU next time the source is used.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  /**
   * Serializes the source into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized source.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output2 = {
      uuid: this.uuid,
      url: "",
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i2 = 0, l2 = data.length; i2 < l2; i2++) {
          if (data[i2].isDataTexture) {
            url.push(serializeImage(data[i2].image));
          } else {
            url.push(serializeImage(data[i2]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output2.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output2;
    }
    return output2;
  }
}
function serializeImage(image) {
  if (
    (typeof HTMLImageElement !== "undefined" &&
      image instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement !== "undefined" &&
      image instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap)
  ) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name,
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
let _textureId = 0;
const _tempVec3 = /* @__PURE__ */ new Vector3();
class Texture extends EventDispatcher {
  /**
   * Constructs a new texture.
   *
   * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(
    image = Texture.DEFAULT_IMAGE,
    mapping = Texture.DEFAULT_MAPPING,
    wrapS = ClampToEdgeWrapping,
    wrapT = ClampToEdgeWrapping,
    magFilter = LinearFilter,
    minFilter = LinearMipmapLinearFilter,
    format = RGBAFormat,
    type = UnsignedByteType,
    anisotropy2 = Texture.DEFAULT_ANISOTROPY,
    colorSpace = NoColorSpace
  ) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: _textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.channel = 0;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy2;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.colorSpace = colorSpace;
    this.userData = {};
    this.updateRanges = [];
    this.version = 0;
    this.onUpdate = null;
    this.renderTarget = null;
    this.isRenderTargetTexture = false;
    this.isArrayTexture =
      image && image.depth && image.depth > 1 ? true : false;
    this.pmremVersion = 0;
  }
  /**
   * The width of the texture in pixels.
   */
  get width() {
    return this.source.getSize(_tempVec3).x;
  }
  /**
   * The height of the texture in pixels.
   */
  get height() {
    return this.source.getSize(_tempVec3).y;
  }
  /**
   * The depth of the texture in pixels.
   */
  get depth() {
    return this.source.getSize(_tempVec3).z;
  }
  /**
   * The image object holding the texture data.
   *
   * @type {?Object}
   */
  get image() {
    return this.source.data;
  }
  set image(value = null) {
    this.source.data = value;
  }
  /**
   * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
   * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
   */
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  /**
   * Adds a range of data in the data texture to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Returns a new texture with copied values from this instance.
   *
   * @return {Texture} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given texture to this instance.
   *
   * @param {Texture} source - The texture to copy.
   * @return {Texture} A reference to this instance.
   */
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.channel = source.channel;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.colorSpace = source.colorSpace;
    this.renderTarget = source.renderTarget;
    this.isRenderTargetTexture = source.isRenderTargetTexture;
    this.isArrayTexture = source.isArrayTexture;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  /**
   * Sets this texture's properties based on `values`.
   * @param {Object} values - A container with texture parameters.
   */
  setValues(values) {
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn(
          `THREE.Texture.setValues(): parameter '${key}' has value of undefined.`
        );
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn(
          `THREE.Texture.setValues(): property '${key}' does not exist.`
        );
        continue;
      }
      if (
        currentValue &&
        newValue &&
        currentValue.isVector2 &&
        newValue.isVector2
      ) {
        currentValue.copy(newValue);
      } else if (
        currentValue &&
        newValue &&
        currentValue.isVector3 &&
        newValue.isVector3
      ) {
        currentValue.copy(newValue);
      } else if (
        currentValue &&
        newValue &&
        currentValue.isMatrix3 &&
        newValue.isMatrix3
      ) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  /**
   * Serializes the texture into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized texture.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output2 = {
      metadata: {
        version: 4.7,
        type: "Texture",
        generator: "Texture.toJSON",
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    if (Object.keys(this.userData).length > 0) output2.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output2;
    }
    return output2;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Texture#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Transforms the given uv vector with the textures uv transformation matrix.
   *
   * @param {Vector2} uv - The uv vector.
   * @return {Vector2} The transformed uv vector.
   */
  transformUv(uv2) {
    if (this.mapping !== UVMapping) return uv2;
    uv2.applyMatrix3(this.matrix);
    if (uv2.x < 0 || uv2.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv2.x = uv2.x - Math.floor(uv2.x);
          break;
        case ClampToEdgeWrapping:
          uv2.x = uv2.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv2.x) % 2) === 1) {
            uv2.x = Math.ceil(uv2.x) - uv2.x;
          } else {
            uv2.x = uv2.x - Math.floor(uv2.x);
          }
          break;
      }
    }
    if (uv2.y < 0 || uv2.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv2.y = uv2.y - Math.floor(uv2.y);
          break;
        case ClampToEdgeWrapping:
          uv2.y = uv2.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv2.y) % 2) === 1) {
            uv2.y = Math.ceil(uv2.y) - uv2.y;
          } else {
            uv2.y = uv2.y - Math.floor(uv2.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv2.y = 1 - uv2.y;
    }
    return uv2;
  }
  /**
   * Setting this property to `true` indicates the engine the texture
   * must be updated in the next render. This triggers a texture upload
   * to the GPU and ensures correct texture parameter configuration.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
  /**
   * Setting this property to `true` indicates the engine the PMREM
   * must be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsPMREMUpdate(value) {
    if (value === true) {
      this.pmremVersion++;
    }
  }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Vector4 {
  /**
   * Constructs a new 4D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   * @param {number} [w=1] - The w value of this vector.
   */
  constructor(x = 0, y = 0, z = 0, w = 1) {
    Vector4.prototype.isVector4 = true;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  /**
   * Alias for {@link Vector4#z}.
   *
   * @type {number}
   */
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  /**
   * Alias for {@link Vector4#w}.
   *
   * @type {number}
   */
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @param {number} w - The value of the w component.
   * @return {Vector4} A reference to this vector.
   */
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector4} A reference to this vector.
   */
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setX(x) {
    this.x = x;
    return this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setY(y) {
    this.y = y;
    return this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setZ(z) {
    this.z = z;
    return this;
  }
  /**
   * Sets the vector's w component to the given value
   *
   * @param {number} w - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setW(w) {
    this.w = w;
    return this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @param {number} value - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @return {number} A vector component value.
   */
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector4} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3|Vector4} v - The vector to copy.
   * @return {Vector4} A reference to this vector.
   */
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector4} v - The vector to add.
   * @return {Vector4} A reference to this vector.
   */
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector4} A reference to this vector.
   */
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    this.w += s2;
    return this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  addVectors(a2, b) {
    this.x = a2.x + b.x;
    this.y = a2.y + b.y;
    this.z = a2.z + b.z;
    this.w = a2.w + b.w;
    return this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector4} A reference to this vector.
   */
  addScaledVector(v, s2) {
    this.x += v.x * s2;
    this.y += v.y * s2;
    this.z += v.z * s2;
    this.w += v.w * s2;
    return this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector4} v - The vector to subtract.
   * @return {Vector4} A reference to this vector.
   */
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector4} A reference to this vector.
   */
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    this.w -= s2;
    return this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  subVectors(a2, b) {
    this.x = a2.x - b.x;
    this.y = a2.y - b.y;
    this.z = a2.z - b.z;
    this.w = a2.w - b.w;
    return this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector4} v - The vector to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  /**
   * Multiplies this vector with the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  applyMatrix4(m) {
    const x = this.x,
      y = this.y,
      z = this.z,
      w = this.w;
    const e2 = m.elements;
    this.x = e2[0] * x + e2[4] * y + e2[8] * z + e2[12] * w;
    this.y = e2[1] * x + e2[5] * y + e2[9] * z + e2[13] * w;
    this.z = e2[2] * x + e2[6] * y + e2[10] * z + e2[14] * w;
    this.w = e2[3] * x + e2[7] * y + e2[11] * z + e2[15] * w;
    return this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector4} v - The vector to divide.
   * @return {Vector4} A reference to this vector.
   */
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    this.w /= v.w;
    return this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector4} A reference to this vector.
   */
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  /**
   * Sets the x, y and z components of this
   * vector to the quaternion's axis and w to the angle.
   *
   * @param {Quaternion} q - The Quaternion to set.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s2 = Math.sqrt(1 - q.w * q.w);
    if (s2 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s2;
      this.y = q.y / s2;
      this.z = q.z / s2;
    }
    return this;
  }
  /**
   * Sets the x, y and z components of this
   * vector to the axis of rotation and w to the angle.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromRotationMatrix(m) {
    let angle, x, y, z;
    const epsilon = 0.01,
      epsilon2 = 0.1,
      te = m.elements,
      m11 = te[0],
      m12 = te[4],
      m13 = te[8],
      m21 = te[1],
      m22 = te[5],
      m23 = te[9],
      m31 = te[2],
      m32 = te[6],
      m33 = te[10];
    if (
      Math.abs(m12 - m21) < epsilon &&
      Math.abs(m13 - m31) < epsilon &&
      Math.abs(m23 - m32) < epsilon
    ) {
      if (
        Math.abs(m12 + m21) < epsilon2 &&
        Math.abs(m13 + m31) < epsilon2 &&
        Math.abs(m23 + m32) < epsilon2 &&
        Math.abs(m11 + m22 + m33 - 3) < epsilon2
      ) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    let s2 = Math.sqrt(
      (m32 - m23) * (m32 - m23) +
        (m13 - m31) * (m13 - m31) +
        (m21 - m12) * (m21 - m12)
    );
    if (Math.abs(s2) < 1e-3) s2 = 1;
    this.x = (m32 - m23) / s2;
    this.y = (m13 - m31) / s2;
    this.z = (m21 - m12) / s2;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  setFromMatrixPosition(m) {
    const e2 = m.elements;
    this.x = e2[12];
    this.y = e2[13];
    this.z = e2[14];
    this.w = e2[15];
    return this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  /**
   * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
   * value, it is replaced by the corresponding value.
   * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector4} min - The minimum x, y and z values.
   * @param {Vector4} max - The maximum x, y and z values in the desired range.
   * @return {Vector4} A reference to this vector.
   */
  clamp(min2, max2) {
    this.x = clamp$1(this.x, min2.x, max2.x);
    this.y = clamp$1(this.y, min2.y, max2.y);
    this.z = clamp$1(this.z, min2.z, max2.z);
    this.w = clamp$1(this.w, min2.w, max2.w);
    return this;
  }
  /**
   * If this vector's x, y, z or w values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y, z or w values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampScalar(minVal, maxVal) {
    this.x = clamp$1(this.x, minVal, maxVal);
    this.y = clamp$1(this.y, minVal, maxVal);
    this.z = clamp$1(this.z, minVal, maxVal);
    this.w = clamp$1(this.w, minVal, maxVal);
    return this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampLength(min2, max2) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(
      clamp$1(length2, min2, max2)
    );
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector4} A reference to this vector.
   */
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    this.w = Math.trunc(this.w);
    return this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
   *
   * @return {Vector4} A reference to this vector.
   */
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector4} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector4} A reference to this vector.
   */
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector4} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector4} v1 - The first vector.
   * @param {Vector4} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector4} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
   * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector4} A reference to this vector.
   */
  fromArray(array2, offset = 0) {
    this.x = array2[offset];
    this.y = array2[offset + 1];
    this.z = array2[offset + 2];
    this.w = array2[offset + 3];
    return this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(array2 = [], offset = 0) {
    array2[offset] = this.x;
    array2[offset + 1] = this.y;
    array2[offset + 2] = this.z;
    array2[offset + 3] = this.w;
    return array2;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector4} A reference to this vector.
   */
  fromBufferAttribute(attribute2, index) {
    this.x = attribute2.getX(index);
    this.y = attribute2.getY(index);
    this.z = attribute2.getZ(index);
    this.w = attribute2.getW(index);
    return this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
}
class RenderTarget extends EventDispatcher {
  /**
   * Render target options.
   *
   * @typedef {Object} RenderTarget~Options
   * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
   * @property {number} [magFilter=LinearFilter] - The mag filter.
   * @property {number} [minFilter=LinearFilter] - The min filter.
   * @property {number} [format=RGBAFormat] - The texture format.
   * @property {number} [type=UnsignedByteType] - The texture type.
   * @property {?string} [internalFormat=null] - The texture's internal format.
   * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [anisotropy=1] - The texture's anisotropy value.
   * @property {string} [colorSpace=NoColorSpace] - The texture's color space.
   * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
   * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
   * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
   * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
   * @property {?Texture} [depthTexture=null] - Reference to a depth texture.
   * @property {number} [samples=0] - The MSAA samples count.
   * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
   * @property {number} [depth=1] - The texture depth.
   * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.
   */
  /**
   * Constructs a new render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(width = 1, height = 1, options = {}) {
    super();
    options = Object.assign(
      {
        generateMipmaps: false,
        internalFormat: null,
        minFilter: LinearFilter,
        depthBuffer: true,
        stencilBuffer: false,
        resolveDepthBuffer: true,
        resolveStencilBuffer: true,
        depthTexture: null,
        samples: 0,
        count: 1,
        depth: 1,
        multiview: false,
      },
      options
    );
    this.isRenderTarget = true;
    this.width = width;
    this.height = height;
    this.depth = options.depth;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    const image = { width, height, depth: options.depth };
    const texture2 = new Texture(image);
    this.textures = [];
    const count = options.count;
    for (let i2 = 0; i2 < count; i2++) {
      this.textures[i2] = texture2.clone();
      this.textures[i2].isRenderTargetTexture = true;
      this.textures[i2].renderTarget = this;
    }
    this._setTextureOptions(options);
    this.depthBuffer = options.depthBuffer;
    this.stencilBuffer = options.stencilBuffer;
    this.resolveDepthBuffer = options.resolveDepthBuffer;
    this.resolveStencilBuffer = options.resolveStencilBuffer;
    this._depthTexture = null;
    this.depthTexture = options.depthTexture;
    this.samples = options.samples;
    this.multiview = options.multiview;
  }
  _setTextureOptions(options = {}) {
    const values = {
      minFilter: LinearFilter,
      generateMipmaps: false,
      flipY: false,
      internalFormat: null,
    };
    if (options.mapping !== void 0) values.mapping = options.mapping;
    if (options.wrapS !== void 0) values.wrapS = options.wrapS;
    if (options.wrapT !== void 0) values.wrapT = options.wrapT;
    if (options.wrapR !== void 0) values.wrapR = options.wrapR;
    if (options.magFilter !== void 0) values.magFilter = options.magFilter;
    if (options.minFilter !== void 0) values.minFilter = options.minFilter;
    if (options.format !== void 0) values.format = options.format;
    if (options.type !== void 0) values.type = options.type;
    if (options.anisotropy !== void 0) values.anisotropy = options.anisotropy;
    if (options.colorSpace !== void 0) values.colorSpace = options.colorSpace;
    if (options.flipY !== void 0) values.flipY = options.flipY;
    if (options.generateMipmaps !== void 0)
      values.generateMipmaps = options.generateMipmaps;
    if (options.internalFormat !== void 0)
      values.internalFormat = options.internalFormat;
    for (let i2 = 0; i2 < this.textures.length; i2++) {
      const texture2 = this.textures[i2];
      texture2.setValues(values);
    }
  }
  /**
   * The texture representing the default color attachment.
   *
   * @type {Texture}
   */
  get texture() {
    return this.textures[0];
  }
  set texture(value) {
    this.textures[0] = value;
  }
  set depthTexture(current) {
    if (this._depthTexture !== null) this._depthTexture.renderTarget = null;
    if (current !== null) current.renderTarget = this;
    this._depthTexture = current;
  }
  /**
   * Instead of saving the depth in a renderbuffer, a texture
   * can be used instead which is useful for further processing
   * e.g. in context of post-processing.
   *
   * @type {?DepthTexture}
   * @default null
   */
  get depthTexture() {
    return this._depthTexture;
  }
  /**
   * Sets the size of this render target.
   *
   * @param {number} width - The width.
   * @param {number} height - The height.
   * @param {number} [depth=1] - The depth.
   */
  setSize(width, height, depth2 = 1) {
    if (
      this.width !== width ||
      this.height !== height ||
      this.depth !== depth2
    ) {
      this.width = width;
      this.height = height;
      this.depth = depth2;
      for (let i2 = 0, il = this.textures.length; i2 < il; i2++) {
        this.textures[i2].image.width = width;
        this.textures[i2].image.height = height;
        this.textures[i2].image.depth = depth2;
        this.textures[i2].isArrayTexture = this.textures[i2].image.depth > 1;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  /**
   * Returns a new render target with copied values from this instance.
   *
   * @return {RenderTarget} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the settings of the given render target. This is a structural copy so
   * no resources are shared between render targets after the copy. That includes
   * all MRT textures and the depth texture.
   *
   * @param {RenderTarget} source - The render target to copy.
   * @return {RenderTarget} A reference to this instance.
   */
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.scissor.copy(source.scissor);
    this.scissorTest = source.scissorTest;
    this.viewport.copy(source.viewport);
    this.textures.length = 0;
    for (let i2 = 0, il = source.textures.length; i2 < il; i2++) {
      this.textures[i2] = source.textures[i2].clone();
      this.textures[i2].isRenderTargetTexture = true;
      this.textures[i2].renderTarget = this;
      const image = Object.assign({}, source.textures[i2].image);
      this.textures[i2].source = new Source(image);
    }
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.resolveDepthBuffer = source.resolveDepthBuffer;
    this.resolveStencilBuffer = source.resolveStencilBuffer;
    if (source.depthTexture !== null)
      this.depthTexture = source.depthTexture.clone();
    this.samples = source.samples;
    return this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires RenderTarget#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class WebGLRenderTarget extends RenderTarget {
  /**
   * Constructs a new 3D render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(width = 1, height = 1, options = {}) {
    super(width, height, options);
    this.isWebGLRenderTarget = true;
  }
}
class DataArrayTexture extends Texture {
  /**
   * Constructs a new data array texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(data = null, width = 1, height = 1, depth2 = 1) {
    super(null);
    this.isDataArrayTexture = true;
    this.image = { data, width, height, depth: depth2 };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.layerUpdates = /* @__PURE__ */ new Set();
  }
  /**
   * Describes that a specific layer of the texture needs to be updated.
   * Normally when {@link Texture#needsUpdate} is set to `true`, the
   * entire data texture array is sent to the GPU. Marking specific
   * layers will only transmit subsets of all mipmaps associated with a
   * specific depth in the array which is often much more performant.
   *
   * @param {number} layerIndex - The layer index that should be updated.
   */
  addLayerUpdate(layerIndex) {
    this.layerUpdates.add(layerIndex);
  }
  /**
   * Resets the layer updates registry.
   */
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Box3 {
  /**
   * Constructs a new bounding box.
   *
   * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
   * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
   */
  constructor(
    min2 = new Vector3(Infinity, Infinity, Infinity),
    max2 = new Vector3(-Infinity, -Infinity, -Infinity)
  ) {
    this.isBox3 = true;
    this.min = min2;
    this.max = max2;
  }
  /**
   * Sets the lower and upper boundaries of this box.
   * Please note that this method only copies the values from the given objects.
   *
   * @param {Vector3} min - The lower boundary of the box.
   * @param {Vector3} max - The upper boundary of the box.
   * @return {Box3} A reference to this bounding box.
   */
  set(min2, max2) {
    this.min.copy(min2);
    this.max.copy(max2);
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<number>} array - An array holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromArray(array2) {
    this.makeEmpty();
    for (let i2 = 0, il = array2.length; i2 < il; i2 += 3) {
      this.expandByPoint(_vector$b.fromArray(array2, i2));
    }
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromBufferAttribute(attribute2) {
    this.makeEmpty();
    for (let i2 = 0, il = attribute2.count; i2 < il; i2++) {
      this.expandByPoint(_vector$b.fromBufferAttribute(attribute2, i2));
    }
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
   * @return {Box3} A reference to this bounding box.
   */
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  /**
   * Centers this box on the given center vector and sets this box's width, height and
   * depth to the given size values.
   *
   * @param {Vector3} center - The center of the box.
   * @param {Vector3} size - The x, y and z dimensions of the box.
   * @return {Box3} A reference to this bounding box.
   */
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  /**
   * Computes the world-axis-aligned bounding box for the given 3D object
   * (including its children), accounting for the object's, and children's,
   * world transforms. The function may result in a larger box than strictly necessary.
   *
   * @param {Object3D} object - The 3D object to compute the bounding box for.
   * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
   * world-axis-aligned bounding box at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  /**
   * Returns a new box with copied values from this instance.
   *
   * @return {Box3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given box to this instance.
   *
   * @param {Box3} box - The box to copy.
   * @return {Box3} A reference to this bounding box.
   */
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  /**
   * Makes this box empty which means in encloses a zero space in 3D.
   *
   * @return {Box3} A reference to this bounding box.
   */
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  /**
   * Returns true if this box includes zero points within its bounds.
   * Note that a box with equal lower and upper bounds still includes one
   * point, the one both bounds share.
   *
   * @return {boolean} Whether this box is empty or not.
   */
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  /**
   * Returns the center point of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The center point.
   */
  getCenter(target) {
    return this.isEmpty()
      ? target.set(0, 0, 0)
      : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  /**
   * Returns the dimensions of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The size.
   */
  getSize(target) {
    return this.isEmpty()
      ? target.set(0, 0, 0)
      : target.subVectors(this.max, this.min);
  }
  /**
   * Expands the boundaries of this box to include the given point.
   *
   * @param {Vector3} point - The point that should be included by the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  /**
   * Expands this box equilaterally by the given vector. The width of this
   * box will be expanded by the x component of the vector in both
   * directions. The height of this box will be expanded by the y component of
   * the vector in both directions. The depth of this box will be
   * expanded by the z component of the vector in both directions.
   *
   * @param {Vector3} vector - The vector that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  /**
   * Expands each dimension of the box by the given scalar. If negative, the
   * dimensions of the box will be contracted.
   *
   * @param {number} scalar - The scalar value that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  /**
   * Expands the boundaries of this box to include the given 3D object and
   * its children, accounting for the object's, and children's, world
   * transforms. The function may result in a larger box than strictly
   * necessary (unless the precise parameter is set to true).
   *
   * @param {Object3D} object - The 3D object that should expand the bounding box.
   * @param {boolean} precise - If set to `true`, the method expands the bounding box
   * as little as necessary at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      const positionAttribute = geometry.getAttribute("position");
      if (
        precise === true &&
        positionAttribute !== void 0 &&
        object.isInstancedMesh !== true
      ) {
        for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2++) {
          if (object.isMesh === true) {
            object.getVertexPosition(i2, _vector$b);
          } else {
            _vector$b.fromBufferAttribute(positionAttribute, i2);
          }
          _vector$b.applyMatrix4(object.matrixWorld);
          this.expandByPoint(_vector$b);
        }
      } else {
        if (object.boundingBox !== void 0) {
          if (object.boundingBox === null) {
            object.computeBoundingBox();
          }
          _box$4.copy(object.boundingBox);
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$4.copy(geometry.boundingBox);
        }
        _box$4.applyMatrix4(object.matrixWorld);
        this.union(_box$4);
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      this.expandByObject(children[i2], precise);
    }
    return this;
  }
  /**
   * Returns `true` if the given point lies within or on the boundaries of this box.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the bounding box contains the given point or not.
   */
  containsPoint(point) {
    return (
      point.x >= this.min.x &&
      point.x <= this.max.x &&
      point.y >= this.min.y &&
      point.y <= this.max.y &&
      point.z >= this.min.z &&
      point.z <= this.max.z
    );
  }
  /**
   * Returns `true` if this bounding box includes the entirety of the given bounding box.
   * If this box and the given one are identical, this function also returns `true`.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box contains the given bounding box or not.
   */
  containsBox(box) {
    return (
      this.min.x <= box.min.x &&
      box.max.x <= this.max.x &&
      this.min.y <= box.min.y &&
      box.max.y <= this.max.y &&
      this.min.z <= box.min.z &&
      box.max.z <= this.max.z
    );
  }
  /**
   * Returns a point as a proportion of this box's width, height and depth.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A point as a proportion of this box's width, height and depth.
   */
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  /**
   * Returns `true` if the given bounding box intersects with this bounding box.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with this bounding box.
   */
  intersectsBox(box) {
    return (
      box.max.x >= this.min.x &&
      box.min.x <= this.max.x &&
      box.max.y >= this.min.y &&
      box.min.y <= this.max.y &&
      box.max.z >= this.min.z &&
      box.min.z <= this.max.z
    );
  }
  /**
   * Returns `true` if the given bounding sphere intersects with this bounding box.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
   */
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return (
      _vector$b.distanceToSquared(sphere.center) <=
      sphere.radius * sphere.radius
    );
  }
  /**
   * Returns `true` if the given plane intersects with this bounding box.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether the given plane intersects with this bounding box.
   */
  intersectsPlane(plane) {
    let min2, max2;
    if (plane.normal.x > 0) {
      min2 = plane.normal.x * this.min.x;
      max2 = plane.normal.x * this.max.x;
    } else {
      min2 = plane.normal.x * this.max.x;
      max2 = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min2 += plane.normal.y * this.min.y;
      max2 += plane.normal.y * this.max.y;
    } else {
      min2 += plane.normal.y * this.max.y;
      max2 += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min2 += plane.normal.z * this.min.z;
      max2 += plane.normal.z * this.max.z;
    } else {
      min2 += plane.normal.z * this.max.z;
      max2 += plane.normal.z * this.min.z;
    }
    return min2 <= -plane.constant && max2 >= -plane.constant;
  }
  /**
   * Returns `true` if the given triangle intersects with this bounding box.
   *
   * @param {Triangle} triangle - The triangle to test.
   * @return {boolean} Whether the given triangle intersects with this bounding box.
   */
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$4.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$4, _v1$7);
    _f2.subVectors(_v0$2, _v2$4);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0,
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
  }
  /**
   * Clamps the given point within the bounds of this box.
   *
   * @param {Vector3} point - The point to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  /**
   * Returns the euclidean distance from any edge of this box to the specified point. If
   * the given point lies inside of this box, the distance will be `0`.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The euclidean distance.
   */
  distanceToPoint(point) {
    return this.clampPoint(point, _vector$b).distanceTo(point);
  }
  /**
   * Returns a bounding sphere that encloses this bounding box.
   *
   * @param {Sphere} target - The target sphere that is used to store the method's result.
   * @return {Sphere} The bounding sphere that encloses this bounding box.
   */
  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$b).length() * 0.5;
    }
    return target;
  }
  /**
   * Computes the intersection of this bounding box and the given one, setting the upper
   * bound of this box to the lesser of the two boxes' upper bounds and the
   * lower bound of this box to the greater of the two boxes' lower bounds. If
   * there's no overlap, makes this box empty.
   *
   * @param {Box3} box - The bounding box to intersect with.
   * @return {Box3} A reference to this bounding box.
   */
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  /**
   * Computes the union of this box and another and the given one, setting the upper
   * bound of this box to the greater of the two boxes' upper bounds and the
   * lower bound of this box to the lesser of the two boxes' lower bounds.
   *
   * @param {Box3} box - The bounding box that will be unioned with this instance.
   * @return {Box3} A reference to this bounding box.
   */
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  /**
   * Transforms this bounding box by the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Box3} A reference to this bounding box.
   */
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  /**
   * Adds the given offset to both the upper and lower bounds of this bounding box,
   * effectively moving it in 3D space.
   *
   * @param {Vector3} offset - The offset that should be used to translate the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  /**
   * Returns `true` if this bounding box is equal with the given one.
   *
   * @param {Box3} box - The box to test for equality.
   * @return {boolean} Whether this bounding box is equal with the given one.
   */
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
  /**
   * Returns a serialized structure of the bounding box.
   *
   * @return {Object} Serialized structure with fields representing the object state.
   */
  toJSON() {
    return {
      min: this.min.toArray(),
      max: this.max.toArray(),
    };
  }
  /**
   * Returns a serialized structure of the bounding box.
   *
   * @param {Object} json - The serialized json to set the box from.
   * @return {Box3} A reference to this bounding box.
   */
  fromJSON(json) {
    this.min.fromArray(json.min);
    this.max.fromArray(json.max);
    return this;
  }
}
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
];
const _vector$b = /* @__PURE__ */ new Vector3();
const _box$4 = /* @__PURE__ */ new Box3();
const _v0$2 = /* @__PURE__ */ new Vector3();
const _v1$7 = /* @__PURE__ */ new Vector3();
const _v2$4 = /* @__PURE__ */ new Vector3();
const _f0 = /* @__PURE__ */ new Vector3();
const _f1 = /* @__PURE__ */ new Vector3();
const _f2 = /* @__PURE__ */ new Vector3();
const _center = /* @__PURE__ */ new Vector3();
const _extents = /* @__PURE__ */ new Vector3();
const _triangleNormal = /* @__PURE__ */ new Vector3();
const _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {
    _testAxis.fromArray(axes, i2);
    const r2 =
      extents.x * Math.abs(_testAxis.x) +
      extents.y * Math.abs(_testAxis.y) +
      extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) {
      return false;
    }
  }
  return true;
}
const _box$3 = /* @__PURE__ */ new Box3();
const _v1$6 = /* @__PURE__ */ new Vector3();
const _v2$3 = /* @__PURE__ */ new Vector3();
class Sphere {
  /**
   * Constructs a new sphere.
   *
   * @param {Vector3} [center=(0,0,0)] - The center of the sphere
   * @param {number} [radius=-1] - The radius of the sphere.
   */
  constructor(center = new Vector3(), radius = -1) {
    this.isSphere = true;
    this.center = center;
    this.radius = radius;
  }
  /**
   * Sets the sphere's components by copying the given values.
   *
   * @param {Vector3} center - The center.
   * @param {number} radius - The radius.
   * @return {Sphere} A reference to this sphere.
   */
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  /**
   * Computes the minimum bounding sphere for list of points.
   * If the optional center point is given, it is used as the sphere's
   * center. Otherwise, the center of the axis-aligned bounding box
   * encompassing the points is calculated.
   *
   * @param {Array<Vector3>} points - A list of points in 3D space.
   * @param {Vector3} [optionalCenter] - The center of the sphere.
   * @return {Sphere} A reference to this sphere.
   */
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$3.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  /**
   * Copies the values of the given sphere to this instance.
   *
   * @param {Sphere} sphere - The sphere to copy.
   * @return {Sphere} A reference to this sphere.
   */
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  /**
   * Returns `true` if the sphere is empty (the radius set to a negative number).
   *
   * Spheres with a radius of `0` contain only their center point and are not
   * considered to be empty.
   *
   * @return {boolean} Whether this sphere is empty or not.
   */
  isEmpty() {
    return this.radius < 0;
  }
  /**
   * Makes this sphere empty which means in encloses a zero space in 3D.
   *
   * @return {Sphere} A reference to this sphere.
   */
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  /**
   * Returns `true` if this sphere contains the given point inclusive of
   * the surface of the sphere.
   *
   * @param {Vector3} point - The point to check.
   * @return {boolean} Whether this sphere contains the given point or not.
   */
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  /**
   * Returns the closest distance from the boundary of the sphere to the
   * given point. If the sphere contains the point, the distance will
   * be negative.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The distance to the point.
   */
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  /**
   * Returns `true` if this sphere intersects with the given one.
   *
   * @param {Sphere} sphere - The sphere to test.
   * @return {boolean} Whether this sphere intersects with the given one or not.
   */
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return (
      sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum
    );
  }
  /**
   * Returns `true` if this sphere intersects with the given box.
   *
   * @param {Box3} box - The box to test.
   * @return {boolean} Whether this sphere intersects with the given box or not.
   */
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  /**
   * Returns `true` if this sphere intersects with the given plane.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether this sphere intersects with the given plane or not.
   */
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  /**
   * Clamps a point within the sphere. If the point is outside the sphere, it
   * will clamp it to the closest point on the edge of the sphere. Points
   * already inside the sphere will not be affected.
   *
   * @param {Vector3} point - The plane to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  /**
   * Returns a bounding box that encloses this sphere.
   *
   * @param {Box3} target - The target box that is used to store the method's result.
   * @return {Box3} The bounding box that encloses this sphere.
   */
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  /**
   * Transforms this sphere with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Sphere} A reference to this sphere.
   */
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  /**
   * Translates the sphere's center by the given offset.
   *
   * @param {Vector3} offset - The offset.
   * @return {Sphere} A reference to this sphere.
   */
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  /**
   * Expands the boundaries of this sphere to include the given point.
   *
   * @param {Vector3} point - The point to include.
   * @return {Sphere} A reference to this sphere.
   */
  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }
    _v1$6.subVectors(point, this.center);
    const lengthSq2 = _v1$6.lengthSq();
    if (lengthSq2 > this.radius * this.radius) {
      const length2 = Math.sqrt(lengthSq2);
      const delta = (length2 - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, delta / length2);
      this.radius += delta;
    }
    return this;
  }
  /**
   * Expands this sphere to enclose both the original sphere and the given sphere.
   *
   * @param {Sphere} sphere - The sphere to include.
   * @return {Sphere} A reference to this sphere.
   */
  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }
    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }
    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
    }
    return this;
  }
  /**
   * Returns `true` if this sphere is equal with the given one.
   *
   * @param {Sphere} sphere - The sphere to test for equality.
   * @return {boolean} Whether this bounding sphere is equal with the given one.
   */
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  /**
   * Returns a new sphere with copied values from this instance.
   *
   * @return {Sphere} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Returns a serialized structure of the bounding sphere.
   *
   * @return {Object} Serialized structure with fields representing the object state.
   */
  toJSON() {
    return {
      radius: this.radius,
      center: this.center.toArray(),
    };
  }
  /**
   * Returns a serialized structure of the bounding sphere.
   *
   * @param {Object} json - The serialized json to set the sphere from.
   * @return {Box3} A reference to this bounding sphere.
   */
  fromJSON(json) {
    this.radius = json.radius;
    this.center.fromArray(json.center);
    return this;
  }
}
const _vector$a = /* @__PURE__ */ new Vector3();
const _segCenter = /* @__PURE__ */ new Vector3();
const _segDir = /* @__PURE__ */ new Vector3();
const _diff = /* @__PURE__ */ new Vector3();
const _edge1 = /* @__PURE__ */ new Vector3();
const _edge2 = /* @__PURE__ */ new Vector3();
const _normal$1 = /* @__PURE__ */ new Vector3();
class Ray {
  /**
   * Constructs a new ray.
   *
   * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
   * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
   */
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  /**
   * Sets the ray's components by copying the given values.
   *
   * @param {Vector3} origin - The origin.
   * @param {Vector3} direction - The direction.
   * @return {Ray} A reference to this ray.
   */
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  /**
   * Copies the values of the given ray to this instance.
   *
   * @param {Ray} ray - The ray to copy.
   * @return {Ray} A reference to this ray.
   */
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  /**
   * Returns a vector that is located at a given distance along this ray.
   *
   * @param {number} t - The distance along the ray to retrieve a position for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A position on the ray.
   */
  at(t2, target) {
    return target.copy(this.origin).addScaledVector(this.direction, t2);
  }
  /**
   * Adjusts the direction of the ray to point at the given vector in world space.
   *
   * @param {Vector3} v - The target position.
   * @return {Ray} A reference to this ray.
   */
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }
  /**
   * Shift the origin of this ray along its direction by the given distance.
   *
   * @param {number} t - The distance along the ray to interpolate.
   * @return {Ray} A reference to this ray.
   */
  recast(t2) {
    this.origin.copy(this.at(t2, _vector$a));
    return this;
  }
  /**
   * Returns the point along this ray that is closest to the given point.
   *
   * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on this ray.
   */
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target
      .copy(this.origin)
      .addScaledVector(this.direction, directionDistance);
  }
  /**
   * Returns the distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The distance.
   */
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  /**
   * Returns the squared distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The squared distance.
   */
  distanceSqToPoint(point) {
    const directionDistance = _vector$a
      .subVectors(point, this.origin)
      .dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$a
      .copy(this.origin)
      .addScaledVector(this.direction, directionDistance);
    return _vector$a.distanceToSquared(point);
  }
  /**
   * Returns the squared distance between this ray and the given line segment.
   *
   * @param {Vector3} v0 - The start point of the line segment.
   * @param {Vector3} v1 - The end point of the line segment.
   * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
   * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
   * @return {number} The squared distance.
   */
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c2 = _diff.lengthSq();
    const det2 = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det2 > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det2;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det2;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist =
              s0 * (s0 + a01 * s1 + 2 * b0) +
              s1 * (a01 * s0 + s1 + 2 * b1) +
              c2;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 =
            s0 > 0
              ? -segExtent
              : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c2;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 =
            s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
    }
    return sqrDist;
  }
  /**
   * Intersects this ray with the given sphere, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t1 < 0) return null;
    if (t0 < 0) return this.at(t1, target);
    return this.at(t0, target);
  }
  /**
   * Returns `true` if this ray intersects with the given sphere.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @return {boolean} Whether this ray intersects with the given sphere or not.
   */
  intersectsSphere(sphere) {
    if (sphere.radius < 0) return false;
    return (
      this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius
    );
  }
  /**
   * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
   * does not intersect with the plane.
   *
   * @param {Plane} plane - The plane to compute the distance to.
   * @return {?number} Whether this ray intersects with the given sphere or not.
   */
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t2 >= 0 ? t2 : null;
  }
  /**
   * Intersects this ray with the given plane, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Plane} plane - The plane to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectPlane(plane, target) {
    const t2 = this.distanceToPlane(plane);
    if (t2 === null) {
      return null;
    }
    return this.at(t2, target);
  }
  /**
   * Returns `true` if this ray intersects with the given plane.
   *
   * @param {Plane} plane - The plane to intersect.
   * @return {boolean} Whether this ray intersects with the given plane or not.
   */
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  /**
   * Intersects this ray with the given bounding box, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Box3} box - The box to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x,
      invdiry = 1 / this.direction.y,
      invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) return null;
    if (tymin > tmin || isNaN(tmin)) tmin = tymin;
    if (tymax < tmax || isNaN(tmax)) tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  /**
   * Returns `true` if this ray intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this ray intersects with the given box or not.
   */
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  /**
   * Intersects this ray with the given triangle, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Vector3} a - The first vertex of the triangle.
   * @param {Vector3} b - The second vertex of the triangle.
   * @param {Vector3} c - The third vertex of the triangle.
   * @param {boolean} backfaceCulling - Whether to use backface culling or not.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectTriangle(a2, b, c2, backfaceCulling, target) {
    _edge1.subVectors(b, a2);
    _edge2.subVectors(c2, a2);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a2);
    const DdQxE2 =
      sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  /**
   * Transforms this ray with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix4 - The transformation matrix.
   * @return {Ray} A reference to this ray.
   */
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  /**
   * Returns `true` if this ray is equal with the given one.
   *
   * @param {Ray} ray - The ray to test for equality.
   * @return {boolean} Whether this ray is equal with the given one.
   */
  equals(ray) {
    return (
      ray.origin.equals(this.origin) && ray.direction.equals(this.direction)
    );
  }
  /**
   * Returns a new ray with copied values from this instance.
   *
   * @return {Ray} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  /**
   * Constructs a new 4x4 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   */
  constructor(
    n11,
    n12,
    n13,
    n14,
    n21,
    n22,
    n23,
    n24,
    n31,
    n32,
    n33,
    n34,
    n41,
    n42,
    n43,
    n44
  ) {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    if (n11 !== void 0) {
      this.set(
        n11,
        n12,
        n13,
        n14,
        n21,
        n22,
        n23,
        n24,
        n31,
        n32,
        n33,
        n34,
        n41,
        n42,
        n43,
        n44
      );
    }
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   * @return {Matrix4} A reference to this matrix.
   */
  set(
    n11,
    n12,
    n13,
    n14,
    n21,
    n22,
    n23,
    n24,
    n31,
    n32,
    n33,
    n34,
    n41,
    n42,
    n43,
    n44
  ) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  /**
   * Sets this matrix to the 4x4 identity matrix.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix4} A clone of this instance.
   */
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix4} m - The matrix to copy.
   * @return {Matrix4} A reference to this matrix.
   */
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  /**
   * Copies the translation component of the given matrix
   * into this matrix's translation component.
   *
   * @param {Matrix4} m - The matrix to copy the translation component.
   * @return {Matrix4} A reference to this matrix.
   */
  copyPosition(m) {
    const te = this.elements,
      me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  /**
   * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  /**
   * Sets the given basis vectors to this matrix.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Extracts the rotation component of the given matrix
   * into this matrix's rotation component.
   *
   * Note: This method does not support reflection matrices.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  extractRotation(m) {
    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  /**
   * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
   * the rotation specified by the given Euler angles. The rest of
   * the matrix is set to the identity. Depending on the {@link Euler#order},
   * there are six possible outcomes. See [this page]{@link https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix}
   * for a complete list.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x = euler.x,
      y = euler.y,
      z = euler.z;
    const a2 = Math.cos(x),
      b = Math.sin(x);
    const c2 = Math.cos(y),
      d2 = Math.sin(y);
    const e2 = Math.cos(z),
      f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a2 * e2,
        af = a2 * f,
        be = b * e2,
        bf = b * f;
      te[0] = c2 * e2;
      te[4] = -c2 * f;
      te[8] = d2;
      te[1] = af + be * d2;
      te[5] = ae - bf * d2;
      te[9] = -b * c2;
      te[2] = bf - ae * d2;
      te[6] = be + af * d2;
      te[10] = a2 * c2;
    } else if (euler.order === "YXZ") {
      const ce = c2 * e2,
        cf = c2 * f,
        de = d2 * e2,
        df = d2 * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a2 * d2;
      te[1] = a2 * f;
      te[5] = a2 * e2;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a2 * c2;
    } else if (euler.order === "ZXY") {
      const ce = c2 * e2,
        cf = c2 * f,
        de = d2 * e2,
        df = d2 * f;
      te[0] = ce - df * b;
      te[4] = -a2 * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a2 * e2;
      te[9] = df - ce * b;
      te[2] = -a2 * d2;
      te[6] = b;
      te[10] = a2 * c2;
    } else if (euler.order === "ZYX") {
      const ae = a2 * e2,
        af = a2 * f,
        be = b * e2,
        bf = b * f;
      te[0] = c2 * e2;
      te[4] = be * d2 - af;
      te[8] = ae * d2 + bf;
      te[1] = c2 * f;
      te[5] = bf * d2 + ae;
      te[9] = af * d2 - be;
      te[2] = -d2;
      te[6] = b * c2;
      te[10] = a2 * c2;
    } else if (euler.order === "YZX") {
      const ac = a2 * c2,
        ad = a2 * d2,
        bc = b * c2,
        bd = b * d2;
      te[0] = c2 * e2;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a2 * e2;
      te[9] = -b * e2;
      te[2] = -d2 * e2;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a2 * c2,
        ad = a2 * d2,
        bc = b * c2,
        bd = b * d2;
      te[0] = c2 * e2;
      te[4] = -f;
      te[8] = d2 * e2;
      te[1] = ac * f + bd;
      te[5] = a2 * e2;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e2;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  /**
   * Sets the rotation component of this matrix to the rotation specified by
   * the given Quaternion as outlined [here]{@link https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion}
   * The rest of the matrix is set to the identity.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  /**
   * Sets the rotation component of the transformation matrix, looking from `eye` towards
   * `target`, and oriented by the up-direction.
   *
   * @param {Vector3} eye - The eye vector.
   * @param {Vector3} target - The target vector.
   * @param {Vector3} up - The up vector.
   * @return {Matrix4} A reference to this matrix.
   */
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  /**
   * Post-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  /**
   * Pre-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  /**
   * Multiples the given 4x4 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix4} a - The first matrix.
   * @param {Matrix4} b - The second matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyMatrices(a2, b) {
    const ae = a2.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
      a12 = ae[4],
      a13 = ae[8],
      a14 = ae[12];
    const a21 = ae[1],
      a22 = ae[5],
      a23 = ae[9],
      a24 = ae[13];
    const a31 = ae[2],
      a32 = ae[6],
      a33 = ae[10],
      a34 = ae[14];
    const a41 = ae[3],
      a42 = ae[7],
      a43 = ae[11],
      a44 = ae[15];
    const b11 = be[0],
      b12 = be[4],
      b13 = be[8],
      b14 = be[12];
    const b21 = be[1],
      b22 = be[5],
      b23 = be[9],
      b24 = be[13];
    const b31 = be[2],
      b32 = be[6],
      b33 = be[10],
      b34 = be[14];
    const b41 = be[3],
      b42 = be[7],
      b43 = be[11],
      b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyScalar(s2) {
    const te = this.elements;
    te[0] *= s2;
    te[4] *= s2;
    te[8] *= s2;
    te[12] *= s2;
    te[1] *= s2;
    te[5] *= s2;
    te[9] *= s2;
    te[13] *= s2;
    te[2] *= s2;
    te[6] *= s2;
    te[10] *= s2;
    te[14] *= s2;
    te[3] *= s2;
    te[7] *= s2;
    te[11] *= s2;
    te[15] *= s2;
    return this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * Based on the method outlined [here]{@link http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html}.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const te = this.elements;
    const n11 = te[0],
      n12 = te[4],
      n13 = te[8],
      n14 = te[12];
    const n21 = te[1],
      n22 = te[5],
      n23 = te[9],
      n24 = te[13];
    const n31 = te[2],
      n32 = te[6],
      n33 = te[10],
      n34 = te[14];
    const n41 = te[3],
      n42 = te[7],
      n43 = te[11],
      n44 = te[15];
    return (
      n41 *
        (+n14 * n23 * n32 -
          n13 * n24 * n32 -
          n14 * n22 * n33 +
          n12 * n24 * n33 +
          n13 * n22 * n34 -
          n12 * n23 * n34) +
      n42 *
        (+n11 * n23 * n34 -
          n11 * n24 * n33 +
          n14 * n21 * n33 -
          n13 * n21 * n34 +
          n13 * n24 * n31 -
          n14 * n23 * n31) +
      n43 *
        (+n11 * n24 * n32 -
          n11 * n22 * n34 -
          n14 * n21 * n32 +
          n12 * n21 * n34 +
          n14 * n22 * n31 -
          n12 * n24 * n31) +
      n44 *
        (-n13 * n22 * n31 -
          n11 * n23 * n32 +
          n11 * n22 * n33 +
          n13 * n21 * n32 -
          n12 * n21 * n33 +
          n12 * n23 * n31)
    );
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }
  /**
   * Sets the position component for this matrix from the given vector,
   * without affecting the rest of the matrix.
   *
   * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
   * @param {number} y - The y component of the vector.
   * @param {number} z - The z component of the vector.
   * @return {Matrix4} A reference to this matrix.
   */
  setPosition(x, y, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }
    return this;
  }
  /**
   * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  invert() {
    const te = this.elements,
      n11 = te[0],
      n21 = te[1],
      n31 = te[2],
      n41 = te[3],
      n12 = te[4],
      n22 = te[5],
      n32 = te[6],
      n42 = te[7],
      n13 = te[8],
      n23 = te[9],
      n33 = te[10],
      n43 = te[11],
      n14 = te[12],
      n24 = te[13],
      n34 = te[14],
      n44 = te[15],
      t11 =
        n23 * n34 * n42 -
        n24 * n33 * n42 +
        n24 * n32 * n43 -
        n22 * n34 * n43 -
        n23 * n32 * n44 +
        n22 * n33 * n44,
      t12 =
        n14 * n33 * n42 -
        n13 * n34 * n42 -
        n14 * n32 * n43 +
        n12 * n34 * n43 +
        n13 * n32 * n44 -
        n12 * n33 * n44,
      t13 =
        n13 * n24 * n42 -
        n14 * n23 * n42 +
        n14 * n22 * n43 -
        n12 * n24 * n43 -
        n13 * n22 * n44 +
        n12 * n23 * n44,
      t14 =
        n14 * n23 * n32 -
        n13 * n24 * n32 -
        n14 * n22 * n33 +
        n12 * n24 * n33 +
        n13 * n22 * n34 -
        n12 * n23 * n34;
    const det2 = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det2 === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det2;
    te[0] = t11 * detInv;
    te[1] =
      (n24 * n33 * n41 -
        n23 * n34 * n41 -
        n24 * n31 * n43 +
        n21 * n34 * n43 +
        n23 * n31 * n44 -
        n21 * n33 * n44) *
      detInv;
    te[2] =
      (n22 * n34 * n41 -
        n24 * n32 * n41 +
        n24 * n31 * n42 -
        n21 * n34 * n42 -
        n22 * n31 * n44 +
        n21 * n32 * n44) *
      detInv;
    te[3] =
      (n23 * n32 * n41 -
        n22 * n33 * n41 -
        n23 * n31 * n42 +
        n21 * n33 * n42 +
        n22 * n31 * n43 -
        n21 * n32 * n43) *
      detInv;
    te[4] = t12 * detInv;
    te[5] =
      (n13 * n34 * n41 -
        n14 * n33 * n41 +
        n14 * n31 * n43 -
        n11 * n34 * n43 -
        n13 * n31 * n44 +
        n11 * n33 * n44) *
      detInv;
    te[6] =
      (n14 * n32 * n41 -
        n12 * n34 * n41 -
        n14 * n31 * n42 +
        n11 * n34 * n42 +
        n12 * n31 * n44 -
        n11 * n32 * n44) *
      detInv;
    te[7] =
      (n12 * n33 * n41 -
        n13 * n32 * n41 +
        n13 * n31 * n42 -
        n11 * n33 * n42 -
        n12 * n31 * n43 +
        n11 * n32 * n43) *
      detInv;
    te[8] = t13 * detInv;
    te[9] =
      (n14 * n23 * n41 -
        n13 * n24 * n41 -
        n14 * n21 * n43 +
        n11 * n24 * n43 +
        n13 * n21 * n44 -
        n11 * n23 * n44) *
      detInv;
    te[10] =
      (n12 * n24 * n41 -
        n14 * n22 * n41 +
        n14 * n21 * n42 -
        n11 * n24 * n42 -
        n12 * n21 * n44 +
        n11 * n22 * n44) *
      detInv;
    te[11] =
      (n13 * n22 * n41 -
        n12 * n23 * n41 -
        n13 * n21 * n42 +
        n11 * n23 * n42 +
        n12 * n21 * n43 -
        n11 * n22 * n43) *
      detInv;
    te[12] = t14 * detInv;
    te[13] =
      (n13 * n24 * n31 -
        n14 * n23 * n31 +
        n14 * n21 * n33 -
        n11 * n24 * n33 -
        n13 * n21 * n34 +
        n11 * n23 * n34) *
      detInv;
    te[14] =
      (n14 * n22 * n31 -
        n12 * n24 * n31 -
        n14 * n21 * n32 +
        n11 * n24 * n32 +
        n12 * n21 * n34 -
        n11 * n22 * n34) *
      detInv;
    te[15] =
      (n12 * n23 * n31 -
        n13 * n22 * n31 +
        n13 * n21 * n32 -
        n11 * n23 * n32 -
        n12 * n21 * n33 +
        n11 * n22 * n33) *
      detInv;
    return this;
  }
  /**
   * Multiplies the columns of this matrix by the given vector.
   *
   * @param {Vector3} v - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  scale(v) {
    const te = this.elements;
    const x = v.x,
      y = v.y,
      z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }
  /**
   * Gets the maximum scale value of the three axes.
   *
   * @return {number} The maximum scale.
   */
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  /**
   * Sets this matrix as a translation transform from the given vector.
   *
   * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @param {number} z - The amount to translate in the z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeTranslation(x, y, z) {
    if (x.isVector3) {
      this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);
    } else {
      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    }
    return this;
  }
  /**
   * Sets this matrix as a rotational transformation around the X axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationX(theta) {
    const c2 = Math.cos(theta),
      s2 = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1);
    return this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Y axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationY(theta) {
    const c2 = Math.cos(theta),
      s2 = Math.sin(theta);
    this.set(c2, 0, s2, 0, 0, 1, 0, 0, -s2, 0, c2, 0, 0, 0, 0, 1);
    return this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Z axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationZ(theta) {
    const c2 = Math.cos(theta),
      s2 = Math.sin(theta);
    this.set(c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  /**
   * Sets this matrix as a rotational transformation around the given axis by
   * the given angle.
   *
   * This is a somewhat controversial but mathematically sound alternative to
   * rotating via Quaternions. See the discussion [here]{@link https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199}.
   *
   * @param {Vector3} axis - The normalized rotation axis.
   * @param {number} angle - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationAxis(axis, angle) {
    const c2 = Math.cos(angle);
    const s2 = Math.sin(angle);
    const t2 = 1 - c2;
    const x = axis.x,
      y = axis.y,
      z = axis.z;
    const tx = t2 * x,
      ty = t2 * y;
    this.set(
      tx * x + c2,
      tx * y - s2 * z,
      tx * z + s2 * y,
      0,
      tx * y + s2 * z,
      ty * y + c2,
      ty * z - s2 * x,
      0,
      tx * z - s2 * y,
      ty * z + s2 * x,
      t2 * z * z + c2,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix as a scale transformation.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @param {number} z - The amount to scale in the Z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeScale(x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  }
  /**
   * Sets this matrix as a shear transformation.
   *
   * @param {number} xy - The amount to shear X by Y.
   * @param {number} xz - The amount to shear X by Z.
   * @param {number} yx - The amount to shear Y by X.
   * @param {number} yz - The amount to shear Y by Z.
   * @param {number} zx - The amount to shear Z by X.
   * @param {number} zy - The amount to shear Z by Y.
   * @return {Matrix4} A reference to this matrix.
   */
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
    return this;
  }
  /**
   * Sets this matrix to the transformation composed of the given position,
   * rotation (Quaternion) and scale.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  compose(position, quaternion, scale2) {
    const te = this.elements;
    const x = quaternion._x,
      y = quaternion._y,
      z = quaternion._z,
      w = quaternion._w;
    const x2 = x + x,
      y2 = y + y,
      z2 = z + z;
    const xx = x * x2,
      xy = x * y2,
      xz = x * z2;
    const yy = y * y2,
      yz = y * z2,
      zz = z * z2;
    const wx = w * x2,
      wy = w * y2,
      wz = w * z2;
    const sx = scale2.x,
      sy = scale2.y,
      sz = scale2.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  /**
   * Decomposes this matrix into its position, rotation and scale components
   * and provides the result in the given objects.
   *
   * Note: Not all matrices are decomposable in this way. For example, if an
   * object has a non-uniformly scaled parent, then the object's world matrix
   * may not be decomposable, and this method may not be appropriate.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  decompose(position, quaternion, scale2) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det2 = this.determinant();
    if (det2 < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$2.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale2.x = sx;
    scale2.y = sy;
    scale2.z = sz;
    return this;
  }
  /**
  	 * Creates a perspective projection matrix. This is used internally by
  	 * {@link PerspectiveCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makePerspective(
    left,
    right,
    top,
    bottom,
    near,
    far,
    coordinateSystem = WebGLCoordinateSystem,
    reversedDepth = false
  ) {
    const te = this.elements;
    const x = (2 * near) / (right - left);
    const y = (2 * near) / (top - bottom);
    const a2 = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c2, d2;
    if (reversedDepth) {
      c2 = near / (far - near);
      d2 = (far * near) / (far - near);
    } else {
      if (coordinateSystem === WebGLCoordinateSystem) {
        c2 = -(far + near) / (far - near);
        d2 = (-2 * far * near) / (far - near);
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        c2 = -far / (far - near);
        d2 = (-far * near) / (far - near);
      } else {
        throw new Error(
          "THREE.Matrix4.makePerspective(): Invalid coordinate system: " +
            coordinateSystem
        );
      }
    }
    te[0] = x;
    te[4] = 0;
    te[8] = a2;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c2;
    te[14] = d2;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  /**
  	 * Creates a orthographic projection matrix. This is used internally by
  	 * {@link OrthographicCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makeOrthographic(
    left,
    right,
    top,
    bottom,
    near,
    far,
    coordinateSystem = WebGLCoordinateSystem,
    reversedDepth = false
  ) {
    const te = this.elements;
    const x = 2 / (right - left);
    const y = 2 / (top - bottom);
    const a2 = -(right + left) / (right - left);
    const b = -(top + bottom) / (top - bottom);
    let c2, d2;
    if (reversedDepth) {
      c2 = 1 / (far - near);
      d2 = far / (far - near);
    } else {
      if (coordinateSystem === WebGLCoordinateSystem) {
        c2 = -2 / (far - near);
        d2 = -(far + near) / (far - near);
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        c2 = -1 / (far - near);
        d2 = -near / (far - near);
      } else {
        throw new Error(
          "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " +
            coordinateSystem
        );
      }
    }
    te[0] = x;
    te[4] = 0;
    te[8] = 0;
    te[12] = a2;
    te[1] = 0;
    te[5] = y;
    te[9] = 0;
    te[13] = b;
    te[2] = 0;
    te[6] = 0;
    te[10] = c2;
    te[14] = d2;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix4} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i2 = 0; i2 < 16; i2++) {
      if (te[i2] !== me[i2]) return false;
    }
    return true;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix4} A reference to this matrix.
   */
  fromArray(array2, offset = 0) {
    for (let i2 = 0; i2 < 16; i2++) {
      this.elements[i2] = array2[i2 + offset];
    }
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(array2 = [], offset = 0) {
    const te = this.elements;
    array2[offset] = te[0];
    array2[offset + 1] = te[1];
    array2[offset + 2] = te[2];
    array2[offset + 3] = te[3];
    array2[offset + 4] = te[4];
    array2[offset + 5] = te[5];
    array2[offset + 6] = te[6];
    array2[offset + 7] = te[7];
    array2[offset + 8] = te[8];
    array2[offset + 9] = te[9];
    array2[offset + 10] = te[10];
    array2[offset + 11] = te[11];
    array2[offset + 12] = te[12];
    array2[offset + 13] = te[13];
    array2[offset + 14] = te[14];
    array2[offset + 15] = te[15];
    return array2;
  }
}
const _v1$5 = /* @__PURE__ */ new Vector3();
const _m1$2 = /* @__PURE__ */ new Matrix4();
const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
const _x = /* @__PURE__ */ new Vector3();
const _y = /* @__PURE__ */ new Vector3();
const _z = /* @__PURE__ */ new Vector3();
const _matrix$2 = /* @__PURE__ */ new Matrix4();
const _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  /**
   * Constructs a new euler instance.
   *
   * @param {number} [x=0] - The angle of the x axis in radians.
   * @param {number} [y=0] - The angle of the y axis in radians.
   * @param {number} [z=0] - The angle of the z axis in radians.
   * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
   */
  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  /**
   * The angle of the x axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  /**
   * The angle of the y axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  /**
   * The angle of the z axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  /**
   * A string representing the order that the rotations are applied.
   *
   * @type {string}
   * @default 'XYZ'
   */
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  /**
   * Sets the Euler components.
   *
   * @param {number} x - The angle of the x axis in radians.
   * @param {number} y - The angle of the y axis in radians.
   * @param {number} z - The angle of the z axis in radians.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  /**
   * Returns a new Euler instance with copied values from this instance.
   *
   * @return {Euler} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  /**
   * Copies the values of the given Euler instance to this instance.
   *
   * @param {Euler} euler - The Euler instance to copy.
   * @return {Euler} A reference to this Euler instance.
   */
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  /**
   * Sets the angles of this Euler instance from a pure rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromRotationMatrix(m, order = this._order, update = true) {
    const te = m.elements;
    const m11 = te[0],
      m12 = te[4],
      m13 = te[8];
    const m21 = te[1],
      m22 = te[5],
      m23 = te[9];
    const m31 = te[2],
      m32 = te[6],
      m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp$1(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp$1(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp$1(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp$1(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp$1(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp$1(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            order
        );
    }
    this._order = order;
    if (update === true) this._onChangeCallback();
    return this;
  }
  /**
   * Sets the angles of this Euler instance from a normalized quaternion.
   *
   * @param {Quaternion} q - A normalized Quaternion.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromQuaternion(q, order, update) {
    _matrix$2.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix$2, order, update);
  }
  /**
   * Sets the angles of this Euler instance from the given vector.
   *
   * @param {Vector3} v - The vector.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }
  /**
   * Resets the euler angle with a new order by creating a quaternion from this
   * euler angle and then setting this euler angle with the quaternion and the
   * new order.
   *
   * Warning: This discards revolution information.
   *
   * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  /**
   * Returns `true` if this Euler instance is equal with the given one.
   *
   * @param {Euler} euler - The Euler instance to test for equality.
   * @return {boolean} Whether this Euler instance is equal with the given one.
   */
  equals(euler) {
    return (
      euler._x === this._x &&
      euler._y === this._y &&
      euler._z === this._z &&
      euler._order === this._order
    );
  }
  /**
   * Sets this Euler instance's components to values from the given array. The first three
   * entries of the array are assign to the x,y and z components. An optional fourth entry
   * defines the Euler order.
   *
   * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
   * @return {Euler} A reference to this Euler instance.
   */
  fromArray(array2) {
    this._x = array2[0];
    this._y = array2[1];
    this._z = array2[2];
    if (array2[3] !== void 0) this._order = array2[3];
    this._onChangeCallback();
    return this;
  }
  /**
   * Writes the components of this Euler instance to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number,number,number,string>} The Euler components.
   */
  toArray(array2 = [], offset = 0) {
    array2[offset] = this._x;
    array2[offset + 1] = this._y;
    array2[offset + 2] = this._z;
    array2[offset + 3] = this._order;
    return array2;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
  /**
   * Constructs a new layers instance, with membership
   * initially set to layer `0`.
   */
  constructor() {
    this.mask = 1 | 0;
  }
  /**
   * Sets membership to the given layer, and remove membership all other layers.
   *
   * @param {number} layer - The layer to set.
   */
  set(layer) {
    this.mask = ((1 << layer) | 0) >>> 0;
  }
  /**
   * Adds membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  enable(layer) {
    this.mask |= (1 << layer) | 0;
  }
  /**
   * Adds membership to all layers.
   */
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  /**
   * Toggles the membership of the given layer.
   *
   * @param {number} layer - The layer to toggle.
   */
  toggle(layer) {
    this.mask ^= (1 << layer) | 0;
  }
  /**
   * Removes membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  disable(layer) {
    this.mask &= ~((1 << layer) | 0);
  }
  /**
   * Removes the membership from all layers.
   */
  disableAll() {
    this.mask = 0;
  }
  /**
   * Returns `true` if this and the given layers object have at least one
   * layer in common.
   *
   * @param {Layers} layers - The layers to test.
   * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
   */
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  /**
   * Returns `true` if the given layer is enabled.
   *
   * @param {number} layer - The layer to test.
   * @return {boolean } Whether the given layer is enabled or not.
   */
  isEnabled(layer) {
    return (this.mask & ((1 << layer) | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3();
const _q1 = /* @__PURE__ */ new Quaternion();
const _m1$1$1 = /* @__PURE__ */ new Matrix4();
const _target$1 = /* @__PURE__ */ new Vector3();
const _position$3 = /* @__PURE__ */ new Vector3();
const _scale$2 = /* @__PURE__ */ new Vector3();
const _quaternion$2 = /* @__PURE__ */ new Quaternion();
const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
const _addedEvent = { type: "added" };
const _removedEvent = { type: "removed" };
const _childaddedEvent = { type: "childadded", child: null };
const _childremovedEvent = { type: "childremoved", child: null };
class Object3D extends EventDispatcher {
  /**
   * Constructs a new 3D object.
   */
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DEFAULT_UP.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale2 = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      /**
       * Represents the object's local position.
       *
       * @name Object3D#position
       * @type {Vector3}
       * @default (0,0,0)
       */
      position: {
        configurable: true,
        enumerable: true,
        value: position,
      },
      /**
       * Represents the object's local rotation as Euler angles, in radians.
       *
       * @name Object3D#rotation
       * @type {Euler}
       * @default (0,0,0)
       */
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation,
      },
      /**
       * Represents the object's local rotation as Quaternions.
       *
       * @name Object3D#quaternion
       * @type {Quaternion}
       */
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion,
      },
      /**
       * Represents the object's local scale.
       *
       * @name Object3D#scale
       * @type {Vector3}
       * @default (1,1,1)
       */
      scale: {
        configurable: true,
        enumerable: true,
        value: scale2,
      },
      /**
       * Represents the object's model-view matrix.
       *
       * @name Object3D#modelViewMatrix
       * @type {Matrix4}
       */
      modelViewMatrix: {
        value: new Matrix4(),
      },
      /**
       * Represents the object's normal matrix.
       *
       * @name Object3D#normalMatrix
       * @type {Matrix3}
       */
      normalMatrix: {
        value: new Matrix3(),
      },
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.customDepthMaterial = void 0;
    this.customDistanceMaterial = void 0;
    this.userData = {};
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeShadow() {}
  /**
   * A callback that is executed immediately after a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onAfterShadow() {}
  /**
   * A callback that is executed immediately before a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {}
  /**
   * A callback that is executed immediately after a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onAfterRender() {}
  /**
   * Applies the given transformation matrix to the object and updates the object's position,
   * rotation and scale.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   */
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  /**
   * Applies a rotation represented by given the quaternion to the 3D object.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Object3D} A reference to this instance.
   */
  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }
  /**
   * Sets the given rotation represented as an axis/angle couple to the 3D object.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   */
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  /**
   * Sets the given rotation represented as Euler angles to the 3D object.
   *
   * @param {Euler} euler - The Euler angles.
   */
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  /**
   * Sets the given rotation represented as rotation matrix to the 3D object.
   *
   * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
   * a pure rotation matrix (i.e, unscaled).
   */
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m);
  }
  /**
   * Sets the given rotation represented as a Quaternion to the 3D object.
   *
   * @param {Quaternion} q - The Quaternion
   */
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  /**
   * Rotates the 3D object along an axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  /**
   * Rotates the 3D object along an axis in world space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  /**
   * Rotates the 3D object around its X axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  /**
   * Rotates the 3D object around its Y axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  /**
   * Rotates the 3D object around its Z axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  /**
   * Translate the 3D object by a distance along the given axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateOnAxis(axis, distance2) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance2));
    return this;
  }
  /**
   * Translate the 3D object by a distance along its X-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateX(distance2) {
    return this.translateOnAxis(_xAxis, distance2);
  }
  /**
   * Translate the 3D object by a distance along its Y-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateY(distance2) {
    return this.translateOnAxis(_yAxis, distance2);
  }
  /**
   * Translate the 3D object by a distance along its Z-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateZ(distance2) {
    return this.translateOnAxis(_zAxis, distance2);
  }
  /**
   * Converts the given vector from this 3D object's local space to world space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }
  /**
   * Converts the given vector from this 3D object's word space to local space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1$1$1.copy(this.matrixWorld).invert());
  }
  /**
   * Rotates the object to face a point in world space.
   *
   * This method does not support objects having non-uniformly-scaled parent(s).
   *
   * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
   * @param {number} [y] - The y coordinate in world space.
   * @param {number} [z] - The z coordinate in world space.
   */
  lookAt(x, y, z) {
    if (x.isVector3) {
      _target$1.copy(x);
    } else {
      _target$1.set(x, y, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1$1.lookAt(_position$3, _target$1, this.up);
    } else {
      _m1$1$1.lookAt(_target$1, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1$1);
    if (parent) {
      _m1$1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  /**
   * Adds the given 3D object as a child to this 3D object. An arbitrary number of
   * objects may be added. Any current parent on an object passed in here will be
   * removed, since an object can have at most one parent.
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to add.
   * @return {Object3D} A reference to this instance.
   */
  add(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    if (object === this) {
      console.error(
        "THREE.Object3D.add: object can't be added as a child of itself.",
        object
      );
      return this;
    }
    if (object && object.isObject3D) {
      object.removeFromParent();
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
      _childaddedEvent.child = object;
      this.dispatchEvent(_childaddedEvent);
      _childaddedEvent.child = null;
    } else {
      console.error(
        "THREE.Object3D.add: object not an instance of THREE.Object3D.",
        object
      );
    }
    return this;
  }
  /**
   * Removes the given 3D object as child from this 3D object.
   * An arbitrary number of objects may be removed.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @param {Object3D} object - The 3D object to remove.
   * @return {Object3D} A reference to this instance.
   */
  remove(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.remove(arguments[i2]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
      _childremovedEvent.child = object;
      this.dispatchEvent(_childremovedEvent);
      _childremovedEvent.child = null;
    }
    return this;
  }
  /**
   * Removes this 3D object from its current parent.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  /**
   * Removes all child objects.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  clear() {
    return this.remove(...this.children);
  }
  /**
   * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
   * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to attach.
   * @return {Object3D} A reference to this instance.
   */
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1$1);
    object.removeFromParent();
    object.parent = this;
    this.children.push(object);
    object.updateWorldMatrix(false, true);
    object.dispatchEvent(_addedEvent);
    _childaddedEvent.child = object;
    this.dispatchEvent(_childaddedEvent);
    _childaddedEvent.child = null;
    return this;
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching ID.
   *
   * @param {number} id - The id.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching name.
   *
   * @param {string} name - The name.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByProperty(name, value) {
    if (this[name] === value) return this;
    for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
      const child = this.children[i2];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns all 3D objects with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @param {Array<Object3D>} result - The method stores the result in this array.
   * @return {Array<Object3D>} The found 3D objects.
   */
  getObjectsByProperty(name, value, result = []) {
    if (this[name] === value) result.push(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].getObjectsByProperty(name, value, result);
    }
    return result;
  }
  /**
   * Returns a vector representing the position of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's position in world space.
   */
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  /**
   * Returns a Quaternion representing the position of the 3D object in world space.
   *
   * @param {Quaternion} target - The target Quaternion the result is stored to.
   * @return {Quaternion} The 3D object's rotation in world space.
   */
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  /**
   * Returns a vector representing the scale of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's scale in world space.
   */
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(e2[8], e2[9], e2[10]).normalize();
  }
  /**
   * Abstract method to get intersections between a casted ray and this
   * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
   * implement this method in order to use raycasting.
   *
   * @abstract
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - An array holding the result of the method.
   */
  raycast() {}
  /**
   * Executes the callback on this 3D object and all descendants.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverse(callback);
    }
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
   * Descendants of invisible 3D objects are not traversed.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverseVisible(callback);
    }
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  /**
   * Updates the transformation matrix in local space by computing it from the current
   * position, rotation and scale values.
   */
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  /**
   * Updates the transformation matrix in world space of this 3D objects and its descendants.
   *
   * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
   * local space. The computation of the local and world matrix can be controlled with the
   * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
   * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
   * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
   */
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.matrixWorldAutoUpdate === true) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          );
        }
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      const child = children[i2];
      child.updateMatrixWorld(force);
    }
  }
  /**
   * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
   * update of ancestor and descendant nodes.
   *
   * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
   * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
   */
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldAutoUpdate === true) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        const child = children[i2];
        child.updateWorldMatrix(false, true);
      }
    }
  }
  /**
   * Serializes the 3D object into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized 3D object.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output2 = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      };
      output2.metadata = {
        version: 4.7,
        type: "Object",
        generator: "Object3D.toJSON",
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "") object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object.instanceColor = this.instanceColor.toJSON();
    }
    if (this.isBatchedMesh) {
      object.type = "BatchedMesh";
      object.perObjectFrustumCulled = this.perObjectFrustumCulled;
      object.sortObjects = this.sortObjects;
      object.drawRanges = this._drawRanges;
      object.reservedRanges = this._reservedRanges;
      object.geometryInfo = this._geometryInfo.map((info) => ({
        ...info,
        boundingBox: info.boundingBox ? info.boundingBox.toJSON() : void 0,
        boundingSphere: info.boundingSphere
          ? info.boundingSphere.toJSON()
          : void 0,
      }));
      object.instanceInfo = this._instanceInfo.map((info) => ({ ...info }));
      object.availableInstanceIds = this._availableInstanceIds.slice();
      object.availableGeometryIds = this._availableGeometryIds.slice();
      object.nextIndexStart = this._nextIndexStart;
      object.nextVertexStart = this._nextVertexStart;
      object.geometryCount = this._geometryCount;
      object.maxInstanceCount = this._maxInstanceCount;
      object.maxVertexCount = this._maxVertexCount;
      object.maxIndexCount = this._maxIndexCount;
      object.geometryInitialized = this._geometryInitialized;
      object.matricesTexture = this._matricesTexture.toJSON(meta);
      object.indirectTexture = this._indirectTexture.toJSON(meta);
      if (this._colorsTexture !== null) {
        object.colorsTexture = this._colorsTexture.toJSON(meta);
      }
      if (this.boundingSphere !== null) {
        object.boundingSphere = this.boundingSphere.toJSON();
      }
      if (this.boundingBox !== null) {
        object.boundingBox = this.boundingBox.toJSON();
      }
    }
    function serialize(library, element2) {
      if (library[element2.uuid] === void 0) {
        library[element2.uuid] = element2.toJSON(meta);
      }
      return element2.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (
        this.environment &&
        this.environment.isTexture &&
        this.environment.isRenderTargetTexture !== true
      ) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
            const shape = shapes[i2];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i2 = 0, l2 = this.material.length; i2 < l2; i2++) {
          uuids.push(serialize(meta.materials, this.material[i2]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i2 = 0; i2 < this.children.length; i2++) {
        object.children.push(this.children[i2].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        const animation = this.animations[i2];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0) output2.geometries = geometries;
      if (materials.length > 0) output2.materials = materials;
      if (textures.length > 0) output2.textures = textures;
      if (images.length > 0) output2.images = images;
      if (shapes.length > 0) output2.shapes = shapes;
      if (skeletons.length > 0) output2.skeletons = skeletons;
      if (animations.length > 0) output2.animations = animations;
      if (nodes.length > 0) output2.nodes = nodes;
    }
    output2.object = object;
    return output2;
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data = cache2[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  /**
   * Returns a new 3D object with copied values from this instance.
   *
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
   * @return {Object3D} A clone of this instance.
   */
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  /**
   * Copies the values of the given 3D object to this instance.
   *
   * @param {Object3D} source - The 3D object to copy.
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
   * @return {Object3D} A reference to this instance.
   */
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i2 = 0; i2 < source.children.length; i2++) {
        const child = source.children[i2];
        this.add(child.clone());
      }
    }
    return this;
  }
}
Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
const _v0$1 = /* @__PURE__ */ new Vector3();
const _v1$3 = /* @__PURE__ */ new Vector3();
const _v2$2 = /* @__PURE__ */ new Vector3();
const _v3$2 = /* @__PURE__ */ new Vector3();
const _vab = /* @__PURE__ */ new Vector3();
const _vac = /* @__PURE__ */ new Vector3();
const _vbc = /* @__PURE__ */ new Vector3();
const _vap = /* @__PURE__ */ new Vector3();
const _vbp = /* @__PURE__ */ new Vector3();
const _vcp = /* @__PURE__ */ new Vector3();
const _v40 = /* @__PURE__ */ new Vector4();
const _v41 = /* @__PURE__ */ new Vector4();
const _v42 = /* @__PURE__ */ new Vector4();
class Triangle {
  /**
   * Constructs a new triangle.
   *
   * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
   * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
   * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
   */
  constructor(a2 = new Vector3(), b = new Vector3(), c2 = new Vector3()) {
    this.a = a2;
    this.b = b;
    this.c = c2;
  }
  /**
   * Computes the normal vector of a triangle.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  static getNormal(a2, b, c2, target) {
    target.subVectors(c2, b);
    _v0$1.subVectors(a2, b);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  static getBarycoord(point, a2, b, c2, target) {
    _v0$1.subVectors(c2, a2);
    _v1$3.subVectors(b, a2);
    _v2$2.subVectors(point, a2);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      target.set(0, 0, 0);
      return null;
    }
    const invDenom = 1 / denom;
    const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u2 - v, v, u2);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  static containsPoint(point, a2, b, c2) {
    if (this.getBarycoord(point, a2, b, c2, _v3$2) === null) {
      return false;
    }
    return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} p1 - The first corner of the triangle.
   * @param {Vector3} p2 - The second corner of the triangle.
   * @param {Vector3} p3 - The third corner of the triangle.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
    if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
      target.x = 0;
      target.y = 0;
      if ("z" in target) target.z = 0;
      if ("w" in target) target.w = 0;
      return null;
    }
    target.setScalar(0);
    target.addScaledVector(v1, _v3$2.x);
    target.addScaledVector(v2, _v3$2.y);
    target.addScaledVector(v3, _v3$2.z);
    return target;
  }
  /**
   * Computes the value barycentrically interpolated for the given attribute and indices.
   *
   * @param {BufferAttribute} attr - The attribute to interpolate.
   * @param {number} i1 - Index of first vertex.
   * @param {number} i2 - Index of second vertex.
   * @param {number} i3 - Index of third vertex.
   * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The interpolated attribute value.
   */
  static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {
    _v40.setScalar(0);
    _v41.setScalar(0);
    _v42.setScalar(0);
    _v40.fromBufferAttribute(attr, i1);
    _v41.fromBufferAttribute(attr, i2);
    _v42.fromBufferAttribute(attr, i3);
    target.setScalar(0);
    target.addScaledVector(_v40, barycoord.x);
    target.addScaledVector(_v41, barycoord.y);
    target.addScaledVector(_v42, barycoord.z);
    return target;
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  static isFrontFacing(a2, b, c2, direction) {
    _v0$1.subVectors(c2, b);
    _v1$3.subVectors(a2, b);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  /**
   * Sets the triangle's vertices by copying the given values.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  set(a2, b, c2) {
    this.a.copy(a2);
    this.b.copy(b);
    this.c.copy(c2);
    return this;
  }
  /**
   * Sets the triangle's vertices by copying the given array values.
   *
   * @param {Array<Vector3>} points - An array with 3D points.
   * @param {number} i0 - The array index representing the first corner of the triangle.
   * @param {number} i1 - The array index representing the second corner of the triangle.
   * @param {number} i2 - The array index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  /**
   * Sets the triangle's vertices by copying the given attribute values.
   *
   * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
   * @param {number} i0 - The attribute index representing the first corner of the triangle.
   * @param {number} i1 - The attribute index representing the second corner of the triangle.
   * @param {number} i2 - The attribute index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromAttributeAndIndices(attribute2, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute2, i0);
    this.b.fromBufferAttribute(attribute2, i1);
    this.c.fromBufferAttribute(attribute2, i2);
    return this;
  }
  /**
   * Returns a new triangle with copied values from this instance.
   *
   * @return {Triangle} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given triangle to this instance.
   *
   * @param {Triangle} triangle - The triangle to copy.
   * @return {Triangle} A reference to this triangle.
   */
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  /**
   * Computes the area of the triangle.
   *
   * @return {number} The triangle's area.
   */
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  /**
   * Computes the midpoint of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's midpoint.
   */
  getMidpoint(target) {
    return target
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  /**
   * Computes the normal of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  /**
   * Computes a plane the triangle lies within.
   *
   * @param {Plane} target - The target vector that is used to store the method's result.
   * @return {Plane} The plane the triangle lies within.
   */
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  getInterpolation(point, v1, v2, v3, target) {
    return Triangle.getInterpolation(
      point,
      this.a,
      this.b,
      this.c,
      v1,
      v2,
      v3,
      target
    );
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  /**
   * Returns `true` if this triangle intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this triangle intersects with the given box or not.
   */
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  /**
   * Returns the closest point on the triangle to the given point.
   *
   * @param {Vector3} p - The point to compute the closest point for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on the triangle.
   */
  closestPointToPoint(p2, target) {
    const a2 = this.a,
      b = this.b,
      c2 = this.c;
    let v, w;
    _vab.subVectors(b, a2);
    _vac.subVectors(c2, a2);
    _vap.subVectors(p2, a2);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a2);
    }
    _vbp.subVectors(p2, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3);
      return target.copy(a2).addScaledVector(_vab, v);
    }
    _vcp.subVectors(p2, c2);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c2);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6);
      return target.copy(a2).addScaledVector(_vac, w);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c2, b);
      w = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b).addScaledVector(_vbc, w);
    }
    const denom = 1 / (va + vb + vc);
    v = vb * denom;
    w = vc * denom;
    return target.copy(a2).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }
  /**
   * Returns `true` if this triangle is equal with the given one.
   *
   * @param {Triangle} triangle - The triangle to test for equality.
   * @return {boolean} Whether this triangle is equal with the given one.
   */
  equals(triangle) {
    return (
      triangle.a.equals(this.a) &&
      triangle.b.equals(this.b) &&
      triangle.c.equals(this.c)
    );
  }
}
const _colorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074,
};
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p2, q, t2) {
  if (t2 < 0) t2 += 1;
  if (t2 > 1) t2 -= 1;
  if (t2 < 1 / 6) return p2 + (q - p2) * 6 * t2;
  if (t2 < 1 / 2) return q;
  if (t2 < 2 / 3) return p2 + (q - p2) * 6 * (2 / 3 - t2);
  return p2;
}
class Color {
  /**
   * Constructs a new color.
   *
   * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
   * and that method is used throughout the rest of the documentation.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   */
  constructor(r2, g2, b) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r2, g2, b);
  }
  /**
   * Sets the colors's components from the given values.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   * @return {Color} A reference to this color.
   */
  set(r2, g2, b) {
    if (g2 === void 0 && b === void 0) {
      const value = r2;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r2, g2, b);
    }
    return this;
  }
  /**
   * Sets the colors's components to the given scalar value.
   *
   * @param {number} scalar - The scalar value.
   * @return {Color} A reference to this color.
   */
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  /**
   * Sets this color from a hexadecimal value.
   *
   * @param {number} hex - The hexadecimal value.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = ((hex >> 16) & 255) / 255;
    this.g = ((hex >> 8) & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.colorSpaceToWorking(this, colorSpace);
    return this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} r - Red channel value between `0.0` and `1.0`.
   * @param {number} g - Green channel value between `0.0` and `1.0`.
   * @param {number} b - Blue channel value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setRGB(r2, g2, b, colorSpace = ColorManagement.workingColorSpace) {
    this.r = r2;
    this.g = g2;
    this.b = b;
    ColorManagement.colorSpaceToWorking(this, colorSpace);
    return this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHSL(h2, s2, l2, colorSpace = ColorManagement.workingColorSpace) {
    h2 = euclideanModulo(h2, 1);
    s2 = clamp$1(s2, 0, 1);
    l2 = clamp$1(l2, 0, 1);
    if (s2 === 0) {
      this.r = this.g = this.b = l2;
    } else {
      const p2 = l2 <= 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      const q = 2 * l2 - p2;
      this.r = hue2rgb(q, p2, h2 + 1 / 3);
      this.g = hue2rgb(q, p2, h2);
      this.b = hue2rgb(q, p2, h2 - 1 / 3);
    }
    ColorManagement.colorSpaceToWorking(this, colorSpace);
    return this;
  }
  /**
   * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
   * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
   * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -
   * all 140 color names are supported).
   *
   * @param {string} style - Color as a CSS-style string.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string2) {
      if (string2 === void 0) return;
      if (parseFloat(string2) < 1) {
        console.warn(
          "THREE.Color: Alpha component of " + style + " will be ignored."
        );
      }
    }
    let m;
    if ((m = /^(\w+)\(([^\)]*)\)/.exec(style))) {
      let color2;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (
            (color2 =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                components
              ))
          ) {
            handleAlpha(color2[4]);
            return this.setRGB(
              Math.min(255, parseInt(color2[1], 10)) / 255,
              Math.min(255, parseInt(color2[2], 10)) / 255,
              Math.min(255, parseInt(color2[3], 10)) / 255,
              colorSpace
            );
          }
          if (
            (color2 =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                components
              ))
          ) {
            handleAlpha(color2[4]);
            return this.setRGB(
              Math.min(100, parseInt(color2[1], 10)) / 100,
              Math.min(100, parseInt(color2[2], 10)) / 100,
              Math.min(100, parseInt(color2[3], 10)) / 100,
              colorSpace
            );
          }
          break;
        case "hsl":
        case "hsla":
          if (
            (color2 =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                components
              ))
          ) {
            handleAlpha(color2[4]);
            return this.setHSL(
              parseFloat(color2[1]) / 360,
              parseFloat(color2[2]) / 100,
              parseFloat(color2[3]) / 100,
              colorSpace
            );
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + style);
      }
    } else if ((m = /^\#([A-Fa-f\d]+)$/.exec(style))) {
      const hex = m[1];
      const size = hex.length;
      if (size === 3) {
        return this.setRGB(
          parseInt(hex.charAt(0), 16) / 15,
          parseInt(hex.charAt(1), 16) / 15,
          parseInt(hex.charAt(2), 16) / 15,
          colorSpace
        );
      } else if (size === 6) {
        return this.setHex(parseInt(hex, 16), colorSpace);
      } else {
        console.warn("THREE.Color: Invalid hex color " + style);
      }
    } else if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  /**
   * Sets this color from a color name. Faster than {@link Color#setStyle} if
   * you don't need the other CSS-style formats.
   *
   * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
   * ```js
   * Color.NAMES.aliceblue // returns 0xF0F8FF
   * ```
   *
   * @param {string} style - The color name.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  /**
   * Returns a new color with copied values from this instance.
   *
   * @return {Color} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  /**
   * Copies the values of the given color to this instance.
   *
   * @param {Color} color - The color to copy.
   * @return {Color} A reference to this color.
   */
  copy(color2) {
    this.r = color2.r;
    this.g = color2.g;
    this.b = color2.b;
    return this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copySRGBToLinear(color2) {
    this.r = SRGBToLinear(color2.r);
    this.g = SRGBToLinear(color2.g);
    this.b = SRGBToLinear(color2.b);
    return this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copyLinearToSRGB(color2) {
    this.r = LinearToSRGB(color2.r);
    this.g = LinearToSRGB(color2.g);
    this.b = LinearToSRGB(color2.b);
    return this;
  }
  /**
   * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  /**
   * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  /**
   * Returns the hexadecimal value of this color.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {number} The hexadecimal value.
   */
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
    return (
      Math.round(clamp$1(_color.r * 255, 0, 255)) * 65536 +
      Math.round(clamp$1(_color.g * 255, 0, 255)) * 256 +
      Math.round(clamp$1(_color.b * 255, 0, 255))
    );
  }
  /**
   * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The hexadecimal value as a string.
   */
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  /**
   * Converts the colors RGB values into the HSL format and stores them into the
   * given target object.
   *
   * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {{h:number,s:number,l:number}} The HSL representation of this color.
   */
  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
    const r2 = _color.r,
      g2 = _color.g,
      b = _color.b;
    const max2 = Math.max(r2, g2, b);
    const min2 = Math.min(r2, g2, b);
    let hue2, saturation2;
    const lightness = (min2 + max2) / 2;
    if (min2 === max2) {
      hue2 = 0;
      saturation2 = 0;
    } else {
      const delta = max2 - min2;
      saturation2 =
        lightness <= 0.5 ? delta / (max2 + min2) : delta / (2 - max2 - min2);
      switch (max2) {
        case r2:
          hue2 = (g2 - b) / delta + (g2 < b ? 6 : 0);
          break;
        case g2:
          hue2 = (b - r2) / delta + 2;
          break;
        case b:
          hue2 = (r2 - g2) / delta + 4;
          break;
      }
      hue2 /= 6;
    }
    target.h = hue2;
    target.s = saturation2;
    target.l = lightness;
    return target;
  }
  /**
   * Returns the RGB values of this color and stores them into the given target object.
   *
   * @param {Color} target - The target color that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} The RGB representation of this color.
   */
  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
    target.r = _color.r;
    target.g = _color.g;
    target.b = _color.b;
    return target;
  }
  /**
   * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The CSS representation of this color.
   */
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
    const r2 = _color.r,
      g2 = _color.g,
      b = _color.b;
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${r2.toFixed(3)} ${g2.toFixed(3)} ${b.toFixed(
        3
      )})`;
    }
    return `rgb(${Math.round(r2 * 255)},${Math.round(g2 * 255)},${Math.round(
      b * 255
    )})`;
  }
  /**
   * Adds the given HSL values to this color's values.
   * Internally, this converts the color's RGB values to HSL, adds HSL
   * and then converts the color back to RGB.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @return {Color} A reference to this color.
   */
  offsetHSL(h2, s2, l2) {
    this.getHSL(_hslA);
    return this.setHSL(_hslA.h + h2, _hslA.s + s2, _hslA.l + l2);
  }
  /**
   * Adds the RGB values of the given color to the RGB values of this color.
   *
   * @param {Color} color - The color to add.
   * @return {Color} A reference to this color.
   */
  add(color2) {
    this.r += color2.r;
    this.g += color2.g;
    this.b += color2.b;
    return this;
  }
  /**
   * Adds the RGB values of the given colors and stores the result in this instance.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @return {Color} A reference to this color.
   */
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  /**
   * Adds the given scalar value to the RGB values of this color.
   *
   * @param {number} s - The scalar to add.
   * @return {Color} A reference to this color.
   */
  addScalar(s2) {
    this.r += s2;
    this.g += s2;
    this.b += s2;
    return this;
  }
  /**
   * Subtracts the RGB values of the given color from the RGB values of this color.
   *
   * @param {Color} color - The color to subtract.
   * @return {Color} A reference to this color.
   */
  sub(color2) {
    this.r = Math.max(0, this.r - color2.r);
    this.g = Math.max(0, this.g - color2.g);
    this.b = Math.max(0, this.b - color2.b);
    return this;
  }
  /**
   * Multiplies the RGB values of the given color with the RGB values of this color.
   *
   * @param {Color} color - The color to multiply.
   * @return {Color} A reference to this color.
   */
  multiply(color2) {
    this.r *= color2.r;
    this.g *= color2.g;
    this.b *= color2.b;
    return this;
  }
  /**
   * Multiplies the given scalar value with the RGB values of this color.
   *
   * @param {number} s - The scalar to multiply.
   * @return {Color} A reference to this color.
   */
  multiplyScalar(s2) {
    this.r *= s2;
    this.g *= s2;
    this.b *= s2;
    return this;
  }
  /**
   * Linearly interpolates this color's RGB values toward the RGB values of the
   * given color. The alpha argument can be thought of as the ratio between
   * the two colors, where `0.0` is this color and `1.0` is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerp(color2, alpha) {
    this.r += (color2.r - this.r) * alpha;
    this.g += (color2.g - this.g) * alpha;
    this.b += (color2.b - this.b) * alpha;
    return this;
  }
  /**
   * Linearly interpolates between the given colors and stores the result in this instance.
   * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
   * is the first and `1.0` is the second color.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  /**
   * Linearly interpolates this color's HSL values toward the HSL values of the
   * given color. It differs from {@link Color#lerp} by not interpolating straight
   * from one color to the other, but instead going through all the hues in between
   * those two colors. The alpha argument can be thought of as the ratio between
   * the two colors, where 0.0 is this color and 1.0 is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpHSL(color2, alpha) {
    this.getHSL(_hslA);
    color2.getHSL(_hslB);
    const h2 = lerp(_hslA.h, _hslB.h, alpha);
    const s2 = lerp(_hslA.s, _hslB.s, alpha);
    const l2 = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h2, s2, l2);
    return this;
  }
  /**
   * Sets the color's RGB components from the given 3D vector.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Color} A reference to this color.
   */
  setFromVector3(v) {
    this.r = v.x;
    this.g = v.y;
    this.b = v.z;
    return this;
  }
  /**
   * Transforms this color with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix.
   * @return {Color} A reference to this color.
   */
  applyMatrix3(m) {
    const r2 = this.r,
      g2 = this.g,
      b = this.b;
    const e2 = m.elements;
    this.r = e2[0] * r2 + e2[3] * g2 + e2[6] * b;
    this.g = e2[1] * r2 + e2[4] * g2 + e2[7] * b;
    this.b = e2[2] * r2 + e2[5] * g2 + e2[8] * b;
    return this;
  }
  /**
   * Returns `true` if this color is equal with the given one.
   *
   * @param {Color} c - The color to test for equality.
   * @return {boolean} Whether this bounding color is equal with the given one.
   */
  equals(c2) {
    return c2.r === this.r && c2.g === this.g && c2.b === this.b;
  }
  /**
   * Sets this color's RGB components from the given array.
   *
   * @param {Array<number>} array - An array holding the RGB values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Color} A reference to this color.
   */
  fromArray(array2, offset = 0) {
    this.r = array2[offset];
    this.g = array2[offset + 1];
    this.b = array2[offset + 2];
    return this;
  }
  /**
   * Writes the RGB components of this color to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the color components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The color components.
   */
  toArray(array2 = [], offset = 0) {
    array2[offset] = this.r;
    array2[offset + 1] = this.g;
    array2[offset + 2] = this.b;
    return array2;
  }
  /**
   * Sets the components of this color from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding color data.
   * @param {number} index - The index into the attribute.
   * @return {Color} A reference to this color.
   */
  fromBufferAttribute(attribute2, index) {
    this.r = attribute2.getX(index);
    this.g = attribute2.getY(index);
    this.b = attribute2.getZ(index);
    return this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the color
   * as a hexadecimal value.
   *
   * @return {number} The hexadecimal value.
   */
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
}
const _color = /* @__PURE__ */ new Color();
Color.NAMES = _colorKeywords;
let _materialId = 0;
class Material extends EventDispatcher {
  /**
   * Constructs a new material.
   */
  constructor() {
    super();
    this.isMaterial = true;
    Object.defineProperty(this, "id", { value: _materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.alphaHash = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.blendColor = new Color(0, 0, 0);
    this.blendAlpha = 0;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.forceSinglePass = false;
    this.allowOverride = true;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  /**
   * Sets the alpha value to be used when running an alpha test. The material
   * will not be rendered if the opacity is lower than this value.
   *
   * @type {number}
   * @readonly
   * @default 0
   */
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  /**
   * An optional callback that is executed immediately before the material is used to render a 3D object.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Object3D} object - The 3D object.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {}
  /**
   * An optional callback that is executed immediately before the shader
   * program is compiled. This function is called with the shader source code
   * as a parameter. Useful for the modification of built-in materials.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}. The
   * recommended approach when customizing materials is to use `WebGPURenderer` with the new
   * Node Material system and [TSL]{@link https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language}.
   *
   * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
   * @param {WebGLRenderer} renderer - A reference to the renderer.
   */
  onBeforeCompile() {}
  /**
   * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
   * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
   * shader or recompile the shader for this material as needed.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}.
   *
   * @return {string} The custom program cache key.
   */
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  /**
   * This method can be used to set default values from parameter objects.
   * It is a generic implementation so it can be used with different types
   * of materials.
   *
   * @param {Object} [values] - The material values to set.
   */
  setValues(values) {
    if (values === void 0) return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn(
          `THREE.Material: parameter '${key}' has value of undefined.`
        );
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn(
          `THREE.Material: '${key}' is not a property of THREE.${this.type}.`
        );
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (
        currentValue &&
        currentValue.isVector3 &&
        newValue &&
        newValue.isVector3
      ) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  /**
   * Serializes the material into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized material.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {},
      };
    }
    const data = {
      metadata: {
        version: 4.7,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== void 0) data.roughness = this.roughness;
    if (this.metalness !== void 0) data.metalness = this.metalness;
    if (this.sheen !== void 0) data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor)
      data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0)
      data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0)
      data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor)
      data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0) data.shininess = this.shininess;
    if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.dispersion !== void 0) data.dispersion = this.dispersion;
    if (this.iridescence !== void 0) data.iridescence = this.iridescence;
    if (this.iridescenceIOR !== void 0)
      data.iridescenceIOR = this.iridescenceIOR;
    if (this.iridescenceThicknessRange !== void 0)
      data.iridescenceThicknessRange = this.iridescenceThicknessRange;
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
    }
    if (
      this.iridescenceThicknessMap &&
      this.iridescenceThicknessMap.isTexture
    ) {
      data.iridescenceThicknessMap =
        this.iridescenceThicknessMap.toJSON(meta).uuid;
    }
    if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;
    if (this.anisotropyRotation !== void 0)
      data.anisotropyRotation = this.anisotropyRotation;
    if (this.anisotropyMap && this.anisotropyMap.isTexture) {
      data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
    }
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
      data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture)
      data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0) data.combine = this.combine;
    }
    if (this.envMapRotation !== void 0)
      data.envMapRotation = this.envMapRotation.toArray();
    if (this.envMapIntensity !== void 0)
      data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0)
      data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0) data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture)
      data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0) data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture)
      data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (
      this.attenuationDistance !== void 0 &&
      this.attenuationDistance !== Infinity
    )
      data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0)
      data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0) data.size = this.size;
    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors === true) data.vertexColors = true;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = true;
    if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
    if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
    if (this.blendEquation !== AddEquation)
      data.blendEquation = this.blendEquation;
    if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
    if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
    if (this.blendEquationAlpha !== null)
      data.blendEquationAlpha = this.blendEquationAlpha;
    if (this.blendColor && this.blendColor.isColor)
      data.blendColor = this.blendColor.getHex();
    if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
    if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
    if (this.depthTest === false) data.depthTest = this.depthTest;
    if (this.depthWrite === false) data.depthWrite = this.depthWrite;
    if (this.colorWrite === false) data.colorWrite = this.colorWrite;
    if (this.stencilWriteMask !== 255)
      data.stencilWriteMask = this.stencilWriteMask;
    if (this.stencilFunc !== AlwaysStencilFunc)
      data.stencilFunc = this.stencilFunc;
    if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
    if (this.stencilFuncMask !== 255)
      data.stencilFuncMask = this.stencilFuncMask;
    if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
    if (this.stencilZFail !== KeepStencilOp)
      data.stencilZFail = this.stencilZFail;
    if (this.stencilZPass !== KeepStencilOp)
      data.stencilZPass = this.stencilZPass;
    if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;
    if (this.rotation !== void 0 && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0) data.dashSize = this.dashSize;
    if (this.gapSize !== void 0) data.gapSize = this.gapSize;
    if (this.scale !== void 0) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.alphaHash === true) data.alphaHash = true;
    if (this.alphaToCoverage === true) data.alphaToCoverage = true;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
    if (this.forceSinglePass === true) data.forceSinglePass = true;
    if (this.wireframe === true) data.wireframe = true;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true) data.flatShading = true;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (this.fog === false) data.fog = false;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }
    return data;
  }
  /**
   * Returns a new material with copied values from this instance.
   *
   * @return {Material} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given material to this instance.
   *
   * @param {Material} source - The material to copy.
   * @return {Material} A reference to this instance.
   */
  copy(source) {
    this.name = source.name;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.blendColor.copy(source.blendColor);
    this.blendAlpha = source.blendAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n2 = srcPlanes.length;
      dstPlanes = new Array(n2);
      for (let i2 = 0; i2 !== n2; ++i2) {
        dstPlanes[i2] = srcPlanes[i2].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaHash = source.alphaHash;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.forceSinglePass = source.forceSinglePass;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Material#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Setting this property to `true` indicates the engine the material
   * needs to be recompiled.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
}
class MeshBasicMaterial extends Material {
  /**
   * Constructs a new mesh basic material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isMeshBasicMaterial = true;
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
}
const _tables = /* @__PURE__ */ _generateTables();
function _generateTables() {
  const buffer2 = new ArrayBuffer(4);
  const floatView = new Float32Array(buffer2);
  const uint32View = new Uint32Array(buffer2);
  const baseTable = new Uint32Array(512);
  const shiftTable = new Uint32Array(512);
  for (let i2 = 0; i2 < 256; ++i2) {
    const e2 = i2 - 127;
    if (e2 < -27) {
      baseTable[i2] = 0;
      baseTable[i2 | 256] = 32768;
      shiftTable[i2] = 24;
      shiftTable[i2 | 256] = 24;
    } else if (e2 < -14) {
      baseTable[i2] = 1024 >> (-e2 - 14);
      baseTable[i2 | 256] = (1024 >> (-e2 - 14)) | 32768;
      shiftTable[i2] = -e2 - 1;
      shiftTable[i2 | 256] = -e2 - 1;
    } else if (e2 <= 15) {
      baseTable[i2] = (e2 + 15) << 10;
      baseTable[i2 | 256] = ((e2 + 15) << 10) | 32768;
      shiftTable[i2] = 13;
      shiftTable[i2 | 256] = 13;
    } else if (e2 < 128) {
      baseTable[i2] = 31744;
      baseTable[i2 | 256] = 64512;
      shiftTable[i2] = 24;
      shiftTable[i2 | 256] = 24;
    } else {
      baseTable[i2] = 31744;
      baseTable[i2 | 256] = 64512;
      shiftTable[i2] = 13;
      shiftTable[i2 | 256] = 13;
    }
  }
  const mantissaTable = new Uint32Array(2048);
  const exponentTable = new Uint32Array(64);
  const offsetTable = new Uint32Array(64);
  for (let i2 = 1; i2 < 1024; ++i2) {
    let m = i2 << 13;
    let e2 = 0;
    while ((m & 8388608) === 0) {
      m <<= 1;
      e2 -= 8388608;
    }
    m &= -8388609;
    e2 += 947912704;
    mantissaTable[i2] = m | e2;
  }
  for (let i2 = 1024; i2 < 2048; ++i2) {
    mantissaTable[i2] = 939524096 + ((i2 - 1024) << 13);
  }
  for (let i2 = 1; i2 < 31; ++i2) {
    exponentTable[i2] = i2 << 23;
  }
  exponentTable[31] = 1199570944;
  exponentTable[32] = 2147483648;
  for (let i2 = 33; i2 < 63; ++i2) {
    exponentTable[i2] = 2147483648 + ((i2 - 32) << 23);
  }
  exponentTable[63] = 3347054592;
  for (let i2 = 1; i2 < 64; ++i2) {
    if (i2 !== 32) {
      offsetTable[i2] = 1024;
    }
  }
  return {
    floatView,
    uint32View,
    baseTable,
    shiftTable,
    mantissaTable,
    exponentTable,
    offsetTable,
  };
}
function toHalfFloat(val) {
  if (Math.abs(val) > 65504)
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range.");
  val = clamp$1(val, -65504, 65504);
  _tables.floatView[0] = val;
  const f = _tables.uint32View[0];
  const e2 = (f >> 23) & 511;
  return _tables.baseTable[e2] + ((f & 8388607) >> _tables.shiftTable[e2]);
}
function fromHalfFloat(val) {
  const m = val >> 10;
  _tables.uint32View[0] =
    _tables.mantissaTable[_tables.offsetTable[m] + (val & 1023)] +
    _tables.exponentTable[m];
  return _tables.floatView[0];
}
const _vector$9 = /* @__PURE__ */ new Vector3();
const _vector2$1 = /* @__PURE__ */ new Vector2();
let _id$2$1 = 0;
class BufferAttribute {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(array2, itemSize, normalized = false) {
    if (Array.isArray(array2)) {
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    }
    this.isBufferAttribute = true;
    Object.defineProperty(this, "id", { value: _id$2$1++ });
    this.name = "";
    this.array = array2;
    this.itemSize = itemSize;
    this.count = array2 !== void 0 ? array2.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage;
    this.updateRanges = [];
    this.gpuType = FloatType;
    this.version = 0;
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute
   * array data to the GPU.
   */
  onUploadCallback() {}
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  /**
   * Sets the usage of this buffer attribute.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {BufferAttribute} A reference to this buffer attribute.
   */
  setUsage(value) {
    this.usage = value;
    return this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given buffer attribute to this instance.
   *
   * @param {BufferAttribute} source - The buffer attribute to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }
  /**
   * Copies a vector from the given buffer attribute to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this buffer attribute.
   * @param {BufferAttribute} attribute - The buffer attribute to copy from.
   * @param {number} index2 - The source index into the given buffer attribute.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyAt(index1, attribute2, index2) {
    index1 *= this.itemSize;
    index2 *= attribute2.itemSize;
    for (let i2 = 0, l2 = this.itemSize; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute2.array[index2 + i2];
    }
    return this;
  }
  /**
   * Copies the given array data into this buffer attribute.
   *
   * @param {(TypedArray|Array)} array - The array to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyArray(array2) {
    this.array.set(array2);
    return this;
  }
  /**
   * Applies the given 3x3 matrix to the given attribute. Works with
   * item size `2` and `3`.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector2$1.fromBufferAttribute(this, i2);
        _vector2$1.applyMatrix3(m);
        this.setXY(i2, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector$9.fromBufferAttribute(this, i2);
        _vector$9.applyMatrix3(m);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix4(m) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.fromBufferAttribute(this, i2);
      _vector$9.applyMatrix4(m);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(m) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.fromBufferAttribute(this, i2);
      _vector$9.applyNormalMatrix(m);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  transformDirection(m) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.fromBufferAttribute(this, i2);
      _vector$9.transformDirection(m);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  /**
   * Sets the given array data in the buffer attribute.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this buffer attribute's array.
   * @return {BufferAttribute} A reference to this instance.
   */
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(index, component) {
    let value = this.array[index * this.itemSize + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setComponent(index, component, value) {
    if (this.normalized) value = normalize$1(value, this.array);
    this.array[index * this.itemSize + component] = value;
    return this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(index) {
    let x = this.array[index * this.itemSize];
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setX(index, x) {
    if (this.normalized) x = normalize$1(x, this.array);
    this.array[index * this.itemSize] = x;
    return this;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(index) {
    let y = this.array[index * this.itemSize + 1];
    if (this.normalized) y = denormalize(y, this.array);
    return y;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setY(index, y) {
    if (this.normalized) y = normalize$1(y, this.array);
    this.array[index * this.itemSize + 1] = y;
    return this;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(index) {
    let z = this.array[index * this.itemSize + 2];
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setZ(index, z) {
    if (this.normalized) z = normalize$1(z, this.array);
    this.array[index * this.itemSize + 2] = z;
    return this;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(index) {
    let w = this.array[index * this.itemSize + 3];
    if (this.normalized) w = denormalize(w, this.array);
    return w;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setW(index, w) {
    if (this.normalized) w = normalize$1(w, this.array);
    this.array[index * this.itemSize + 3] = w;
    return this;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXY(index, x, y) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZ(index, x, y, z) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
      z = normalize$1(z, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
      z = normalize$1(z, this.array);
      w = normalize$1(w, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the attribute array data to the GPU. Can be used to perform clean-up operations after
   * the upload when attribute data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {BufferAttribute} A reference to this instance.
   */
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * @return {BufferAttribute} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    if (this.name !== "") data.name = this.name;
    if (this.usage !== StaticDrawUsage) data.usage = this.usage;
    return data;
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(array2, itemSize, normalized) {
    super(new Uint16Array(array2), itemSize, normalized);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(array2, itemSize, normalized) {
    super(new Uint32Array(array2), itemSize, normalized);
  }
}
class Float16BufferAttribute extends BufferAttribute {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(array2, itemSize, normalized) {
    super(new Uint16Array(array2), itemSize, normalized);
    this.isFloat16BufferAttribute = true;
  }
  getX(index) {
    let x = fromHalfFloat(this.array[index * this.itemSize]);
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  setX(index, x) {
    if (this.normalized) x = normalize$1(x, this.array);
    this.array[index * this.itemSize] = toHalfFloat(x);
    return this;
  }
  getY(index) {
    let y = fromHalfFloat(this.array[index * this.itemSize + 1]);
    if (this.normalized) y = denormalize(y, this.array);
    return y;
  }
  setY(index, y) {
    if (this.normalized) y = normalize$1(y, this.array);
    this.array[index * this.itemSize + 1] = toHalfFloat(y);
    return this;
  }
  getZ(index) {
    let z = fromHalfFloat(this.array[index * this.itemSize + 2]);
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize$1(z, this.array);
    this.array[index * this.itemSize + 2] = toHalfFloat(z);
    return this;
  }
  getW(index) {
    let w = fromHalfFloat(this.array[index * this.itemSize + 3]);
    if (this.normalized) w = denormalize(w, this.array);
    return w;
  }
  setW(index, w) {
    if (this.normalized) w = normalize$1(w, this.array);
    this.array[index * this.itemSize + 3] = toHalfFloat(w);
    return this;
  }
  setXY(index, x, y) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
    }
    this.array[index + 0] = toHalfFloat(x);
    this.array[index + 1] = toHalfFloat(y);
    return this;
  }
  setXYZ(index, x, y, z) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
      z = normalize$1(z, this.array);
    }
    this.array[index + 0] = toHalfFloat(x);
    this.array[index + 1] = toHalfFloat(y);
    this.array[index + 2] = toHalfFloat(z);
    return this;
  }
  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
      z = normalize$1(z, this.array);
      w = normalize$1(w, this.array);
    }
    this.array[index + 0] = toHalfFloat(x);
    this.array[index + 1] = toHalfFloat(y);
    this.array[index + 2] = toHalfFloat(z);
    this.array[index + 3] = toHalfFloat(w);
    return this;
  }
}
class Float32BufferAttribute extends BufferAttribute {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(array2, itemSize, normalized) {
    super(new Float32Array(array2), itemSize, normalized);
  }
}
let _id$1$1 = 0;
const _m1$3 = /* @__PURE__ */ new Matrix4();
const _obj = /* @__PURE__ */ new Object3D();
const _offset = /* @__PURE__ */ new Vector3();
const _box$2 = /* @__PURE__ */ new Box3();
const _boxMorphTargets = /* @__PURE__ */ new Box3();
const _vector$8 = /* @__PURE__ */ new Vector3();
class BufferGeometry extends EventDispatcher {
  /**
   * Constructs a new geometry.
   */
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, "id", { value: _id$1$1++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.indirect = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  /**
   * Returns the index of this geometry.
   *
   * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
   */
  getIndex() {
    return this.index;
  }
  /**
   * Sets the given index to this geometry.
   *
   * @param {Array<number>|BufferAttribute} index - The index to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (
        arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute
      )(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  /**
   * Sets the given indirect attribute to this geometry.
   *
   * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndirect(indirect) {
    this.indirect = indirect;
    return this;
  }
  /**
   * Returns the indirect attribute of this geometry.
   *
   * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
   */
  getIndirect() {
    return this.indirect;
  }
  /**
   * Returns the buffer attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
   * Returns `undefined` if not attribute has been found.
   */
  getAttribute(name) {
    return this.attributes[name];
  }
  /**
   * Sets the given attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setAttribute(name, attribute2) {
    this.attributes[name] = attribute2;
    return this;
  }
  /**
   * Deletes the attribute for the given name.
   *
   * @param {string} name - The attribute name to delete.
   * @return {BufferGeometry} A reference to this instance.
   */
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  /**
   * Returns `true` if this geometry has an attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {boolean} Whether this geometry has an attribute for the given name or not.
   */
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  /**
   * Adds a group to this geometry.
   *
   * @param {number} start - The first element in this draw call. That is the first
   * vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - Specifies how many vertices (or indices) are part of this group.
   * @param {number} [materialIndex=0] - The material array index to use.
   */
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex,
    });
  }
  /**
   * Clears all groups.
   */
  clearGroups() {
    this.groups = [];
  }
  /**
   * Sets the draw range for this geometry.
   *
   * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
   * For indexed BufferGeometry, `count` is the number of indices to render.
   */
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  /**
   * Applies the given 4x4 transformation matrix to the geometry.
   *
   * @param {Matrix4} matrix - The matrix to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal2 = this.attributes.normal;
    if (normal2 !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal2.applyNormalMatrix(normalMatrix);
      normal2.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  /**
   * Applies the rotation represented by the Quaternion to the geometry.
   *
   * @param {Quaternion} q - The Quaternion to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyQuaternion(q) {
    _m1$3.makeRotationFromQuaternion(q);
    this.applyMatrix4(_m1$3);
    return this;
  }
  /**
   * Rotates the geometry about the X axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateX(angle) {
    _m1$3.makeRotationX(angle);
    this.applyMatrix4(_m1$3);
    return this;
  }
  /**
   * Rotates the geometry about the Y axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateY(angle) {
    _m1$3.makeRotationY(angle);
    this.applyMatrix4(_m1$3);
    return this;
  }
  /**
   * Rotates the geometry about the Z axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateZ(angle) {
    _m1$3.makeRotationZ(angle);
    this.applyMatrix4(_m1$3);
    return this;
  }
  /**
   * Translates the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#position} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x offset.
   * @param {number} y - The y offset.
   * @param {number} z - The z offset.
   * @return {BufferGeometry} A reference to this instance.
   */
  translate(x, y, z) {
    _m1$3.makeTranslation(x, y, z);
    this.applyMatrix4(_m1$3);
    return this;
  }
  /**
   * Scales the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#scale} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x scale.
   * @param {number} y - The y scale.
   * @param {number} z - The z scale.
   * @return {BufferGeometry} A reference to this instance.
   */
  scale(x, y, z) {
    _m1$3.makeScale(x, y, z);
    this.applyMatrix4(_m1$3);
    return this;
  }
  /**
   * Rotates the geometry to face a point in 3D space. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
   * real-time mesh rotation.
   *
   * @param {Vector3} vector - The target point.
   * @return {BufferGeometry} A reference to this instance.
   */
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  /**
   * Center the geometry based on its bounding box.
   *
   * @return {BufferGeometry} A reference to this instance.
   */
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  /**
   * Defines a geometry by creating a `position` attribute based on the given array of points. The array
   * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
   * set to `0`.
   *
   * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
   * data from the array. The length of the array must match the vertex count.
   *
   * @param {Array<Vector2>|Array<Vector3>} points - The points.
   * @return {BufferGeometry} A reference to this instance.
   */
  setFromPoints(points) {
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute === void 0) {
      const position = [];
      for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
        const point = points[i2];
        position.push(point.x, point.y, point.z || 0);
      }
      this.setAttribute("position", new Float32BufferAttribute(position, 3));
    } else {
      const l2 = Math.min(points.length, positionAttribute.count);
      for (let i2 = 0; i2 < l2; i2++) {
        const point = points[i2];
        positionAttribute.setXYZ(i2, point.x, point.y, point.z || 0);
      }
      if (points.length > positionAttribute.count) {
        console.warn(
          "THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."
        );
      }
      positionAttribute.needsUpdate = true;
    }
    return this;
  }
  /**
   * Computes the bounding box of the geometry, and updates the `boundingBox` member.
   * The bounding box is not computed by the engine; it must be computed by your app.
   * You may need to recompute the bounding box if the geometry vertices are modified.
   */
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      );
      this.boundingBox.set(
        new Vector3(-Infinity, -Infinity, -Infinity),
        new Vector3(Infinity, Infinity, Infinity)
      );
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _box$2.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$2.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$2.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (
      isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)
    ) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
    }
  }
  /**
   * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
   * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
   * You may need to recompute the bounding sphere if the geometry vertices are modified.
   */
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      );
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$2.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
            _box$2.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
            _box$2.expandByPoint(_vector$8);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);
            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$2.getCenter(center);
      let maxRadiusSq = 0;
      for (let i2 = 0, il = position.count; i2 < il; i2++) {
        _vector$8.fromBufferAttribute(position, i2);
        maxRadiusSq = Math.max(
          maxRadiusSq,
          center.distanceToSquared(_vector$8)
        );
      }
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$8.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(
              maxRadiusSq,
              center.distanceToSquared(_vector$8)
            );
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error(
          'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
          this
        );
      }
    }
  }
  /**
   * Calculates and adds a tangent attribute to this geometry.
   *
   * The computation is only supported for indexed geometries and if position, normal, and uv attributes
   * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
   * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
   */
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (
      index === null ||
      attributes.position === void 0 ||
      attributes.normal === void 0 ||
      attributes.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const positionAttribute = attributes.position;
    const normalAttribute = attributes.normal;
    const uvAttribute = attributes.uv;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute(
        "tangent",
        new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4)
      );
    }
    const tangentAttribute = this.getAttribute("tangent");
    const tan1 = [],
      tan2 = [];
    for (let i2 = 0; i2 < positionAttribute.count; i2++) {
      tan1[i2] = new Vector3();
      tan2[i2] = new Vector3();
    }
    const vA = new Vector3(),
      vB = new Vector3(),
      vC = new Vector3(),
      uvA = new Vector2(),
      uvB = new Vector2(),
      uvC = new Vector2(),
      sdir = new Vector3(),
      tdir = new Vector3();
    function handleTriangle(a2, b, c2) {
      vA.fromBufferAttribute(positionAttribute, a2);
      vB.fromBufferAttribute(positionAttribute, b);
      vC.fromBufferAttribute(positionAttribute, c2);
      uvA.fromBufferAttribute(uvAttribute, a2);
      uvB.fromBufferAttribute(uvAttribute, b);
      uvC.fromBufferAttribute(uvAttribute, c2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r2)) return;
      sdir
        .copy(vB)
        .multiplyScalar(uvC.y)
        .addScaledVector(vC, -uvB.y)
        .multiplyScalar(r2);
      tdir
        .copy(vC)
        .multiplyScalar(uvB.x)
        .addScaledVector(vB, -uvC.x)
        .multiplyScalar(r2);
      tan1[a2].add(sdir);
      tan1[b].add(sdir);
      tan1[c2].add(sdir);
      tan2[a2].add(tdir);
      tan2[b].add(tdir);
      tan2[c2].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [
        {
          start: 0,
          count: index.count,
        },
      ];
    }
    for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(index.getX(j + 0), index.getX(j + 1), index.getX(j + 2));
      }
    }
    const tmp = new Vector3(),
      tmp2 = new Vector3();
    const n2 = new Vector3(),
      n22 = new Vector3();
    function handleVertex(v) {
      n2.fromBufferAttribute(normalAttribute, v);
      n22.copy(n2);
      const t2 = tan1[v];
      tmp.copy(t2);
      tmp.sub(n2.multiplyScalar(n2.dot(t2))).normalize();
      tmp2.crossVectors(n22, t2);
      const test = tmp2.dot(tan2[v]);
      const w = test < 0 ? -1 : 1;
      tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);
    }
    for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(index.getX(j + 0));
        handleVertex(index.getX(j + 1));
        handleVertex(index.getX(j + 2));
      }
    }
  }
  /**
   * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
   * each vertex normal to be the average of the face normals of the faces that share that vertex.
   * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
   * to be the same as the face normal.
   */
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(
          new Float32Array(positionAttribute.count * 3),
          3
        );
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
          normalAttribute.setXYZ(i2, 0, 0, 0);
        }
      }
      const pA = new Vector3(),
        pB = new Vector3(),
        pC = new Vector3();
      const nA = new Vector3(),
        nB = new Vector3(),
        nC = new Vector3();
      const cb = new Vector3(),
        ab = new Vector3();
      if (index) {
        for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
          const vA = index.getX(i2 + 0);
          const vB = index.getX(i2 + 1);
          const vC = index.getX(i2 + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
          pA.fromBufferAttribute(positionAttribute, i2 + 0);
          pB.fromBufferAttribute(positionAttribute, i2 + 1);
          pC.fromBufferAttribute(positionAttribute, i2 + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  /**
   * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
   * correct lighting on the geometry surfaces.
   */
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i2 = 0, il = normals.count; i2 < il; i2++) {
      _vector$8.fromBufferAttribute(normals, i2);
      _vector$8.normalize();
      normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  /**
   * Return a new non-index version of this indexed geometry. If the geometry
   * is already non-indexed, the method is a NOOP.
   *
   * @return {BufferGeometry} The non-indexed version of this indexed geometry.
   */
  toNonIndexed() {
    function convertBufferAttribute(attribute2, indices2) {
      const array2 = attribute2.array;
      const itemSize = attribute2.itemSize;
      const normalized = attribute2.normalized;
      const array22 = new array2.constructor(indices2.length * itemSize);
      let index = 0,
        index2 = 0;
      for (let i2 = 0, l2 = indices2.length; i2 < l2; i2++) {
        if (attribute2.isInterleavedBufferAttribute) {
          index = indices2[i2] * attribute2.data.stride + attribute2.offset;
        } else {
          index = indices2[i2] * itemSize;
        }
        for (let j = 0; j < itemSize; j++) {
          array22[index2++] = array2[index++];
        }
      }
      return new BufferAttribute(array22, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn(
        "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
      );
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute2 = attributes[name];
      const newAttribute = convertBufferAttribute(attribute2, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
        const attribute2 = morphAttribute[i2];
        const newAttribute = convertBufferAttribute(attribute2, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
      const group = groups[i2];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  /**
   * Serializes the geometry into JSON.
   *
   * @return {Object} A JSON object representing the serialized geometry.
   */
  toJSON() {
    const data = {
      metadata: {
        version: 4.7,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0) data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array),
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute2 = attributes[key];
      data.data.attributes[key] = attribute2.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray2 = this.morphAttributes[key];
      const array2 = [];
      for (let i2 = 0, il = attributeArray2.length; i2 < il; i2++) {
        const attribute2 = attributeArray2[i2];
        array2.push(attribute2.toJSON(data.data));
      }
      if (array2.length > 0) {
        morphAttributes[key] = array2;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = boundingSphere.toJSON();
    }
    return data;
  }
  /**
   * Returns a new geometry with copied values from this instance.
   *
   * @return {BufferGeometry} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given geometry to this instance.
   *
   * @param {BufferGeometry} source - The geometry to copy.
   * @return {BufferGeometry} A reference to this instance.
   */
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone());
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute2 = attributes[name];
      this.setAttribute(name, attribute2.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array2 = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, l2 = morphAttribute.length; i2 < l2; i2++) {
        array2.push(morphAttribute[i2].clone(data));
      }
      this.morphAttributes[name] = array2;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
      const group = groups[i2];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires BufferGeometry#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();
const _ray$3 = /* @__PURE__ */ new Ray();
const _sphere$6 = /* @__PURE__ */ new Sphere();
const _sphereHitAt = /* @__PURE__ */ new Vector3();
const _vA$1 = /* @__PURE__ */ new Vector3();
const _vB$1 = /* @__PURE__ */ new Vector3();
const _vC$1 = /* @__PURE__ */ new Vector3();
const _tempA = /* @__PURE__ */ new Vector3();
const _morphA = /* @__PURE__ */ new Vector3();
const _intersectionPoint = /* @__PURE__ */ new Vector3();
const _intersectionPointWorld = /* @__PURE__ */ new Vector3();
class Mesh extends Object3D {
  /**
   * Constructs a new mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   */
  constructor(
    geometry = new BufferGeometry(),
    material = new MeshBasicMaterial()
  ) {
    super();
    this.isMesh = true;
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.morphTargetDictionary = void 0;
    this.morphTargetInfluences = void 0;
    this.count = 1;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign(
        {},
        source.morphTargetDictionary
      );
    }
    this.material = Array.isArray(source.material)
      ? source.material.slice()
      : source.material;
    this.geometry = source.geometry;
    return this;
  }
  /**
   * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
  /**
   * Returns the local-space position of the vertex at the given index, taking into
   * account the current animation state of both morph targets and skinning.
   *
   * @param {number} index - The vertex index.
   * @param {Vector3} target - The target object that is used to store the method's result.
   * @return {Vector3} The vertex position in local space.
   */
  getVertexPosition(index, target) {
    const geometry = this.geometry;
    const position = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    target.fromBufferAttribute(position, index);
    const morphInfluences = this.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
        const influence = morphInfluences[i2];
        const morphAttribute = morphPosition[i2];
        if (influence === 0) continue;
        _tempA.fromBufferAttribute(morphAttribute, index);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(target), influence);
        }
      }
      target.add(_morphA);
    }
    return target;
  }
  /**
   * Computes intersection points between a casted ray and this line.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$6.copy(geometry.boundingSphere);
    _sphere$6.applyMatrix4(matrixWorld);
    _ray$3.copy(raycaster.ray).recast(raycaster.near);
    if (_sphere$6.containsPoint(_ray$3.origin) === false) {
      if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
      if (
        _ray$3.origin.distanceToSquared(_sphereHitAt) >
        (raycaster.far - raycaster.near) ** 2
      )
        return;
    }
    _inverseMatrix$3.copy(matrixWorld).invert();
    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
    if (geometry.boundingBox !== null) {
      if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects, _ray$3);
  }
  _computeIntersections(raycaster, intersects, rayLocalSpace) {
    let intersection;
    const geometry = this.geometry;
    const material = this.material;
    const index = geometry.index;
    const position = geometry.attributes.position;
    const uv2 = geometry.attributes.uv;
    const uv1 = geometry.attributes.uv1;
    const normal2 = geometry.attributes.normal;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;
    if (index !== null) {
      if (Array.isArray(material)) {
        for (let i2 = 0, il = groups.length; i2 < il; i2++) {
          const group = groups[i2];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(
            index.count,
            Math.min(
              group.start + group.count,
              drawRange.start + drawRange.count
            )
          );
          for (let j = start, jl = end; j < jl; j += 3) {
            const a2 = index.getX(j);
            const b = index.getX(j + 1);
            const c2 = index.getX(j + 2);
            intersection = checkGeometryIntersection(
              this,
              groupMaterial,
              raycaster,
              rayLocalSpace,
              uv2,
              uv1,
              normal2,
              a2,
              b,
              c2
            );
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i2 = start, il = end; i2 < il; i2 += 3) {
          const a2 = index.getX(i2);
          const b = index.getX(i2 + 1);
          const c2 = index.getX(i2 + 2);
          intersection = checkGeometryIntersection(
            this,
            material,
            raycaster,
            rayLocalSpace,
            uv2,
            uv1,
            normal2,
            a2,
            b,
            c2
          );
          if (intersection) {
            intersection.faceIndex = Math.floor(i2 / 3);
            intersects.push(intersection);
          }
        }
      }
    } else if (position !== void 0) {
      if (Array.isArray(material)) {
        for (let i2 = 0, il = groups.length; i2 < il; i2++) {
          const group = groups[i2];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(
            position.count,
            Math.min(
              group.start + group.count,
              drawRange.start + drawRange.count
            )
          );
          for (let j = start, jl = end; j < jl; j += 3) {
            const a2 = j;
            const b = j + 1;
            const c2 = j + 2;
            intersection = checkGeometryIntersection(
              this,
              groupMaterial,
              raycaster,
              rayLocalSpace,
              uv2,
              uv1,
              normal2,
              a2,
              b,
              c2
            );
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(position.count, drawRange.start + drawRange.count);
        for (let i2 = start, il = end; i2 < il; i2 += 3) {
          const a2 = i2;
          const b = i2 + 1;
          const c2 = i2 + 2;
          intersection = checkGeometryIntersection(
            this,
            material,
            raycaster,
            rayLocalSpace,
            uv2,
            uv1,
            normal2,
            a2,
            b,
            c2
          );
          if (intersection) {
            intersection.faceIndex = Math.floor(i2 / 3);
            intersects.push(intersection);
          }
        }
      }
    }
  }
}
function checkIntersection$1(
  object,
  material,
  raycaster,
  ray,
  pA,
  pB,
  pC,
  point
) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(
      pA,
      pB,
      pC,
      material.side === FrontSide,
      point
    );
  }
  if (intersect === null) return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance2 = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance2 < raycaster.near || distance2 > raycaster.far) return null;
  return {
    distance: distance2,
    point: _intersectionPointWorld.clone(),
    object,
  };
}
function checkGeometryIntersection(
  object,
  material,
  raycaster,
  ray,
  uv2,
  uv1,
  normal2,
  a2,
  b,
  c2
) {
  object.getVertexPosition(a2, _vA$1);
  object.getVertexPosition(b, _vB$1);
  object.getVertexPosition(c2, _vC$1);
  const intersection = checkIntersection$1(
    object,
    material,
    raycaster,
    ray,
    _vA$1,
    _vB$1,
    _vC$1,
    _intersectionPoint
  );
  if (intersection) {
    const barycoord = new Vector3();
    Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);
    if (uv2) {
      intersection.uv = Triangle.getInterpolatedAttribute(
        uv2,
        a2,
        b,
        c2,
        barycoord,
        new Vector2()
      );
    }
    if (uv1) {
      intersection.uv1 = Triangle.getInterpolatedAttribute(
        uv1,
        a2,
        b,
        c2,
        barycoord,
        new Vector2()
      );
    }
    if (normal2) {
      intersection.normal = Triangle.getInterpolatedAttribute(
        normal2,
        a2,
        b,
        c2,
        barycoord,
        new Vector3()
      );
      if (intersection.normal.dot(ray.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a: a2,
      b,
      c: c2,
      normal: new Vector3(),
      materialIndex: 0,
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
    intersection.barycoord = barycoord;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  /**
   * Constructs a new box geometry.
   *
   * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
   * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
   * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
   * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
   * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
   * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
   */
  constructor(
    width = 1,
    height = 1,
    depth2 = 1,
    widthSegments = 1,
    heightSegments = 1,
    depthSegments = 1
  ) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth: depth2,
      widthSegments,
      heightSegments,
      depthSegments,
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane(
      "z",
      "y",
      "x",
      -1,
      -1,
      depth2,
      height,
      width,
      depthSegments,
      heightSegments,
      0
    );
    buildPlane(
      "z",
      "y",
      "x",
      1,
      -1,
      depth2,
      height,
      -width,
      depthSegments,
      heightSegments,
      1
    );
    buildPlane(
      "x",
      "z",
      "y",
      1,
      1,
      width,
      depth2,
      height,
      widthSegments,
      depthSegments,
      2
    );
    buildPlane(
      "x",
      "z",
      "y",
      1,
      -1,
      width,
      depth2,
      -height,
      widthSegments,
      depthSegments,
      3
    );
    buildPlane(
      "x",
      "y",
      "z",
      1,
      -1,
      width,
      height,
      depth2,
      widthSegments,
      heightSegments,
      4
    );
    buildPlane(
      "x",
      "y",
      "z",
      -1,
      -1,
      width,
      height,
      -depth2,
      widthSegments,
      heightSegments,
      5
    );
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(
      u2,
      v,
      w,
      udir,
      vdir,
      width2,
      height2,
      depth3,
      gridX,
      gridY,
      materialIndex
    ) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth3 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;
          vector[u2] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u2] = 0;
          vector[v] = 0;
          vector[w] = depth3 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a2 = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c2 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a2, b, d2);
          indices.push(b, c2, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {BoxGeometry} A new instance.
   */
  static fromJSON(data) {
    return new BoxGeometry(
      data.width,
      data.height,
      data.depth,
      data.widthSegments,
      data.heightSegments,
      data.depthSegments
    );
  }
}
function cloneUniforms(src) {
  const dst = {};
  for (const u2 in src) {
    dst[u2] = {};
    for (const p2 in src[u2]) {
      const property2 = src[u2][p2];
      if (
        property2 &&
        (property2.isColor ||
          property2.isMatrix3 ||
          property2.isMatrix4 ||
          property2.isVector2 ||
          property2.isVector3 ||
          property2.isVector4 ||
          property2.isTexture ||
          property2.isQuaternion)
      ) {
        if (property2.isRenderTargetTexture) {
          console.warn(
            "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
          );
          dst[u2][p2] = null;
        } else {
          dst[u2][p2] = property2.clone();
        }
      } else if (Array.isArray(property2)) {
        dst[u2][p2] = property2.slice();
      } else {
        dst[u2][p2] = property2;
      }
    }
  }
  return dst;
}
function cloneUniformsGroups(src) {
  const dst = [];
  for (let u2 = 0; u2 < src.length; u2++) {
    dst.push(src[u2].clone());
  }
  return dst;
}
var default_vertex =
  "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment =
  "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
class ShaderMaterial extends Material {
  /**
   * Constructs a new shader material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isShaderMaterial = true;
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.uniformsGroups = [];
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.forceSinglePass = true;
    this.extensions = {
      clipCullDistance: false,
      // set to use vertex shader clipping
      multiDraw: false,
      // set to use vertex shader multi_draw / enable gl_DrawID
    };
    this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0],
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.fog = source.fog;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform2 = this.uniforms[name];
      const value = uniform2.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid,
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex(),
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray(),
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray(),
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray(),
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray(),
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray(),
        };
      } else {
        data.uniforms[name] = {
          value,
        };
      }
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    data.lights = this.lights;
    data.clipping = this.clipping;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true) extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
  }
}
class Camera extends Object3D {
  /**
   * Constructs a new camera.
   */
  constructor() {
    super();
    this.isCamera = true;
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
    this.coordinateSystem = WebGLCoordinateSystem;
    this._reversedDepth = false;
  }
  /**
   * The flag that indicates whether the camera uses a reversed depth buffer.
   *
   * @type {boolean}
   * @default false
   */
  get reversedDepth() {
    return this._reversedDepth;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    this.coordinateSystem = source.coordinateSystem;
    return this;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * This method is overwritten since cameras have a different forward vector compared to other
   * 3D objects. A camera looks down its local, negative z-axis by default.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(target) {
    return super.getWorldDirection(target).negate();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _v3$1 = /* @__PURE__ */ new Vector3();
const _minTarget = /* @__PURE__ */ new Vector2();
const _maxTarget = /* @__PURE__ */ new Vector2();
class PerspectiveCamera extends Camera {
  /**
   * Constructs a new perspective camera.
   *
   * @param {number} [fov=50] - The vertical field of view.
   * @param {number} [aspect=1] - The aspect ratio.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.isPerspectiveCamera = true;
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(focalLength) {
    const vExtentSlope = (0.5 * this.getFilmHeight()) / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Returns the focal length from the current {@link PerspectiveCamera#fov} and
   * {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The computed focal length.
   */
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / vExtentSlope;
  }
  /**
   * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
   *
   * @return {number} The effective FOV.
   */
  getEffectiveFOV() {
    return (
      RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom)
    );
  }
  /**
   * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  /**
   * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
   * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
   */
  getViewBounds(distance2, minTarget, maxTarget) {
    _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance2 / _v3$1.z);
    _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance2 / _v3$1.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
   * @returns {Vector2} The view size.
   */
  getViewSize(distance2, target) {
    this.getViewBounds(distance2, _minTarget, _maxTarget);
    return target.subVectors(_maxTarget, _minTarget);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *```
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *```
   * then for each monitor you would call it like this:
   *```js
   * const w = 1920;
   * const h = 1080;
   * const fullWidth = w * 3;
   * const fullHeight = h * 2;
   *
   * // --A--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   * // --B--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   * // --C--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   * // --D--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   * // --E--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   * // --F--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   * ```
   *
   * Note there is no reason monitors have to be the same size or in a grid.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   */
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const near = this.near;
    let top = (near * Math.tan(DEG2RAD * 0.5 * this.fov)) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth,
        fullHeight = view.fullHeight;
      left += (view.offsetX * width) / fullWidth;
      top -= (view.offsetY * height) / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0) left += (near * skew) / this.getFilmWidth();
    this.projectionMatrix.makePerspective(
      left,
      left + width,
      top,
      top - height,
      near,
      this.far,
      this.coordinateSystem,
      this.reversedDepth
    );
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
}
const fov = -90;
const aspect = 1;
class CubeCamera extends Object3D {
  /**
   * Constructs a new cube camera.
   *
   * @param {number} near - The camera's near plane.
   * @param {number} far - The camera's far plane.
   * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
   */
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    this.renderTarget = renderTarget;
    this.coordinateSystem = null;
    this.activeMipmapLevel = 0;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    this.add(cameraNZ);
  }
  /**
   * Must be called when the coordinate system of the cube camera is changed.
   */
  updateCoordinateSystem() {
    const coordinateSystem = this.coordinateSystem;
    const cameras = this.children.concat();
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] =
      cameras;
    for (const camera2 of cameras) this.remove(camera2);
    if (coordinateSystem === WebGLCoordinateSystem) {
      cameraPX.up.set(0, 1, 0);
      cameraPX.lookAt(1, 0, 0);
      cameraNX.up.set(0, 1, 0);
      cameraNX.lookAt(-1, 0, 0);
      cameraPY.up.set(0, 0, -1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, 1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, 1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, 1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(-1, 0, 0);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(1, 0, 0);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else {
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          coordinateSystem
      );
    }
    for (const camera2 of cameras) {
      this.add(camera2);
      camera2.updateMatrixWorld();
    }
  }
  /**
   * Calling this method will render the given scene with the given renderer
   * into the cube render target of the camera.
   *
   * @param {(Renderer|WebGLRenderer)} renderer - The renderer.
   * @param {Scene} scene - The scene to render.
   */
  update(renderer2, scene2) {
    if (this.parent === null) this.updateMatrixWorld();
    const { renderTarget, activeMipmapLevel } = this;
    if (this.coordinateSystem !== renderer2.coordinateSystem) {
      this.coordinateSystem = renderer2.coordinateSystem;
      this.updateCoordinateSystem();
    }
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] =
      this.children;
    const currentRenderTarget = renderer2.getRenderTarget();
    const currentActiveCubeFace = renderer2.getActiveCubeFace();
    const currentActiveMipmapLevel = renderer2.getActiveMipmapLevel();
    const currentXrEnabled = renderer2.xr.enabled;
    renderer2.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer2.setRenderTarget(renderTarget, 0, activeMipmapLevel);
    renderer2.render(scene2, cameraPX);
    renderer2.setRenderTarget(renderTarget, 1, activeMipmapLevel);
    renderer2.render(scene2, cameraNX);
    renderer2.setRenderTarget(renderTarget, 2, activeMipmapLevel);
    renderer2.render(scene2, cameraPY);
    renderer2.setRenderTarget(renderTarget, 3, activeMipmapLevel);
    renderer2.render(scene2, cameraNY);
    renderer2.setRenderTarget(renderTarget, 4, activeMipmapLevel);
    renderer2.render(scene2, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer2.setRenderTarget(renderTarget, 5, activeMipmapLevel);
    renderer2.render(scene2, cameraNZ);
    renderer2.setRenderTarget(
      currentRenderTarget,
      currentActiveCubeFace,
      currentActiveMipmapLevel
    );
    renderer2.xr.enabled = currentXrEnabled;
    renderTarget.texture.needsPMREMUpdate = true;
  }
}
class CubeTexture extends Texture {
  /**
   * Constructs a new cube texture.
   *
   * @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
   * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space value.
   */
  constructor(
    images = [],
    mapping = CubeReflectionMapping,
    wrapS,
    wrapT,
    magFilter,
    minFilter,
    format,
    type,
    anisotropy2,
    colorSpace
  ) {
    super(
      images,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy2,
      colorSpace
    );
    this.isCubeTexture = true;
    this.flipY = false;
  }
  /**
   * Alias for {@link CubeTexture#image}.
   *
   * @type {Array<Image>}
   */
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  /**
   * Constructs a new cube render target.
   *
   * @param {number} [size=1] - The size of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(size = 1, options = {}) {
    super(size, size, options);
    this.isWebGLCubeRenderTarget = true;
    const image = { width: size, height: size, depth: 1 };
    const images = [image, image, image, image, image, image];
    this.texture = new CubeTexture(images);
    this._setTextureOptions(options);
    this.texture.isRenderTargetTexture = true;
  }
  /**
   * Converts the given equirectangular texture to a cube map.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Texture} texture - The equirectangular texture.
   * @return {WebGLCubeRenderTarget} A reference to this cube render target.
   */
  fromEquirectangularTexture(renderer2, texture2) {
    this.texture.type = texture2.type;
    this.texture.colorSpace = texture2.colorSpace;
    this.texture.generateMipmaps = texture2.generateMipmaps;
    this.texture.minFilter = texture2.minFilter;
    this.texture.magFilter = texture2.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null },
      },
      vertexShader:
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader:
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending,
    });
    material.uniforms.tEquirect.value = texture2;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture2.minFilter;
    if (texture2.minFilter === LinearMipmapLinearFilter)
      texture2.minFilter = LinearFilter;
    const camera2 = new CubeCamera(1, 10, this);
    camera2.update(renderer2, mesh);
    texture2.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  /**
   * Clears this cube render target.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   */
  clear(renderer2, color2 = true, depth2 = true, stencil = true) {
    const currentRenderTarget = renderer2.getRenderTarget();
    for (let i2 = 0; i2 < 6; i2++) {
      renderer2.setRenderTarget(this, i2);
      renderer2.clear(color2, depth2, stencil);
    }
    renderer2.setRenderTarget(currentRenderTarget);
  }
}
class Group extends Object3D {
  constructor() {
    super();
    this.isGroup = true;
    this.type = "Group";
  }
}
const _moveEvent = { type: "move" };
class WebXRController {
  /**
   * Constructs a new XR controller.
   */
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  /**
   * Returns a group representing the hand space of the XR controller.
   *
   * @return {Group} A group representing the hand space of the XR controller.
   */
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  /**
   * Returns a group representing the target ray space of the XR controller.
   *
   * @return {Group} A group representing the target ray space of the XR controller.
   */
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  /**
   * Returns a group representing the grip space of the XR controller.
   *
   * @return {Group} A group representing the grip space of the XR controller.
   */
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  /**
   * Dispatches the given event to the groups representing
   * the different coordinate spaces of the XR controller.
   *
   * @param {Object} event - The event to dispatch.
   * @return {WebXRController} A reference to this instance.
   */
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  /**
   * Connects the controller with the given XR input source.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @return {WebXRController} A reference to this instance.
   */
  connect(inputSource) {
    if (inputSource && inputSource.hand) {
      const hand = this._hand;
      if (hand) {
        for (const inputjoint of inputSource.hand.values()) {
          this._getHandJoint(hand, inputjoint);
        }
      }
    }
    this.dispatchEvent({ type: "connected", data: inputSource });
    return this;
  }
  /**
   * Disconnects the controller from the given XR input source.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @return {WebXRController} A reference to this instance.
   */
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  /**
   * Updates the controller with the given input source, XR frame and reference space.
   * This updates the transformations of the groups that represent the different
   * coordinate systems of the controller.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @param {XRFrame} frame - The XR frame.
   * @param {XRReferenceSpace} referenceSpace - The reference space.
   * @return {WebXRController} A reference to this instance.
   */
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          const joint = this._getHandJoint(hand, inputjoint);
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.matrixWorldNeedsUpdate = true;
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance2 = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (
          hand.inputState.pinching &&
          distance2 > distanceToPinch + threshold
        ) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this,
          });
        } else if (
          !hand.inputState.pinching &&
          distance2 <= distanceToPinch - threshold
        ) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this,
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            grip.matrixWorldNeedsUpdate = true;
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose === null && gripPose !== null) {
          inputPose = gripPose;
        }
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(
            targetRay.position,
            targetRay.rotation,
            targetRay.scale
          );
          targetRay.matrixWorldNeedsUpdate = true;
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
  /**
   * Returns a group representing the hand joint for the given input joint.
   *
   * @private
   * @param {Group} hand - The group representing the hand space.
   * @param {XRJointSpace} inputjoint - The hand joint data.
   * @return {Group} A group representing the hand joint for the given input joint.
   */
  _getHandJoint(hand, inputjoint) {
    if (hand.joints[inputjoint.jointName] === void 0) {
      const joint = new Group();
      joint.matrixAutoUpdate = false;
      joint.visible = false;
      hand.joints[inputjoint.jointName] = joint;
      hand.add(joint);
    }
    return hand.joints[inputjoint.jointName];
  }
}
class Scene extends Object3D {
  /**
   * Constructs a new scene.
   */
  constructor() {
    super();
    this.isScene = true;
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.backgroundBlurriness = 0;
    this.backgroundIntensity = 1;
    this.backgroundRotation = new Euler();
    this.environmentIntensity = 1;
    this.environmentRotation = new Euler();
    this.overrideMaterial = null;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this })
      );
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    this.backgroundBlurriness = source.backgroundBlurriness;
    this.backgroundIntensity = source.backgroundIntensity;
    this.backgroundRotation.copy(source.backgroundRotation);
    this.environmentIntensity = source.environmentIntensity;
    this.environmentRotation.copy(source.environmentRotation);
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    if (this.backgroundBlurriness > 0)
      data.object.backgroundBlurriness = this.backgroundBlurriness;
    if (this.backgroundIntensity !== 1)
      data.object.backgroundIntensity = this.backgroundIntensity;
    data.object.backgroundRotation = this.backgroundRotation.toArray();
    if (this.environmentIntensity !== 1)
      data.object.environmentIntensity = this.environmentIntensity;
    data.object.environmentRotation = this.environmentRotation.toArray();
    return data;
  }
}
class InterleavedBuffer {
  /**
   * Constructs a new interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   */
  constructor(array2, stride) {
    this.isInterleavedBuffer = true;
    this.array = array2;
    this.stride = stride;
    this.count = array2 !== void 0 ? array2.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRanges = [];
    this.version = 0;
    this.uuid = generateUUID();
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute array
   * data to the GPU.
   */
  onUploadCallback() {}
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  /**
   * Sets the usage of this interleaved buffer.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {InterleavedBuffer} A reference to this interleaved buffer.
   */
  setUsage(value) {
    this.usage = value;
    return this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given interleaved buffer to this instance.
   *
   * @param {InterleavedBuffer} source - The interleaved buffer to copy.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  /**
   * Copies a vector from the given interleaved buffer to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this interleaved buffer.
   * @param {InterleavedBuffer} interleavedBuffer - The interleaved buffer to copy from.
   * @param {number} index2 - The source index into the given interleaved buffer.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copyAt(index1, interleavedBuffer, index2) {
    index1 *= this.stride;
    index2 *= interleavedBuffer.stride;
    for (let i2 = 0, l2 = this.stride; i2 < l2; i2++) {
      this.array[index1 + i2] = interleavedBuffer.array[index2 + i2];
    }
    return this;
  }
  /**
   * Sets the given array data in the interleaved buffer.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this interleaved buffer's array.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  /**
   * Returns a new interleaved buffer with copied values from this instance.
   *
   * @param {Object} [data] - An object with shared array buffers that allows to retain shared structures.
   * @return {InterleavedBuffer} A clone of this instance.
   */
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array2 = new this.array.constructor(
      data.arrayBuffers[this.array.buffer._uuid]
    );
    const ib = new this.constructor(array2, this.stride);
    ib.setUsage(this.usage);
    return ib;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the array data to the GPU. Can be used to perform clean-up operations after
   * the upload when data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  /**
   * Serializes the interleaved buffer into JSON.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized interleaved buffer.
   */
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.from(
        new Uint32Array(this.array.buffer)
      );
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride,
    };
  }
}
const _vector$7 = /* @__PURE__ */ new Vector3();
class InterleavedBufferAttribute {
  /**
   * Constructs a new interleaved buffer attribute.
   *
   * @param {InterleavedBuffer} interleavedBuffer - The buffer holding the interleaved data.
   * @param {number} itemSize - The item size.
   * @param {number} offset - The attribute offset into the buffer.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.isInterleavedBufferAttribute = true;
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized;
  }
  /**
   * The item count of this buffer attribute.
   *
   * @type {number}
   * @readonly
   */
  get count() {
    return this.data.count;
  }
  /**
   * The array holding the interleaved buffer attribute data.
   *
   * @type {TypedArray}
   */
  get array() {
    return this.data.array;
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyMatrix4(m) {
    for (let i2 = 0, l2 = this.data.count; i2 < l2; i2++) {
      _vector$7.fromBufferAttribute(this, i2);
      _vector$7.applyMatrix4(m);
      this.setXYZ(i2, _vector$7.x, _vector$7.y, _vector$7.z);
    }
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(m) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$7.fromBufferAttribute(this, i2);
      _vector$7.applyNormalMatrix(m);
      this.setXYZ(i2, _vector$7.x, _vector$7.y, _vector$7.z);
    }
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  transformDirection(m) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$7.fromBufferAttribute(this, i2);
      _vector$7.transformDirection(m);
      this.setXYZ(i2, _vector$7.x, _vector$7.y, _vector$7.z);
    }
    return this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(index, component) {
    let value = this.array[index * this.data.stride + this.offset + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setComponent(index, component, value) {
    if (this.normalized) value = normalize$1(value, this.array);
    this.data.array[index * this.data.stride + this.offset + component] = value;
    return this;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setX(index, x) {
    if (this.normalized) x = normalize$1(x, this.array);
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setY(index, y) {
    if (this.normalized) y = normalize$1(y, this.array);
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setZ(index, z) {
    if (this.normalized) z = normalize$1(z, this.array);
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setW(index, w) {
    if (this.normalized) w = normalize$1(w, this.array);
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(index) {
    let x = this.data.array[index * this.data.stride + this.offset];
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(index) {
    let y = this.data.array[index * this.data.stride + this.offset + 1];
    if (this.normalized) y = denormalize(y, this.array);
    return y;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(index) {
    let z = this.data.array[index * this.data.stride + this.offset + 2];
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(index) {
    let w = this.data.array[index * this.data.stride + this.offset + 3];
    if (this.normalized) w = denormalize(w, this.array);
    return w;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXY(index, x, y) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZ(index, x, y, z) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
      z = normalize$1(z, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZW(index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
      z = normalize$1(z, this.array);
      w = normalize$1(w, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An object with interleaved buffers that allows to retain the interleaved property.
   * @return {BufferAttribute|InterleavedBufferAttribute} A clone of this instance.
   */
  clone(data) {
    if (data === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const array2 = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array2.push(this.data.array[index + j]);
        }
      }
      return new BufferAttribute(
        new this.array.constructor(array2),
        this.itemSize,
        this.normalized
      );
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(
        data.interleavedBuffers[this.data.uuid],
        this.itemSize,
        this.offset,
        this.normalized
      );
    }
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON(data) {
    if (data === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const array2 = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array2.push(this.data.array[index + j]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: array2,
        normalized: this.normalized,
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized,
      };
    }
  }
}
class SpriteMaterial extends Material {
  /**
   * Constructs a new sprite material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isSpriteMaterial = true;
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    this.fog = source.fog;
    return this;
  }
}
class DataTexture extends Texture {
  /**
   * Constructs a new data texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=NearestFilter] - The mag filter value.
   * @param {number} [minFilter=NearestFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(
    data = null,
    width = 1,
    height = 1,
    format,
    type,
    mapping,
    wrapS,
    wrapT,
    magFilter = NearestFilter,
    minFilter = NearestFilter,
    anisotropy2,
    colorSpace
  ) {
    super(
      null,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy2,
      colorSpace
    );
    this.isDataTexture = true;
    this.image = { data, width, height };
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  /**
   * Constructs a new instanced buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   * @param {number} [meshPerAttribute=1] - How often a value of this buffer attribute should be repeated.
   */
  constructor(array2, itemSize, normalized, meshPerAttribute = 1) {
    super(array2, itemSize, normalized);
    this.isInstancedBufferAttribute = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
}
const _vector1 = /* @__PURE__ */ new Vector3();
const _vector2$2 = /* @__PURE__ */ new Vector3();
const _normalMatrix = /* @__PURE__ */ new Matrix3();
class Plane {
  /**
   * Constructs a new plane.
   *
   * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
   * @param {number} [constant=0] - The signed distance from the origin to the plane.
   */
  constructor(normal2 = new Vector3(1, 0, 0), constant = 0) {
    this.isPlane = true;
    this.normal = normal2;
    this.constant = constant;
  }
  /**
   * Sets the plane components by copying the given values.
   *
   * @param {Vector3} normal - The normal.
   * @param {number} constant - The constant.
   * @return {Plane} A reference to this plane.
   */
  set(normal2, constant) {
    this.normal.copy(normal2);
    this.constant = constant;
    return this;
  }
  /**
   * Sets the plane components by defining `x`, `y`, `z` as the
   * plane normal and `w` as the constant.
   *
   * @param {number} x - The value for the normal's x component.
   * @param {number} y - The value for the normal's y component.
   * @param {number} z - The value for the normal's z component.
   * @param {number} w - The constant value.
   * @return {Plane} A reference to this plane.
   */
  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  }
  /**
   * Sets the plane from the given normal and coplanar point (that is a point
   * that lies onto the plane).
   *
   * @param {Vector3} normal - The normal.
   * @param {Vector3} point - A coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromNormalAndCoplanarPoint(normal2, point) {
    this.normal.copy(normal2);
    this.constant = -point.dot(this.normal);
    return this;
  }
  /**
   * Sets the plane from three coplanar points. The winding order is
   * assumed to be counter-clockwise, and determines the direction of
   * the plane normal.
   *
   * @param {Vector3} a - The first coplanar point.
   * @param {Vector3} b - The second coplanar point.
   * @param {Vector3} c - The third coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromCoplanarPoints(a2, b, c2) {
    const normal2 = _vector1
      .subVectors(c2, b)
      .cross(_vector2$2.subVectors(a2, b))
      .normalize();
    this.setFromNormalAndCoplanarPoint(normal2, a2);
    return this;
  }
  /**
   * Copies the values of the given plane to this instance.
   *
   * @param {Plane} plane - The plane to copy.
   * @return {Plane} A reference to this plane.
   */
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  /**
   * Normalizes the plane normal and adjusts the constant accordingly.
   *
   * @return {Plane} A reference to this plane.
   */
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  /**
   * Negates both the plane normal and the constant.
   *
   * @return {Plane} A reference to this plane.
   */
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  /**
   * Returns the signed distance from the given point to this plane.
   *
   * @param {Vector3} point - The point to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  /**
   * Returns the signed distance from the given sphere to this plane.
   *
   * @param {Sphere} sphere - The sphere to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  /**
   * Projects a the given point onto the plane.
   *
   * @param {Vector3} point - The point to project.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The projected point on the plane.
   */
  projectPoint(point, target) {
    return target
      .copy(point)
      .addScaledVector(this.normal, -this.distanceToPoint(point));
  }
  /**
   * Returns the intersection point of the passed line and the plane. Returns
   * `null` if the line does not intersect. Returns the line's starting point if
   * the line is coplanar with the plane.
   *
   * @param {Line3} line - The line to compute the intersection for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t2 < 0 || t2 > 1) {
      return null;
    }
    return target.copy(line.start).addScaledVector(direction, t2);
  }
  /**
   * Returns `true` if the given line segment intersects with (passes through) the plane.
   *
   * @param {Line3} line - The line to test.
   * @return {boolean} Whether the given line segment intersects with the plane or not.
   */
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
  }
  /**
   * Returns `true` if the given bounding box intersects with the plane.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with the plane or not.
   */
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  /**
   * Returns `true` if the given bounding sphere intersects with the plane.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
   */
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  /**
   * Returns a coplanar vector to the plane, by calculating the
   * projection of the normal at the origin onto the plane.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The coplanar point.
   */
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  /**
   * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
   *
   * The optional normal matrix can be pre-computed like so:
   * ```js
   * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
   * ```
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
   * @return {Plane} A reference to this plane.
   */
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix =
      optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal2 = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal2);
    return this;
  }
  /**
   * Translates the plane by the distance defined by the given offset vector.
   * Note that this only affects the plane constant and will not affect the normal vector.
   *
   * @param {Vector3} offset - The offset vector.
   * @return {Plane} A reference to this plane.
   */
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  /**
   * Returns `true` if this plane is equal with the given one.
   *
   * @param {Plane} plane - The plane to test for equality.
   * @return {boolean} Whether this plane is equal with the given one.
   */
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  /**
   * Returns a new plane with copied values from this instance.
   *
   * @return {Plane} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const _sphere$3 = /* @__PURE__ */ new Sphere();
const _defaultSpriteCenter = /* @__PURE__ */ new Vector2(0.5, 0.5);
const _vector$6 = /* @__PURE__ */ new Vector3();
class Frustum {
  /**
   * Constructs a new frustum.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   */
  constructor(
    p0 = new Plane(),
    p1 = new Plane(),
    p2 = new Plane(),
    p3 = new Plane(),
    p4 = new Plane(),
    p5 = new Plane()
  ) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  /**
   * Sets the frustum planes by copying the given planes.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   * @return {Frustum} A reference to this frustum.
   */
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  /**
   * Copies the values of the given frustum to this instance.
   *
   * @param {Frustum} frustum - The frustum to copy.
   * @return {Frustum} A reference to this frustum.
   */
  copy(frustum) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      planes[i2].copy(frustum.planes[i2]);
    }
    return this;
  }
  /**
   * Sets the frustum planes from the given projection matrix.
   *
   * @param {Matrix4} m - The projection matrix.
   * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
   * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
   * @return {Frustum} A reference to this frustum.
   */
  setFromProjectionMatrix(
    m,
    coordinateSystem = WebGLCoordinateSystem,
    reversedDepth = false
  ) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0],
      me1 = me[1],
      me2 = me[2],
      me3 = me[3];
    const me4 = me[4],
      me5 = me[5],
      me6 = me[6],
      me7 = me[7];
    const me8 = me[8],
      me9 = me[9],
      me10 = me[10],
      me11 = me[11];
    const me12 = me[12],
      me13 = me[13],
      me14 = me[14],
      me15 = me[15];
    planes[0]
      .setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12)
      .normalize();
    planes[1]
      .setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12)
      .normalize();
    planes[2]
      .setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13)
      .normalize();
    planes[3]
      .setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13)
      .normalize();
    if (reversedDepth) {
      planes[4].setComponents(me2, me6, me10, me14).normalize();
      planes[5]
        .setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14)
        .normalize();
    } else {
      planes[4]
        .setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14)
        .normalize();
      if (coordinateSystem === WebGLCoordinateSystem) {
        planes[5]
          .setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14)
          .normalize();
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        planes[5].setComponents(me2, me6, me10, me14).normalize();
      } else {
        throw new Error(
          "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
            coordinateSystem
        );
      }
    }
    return this;
  }
  /**
   * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
   *
   * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
   *
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
   */
  intersectsObject(object) {
    if (object.boundingSphere !== void 0) {
      if (object.boundingSphere === null) object.computeBoundingSphere();
      _sphere$3.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
    } else {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$3.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    }
    return this.intersectsSphere(_sphere$3);
  }
  /**
   * Returns `true` if the given sprite is intersecting this frustum.
   *
   * @param {Sprite} sprite - The sprite to test.
   * @return {boolean} Whether the sprite is intersecting this frustum or not.
   */
  intersectsSprite(sprite) {
    _sphere$3.center.set(0, 0, 0);
    const offset = _defaultSpriteCenter.distanceTo(sprite.center);
    _sphere$3.radius = 0.7071067811865476 + offset;
    _sphere$3.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$3);
  }
  /**
   * Returns `true` if the given bounding sphere is intersecting this frustum.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
   */
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i2 = 0; i2 < 6; i2++) {
      const distance2 = planes[i2].distanceToPoint(center);
      if (distance2 < negRadius) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns `true` if the given bounding box is intersecting this frustum.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box is intersecting this frustum or not.
   */
  intersectsBox(box) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      const plane = planes[i2];
      _vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$6) < 0) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns `true` if the given point lies within the frustum.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the point lies within this frustum or not.
   */
  containsPoint(point) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      if (planes[i2].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns a new frustum with copied values from this instance.
   *
   * @return {Frustum} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const _projScreenMatrix$2 = /* @__PURE__ */ new Matrix4();
const _frustum$1 = /* @__PURE__ */ new Frustum();
class FrustumArray {
  /**
   * Constructs a new frustum array.
   *
   */
  constructor() {
    this.coordinateSystem = WebGLCoordinateSystem;
  }
  /**
   * Returns `true` if the 3D object's bounding sphere is intersecting any frustum
   * from the camera array.
   *
   * @param {Object3D} object - The 3D object to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the 3D object is visible in any camera.
   */
  intersectsObject(object, cameraArray) {
    if (!cameraArray.isArrayCamera || cameraArray.cameras.length === 0) {
      return false;
    }
    for (let i2 = 0; i2 < cameraArray.cameras.length; i2++) {
      const camera2 = cameraArray.cameras[i2];
      _projScreenMatrix$2.multiplyMatrices(
        camera2.projectionMatrix,
        camera2.matrixWorldInverse
      );
      _frustum$1.setFromProjectionMatrix(
        _projScreenMatrix$2,
        camera2.coordinateSystem,
        camera2.reversedDepth
      );
      if (_frustum$1.intersectsObject(object)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns `true` if the given sprite is intersecting any frustum
   * from the camera array.
   *
   * @param {Sprite} sprite - The sprite to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the sprite is visible in any camera.
   */
  intersectsSprite(sprite, cameraArray) {
    if (
      !cameraArray ||
      !cameraArray.cameras ||
      cameraArray.cameras.length === 0
    ) {
      return false;
    }
    for (let i2 = 0; i2 < cameraArray.cameras.length; i2++) {
      const camera2 = cameraArray.cameras[i2];
      _projScreenMatrix$2.multiplyMatrices(
        camera2.projectionMatrix,
        camera2.matrixWorldInverse
      );
      _frustum$1.setFromProjectionMatrix(
        _projScreenMatrix$2,
        camera2.coordinateSystem,
        camera2.reversedDepth
      );
      if (_frustum$1.intersectsSprite(sprite)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns `true` if the given bounding sphere is intersecting any frustum
   * from the camera array.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the sphere is visible in any camera.
   */
  intersectsSphere(sphere, cameraArray) {
    if (
      !cameraArray ||
      !cameraArray.cameras ||
      cameraArray.cameras.length === 0
    ) {
      return false;
    }
    for (let i2 = 0; i2 < cameraArray.cameras.length; i2++) {
      const camera2 = cameraArray.cameras[i2];
      _projScreenMatrix$2.multiplyMatrices(
        camera2.projectionMatrix,
        camera2.matrixWorldInverse
      );
      _frustum$1.setFromProjectionMatrix(
        _projScreenMatrix$2,
        camera2.coordinateSystem,
        camera2.reversedDepth
      );
      if (_frustum$1.intersectsSphere(sphere)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns `true` if the given bounding box is intersecting any frustum
   * from the camera array.
   *
   * @param {Box3} box - The bounding box to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the box is visible in any camera.
   */
  intersectsBox(box, cameraArray) {
    if (
      !cameraArray ||
      !cameraArray.cameras ||
      cameraArray.cameras.length === 0
    ) {
      return false;
    }
    for (let i2 = 0; i2 < cameraArray.cameras.length; i2++) {
      const camera2 = cameraArray.cameras[i2];
      _projScreenMatrix$2.multiplyMatrices(
        camera2.projectionMatrix,
        camera2.matrixWorldInverse
      );
      _frustum$1.setFromProjectionMatrix(
        _projScreenMatrix$2,
        camera2.coordinateSystem,
        camera2.reversedDepth
      );
      if (_frustum$1.intersectsBox(box)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns `true` if the given point lies within any frustum
   * from the camera array.
   *
   * @param {Vector3} point - The point to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the point is visible in any camera.
   */
  containsPoint(point, cameraArray) {
    if (
      !cameraArray ||
      !cameraArray.cameras ||
      cameraArray.cameras.length === 0
    ) {
      return false;
    }
    for (let i2 = 0; i2 < cameraArray.cameras.length; i2++) {
      const camera2 = cameraArray.cameras[i2];
      _projScreenMatrix$2.multiplyMatrices(
        camera2.projectionMatrix,
        camera2.matrixWorldInverse
      );
      _frustum$1.setFromProjectionMatrix(
        _projScreenMatrix$2,
        camera2.coordinateSystem,
        camera2.reversedDepth
      );
      if (_frustum$1.containsPoint(point)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns a new frustum array with copied values from this instance.
   *
   * @return {FrustumArray} A clone of this instance.
   */
  clone() {
    return new FrustumArray();
  }
}
class LineBasicMaterial extends Material {
  /**
   * Constructs a new line basic material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isLineBasicMaterial = true;
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.fog = source.fog;
    return this;
  }
}
const _vStart = /* @__PURE__ */ new Vector3();
const _vEnd = /* @__PURE__ */ new Vector3();
const _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
const _ray$1 = /* @__PURE__ */ new Ray();
const _sphere$1 = /* @__PURE__ */ new Sphere();
const _intersectPointOnRay = /* @__PURE__ */ new Vector3();
const _intersectPointOnSegment = /* @__PURE__ */ new Vector3();
class Line extends Object3D {
  /**
   * Constructs a new line.
   *
   * @param {BufferGeometry} [geometry] - The line geometry.
   * @param {Material|Array<Material>} [material] - The line material.
   */
  constructor(
    geometry = new BufferGeometry(),
    material = new LineBasicMaterial()
  ) {
    super();
    this.isLine = true;
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.morphTargetDictionary = void 0;
    this.morphTargetInfluences = void 0;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material)
      ? source.material.slice()
      : source.material;
    this.geometry = source.geometry;
    return this;
  }
  /**
   * Computes an array of distance values which are necessary for rendering dashed lines.
   * For each vertex in the geometry, the method calculates the cumulative length from the
   * current point to the very beginning of the line.
   *
   * @return {Line} A reference to this line.
   */
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [0];
      for (let i2 = 1, l2 = positionAttribute.count; i2 < l2; i2++) {
        _vStart.fromBufferAttribute(positionAttribute, i2 - 1);
        _vEnd.fromBufferAttribute(positionAttribute, i2);
        lineDistances[i2] = lineDistances[i2 - 1];
        lineDistances[i2] += _vStart.distanceTo(_vEnd);
      }
      geometry.setAttribute(
        "lineDistance",
        new Float32BufferAttribute(lineDistances, 1)
      );
    } else {
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    }
    return this;
  }
  /**
   * Computes intersection points between a casted ray and this line.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold =
      threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const step2 = this.isLineSegments ? 2 : 1;
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index.count, drawRange.start + drawRange.count);
      for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step2) {
        const a2 = index.getX(i2);
        const b = index.getX(i2 + 1);
        const intersect = checkIntersection(
          this,
          raycaster,
          _ray$1,
          localThresholdSq,
          a2,
          b,
          i2
        );
        if (intersect) {
          intersects.push(intersect);
        }
      }
      if (this.isLineLoop) {
        const a2 = index.getX(end - 1);
        const b = index.getX(start);
        const intersect = checkIntersection(
          this,
          raycaster,
          _ray$1,
          localThresholdSq,
          a2,
          b,
          end - 1
        );
        if (intersect) {
          intersects.push(intersect);
        }
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(
        positionAttribute.count,
        drawRange.start + drawRange.count
      );
      for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step2) {
        const intersect = checkIntersection(
          this,
          raycaster,
          _ray$1,
          localThresholdSq,
          i2,
          i2 + 1,
          i2
        );
        if (intersect) {
          intersects.push(intersect);
        }
      }
      if (this.isLineLoop) {
        const intersect = checkIntersection(
          this,
          raycaster,
          _ray$1,
          localThresholdSq,
          end - 1,
          start,
          end - 1
        );
        if (intersect) {
          intersects.push(intersect);
        }
      }
    }
  }
  /**
   * Sets the values of {@link Line#morphTargetDictionary} and {@link Line#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
}
function checkIntersection(object, raycaster, ray, thresholdSq, a2, b, i2) {
  const positionAttribute = object.geometry.attributes.position;
  _vStart.fromBufferAttribute(positionAttribute, a2);
  _vEnd.fromBufferAttribute(positionAttribute, b);
  const distSq = ray.distanceSqToSegment(
    _vStart,
    _vEnd,
    _intersectPointOnRay,
    _intersectPointOnSegment
  );
  if (distSq > thresholdSq) return;
  _intersectPointOnRay.applyMatrix4(object.matrixWorld);
  const distance2 = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
  if (distance2 < raycaster.near || distance2 > raycaster.far) return;
  return {
    distance: distance2,
    // What do we want? intersection point on the ray or on the segment??
    // point: raycaster.ray.at( distance ),
    point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
    index: i2,
    face: null,
    faceIndex: null,
    barycoord: null,
    object,
  };
}
const _start = /* @__PURE__ */ new Vector3();
const _end = /* @__PURE__ */ new Vector3();
class LineSegments extends Line {
  /**
   * Constructs a new line segments.
   *
   * @param {BufferGeometry} [geometry] - The line geometry.
   * @param {Material|Array<Material>} [material] - The line material.
   */
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineSegments = true;
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [];
      for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2 += 2) {
        _start.fromBufferAttribute(positionAttribute, i2);
        _end.fromBufferAttribute(positionAttribute, i2 + 1);
        lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
        lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
      }
      geometry.setAttribute(
        "lineDistance",
        new Float32BufferAttribute(lineDistances, 1)
      );
    } else {
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    }
    return this;
  }
}
class PointsMaterial extends Material {
  /**
   * Constructs a new points material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isPointsMaterial = true;
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.fog = source.fog;
    return this;
  }
}
class FramebufferTexture extends Texture {
  /**
   * Constructs a new framebuffer texture.
   *
   * @param {number} [width] - The width of the texture.
   * @param {number} [height] - The height of the texture.
   */
  constructor(width, height) {
    super({ width, height });
    this.isFramebufferTexture = true;
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.generateMipmaps = false;
    this.needsUpdate = true;
  }
}
class DepthTexture extends Texture {
  /**
   * Constructs a new depth texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} [type=UnsignedIntType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {number} [format=DepthFormat] - The texture format.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(
    width,
    height,
    type = UnsignedIntType,
    mapping,
    wrapS,
    wrapT,
    magFilter = NearestFilter,
    minFilter = NearestFilter,
    anisotropy2,
    format = DepthFormat,
    depth2 = 1
  ) {
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    }
    const image = { width, height, depth: depth2 };
    super(
      image,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy2
    );
    this.isDepthTexture = true;
    this.flipY = false;
    this.generateMipmaps = false;
    this.compareFunction = null;
  }
  copy(source) {
    super.copy(source);
    this.source = new Source(Object.assign({}, source.image));
    this.compareFunction = source.compareFunction;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.compareFunction !== null)
      data.compareFunction = this.compareFunction;
    return data;
  }
}
class CylinderGeometry extends BufferGeometry {
  /**
   * Constructs a new cylinder geometry.
   *
   * @param {number} [radiusTop=1] - Radius of the cylinder at the top.
   * @param {number} [radiusBottom=1] - Radius of the cylinder at the bottom.
   * @param {number} [height=1] - Height of the cylinder.
   * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cylinder.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cylinder.
   * @param {boolean} [openEnded=false] - Whether the base of the cylinder is open or capped.
   * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
   * The default value results in a complete cylinder.
   */
  constructor(
    radiusTop = 1,
    radiusBottom = 1,
    height = 1,
    radialSegments = 32,
    heightSegments = 1,
    openEnded = false,
    thetaStart = 0,
    thetaLength = Math.PI * 2
  ) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength,
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal2 = new Vector3();
      const vertex = new Vector3();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y = 0; y <= heightSegments; y++) {
        const indexRow = [];
        const v = y / heightSegments;
        const radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (let x = 0; x <= radialSegments; x++) {
          const u2 = x / radialSegments;
          const theta = u2 * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex.x = radius * sinTheta;
          vertex.y = -v * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal2.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal2.x, normal2.y, normal2.z);
          uvs.push(u2, 1 - v);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (let x = 0; x < radialSegments; x++) {
        for (let y = 0; y < heightSegments; y++) {
          const a2 = indexArray[y][x];
          const b = indexArray[y + 1][x];
          const c2 = indexArray[y + 1][x + 1];
          const d2 = indexArray[y][x + 1];
          if (radiusTop > 0 || y !== 0) {
            indices.push(a2, b, d2);
            groupCount += 3;
          }
          if (radiusBottom > 0 || y !== heightSegments - 1) {
            indices.push(b, c2, d2);
            groupCount += 3;
          }
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index;
      const uv2 = new Vector2();
      const vertex = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign2 = top === true ? 1 : -1;
      for (let x = 1; x <= radialSegments; x++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index++;
      }
      const centerIndexEnd = index;
      for (let x = 0; x <= radialSegments; x++) {
        const u2 = x / radialSegments;
        const theta = u2 * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign2;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, sign2, 0);
        uv2.x = cosTheta * 0.5 + 0.5;
        uv2.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv2.x, uv2.y);
        index++;
      }
      for (let x = 0; x < radialSegments; x++) {
        const c2 = centerIndexStart + x;
        const i2 = centerIndexEnd + x;
        if (top === true) {
          indices.push(i2, i2 + 1, c2);
        } else {
          indices.push(i2 + 1, i2, c2);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CylinderGeometry} A new instance.
   */
  static fromJSON(data) {
    return new CylinderGeometry(
      data.radiusTop,
      data.radiusBottom,
      data.height,
      data.radialSegments,
      data.heightSegments,
      data.openEnded,
      data.thetaStart,
      data.thetaLength
    );
  }
}
class PlaneGeometry extends BufferGeometry {
  /**
   * Constructs a new plane geometry.
   *
   * @param {number} [width=1] - The width along the X axis.
   * @param {number} [height=1] - The height along the Y axis
   * @param {number} [widthSegments=1] - The number of segments along the X axis.
   * @param {number} [heightSegments=1] - The number of segments along the Y axis.
   */
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments,
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a2 = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c2 = ix + 1 + gridX1 * (iy + 1);
        const d2 = ix + 1 + gridX1 * iy;
        indices.push(a2, b, d2);
        indices.push(b, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {PlaneGeometry} A new instance.
   */
  static fromJSON(data) {
    return new PlaneGeometry(
      data.width,
      data.height,
      data.widthSegments,
      data.heightSegments
    );
  }
}
class SphereGeometry extends BufferGeometry {
  /**
   * Constructs a new sphere geometry.
   *
   * @param {number} [radius=1] - The sphere radius.
   * @param {number} [widthSegments=32] - The number of horizontal segments. Minimum value is `3`.
   * @param {number} [heightSegments=16] - The number of vertical segments. Minimum value is `2`.
   * @param {number} [phiStart=0] - The horizontal starting angle in radians.
   * @param {number} [phiLength=Math.PI*2] - The horizontal sweep angle size.
   * @param {number} [thetaStart=0] - The vertical starting angle in radians.
   * @param {number} [thetaLength=Math.PI] - The vertical sweep angle size.
   */
  constructor(
    radius = 1,
    widthSegments = 32,
    heightSegments = 16,
    phiStart = 0,
    phiLength = Math.PI * 2,
    thetaStart = 0,
    thetaLength = Math.PI
  ) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength,
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex = new Vector3();
    const normal2 = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;
      let uOffset = 0;
      if (iy === 0 && thetaStart === 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy === heightSegments && thetaEnd === Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u2 = ix / widthSegments;
        vertex.x =
          -radius *
          Math.cos(phiStart + u2 * phiLength) *
          Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z =
          radius *
          Math.sin(phiStart + u2 * phiLength) *
          Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal2.copy(vertex).normalize();
        normals.push(normal2.x, normal2.y, normal2.z);
        uvs.push(u2 + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a2 = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c2 = grid[iy + 1][ix];
        const d2 = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a2, b, d2);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {SphereGeometry} A new instance.
   */
  static fromJSON(data) {
    return new SphereGeometry(
      data.radius,
      data.widthSegments,
      data.heightSegments,
      data.phiStart,
      data.phiLength,
      data.thetaStart,
      data.thetaLength
    );
  }
}
class ShadowMaterial extends Material {
  /**
   * Constructs a new shadow material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isShadowMaterial = true;
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.fog = source.fog;
    return this;
  }
}
class MeshStandardMaterial extends Material {
  /**
   * Constructs a new mesh standard material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isMeshStandardMaterial = true;
    this.type = "MeshStandardMaterial";
    this.defines = { STANDARD: "" };
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.envMapIntensity = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { STANDARD: "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.envMapIntensity = source.envMapIntensity;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshPhysicalMaterial extends MeshStandardMaterial {
  /**
   * Constructs a new mesh physical material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isMeshPhysicalMaterial = true;
    this.defines = {
      STANDARD: "",
      PHYSICAL: "",
    };
    this.type = "MeshPhysicalMaterial";
    this.anisotropyRotation = 0;
    this.anisotropyMap = null;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.ior = 1.5;
    Object.defineProperty(this, "reflectivity", {
      get: function () {
        return clamp$1((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
      },
      set: function (reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      },
    });
    this.iridescenceMap = null;
    this.iridescenceIOR = 1.3;
    this.iridescenceThicknessRange = [100, 400];
    this.iridescenceThicknessMap = null;
    this.sheenColor = new Color(0);
    this.sheenColorMap = null;
    this.sheenRoughness = 1;
    this.sheenRoughnessMap = null;
    this.transmissionMap = null;
    this.thickness = 0;
    this.thicknessMap = null;
    this.attenuationDistance = Infinity;
    this.attenuationColor = new Color(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularColor = new Color(1, 1, 1);
    this.specularColorMap = null;
    this._anisotropy = 0;
    this._clearcoat = 0;
    this._dispersion = 0;
    this._iridescence = 0;
    this._sheen = 0;
    this._transmission = 0;
    this.setValues(parameters);
  }
  /**
   * The anisotropy strength.
   *
   * @type {number}
   * @default 0
   */
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(value) {
    if (this._anisotropy > 0 !== value > 0) {
      this.version++;
    }
    this._anisotropy = value;
  }
  /**
   * Represents the intensity of the clear coat layer, from `0.0` to `1.0`. Use
   * clear coat related properties to enable multilayer materials that have a
   * thin translucent layer over the base layer.
   *
   * @type {number}
   * @default 0
   */
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++;
    }
    this._clearcoat = value;
  }
  /**
   * The intensity of the iridescence layer, simulating RGB color shift based on the angle between
   * the surface and the viewer, from `0.0` to `1.0`.
   *
   * @type {number}
   * @default 0
   */
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(value) {
    if (this._iridescence > 0 !== value > 0) {
      this.version++;
    }
    this._iridescence = value;
  }
  /**
   * Defines the strength of the angular separation of colors (chromatic aberration) transmitting
   * through a relatively clear volume. Any value zero or larger is valid, the typical range of
   * realistic values is `[0, 1]`. This property can be only be used with transmissive objects.
   *
   * @type {number}
   * @default 0
   */
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(value) {
    if (this._dispersion > 0 !== value > 0) {
      this.version++;
    }
    this._dispersion = value;
  }
  /**
   * The intensity of the sheen layer, from `0.0` to `1.0`.
   *
   * @type {number}
   * @default 0
   */
  get sheen() {
    return this._sheen;
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++;
    }
    this._sheen = value;
  }
  /**
   * Degree of transmission (or optical transparency), from `0.0` to `1.0`.
   *
   * Thin, transparent or semitransparent, plastic or glass materials remain
   * largely reflective even if they are fully transmissive. The transmission
   * property can be used to model these materials.
   *
   * When transmission is non-zero, `opacity` should be  set to `1`.
   *
   * @type {number}
   * @default 0
   */
  get transmission() {
    return this._transmission;
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++;
    }
    this._transmission = value;
  }
  copy(source) {
    super.copy(source);
    this.defines = {
      STANDARD: "",
      PHYSICAL: "",
    };
    this.anisotropy = source.anisotropy;
    this.anisotropyRotation = source.anisotropyRotation;
    this.anisotropyMap = source.anisotropyMap;
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.dispersion = source.dispersion;
    this.ior = source.ior;
    this.iridescence = source.iridescence;
    this.iridescenceMap = source.iridescenceMap;
    this.iridescenceIOR = source.iridescenceIOR;
    this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
    this.iridescenceThicknessMap = source.iridescenceThicknessMap;
    this.sheen = source.sheen;
    this.sheenColor.copy(source.sheenColor);
    this.sheenColorMap = source.sheenColorMap;
    this.sheenRoughness = source.sheenRoughness;
    this.sheenRoughnessMap = source.sheenRoughnessMap;
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    this.thickness = source.thickness;
    this.thicknessMap = source.thicknessMap;
    this.attenuationDistance = source.attenuationDistance;
    this.attenuationColor.copy(source.attenuationColor);
    this.specularIntensity = source.specularIntensity;
    this.specularIntensityMap = source.specularIntensityMap;
    this.specularColor.copy(source.specularColor);
    this.specularColorMap = source.specularColorMap;
    return this;
  }
}
class MeshPhongMaterial extends Material {
  /**
   * Constructs a new mesh phong material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isMeshPhongMaterial = true;
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshToonMaterial extends Material {
  /**
   * Constructs a new mesh toon material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isMeshToonMaterial = true;
    this.defines = { TOON: "" };
    this.type = "MeshToonMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
}
class MeshNormalMaterial extends Material {
  /**
   * Constructs a new mesh normal material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isMeshNormalMaterial = true;
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.flatShading = source.flatShading;
    return this;
  }
}
class MeshLambertMaterial extends Material {
  /**
   * Constructs a new mesh lambert material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isMeshLambertMaterial = true;
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshMatcapMaterial extends Material {
  /**
   * Constructs a new mesh matcap material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isMeshMatcapMaterial = true;
    this.defines = { MATCAP: "" };
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { MATCAP: "" };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class LineDashedMaterial extends LineBasicMaterial {
  /**
   * Constructs a new line dashed material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isLineDashedMaterial = true;
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }
}
const Cache = {
  /**
   * Whether caching is enabled or not.
   *
   * @static
   * @type {boolean}
   * @default false
   */
  enabled: false,
  /**
   * A dictionary that holds cached files.
   *
   * @static
   * @type {Object<string,Object>}
   */
  files: {},
  /**
   * Adds a cache entry with a key to reference the file. If this key already
   * holds a file, it is overwritten.
   *
   * @static
   * @param {string} key - The key to reference the cached file.
   * @param {Object} file -  The file to be cached.
   */
  add: function (key, file) {
    if (this.enabled === false) return;
    this.files[key] = file;
  },
  /**
   * Gets the cached value for the given key.
   *
   * @static
   * @param {string} key - The key to reference the cached file.
   * @return {Object|undefined} The cached file. If the key does not exist `undefined` is returned.
   */
  get: function (key) {
    if (this.enabled === false) return;
    return this.files[key];
  },
  /**
   * Removes the cached file associated with the given key.
   *
   * @static
   * @param {string} key - The key to reference the cached file.
   */
  remove: function (key) {
    delete this.files[key];
  },
  /**
   * Remove all values from the cache.
   *
   * @static
   */
  clear: function () {
    this.files = {};
  },
};
class LoadingManager {
  /**
   * Constructs a new loading manager.
   *
   * @param {Function} [onLoad] - Executes when all items have been loaded.
   * @param {Function} [onProgress] - Executes when single items have been loaded.
   * @param {Function} [onError] - Executes when an error occurs.
   */
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.abortController = new AbortController();
    this.itemStart = function (url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function (url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function (url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function (url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function (transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function (regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function (regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function (file) {
      for (let i2 = 0, l2 = handlers.length; i2 < l2; i2 += 2) {
        const regex = handlers[i2];
        const loader = handlers[i2 + 1];
        if (regex.global) regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
    this.abort = function () {
      this.abortController.abort();
      this.abortController = new AbortController();
      return this;
    };
  }
}
const DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
class Loader {
  /**
   * Constructs a new loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  /**
   * This method needs to be implemented by all concrete loaders. It holds the
   * logic for loading assets from the backend.
   *
   * @abstract
   * @param {string} url - The path/URL of the file to be loaded.
   * @param {Function} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
   * @param {onErrorCallback} [onError] - Executed when errors occur.
   */
  load() {}
  /**
   * A async version of {@link Loader#load}.
   *
   * @param {string} url - The path/URL of the file to be loaded.
   * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
   * @return {Promise} A Promise that resolves when the asset has been loaded.
   */
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function (resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  /**
   * This method needs to be implemented by all concrete loaders. It holds the
   * logic for parsing the asset into three.js entities.
   *
   * @abstract
   * @param {any} data - The data to parse.
   */
  parse() {}
  /**
   * Sets the `crossOrigin` String to implement CORS for loading the URL
   * from a different domain that allows CORS.
   *
   * @param {string} crossOrigin - The `crossOrigin` value.
   * @return {Loader} A reference to this instance.
   */
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  /**
   * Whether the XMLHttpRequest uses credentials such as cookies, authorization
   * headers or TLS client certificates, see [XMLHttpRequest.withCredentials]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials}.
   *
   * Note: This setting has no effect if you are loading files locally or from the same domain.
   *
   * @param {boolean} value - The `withCredentials` value.
   * @return {Loader} A reference to this instance.
   */
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  /**
   * Sets the base path for the asset.
   *
   * @param {string} path - The base path.
   * @return {Loader} A reference to this instance.
   */
  setPath(path) {
    this.path = path;
    return this;
  }
  /**
   * Sets the base path for dependent resources like textures.
   *
   * @param {string} resourcePath - The resource path.
   * @return {Loader} A reference to this instance.
   */
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  /**
   * Sets the given request header.
   *
   * @param {Object} requestHeader - A [request header]{@link https://developer.mozilla.org/en-US/docs/Glossary/Request_header}
   * for configuring the HTTP request.
   * @return {Loader} A reference to this instance.
   */
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
  /**
   * This method can be implemented in loaders for aborting ongoing requests.
   *
   * @abstract
   * @return {Loader} A reference to this instance.
   */
  abort() {
    return this;
  }
}
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const _loading = /* @__PURE__ */ new WeakMap();
class ImageLoader extends Loader {
  /**
   * Constructs a new image loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(manager) {
    super(manager);
  }
  /**
   * Starts loading from the given URL and passes the loaded image
   * to the `onLoad()` callback. The method also returns a new `Image` object which can
   * directly be used for texture creation. If you do it this way, the texture
   * may pop up in your scene once the respective loading process is finished.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(Image)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Unsupported in this loader.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {Image} The image.
   */
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(`image:${url}`);
    if (cached !== void 0) {
      if (cached.complete === true) {
        scope.manager.itemStart(url);
        setTimeout(function () {
          if (onLoad) onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
      } else {
        let arr = _loading.get(cached);
        if (arr === void 0) {
          arr = [];
          _loading.set(cached, arr);
        }
        arr.push({ onLoad, onError });
      }
      return cached;
    }
    const image = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      if (onLoad) onLoad(this);
      const callbacks = _loading.get(this) || [];
      for (let i2 = 0; i2 < callbacks.length; i2++) {
        const callback = callbacks[i2];
        if (callback.onLoad) callback.onLoad(this);
      }
      _loading.delete(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError) onError(event);
      Cache.remove(`image:${url}`);
      const callbacks = _loading.get(this) || [];
      for (let i2 = 0; i2 < callbacks.length; i2++) {
        const callback = callbacks[i2];
        if (callback.onError) callback.onError(event);
      }
      _loading.delete(this);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.slice(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0) image.crossOrigin = this.crossOrigin;
    }
    Cache.add(`image:${url}`, image);
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
}
class TextureLoader extends Loader {
  /**
   * Constructs a new texture loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(manager) {
    super(manager);
  }
  /**
   * Starts loading from the given URL and pass the fully loaded texture
   * to the `onLoad()` callback. The method also returns a new texture object which can
   * directly be used for material creation. If you do it this way, the texture
   * may pop up in your scene once the respective loading process is finished.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(Texture)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Unsupported in this loader.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {Texture} The texture.
   */
  load(url, onLoad, onProgress, onError) {
    const texture2 = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(
      url,
      function (image) {
        texture2.image = image;
        texture2.needsUpdate = true;
        if (onLoad !== void 0) {
          onLoad(texture2);
        }
      },
      onProgress,
      onError
    );
    return texture2;
  }
}
class Light extends Object3D {
  /**
   * Constructs a new light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(color2, intensity = 1) {
    super();
    this.isLight = true;
    this.type = "Light";
    this.color = new Color(color2);
    this.intensity = intensity;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {}
  copy(source, recursive) {
    super.copy(source, recursive);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0) data.object.distance = this.distance;
    if (this.angle !== void 0) data.object.angle = this.angle;
    if (this.decay !== void 0) data.object.decay = this.decay;
    if (this.penumbra !== void 0) data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON();
    if (this.target !== void 0) data.object.target = this.target.uuid;
    return data;
  }
}
class HemisphereLight extends Light {
  /**
   * Constructs a new hemisphere light.
   *
   * @param {(number|Color|string)} [skyColor=0xffffff] - The light's sky color.
   * @param {(number|Color|string)} [groundColor=0xffffff] - The light's ground color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.isHemisphereLight = true;
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.groundColor.copy(source.groundColor);
    return this;
  }
}
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
const _lookTarget$1 = /* @__PURE__ */ new Vector3();
class LightShadow {
  /**
   * Constructs a new light shadow.
   *
   * @param {Camera} camera - The light's view of the world.
   */
  constructor(camera2) {
    this.camera = camera2;
    this.intensity = 1;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.mapType = UnsignedByteType;
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [new Vector4(0, 0, 1, 1)];
  }
  /**
   * Used internally by the renderer to get the number of viewports that need
   * to be rendered for this shadow.
   *
   * @return {number} The viewport count.
   */
  getViewportCount() {
    return this._viewportCount;
  }
  /**
   * Gets the shadow cameras frustum. Used internally by the renderer to cull objects.
   *
   * @return {Frustum} The shadow camera frustum.
   */
  getFrustum() {
    return this._frustum;
  }
  /**
   * Update the matrices for the camera and shadow, used internally by the renderer.
   *
   * @param {Light} light - The light for which the shadow is being rendered.
   */
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(
      shadowCamera.projectionMatrix,
      shadowCamera.matrixWorldInverse
    );
    this._frustum.setFromProjectionMatrix(
      _projScreenMatrix$1,
      shadowCamera.coordinateSystem,
      shadowCamera.reversedDepth
    );
    if (shadowCamera.reversedDepth) {
      shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1);
    } else {
      shadowMatrix.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      );
    }
    shadowMatrix.multiply(_projScreenMatrix$1);
  }
  /**
   * Returns a viewport definition for the given viewport index.
   *
   * @param {number} viewportIndex - The viewport index.
   * @return {Vector4} The viewport.
   */
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  /**
   * Returns the frame extends.
   *
   * @return {Vector2} The frame extends.
   */
  getFrameExtents() {
    return this._frameExtents;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  /**
   * Copies the values of the given light shadow instance to this instance.
   *
   * @param {LightShadow} source - The light shadow to copy.
   * @return {LightShadow} A reference to this light shadow instance.
   */
  copy(source) {
    this.camera = source.camera.clone();
    this.intensity = source.intensity;
    this.bias = source.bias;
    this.radius = source.radius;
    this.autoUpdate = source.autoUpdate;
    this.needsUpdate = source.needsUpdate;
    this.normalBias = source.normalBias;
    this.blurSamples = source.blurSamples;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  /**
   * Returns a new light shadow instance with copied values from this instance.
   *
   * @return {LightShadow} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Serializes the light shadow into JSON.
   *
   * @return {Object} A JSON object representing the serialized light shadow.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const object = {};
    if (this.intensity !== 1) object.intensity = this.intensity;
    if (this.bias !== 0) object.bias = this.bias;
    if (this.normalBias !== 0) object.normalBias = this.normalBias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
}
class SpotLightShadow extends LightShadow {
  /**
   * Constructs a new spot light shadow.
   */
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.isSpotLightShadow = true;
    this.focus = 1;
    this.aspect = 1;
  }
  updateMatrices(light) {
    const camera2 = this.camera;
    const fov2 = RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = (this.mapSize.width / this.mapSize.height) * this.aspect;
    const far = light.distance || camera2.far;
    if (
      fov2 !== camera2.fov ||
      aspect2 !== camera2.aspect ||
      far !== camera2.far
    ) {
      camera2.fov = fov2;
      camera2.aspect = aspect2;
      camera2.far = far;
      camera2.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
}
class SpotLight extends Light {
  /**
   * Constructs a new spot light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(
    color2,
    intensity,
    distance2 = 0,
    angle = Math.PI / 3,
    penumbra = 0,
    decay = 2
  ) {
    super(color2, intensity);
    this.isSpotLight = true;
    this.type = "SpotLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance2;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.map = null;
    this.shadow = new SpotLightShadow();
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   *  Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
const _projScreenMatrix$3 = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld = /* @__PURE__ */ new Vector3();
const _lookTarget = /* @__PURE__ */ new Vector3();
class PointLightShadow extends LightShadow {
  /**
   * Constructs a new point light shadow.
   */
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this.isPointLightShadow = true;
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Vector4(2, 1, 1, 1),
      // negative X
      new Vector4(0, 1, 1, 1),
      // positive Z
      new Vector4(3, 1, 1, 1),
      // negative Z
      new Vector4(1, 1, 1, 1),
      // positive Y
      new Vector4(3, 0, 1, 1),
      // negative Y
      new Vector4(1, 0, 1, 1),
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0),
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
    ];
  }
  /**
   * Update the matrices for the camera and shadow, used internally by the renderer.
   *
   * @param {Light} light - The light for which the shadow is being rendered.
   * @param {number} [viewportIndex=0] - The viewport index.
   */
  updateMatrices(light, viewportIndex = 0) {
    const camera2 = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera2.far;
    if (far !== camera2.far) {
      camera2.far = far;
      camera2.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera2.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera2.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera2.up.copy(this._cubeUps[viewportIndex]);
    camera2.lookAt(_lookTarget);
    camera2.updateMatrixWorld();
    shadowMatrix.makeTranslation(
      -_lightPositionWorld.x,
      -_lightPositionWorld.y,
      -_lightPositionWorld.z
    );
    _projScreenMatrix$3.multiplyMatrices(
      camera2.projectionMatrix,
      camera2.matrixWorldInverse
    );
    this._frustum.setFromProjectionMatrix(
      _projScreenMatrix$3,
      camera2.coordinateSystem,
      camera2.reversedDepth
    );
  }
}
class PointLight extends Light {
  /**
   * Constructs a new point light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(color2, intensity, distance2 = 0, decay = 2) {
    super(color2, intensity);
    this.isPointLight = true;
    this.type = "PointLight";
    this.distance = distance2;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   * Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
}
class OrthographicCamera extends Camera {
  /**
   * Constructs a new orthographic camera.
   *
   * @param {number} [left=-1] - The left plane of the camera's frustum.
   * @param {number} [right=1] - The right plane of the camera's frustum.
   * @param {number} [top=1] - The top plane of the camera's frustum.
   * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(
    left = -1,
    right = 1,
    top = 1,
    bottom = -1,
    near = 0.1,
    far = 2e3
  ) {
    super();
    this.isOrthographicCamera = true;
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   * @see {@link PerspectiveCamera#setViewOffset}
   */
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH =
        (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(
      left,
      right,
      top,
      bottom,
      this.near,
      this.far,
      this.coordinateSystem,
      this.reversedDepth
    );
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
}
class DirectionalLightShadow extends LightShadow {
  /**
   * Constructs a new directional light shadow.
   */
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    this.isDirectionalLightShadow = true;
  }
}
class DirectionalLight extends Light {
  /**
   * Constructs a new directional light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(color2, intensity) {
    super(color2, intensity);
    this.isDirectionalLight = true;
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
class AmbientLight extends Light {
  /**
   * Constructs a new ambient light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(color2, intensity) {
    super(color2, intensity);
    this.isAmbientLight = true;
    this.type = "AmbientLight";
  }
}
class RectAreaLight extends Light {
  /**
   * Constructs a new area light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   * @param {number} [width=10] - The width of the light.
   * @param {number} [height=10] - The height of the light.
   */
  constructor(color2, intensity, width = 10, height = 10) {
    super(color2, intensity);
    this.isRectAreaLight = true;
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   * Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(power) {
    this.intensity = power / (this.width * this.height * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
}
class SphericalHarmonics3 {
  /**
   * Constructs a new spherical harmonics.
   */
  constructor() {
    this.isSphericalHarmonics3 = true;
    this.coefficients = [];
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients.push(new Vector3());
    }
  }
  /**
   * Sets the given SH coefficients to this instance by copying
   * the values.
   *
   * @param {Array<Vector3>} coefficients - The SH coefficients.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  set(coefficients) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].copy(coefficients[i2]);
    }
    return this;
  }
  /**
   * Sets all SH coefficients to `0`.
   *
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  zero() {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].set(0, 0, 0);
    }
    return this;
  }
  /**
   * Returns the radiance in the direction of the given normal.
   *
   * @param {Vector3} normal - The normal vector (assumed to be unit length)
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The radiance.
   */
  getAt(normal2, target) {
    const x = normal2.x,
      y = normal2.y,
      z = normal2.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y);
    target.addScaledVector(coeff[2], 0.488603 * z);
    target.addScaledVector(coeff[3], 0.488603 * x);
    target.addScaledVector(coeff[4], 1.092548 * (x * y));
    target.addScaledVector(coeff[5], 1.092548 * (y * z));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x * z));
    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
    return target;
  }
  /**
   * Returns the irradiance (radiance convolved with cosine lobe) in the
   * direction of the given normal.
   *
   * @param {Vector3} normal - The normal vector (assumed to be unit length)
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The irradiance.
   */
  getIrradianceAt(normal2, target) {
    const x = normal2.x,
      y = normal2.y,
      z = normal2.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
    return target;
  }
  /**
   * Adds the given SH to this instance.
   *
   * @param {SphericalHarmonics3} sh - The SH to add.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  add(sh) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].add(sh.coefficients[i2]);
    }
    return this;
  }
  /**
   * A convenience method for performing {@link SphericalHarmonics3#add} and
   * {@link SphericalHarmonics3#scale} at once.
   *
   * @param {SphericalHarmonics3} sh - The SH to add.
   * @param {number} s - The scale factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  addScaledSH(sh, s2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].addScaledVector(sh.coefficients[i2], s2);
    }
    return this;
  }
  /**
   * Scales this SH by the given scale factor.
   *
   * @param {number} s - The scale factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  scale(s2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].multiplyScalar(s2);
    }
    return this;
  }
  /**
   * Linear interpolates between the given SH and this instance by the given
   * alpha factor.
   *
   * @param {SphericalHarmonics3} sh - The SH to interpolate with.
   * @param {number} alpha - The alpha factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  lerp(sh, alpha) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
    }
    return this;
  }
  /**
   * Returns `true` if this spherical harmonics is equal with the given one.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics to test for equality.
   * @return {boolean} Whether this spherical harmonics is equal with the given one.
   */
  equals(sh) {
    for (let i2 = 0; i2 < 9; i2++) {
      if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Copies the values of the given spherical harmonics to this instance.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics to copy.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  copy(sh) {
    return this.set(sh.coefficients);
  }
  /**
   * Returns a new spherical harmonics with copied values from this instance.
   *
   * @return {SphericalHarmonics3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Sets the SH coefficients of this instance from the given array.
   *
   * @param {Array<number>} array - An array holding the SH coefficients.
   * @param {number} [offset=0] - The array offset where to start copying.
   * @return {SphericalHarmonics3} A clone of this instance.
   */
  fromArray(array2, offset = 0) {
    const coefficients = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++) {
      coefficients[i2].fromArray(array2, offset + i2 * 3);
    }
    return this;
  }
  /**
   * Returns an array with the SH coefficients, or copies them into the provided
   * array. The coefficients are represented as numbers.
   *
   * @param {Array<number>} [array=[]] - The target array.
   * @param {number} [offset=0] - The array offset where to start copying.
   * @return {Array<number>} An array with flat SH coefficients.
   */
  toArray(array2 = [], offset = 0) {
    const coefficients = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++) {
      coefficients[i2].toArray(array2, offset + i2 * 3);
    }
    return array2;
  }
  /**
   * Computes the SH basis for the given normal vector.
   *
   * @param {Vector3} normal - The normal.
   * @param {Array<number>} shBasis - The target array holding the SH basis.
   */
  static getBasisAt(normal2, shBasis) {
    const x = normal2.x,
      y = normal2.y,
      z = normal2.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y;
    shBasis[2] = 0.488603 * z;
    shBasis[3] = 0.488603 * x;
    shBasis[4] = 1.092548 * x * y;
    shBasis[5] = 1.092548 * y * z;
    shBasis[6] = 0.315392 * (3 * z * z - 1);
    shBasis[7] = 1.092548 * x * z;
    shBasis[8] = 0.546274 * (x * x - y * y);
  }
}
class LightProbe extends Light {
  /**
   * Constructs a new light probe.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics which represents encoded lighting information.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.isLightProbe = true;
    this.sh = sh;
  }
  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }
  /**
   * Deserializes the light prove from the given JSON.
   *
   * @param {Object} json - The JSON holding the serialized light probe.
   * @return {LightProbe} A reference to this light probe.
   */
  fromJSON(json) {
    this.intensity = json.intensity;
    this.sh.fromArray(json.sh);
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
}
class ArrayCamera extends PerspectiveCamera {
  /**
   * Constructs a new array camera.
   *
   * @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
   */
  constructor(array2 = []) {
    super();
    this.isArrayCamera = true;
    this.isMultiViewCamera = false;
    this.cameras = array2;
  }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
  /**
   * Constructs a new instanced interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   * @param {number} [meshPerAttribute=1] - Defines how often a value of this interleaved buffer should be repeated.
   */
  constructor(array2, stride, meshPerAttribute = 1) {
    super(array2, stride);
    this.isInstancedInterleavedBuffer = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  clone(data) {
    const ib = super.clone(data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  }
  toJSON(data) {
    const json = super.toJSON(data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
}
class Spherical {
  /**
   * Constructs a new spherical.
   *
   * @param {number} [radius=1] - The radius, or the Euclidean distance (straight-line distance) from the point to the origin.
   * @param {number} [phi=0] - The polar angle in radians from the y (up) axis.
   * @param {number} [theta=0] - The equator/azimuthal angle in radians around the y (up) axis.
   */
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
  }
  /**
   * Sets the spherical components by copying the given values.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The polar angle.
   * @param {number} theta - The azimuthal angle.
   * @return {Spherical} A reference to this spherical.
   */
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  /**
   * Copies the values of the given spherical to this instance.
   *
   * @param {Spherical} other - The spherical to copy.
   * @return {Spherical} A reference to this spherical.
   */
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }
  /**
   * Restricts the polar angle [page:.phi phi] to be between `0.000001` and pi -
   * `0.000001`.
   *
   * @return {Spherical} A reference to this spherical.
   */
  makeSafe() {
    const EPS = 1e-6;
    this.phi = clamp$1(this.phi, EPS, Math.PI - EPS);
    return this;
  }
  /**
   * Sets the spherical components from the given vector which is assumed to hold
   * Cartesian coordinates.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Spherical} A reference to this spherical.
   */
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }
  /**
   * Sets the spherical components from the given Cartesian coordinates.
   *
   * @param {number} x - The x value.
   * @param {number} y - The y value.
   * @param {number} z - The z value.
   * @return {Spherical} A reference to this spherical.
   */
  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + y * y + z * z);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z);
      this.phi = Math.acos(clamp$1(y / this.radius, -1, 1));
    }
    return this;
  }
  /**
   * Returns a new spherical with copied values from this instance.
   *
   * @return {Spherical} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix2 {
  /**
   * Constructs a new 2x2 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   */
  constructor(n11, n12, n21, n22) {
    Matrix2.prototype.isMatrix2 = true;
    this.elements = [1, 0, 0, 1];
    if (n11 !== void 0) {
      this.set(n11, n12, n21, n22);
    }
  }
  /**
   * Sets this matrix to the 2x2 identity matrix.
   *
   * @return {Matrix2} A reference to this matrix.
   */
  identity() {
    this.set(1, 0, 0, 1);
    return this;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix2} A reference to this matrix.
   */
  fromArray(array2, offset = 0) {
    for (let i2 = 0; i2 < 4; i2++) {
      this.elements[i2] = array2[i2 + offset];
    }
    return this;
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} n11 - 1-1 matrix element.
   * @param {number} n12 - 1-2 matrix element.
   * @param {number} n21 - 2-1 matrix element.
   * @param {number} n22 - 2-2 matrix element.
   * @return {Matrix2} A reference to this matrix.
   */
  set(n11, n12, n21, n22) {
    const te = this.elements;
    te[0] = n11;
    te[2] = n12;
    te[1] = n21;
    te[3] = n22;
    return this;
  }
}
class GridHelper extends LineSegments {
  /**
   * Constructs a new grid helper.
   *
   * @param {number} [size=10] - The size of the grid.
   * @param {number} [divisions=10] - The number of divisions across the grid.
   * @param {number|Color|string} [color1=0x444444] - The color of the center line.
   * @param {number|Color|string} [color2=0x888888] - The color of the lines of the grid.
   */
  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center = divisions / 2;
    const step2 = size / divisions;
    const halfSize = size / 2;
    const vertices = [],
      colors = [];
    for (let i2 = 0, j = 0, k = -halfSize; i2 <= divisions; i2++, k += step2) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      const color3 = i2 === center ? color1 : color2;
      color3.toArray(colors, j);
      j += 3;
      color3.toArray(colors, j);
      j += 3;
      color3.toArray(colors, j);
      j += 3;
      color3.toArray(colors, j);
      j += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false,
    });
    super(geometry, material);
    this.type = "GridHelper";
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
class Controls extends EventDispatcher {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
   */
  constructor(object, domElement = null) {
    super();
    this.object = object;
    this.domElement = domElement;
    this.enabled = true;
    this.state = -1;
    this.keys = {};
    this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };
    this.touches = { ONE: null, TWO: null };
  }
  /**
   * Connects the controls to the DOM. This method has so called "side effects" since
   * it adds the module's event listeners to the DOM.
   *
   * @param {HTMLDOMElement} element - The DOM element to connect to.
   */
  connect(element2) {
    if (element2 === void 0) {
      console.warn("THREE.Controls: connect() now requires an element.");
      return;
    }
    if (this.domElement !== null) this.disconnect();
    this.domElement = element2;
  }
  /**
   * Disconnects the controls from the DOM.
   */
  disconnect() {}
  /**
   * Call this method if you no longer want use to the controls. It frees all internal
   * resources and removes all event listeners.
   */
  dispose() {}
  /**
   * Controls should implement this method if they have to update their internal state
   * per simulation step.
   *
   * @param {number} [delta] - The time delta in seconds.
   */
  update() {}
}
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", {
      detail: {
        revision: REVISION,
      },
    })
  );
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const refreshUniforms = [
  "alphaMap",
  "alphaTest",
  "anisotropy",
  "anisotropyMap",
  "anisotropyRotation",
  "aoMap",
  "aoMapIntensity",
  "attenuationColor",
  "attenuationDistance",
  "bumpMap",
  "clearcoat",
  "clearcoatMap",
  "clearcoatNormalMap",
  "clearcoatNormalScale",
  "clearcoatRoughness",
  "color",
  "dispersion",
  "displacementMap",
  "emissive",
  "emissiveIntensity",
  "emissiveMap",
  "envMap",
  "envMapIntensity",
  "gradientMap",
  "ior",
  "iridescence",
  "iridescenceIOR",
  "iridescenceMap",
  "iridescenceThicknessMap",
  "lightMap",
  "lightMapIntensity",
  "map",
  "matcap",
  "metalness",
  "metalnessMap",
  "normalMap",
  "normalScale",
  "opacity",
  "roughness",
  "roughnessMap",
  "sheen",
  "sheenColor",
  "sheenColorMap",
  "sheenRoughnessMap",
  "shininess",
  "specular",
  "specularColor",
  "specularColorMap",
  "specularIntensity",
  "specularIntensityMap",
  "specularMap",
  "thickness",
  "transmission",
  "transmissionMap",
];
const _lightsCache = /* @__PURE__ */ new WeakMap();
class NodeMaterialObserver {
  /**
   * Constructs a new node material observer.
   *
   * @param {NodeBuilder} builder - The node builder.
   */
  constructor(builder) {
    this.renderObjects = /* @__PURE__ */ new WeakMap();
    this.hasNode = this.containsNode(builder);
    this.hasAnimation = builder.object.isSkinnedMesh === true;
    this.refreshUniforms = refreshUniforms;
    this.renderId = 0;
  }
  /**
   * Returns `true` if the given render object is verified for the first time of this observer.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the given render object is verified for the first time of this observer.
   */
  firstInitialization(renderObject) {
    const hasInitialized = this.renderObjects.has(renderObject);
    if (hasInitialized === false) {
      this.getRenderObjectData(renderObject);
      return true;
    }
    return false;
  }
  /**
   * Returns `true` if the current rendering produces motion vectors.
   *
   * @param {Renderer} renderer - The renderer.
   * @return {boolean} Whether the current rendering produces motion vectors or not.
   */
  needsVelocity(renderer2) {
    const mrt2 = renderer2.getMRT();
    return mrt2 !== null && mrt2.has("velocity");
  }
  /**
   * Returns monitoring data for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Object} The monitoring data.
   */
  getRenderObjectData(renderObject) {
    let data = this.renderObjects.get(renderObject);
    if (data === void 0) {
      const { geometry, material, object } = renderObject;
      data = {
        material: this.getMaterialData(material),
        geometry: {
          id: geometry.id,
          attributes: this.getAttributesData(geometry.attributes),
          indexVersion: geometry.index ? geometry.index.version : null,
          drawRange: {
            start: geometry.drawRange.start,
            count: geometry.drawRange.count,
          },
        },
        worldMatrix: object.matrixWorld.clone(),
      };
      if (object.center) {
        data.center = object.center.clone();
      }
      if (object.morphTargetInfluences) {
        data.morphTargetInfluences = object.morphTargetInfluences.slice();
      }
      if (renderObject.bundle !== null) {
        data.version = renderObject.bundle.version;
      }
      if (data.material.transmission > 0) {
        const { width, height } = renderObject.context;
        data.bufferWidth = width;
        data.bufferHeight = height;
      }
      data.lights = this.getLightsData(renderObject.lightsNode.getLights());
      this.renderObjects.set(renderObject, data);
    }
    return data;
  }
  /**
   * Returns an attribute data structure holding the attributes versions for
   * monitoring.
   *
   * @param {Object} attributes - The geometry attributes.
   * @return {Object} An object for monitoring the versions of attributes.
   */
  getAttributesData(attributes) {
    const attributesData = {};
    for (const name in attributes) {
      const attribute2 = attributes[name];
      attributesData[name] = {
        version: attribute2.version,
      };
    }
    return attributesData;
  }
  /**
   * Returns `true` if the node builder's material uses
   * node properties.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether the node builder's material uses node properties or not.
   */
  containsNode(builder) {
    const material = builder.material;
    for (const property2 in material) {
      if (material[property2] && material[property2].isNode) return true;
    }
    if (
      builder.renderer.overrideNodes.modelViewMatrix !== null ||
      builder.renderer.overrideNodes.modelNormalViewMatrix !== null
    )
      return true;
    return false;
  }
  /**
   * Returns a material data structure holding the material property values for
   * monitoring.
   *
   * @param {Material} material - The material.
   * @return {Object} An object for monitoring material properties.
   */
  getMaterialData(material) {
    const data = {};
    for (const property2 of this.refreshUniforms) {
      const value = material[property2];
      if (value === null || value === void 0) continue;
      if (typeof value === "object" && value.clone !== void 0) {
        if (value.isTexture === true) {
          data[property2] = { id: value.id, version: value.version };
        } else {
          data[property2] = value.clone();
        }
      } else {
        data[property2] = value;
      }
    }
    return data;
  }
  /**
   * Returns `true` if the given render object has not changed its state.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Light>} lightsData - The current material lights.
   * @return {boolean} Whether the given render object has changed its state or not.
   */
  equals(renderObject, lightsData) {
    const { object, material, geometry } = renderObject;
    const renderObjectData = this.getRenderObjectData(renderObject);
    if (renderObjectData.worldMatrix.equals(object.matrixWorld) !== true) {
      renderObjectData.worldMatrix.copy(object.matrixWorld);
      return false;
    }
    const materialData = renderObjectData.material;
    for (const property2 in materialData) {
      const value = materialData[property2];
      const mtlValue = material[property2];
      if (value.equals !== void 0) {
        if (value.equals(mtlValue) === false) {
          value.copy(mtlValue);
          return false;
        }
      } else if (mtlValue.isTexture === true) {
        if (value.id !== mtlValue.id || value.version !== mtlValue.version) {
          value.id = mtlValue.id;
          value.version = mtlValue.version;
          return false;
        }
      } else if (value !== mtlValue) {
        materialData[property2] = mtlValue;
        return false;
      }
    }
    if (materialData.transmission > 0) {
      const { width, height } = renderObject.context;
      if (
        renderObjectData.bufferWidth !== width ||
        renderObjectData.bufferHeight !== height
      ) {
        renderObjectData.bufferWidth = width;
        renderObjectData.bufferHeight = height;
        return false;
      }
    }
    const storedGeometryData = renderObjectData.geometry;
    const attributes = geometry.attributes;
    const storedAttributes = storedGeometryData.attributes;
    const storedAttributeNames = Object.keys(storedAttributes);
    const currentAttributeNames = Object.keys(attributes);
    if (storedGeometryData.id !== geometry.id) {
      storedGeometryData.id = geometry.id;
      return false;
    }
    if (storedAttributeNames.length !== currentAttributeNames.length) {
      renderObjectData.geometry.attributes = this.getAttributesData(attributes);
      return false;
    }
    for (const name of storedAttributeNames) {
      const storedAttributeData = storedAttributes[name];
      const attribute2 = attributes[name];
      if (attribute2 === void 0) {
        delete storedAttributes[name];
        return false;
      }
      if (storedAttributeData.version !== attribute2.version) {
        storedAttributeData.version = attribute2.version;
        return false;
      }
    }
    const index = geometry.index;
    const storedIndexVersion = storedGeometryData.indexVersion;
    const currentIndexVersion = index ? index.version : null;
    if (storedIndexVersion !== currentIndexVersion) {
      storedGeometryData.indexVersion = currentIndexVersion;
      return false;
    }
    if (
      storedGeometryData.drawRange.start !== geometry.drawRange.start ||
      storedGeometryData.drawRange.count !== geometry.drawRange.count
    ) {
      storedGeometryData.drawRange.start = geometry.drawRange.start;
      storedGeometryData.drawRange.count = geometry.drawRange.count;
      return false;
    }
    if (renderObjectData.morphTargetInfluences) {
      let morphChanged = false;
      for (
        let i2 = 0;
        i2 < renderObjectData.morphTargetInfluences.length;
        i2++
      ) {
        if (
          renderObjectData.morphTargetInfluences[i2] !==
          object.morphTargetInfluences[i2]
        ) {
          morphChanged = true;
        }
      }
      if (morphChanged) return true;
    }
    if (renderObjectData.lights) {
      for (let i2 = 0; i2 < lightsData.length; i2++) {
        if (renderObjectData.lights[i2].map !== lightsData[i2].map) {
          return false;
        }
      }
    }
    if (renderObjectData.center) {
      if (renderObjectData.center.equals(object.center) === false) {
        renderObjectData.center.copy(object.center);
        return true;
      }
    }
    if (renderObject.bundle !== null) {
      renderObjectData.version = renderObject.bundle.version;
    }
    return true;
  }
  /**
   * Returns the lights data for the given material lights.
   *
   * @param {Array<Light>} materialLights - The material lights.
   * @return {Array<Object>} The lights data for the given material lights.
   */
  getLightsData(materialLights) {
    const lights2 = [];
    for (const light of materialLights) {
      if (light.isSpotLight === true && light.map !== null) {
        lights2.push({ map: light.map.version });
      }
    }
    return lights2;
  }
  /**
   * Returns the lights for the given lights node and render ID.
   *
   * @param {LightsNode} lightsNode - The lights node.
   * @param {number} renderId - The render ID.
   * @return {Array} The lights for the given lights node and render ID.
   */
  getLights(lightsNode, renderId) {
    if (_lightsCache.has(lightsNode)) {
      const cached = _lightsCache.get(lightsNode);
      if (cached.renderId === renderId) {
        return cached.lightsData;
      }
    }
    const lightsData = this.getLightsData(lightsNode.getLights());
    _lightsCache.set(lightsNode, { renderId, lightsData });
    return lightsData;
  }
  /**
   * Checks if the given render object requires a refresh.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {NodeFrame} nodeFrame - The current node frame.
   * @return {boolean} Whether the given render object requires a refresh or not.
   */
  needsRefresh(renderObject, nodeFrame) {
    if (
      this.hasNode ||
      this.hasAnimation ||
      this.firstInitialization(renderObject) ||
      this.needsVelocity(nodeFrame.renderer)
    )
      return true;
    const { renderId } = nodeFrame;
    if (this.renderId !== renderId) {
      this.renderId = renderId;
      return true;
    }
    const isStatic = renderObject.object.static === true;
    const isBundle =
      renderObject.bundle !== null &&
      renderObject.bundle.static === true &&
      this.getRenderObjectData(renderObject).version ===
        renderObject.bundle.version;
    if (isStatic || isBundle) return false;
    const lightsData = this.getLights(renderObject.lightsNode, renderId);
    const notEqual2 = this.equals(renderObject, lightsData) !== true;
    return notEqual2;
  }
}
function cyrb53(value, seed = 0) {
  let h12 = 3735928559 ^ seed,
    h2 = 1103547991 ^ seed;
  if (value instanceof Array) {
    for (let i2 = 0, val; i2 < value.length; i2++) {
      val = value[i2];
      h12 = Math.imul(h12 ^ val, 2654435761);
      h2 = Math.imul(h2 ^ val, 1597334677);
    }
  } else {
    for (let i2 = 0, ch; i2 < value.length; i2++) {
      ch = value.charCodeAt(i2);
      h12 = Math.imul(h12 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
    }
  }
  h12 = Math.imul(h12 ^ (h12 >>> 16), 2246822507);
  h12 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);
  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507);
  h2 ^= Math.imul(h12 ^ (h12 >>> 13), 3266489909);
  return 4294967296 * (2097151 & h2) + (h12 >>> 0);
}
const hashString = (str) => cyrb53(str);
const hashArray = (array2) => cyrb53(array2);
const hash$1 = (...params) => cyrb53(params);
function getCacheKey$1(object, force = false) {
  const values = [];
  if (object.isNode === true) {
    values.push(object.id);
    object = object.getSelf();
  }
  for (const { property: property2, childNode } of getNodeChildren(object)) {
    values.push(cyrb53(property2.slice(0, -4)), childNode.getCacheKey(force));
  }
  return cyrb53(values);
}
function* getNodeChildren(node, toJSON = false) {
  for (const property2 in node) {
    if (property2.startsWith("_") === true) continue;
    const object = node[property2];
    if (Array.isArray(object) === true) {
      for (let i2 = 0; i2 < object.length; i2++) {
        const child = object[i2];
        if (
          child &&
          (child.isNode === true ||
            (toJSON && typeof child.toJSON === "function"))
        ) {
          yield { property: property2, index: i2, childNode: child };
        }
      }
    } else if (object && object.isNode === true) {
      yield { property: property2, childNode: object };
    } else if (object && Object.getPrototypeOf(object) === Object.prototype) {
      for (const subProperty in object) {
        if (subProperty.startsWith("_") === true) continue;
        const child = object[subProperty];
        if (
          child &&
          (child.isNode === true ||
            (toJSON && typeof child.toJSON === "function"))
        ) {
          yield { property: property2, index: subProperty, childNode: child };
        }
      }
    }
  }
}
const typeFromLength = /* @__PURE__ */ new Map([
  [1, "float"],
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"],
]);
const dataFromObject = /* @__PURE__ */ new WeakMap();
function getTypeFromLength(length2) {
  return typeFromLength.get(length2);
}
function getTypedArrayFromType(type) {
  if (/[iu]?vec\d/.test(type)) {
    if (type.startsWith("ivec")) return Int32Array;
    if (type.startsWith("uvec")) return Uint32Array;
    return Float32Array;
  }
  if (/mat\d/.test(type)) return Float32Array;
  if (/float/.test(type)) return Float32Array;
  if (/uint/.test(type)) return Uint32Array;
  if (/int/.test(type)) return Int32Array;
  throw new Error(`THREE.NodeUtils: Unsupported type: ${type}`);
}
function getLengthFromType(type) {
  if (/float|int|uint/.test(type)) return 1;
  if (/vec2/.test(type)) return 2;
  if (/vec3/.test(type)) return 3;
  if (/vec4/.test(type)) return 4;
  if (/mat2/.test(type)) return 4;
  if (/mat3/.test(type)) return 9;
  if (/mat4/.test(type)) return 16;
  console.error("THREE.TSL: Unsupported type:", type);
}
function getMemoryLengthFromType(type) {
  if (/float|int|uint/.test(type)) return 1;
  if (/vec2/.test(type)) return 2;
  if (/vec3/.test(type)) return 3;
  if (/vec4/.test(type)) return 4;
  if (/mat2/.test(type)) return 4;
  if (/mat3/.test(type)) return 12;
  if (/mat4/.test(type)) return 16;
  console.error("THREE.TSL: Unsupported type:", type);
}
function getByteBoundaryFromType(type) {
  if (/float|int|uint/.test(type)) return 4;
  if (/vec2/.test(type)) return 8;
  if (/vec3/.test(type)) return 16;
  if (/vec4/.test(type)) return 16;
  if (/mat2/.test(type)) return 8;
  if (/mat3/.test(type)) return 48;
  if (/mat4/.test(type)) return 64;
  console.error("THREE.TSL: Unsupported type:", type);
}
function getValueType(value) {
  if (value === void 0 || value === null) return null;
  const typeOf = typeof value;
  if (value.isNode === true) {
    return "node";
  } else if (typeOf === "number") {
    return "float";
  } else if (typeOf === "boolean") {
    return "bool";
  } else if (typeOf === "string") {
    return "string";
  } else if (typeOf === "function") {
    return "shader";
  } else if (value.isVector2 === true) {
    return "vec2";
  } else if (value.isVector3 === true) {
    return "vec3";
  } else if (value.isVector4 === true) {
    return "vec4";
  } else if (value.isMatrix2 === true) {
    return "mat2";
  } else if (value.isMatrix3 === true) {
    return "mat3";
  } else if (value.isMatrix4 === true) {
    return "mat4";
  } else if (value.isColor === true) {
    return "color";
  } else if (value instanceof ArrayBuffer) {
    return "ArrayBuffer";
  }
  return null;
}
function getValueFromType(type, ...params) {
  const last4 = type ? type.slice(-4) : void 0;
  if (params.length === 1) {
    if (last4 === "vec2") params = [params[0], params[0]];
    else if (last4 === "vec3") params = [params[0], params[0], params[0]];
    else if (last4 === "vec4")
      params = [params[0], params[0], params[0], params[0]];
  }
  if (type === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat2") {
    return new Matrix2(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type === "bool") {
    return params[0] || false;
  } else if (type === "float" || type === "int" || type === "uint") {
    return params[0] || 0;
  } else if (type === "string") {
    return params[0] || "";
  } else if (type === "ArrayBuffer") {
    return base64ToArrayBuffer(params[0]);
  }
  return null;
}
function getDataFromObject(object) {
  let data = dataFromObject.get(object);
  if (data === void 0) {
    data = {};
    dataFromObject.set(object, data);
  }
  return data;
}
function arrayBufferToBase64(arrayBuffer2) {
  let chars = "";
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i2 = 0; i2 < array2.length; i2++) {
    chars += String.fromCharCode(array2[i2]);
  }
  return btoa(chars);
}
function base64ToArrayBuffer(base64) {
  return Uint8Array.from(atob(base64), (c2) => c2.charCodeAt(0)).buffer;
}
const NodeShaderStage = {
  VERTEX: "vertex",
  FRAGMENT: "fragment",
};
const NodeUpdateType = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object",
};
const NodeType = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX2: "mat2",
  MATRIX3: "mat3",
  MATRIX4: "mat4",
};
const NodeAccess = {
  READ_ONLY: "readOnly",
  WRITE_ONLY: "writeOnly",
  READ_WRITE: "readWrite",
};
const defaultShaderStages = ["fragment", "vertex"];
const defaultBuildStages = ["setup", "analyze", "generate"];
const shaderStages = [...defaultShaderStages, "compute"];
const vectorComponents = ["x", "y", "z", "w"];
const _parentBuildStage = {
  analyze: "setup",
  generate: "analyze",
};
let _nodeId = 0;
class Node extends EventDispatcher {
  static get type() {
    return "Node";
  }
  /**
   * Constructs a new node.
   *
   * @param {?string} nodeType - The node type.
   */
  constructor(nodeType = null) {
    super();
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.NONE;
    this.updateBeforeType = NodeUpdateType.NONE;
    this.updateAfterType = NodeUpdateType.NONE;
    this.uuid = MathUtils.generateUUID();
    this.version = 0;
    this.global = false;
    this.parents = false;
    this.isNode = true;
    this._cacheKey = null;
    this._cacheKeyVersion = 0;
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  /**
   * Set this property to `true` when the node should be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
    }
  }
  /**
   * The type of the class. The value is usually the constructor name.
   *
   * @type {string}
   * @readonly
   */
  get type() {
    return this.constructor.type;
  }
  /**
   * Convenient method for defining {@link Node#update}.
   *
   * @param {Function} callback - The update method.
   * @param {string} updateType - The update type.
   * @return {Node} A reference to this node.
   */
  onUpdate(callback, updateType) {
    this.updateType = updateType;
    this.update = callback.bind(this.getSelf());
    return this;
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `FRAME`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onFrameUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.FRAME);
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `RENDER`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onRenderUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.RENDER);
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `OBJECT`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onObjectUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.OBJECT);
  }
  /**
   * Convenient method for defining {@link Node#updateReference}.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onReference(callback) {
    this.updateReference = callback.bind(this.getSelf());
    return this;
  }
  /**
   * The `this` reference might point to a Proxy so this method can be used
   * to get the reference to the actual node instance.
   *
   * @return {Node} A reference to the node.
   */
  getSelf() {
    return this.self || this;
  }
  /**
   * Nodes might refer to other objects like materials. This method allows to dynamically update the reference
   * to such objects based on a given state (e.g. the current node frame or builder).
   *
   * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
   * @return {any} The updated reference.
   */
  updateReference() {
    return this;
  }
  /**
   * By default this method returns the value of the {@link Node#global} flag. This method
   * can be overwritten in derived classes if an analytical way is required to determine the
   * global cache referring to the current shader-stage.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether this node is global or not.
   */
  isGlobal() {
    return this.global;
  }
  /**
   * Generator function that can be used to iterate over the child nodes.
   *
   * @generator
   * @yields {Node} A child node.
   */
  *getChildren() {
    for (const { childNode } of getNodeChildren(this)) {
      yield childNode;
    }
  }
  /**
   * Calling this method dispatches the `dispose` event. This event can be used
   * to register event listeners for clean up tasks.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Callback for {@link Node#traverse}.
   *
   * @callback traverseCallback
   * @param {Node} node - The current node.
   */
  /**
   * Can be used to traverse through the node's hierarchy.
   *
   * @param {traverseCallback} callback - A callback that is executed per node.
   */
  traverse(callback) {
    callback(this);
    for (const childNode of this.getChildren()) {
      childNode.traverse(callback);
    }
  }
  /**
   * Returns the cache key for this node.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.
   * @return {number} The cache key of the node.
   */
  getCacheKey(force = false) {
    force = force || this.version !== this._cacheKeyVersion;
    if (force === true || this._cacheKey === null) {
      this._cacheKey = hash$1(
        getCacheKey$1(this, force),
        this.customCacheKey()
      );
      this._cacheKeyVersion = this.version;
    }
    return this._cacheKey;
  }
  /**
   * Generate a custom cache key for this node.
   *
   * @return {number} The cache key of the node.
   */
  customCacheKey() {
    return 0;
  }
  /**
   * Returns the references to this node which is by default `this`.
   *
   * @return {Node} A reference to this node.
   */
  getScope() {
    return this;
  }
  /**
   * Returns the hash of the node which is used to identify the node. By default it's
   * the {@link Node#uuid} however derived node classes might have to overwrite this method
   * depending on their implementation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash() {
    return this.uuid;
  }
  /**
   * Returns the update type of {@link Node#update}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateType() {
    return this.updateType;
  }
  /**
   * Returns the update type of {@link Node#updateBefore}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  /**
   * Returns the update type of {@link Node#updateAfter}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateAfterType() {
    return this.updateAfterType;
  }
  /**
   * Certain types are composed of multiple elements. For example a `vec3`
   * is composed of three `float` values. This method returns the type of
   * these elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getElementType(builder) {
    const type = this.getNodeType(builder);
    const elementType = builder.getElementType(type);
    return elementType;
  }
  /**
   * Returns the node member type for the given name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the node.
   */
  getMemberType() {
    return "void";
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getNodeType(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    if (nodeProperties.outputNode) {
      return nodeProperties.outputNode.getNodeType(builder);
    }
    return this.nodeType;
  }
  /**
   * This method is used during the build process of a node and ensures
   * equal nodes are not built multiple times but just once. For example if
   * `attribute( 'uv' )` is used multiple times by the user, the build
   * process makes sure to process just the first node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The shared node if possible. Otherwise `this` is returned.
   */
  getShared(builder) {
    const hash2 = this.getHash(builder);
    const nodeFromHash = builder.getNodeFromHash(hash2);
    return nodeFromHash || this;
  }
  /**
   * Returns the number of elements in the node array.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?number} The number of elements in the node array.
   */
  getArrayCount() {
    return null;
  }
  /**
   * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.
   * This method is often overwritten in derived modules to prepare the node which is used as a node's output/result.
   * If an output node is prepared, then it must be returned in the `return` statement of the derived module's setup function.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?Node} The output node.
   */
  setup(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    let index = 0;
    for (const childNode of this.getChildren()) {
      nodeProperties["node" + index++] = childNode;
    }
    return nodeProperties.outputNode || null;
  }
  /**
   * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.
   * This stage analyzes the node hierarchy and ensures descendent nodes are built.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?Node} output - The target output node.
   */
  analyze(builder, output2 = null) {
    const usageCount = builder.increaseUsage(this);
    if (this.parents === true) {
      const nodeData = builder.getDataFromNode(this, "any");
      nodeData.stages = nodeData.stages || {};
      nodeData.stages[builder.shaderStage] =
        nodeData.stages[builder.shaderStage] || [];
      nodeData.stages[builder.shaderStage].push(output2);
    }
    if (usageCount === 1) {
      const nodeProperties = builder.getNodeProperties(this);
      for (const childNode of Object.values(nodeProperties)) {
        if (childNode && childNode.isNode === true) {
          childNode.build(builder, this);
        }
      }
    }
  }
  /**
   * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.
   * This state builds the output node and returns the resulting shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?string} output - Can be used to define the output type.
   * @return {?string} The generated shader string.
   */
  generate(builder, output2) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode && outputNode.isNode === true) {
      return outputNode.build(builder, output2);
    }
  }
  /**
   * The method can be implemented to update the node's internal state before it is used to render an object.
   * The {@link Node#updateBeforeType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  updateBefore() {
    console.warn("Abstract function.");
  }
  /**
   * The method can be implemented to update the node's internal state after it was used to render an object.
   * The {@link Node#updateAfterType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  updateAfter() {
    console.warn("Abstract function.");
  }
  /**
   * The method can be implemented to update the node's internal state when it is used to render an object.
   * The {@link Node#updateType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  update() {
    console.warn("Abstract function.");
  }
  /**
   * This method performs the build of a node. The behavior and return value depend on the current build stage:
   * - **setup**: Prepares the node and its children for the build process. This process can also create new nodes. Returns the node itself or a variant.
   * - **analyze**: Analyzes the node hierarchy for optimizations in the code generation stage. Returns `null`.
   * - **generate**: Generates the shader code for the node. Returns the generated shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string|Node|null} [output=null] - Can be used to define the output type.
   * @return {Node|string|null} The result of the build process, depending on the build stage.
   */
  build(builder, output2 = null) {
    const refNode = this.getShared(builder);
    if (this !== refNode) {
      return refNode.build(builder, output2);
    }
    const nodeData = builder.getDataFromNode(this);
    nodeData.buildStages = nodeData.buildStages || {};
    nodeData.buildStages[builder.buildStage] = true;
    const parentBuildStage = _parentBuildStage[builder.buildStage];
    if (parentBuildStage && nodeData.buildStages[parentBuildStage] !== true) {
      const previousBuildStage = builder.getBuildStage();
      builder.setBuildStage(parentBuildStage);
      this.build(builder);
      builder.setBuildStage(previousBuildStage);
    }
    builder.addNode(this);
    builder.addChain(this);
    let result = null;
    const buildStage = builder.getBuildStage();
    if (buildStage === "setup") {
      this.updateReference(builder);
      const properties = builder.getNodeProperties(this);
      if (properties.initialized !== true) {
        properties.initialized = true;
        properties.outputNode =
          this.setup(builder) || properties.outputNode || null;
        for (const childNode of Object.values(properties)) {
          if (childNode && childNode.isNode === true) {
            if (childNode.parents === true) {
              const childProperties = builder.getNodeProperties(childNode);
              childProperties.parents = childProperties.parents || [];
              childProperties.parents.push(this);
            }
            childNode.build(builder);
          }
        }
      }
      result = properties.outputNode;
    } else if (buildStage === "analyze") {
      this.analyze(builder, output2);
    } else if (buildStage === "generate") {
      const isGenerateOnce = this.generate.length === 1;
      if (isGenerateOnce) {
        const type = this.getNodeType(builder);
        const nodeData2 = builder.getDataFromNode(this);
        result = nodeData2.snippet;
        if (result === void 0) {
          if (nodeData2.generated === void 0) {
            nodeData2.generated = true;
            result = this.generate(builder) || "";
            nodeData2.snippet = result;
          } else {
            console.warn("THREE.Node: Recursion detected.", this);
            result = "/* Recursion detected. */";
          }
        } else if (
          nodeData2.flowCodes !== void 0 &&
          builder.context.nodeBlock !== void 0
        ) {
          builder.addFlowCodeHierarchy(this, builder.context.nodeBlock);
        }
        result = builder.format(result, type, output2);
      } else {
        result = this.generate(builder, output2) || "";
      }
    }
    builder.removeChain(this);
    builder.addSequentialNode(this);
    return result;
  }
  /**
   * Returns the child nodes as a JSON object.
   *
   * @return {Array<Object>} An iterable list of serialized child objects as JSON.
   */
  getSerializeChildren() {
    return getNodeChildren(this);
  }
  /**
   * Serializes the node to JSON.
   *
   * @param {Object} json - The output JSON object.
   */
  serialize(json) {
    const nodeChildren = this.getSerializeChildren();
    const inputNodes = {};
    for (const { property: property2, index, childNode } of nodeChildren) {
      if (index !== void 0) {
        if (inputNodes[property2] === void 0) {
          inputNodes[property2] = Number.isInteger(index) ? [] : {};
        }
        inputNodes[property2][index] = childNode.toJSON(json.meta).uuid;
      } else {
        inputNodes[property2] = childNode.toJSON(json.meta).uuid;
      }
    }
    if (Object.keys(inputNodes).length > 0) {
      json.inputNodes = inputNodes;
    }
  }
  /**
   * Deserializes the node from the given JSON.
   *
   * @param {Object} json - The JSON object.
   */
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property2 in json.inputNodes) {
        if (Array.isArray(json.inputNodes[property2])) {
          const inputArray = [];
          for (const uuid of json.inputNodes[property2]) {
            inputArray.push(nodes[uuid]);
          }
          this[property2] = inputArray;
        } else if (typeof json.inputNodes[property2] === "object") {
          const inputObject = {};
          for (const subProperty in json.inputNodes[property2]) {
            const uuid = json.inputNodes[property2][subProperty];
            inputObject[subProperty] = nodes[uuid];
          }
          this[property2] = inputObject;
        } else {
          const uuid = json.inputNodes[property2];
          this[property2] = nodes[uuid];
        }
      }
    }
  }
  /**
   * Serializes the node into the three.js JSON Object/Scene format.
   *
   * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.
   * @return {Object} The serialized node.
   */
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {},
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.7,
          type: "Node",
          generator: "Node.toJSON",
        },
      };
      if (isRoot !== true) meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
      if (nodes.length > 0) data.nodes = nodes;
    }
    return data;
  }
}
class ArrayElementNode extends Node {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  static get type() {
    return "ArrayElementNode";
  }
  /**
   * Constructs an array element node.
   *
   * @param {Node} node - The array-like node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
    this.isArrayElementNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from the array-like node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.node.getElementType(builder);
  }
  generate(builder) {
    const indexType = this.indexNode.getNodeType(builder);
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(
      builder,
      !builder.isVector(indexType) && builder.isInteger(indexType)
        ? indexType
        : "uint"
    );
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
}
class ConvertNode extends Node {
  static get type() {
    return "ConvertNode";
  }
  /**
   * Constructs a new convert node.
   *
   * @param {Node} node - The node which type should be converted.
   * @param {string} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.
   */
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  /**
   * This method is overwritten since the implementation tries to infer the best
   * matching type from the {@link ConvertNode#convertTo} property.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const requestType = this.node.getNodeType(builder);
    let convertTo = null;
    for (const overloadingType of this.convertTo.split("|")) {
      if (
        convertTo === null ||
        builder.getTypeLength(requestType) ===
          builder.getTypeLength(overloadingType)
      ) {
        convertTo = overloadingType;
      }
    }
    return convertTo;
  }
  serialize(data) {
    super.serialize(data);
    data.convertTo = this.convertTo;
  }
  deserialize(data) {
    super.deserialize(data);
    this.convertTo = data.convertTo;
  }
  generate(builder, output2) {
    const node = this.node;
    const type = this.getNodeType(builder);
    const snippet = node.build(builder, type);
    return builder.format(snippet, type, output2);
  }
}
class TempNode extends Node {
  static get type() {
    return "TempNode";
  }
  /**
   * Constructs a temp node.
   *
   * @param {?string} nodeType - The node type.
   */
  constructor(nodeType = null) {
    super(nodeType);
    this.isTempNode = true;
  }
  /**
   * Whether this node is used more than once in context of other nodes.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @return {boolean} A flag that indicates if there is more than one dependency to other nodes.
   */
  hasDependencies(builder) {
    return builder.getDataFromNode(this).usageCount > 1;
  }
  build(builder, output2) {
    const buildStage = builder.getBuildStage();
    if (buildStage === "generate") {
      const type = builder.getVectorType(this.getNodeType(builder, output2));
      const nodeData = builder.getDataFromNode(this);
      if (nodeData.propertyName !== void 0) {
        return builder.format(nodeData.propertyName, type, output2);
      } else if (
        type !== "void" &&
        output2 !== "void" &&
        this.hasDependencies(builder)
      ) {
        const snippet = super.build(builder, type);
        const nodeVar = builder.getVarFromNode(this, null, type);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
        return builder.format(nodeData.propertyName, type, output2);
      }
    }
    return super.build(builder, output2);
  }
}
class JoinNode extends TempNode {
  static get type() {
    return "JoinNode";
  }
  /**
   * Constructs a new join node.
   *
   * @param {Array<Node>} nodes - An array of nodes that should be joined.
   * @param {?string} [nodeType=null] - The node type.
   */
  constructor(nodes = [], nodeType = null) {
    super(nodeType);
    this.nodes = nodes;
  }
  /**
   * This method is overwritten since the node type must be inferred from the
   * joined data length if not explicitly defined.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.nodeType !== null) {
      return builder.getVectorType(this.nodeType);
    }
    return builder.getTypeFromLength(
      this.nodes.reduce(
        (count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)),
        0
      )
    );
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const maxLength = builder.getTypeLength(type);
    const nodes = this.nodes;
    const primitiveType = builder.getComponentType(type);
    const snippetValues = [];
    let length2 = 0;
    for (const input of nodes) {
      if (length2 >= maxLength) {
        console.error(
          `THREE.TSL: Length of parameters exceeds maximum length of function '${type}()' type.`
        );
        break;
      }
      let inputType = input.getNodeType(builder);
      let inputTypeLength = builder.getTypeLength(inputType);
      let inputSnippet;
      if (length2 + inputTypeLength > maxLength) {
        console.error(
          `THREE.TSL: Length of '${type}()' data exceeds maximum length of output type.`
        );
        inputTypeLength = maxLength - length2;
        inputType = builder.getTypeFromLength(inputTypeLength);
      }
      length2 += inputTypeLength;
      inputSnippet = input.build(builder, inputType);
      const inputPrimitiveType = builder.getComponentType(inputType);
      if (inputPrimitiveType !== primitiveType) {
        inputSnippet = builder.format(
          inputSnippet,
          inputPrimitiveType,
          primitiveType
        );
      }
      snippetValues.push(inputSnippet);
    }
    const snippet = `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
    return builder.format(snippet, type, output2);
  }
}
const _stringVectorComponents = vectorComponents.join("");
class SplitNode extends Node {
  static get type() {
    return "SplitNode";
  }
  /**
   * Constructs a new split node.
   *
   * @param {Node} node - The node that should be accessed.
   * @param {string} [components='x'] - The components that should be accessed.
   */
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
    this.isSplitNode = true;
  }
  /**
   * Returns the vector length which is computed based on the requested components.
   *
   * @return {number} The vector length.
   */
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c2 of this.components) {
      vectorLength = Math.max(vectorComponents.indexOf(c2) + 1, vectorLength);
    }
    return vectorLength;
  }
  /**
   * Returns the component type of the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The component type.
   */
  getComponentType(builder) {
    return builder.getComponentType(this.node.getNodeType(builder));
  }
  /**
   * This method is overwritten since the node type is inferred from requested components.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return builder.getTypeFromLength(
      this.components.length,
      this.getComponentType(builder)
    );
  }
  generate(builder, output2) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    let snippet = null;
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(
          this.getVectorLength(),
          this.getComponentType(builder)
        );
      }
      const nodeSnippet = node.build(builder, type);
      if (
        this.components.length === nodeTypeLength &&
        this.components ===
          _stringVectorComponents.slice(0, this.components.length)
      ) {
        snippet = builder.format(nodeSnippet, type, output2);
      } else {
        snippet = builder.format(
          `${nodeSnippet}.${this.components}`,
          this.getNodeType(builder),
          output2
        );
      }
    } else {
      snippet = node.build(builder, output2);
    }
    return snippet;
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
}
class SetNode extends TempNode {
  static get type() {
    return "SetNode";
  }
  /**
   * Constructs a new set node.
   *
   * @param {Node} sourceNode - The node that should be updated.
   * @param {string} components - The components that should be updated.
   * @param {Node} targetNode - The value node.
   */
  constructor(sourceNode, components, targetNode) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
    this.targetNode = targetNode;
  }
  /**
   * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { sourceNode, components, targetNode } = this;
    const sourceType = this.getNodeType(builder);
    const componentType = builder.getComponentType(
      targetNode.getNodeType(builder)
    );
    const targetType = builder.getTypeFromLength(
      components.length,
      componentType
    );
    const targetSnippet = targetNode.build(builder, targetType);
    const sourceSnippet = sourceNode.build(builder, sourceType);
    const length2 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    for (let i2 = 0; i2 < length2; i2++) {
      const component = vectorComponents[i2];
      if (component === components[0]) {
        snippetValues.push(targetSnippet);
        i2 += components.length - 1;
      } else {
        snippetValues.push(sourceSnippet + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
}
class FlipNode extends TempNode {
  static get type() {
    return "FlipNode";
  }
  /**
   * Constructs a new flip node.
   *
   * @param {Node} sourceNode - The node which component(s) should be flipped.
   * @param {string} components - The components that should be flipped e.g. `'x'` or `'xy'`.
   */
  constructor(sourceNode, components) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
  }
  /**
   * This method is overwritten since the node type is inferred from the source node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { components, sourceNode } = this;
    const sourceType = this.getNodeType(builder);
    const sourceSnippet = sourceNode.build(builder);
    const sourceCache = builder.getVarFromNode(this);
    const sourceProperty = builder.getPropertyName(sourceCache);
    builder.addLineFlowCode(sourceProperty + " = " + sourceSnippet, this);
    const length2 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    let componentIndex = 0;
    for (let i2 = 0; i2 < length2; i2++) {
      const component = vectorComponents[i2];
      if (component === components[componentIndex]) {
        snippetValues.push("1.0 - " + (sourceProperty + "." + component));
        componentIndex++;
      } else {
        snippetValues.push(sourceProperty + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
}
class InputNode extends Node {
  static get type() {
    return "InputNode";
  }
  /**
   * Constructs a new input node.
   *
   * @param {any} value - The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(nodeType);
    this.isInputNode = true;
    this.value = value;
    this.precision = null;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  /**
   * Returns the input type of the node which is by default the node type. Derived modules
   * might overwrite this method and use a fixed type or compute one analytically.
   *
   * A typical example for different input and node types are textures. The input type of a
   * normal RGBA texture is `texture` whereas its node type is `vec4`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  /**
   * Sets the precision to the given value. The method can be
   * overwritten in derived classes if the final precision must be computed
   * analytically.
   *
   * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.
   * @return {InputNode} A reference to this node.
   */
  setPrecision(precision) {
    this.precision = precision;
    return this;
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value;
    if (this.value && this.value.toArray) data.value = this.value.toArray();
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
    if (data.valueType === "ArrayBuffer")
      data.value = arrayBufferToBase64(data.value);
    data.precision = this.precision;
  }
  deserialize(data) {
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = Array.isArray(data.value)
      ? getValueFromType(data.valueType, ...data.value)
      : data.value;
    this.precision = data.precision || null;
    if (this.value && this.value.fromArray)
      this.value = this.value.fromArray(data.value);
  }
  generate() {
    console.warn("Abstract function.");
  }
}
const _regNum = /float|u?int/;
class ConstNode extends InputNode {
  static get type() {
    return "ConstNode";
  }
  /**
   * Constructs a new input node.
   *
   * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isConstNode = true;
  }
  /**
   * Generates the shader string of the value with the current node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated value as a shader string.
   */
  generateConst(builder) {
    return builder.generateConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    if (_regNum.test(type) && _regNum.test(output2)) {
      return builder.generateConst(output2, this.value);
    }
    return builder.format(this.generateConst(builder), type, output2);
  }
}
class MemberNode extends Node {
  static get type() {
    return "MemberNode";
  }
  /**
   * Constructs an array element node.
   *
   * @param {Node} node - The array-like node.
   * @param {string} property - The property name.
   */
  constructor(node, property2) {
    super();
    this.node = node;
    this.property = property2;
    this.isMemberNode = true;
  }
  getNodeType(builder) {
    return this.node.getMemberType(builder, this.property);
  }
  generate(builder) {
    const propertyName = this.node.build(builder);
    return propertyName + "." + this.property;
  }
}
let currentStack = null;
const NodeElements = /* @__PURE__ */ new Map();
function addMethodChaining(name, nodeElement) {
  if (NodeElements.has(name)) {
    console.warn(`THREE.TSL: Redefinition of method chaining '${name}'.`);
    return;
  }
  if (typeof nodeElement !== "function")
    throw new Error(`THREE.TSL: Node element ${name} is not a function`);
  NodeElements.set(name, nodeElement);
}
const parseSwizzle = (props) =>
  props
    .replace(/r|s/g, "x")
    .replace(/g|t/g, "y")
    .replace(/b|p/g, "z")
    .replace(/a|q/g, "w");
const parseSwizzleAndSort = (props) =>
  parseSwizzle(props).split("").sort().join("");
const shaderNodeHandler = {
  setup(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(nodeObjects(inputs), ...params);
  },
  get(node, prop, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (node.isStackNode !== true && prop === "assign") {
        return (...params) => {
          currentStack.assign(nodeObj, ...params);
          return nodeObj;
        };
      } else if (NodeElements.has(prop)) {
        const nodeElement = NodeElements.get(prop);
        return node.isStackNode
          ? (...params) => nodeObj.add(nodeElement(...params))
          : (...params) => nodeElement(nodeObj, ...params);
      } else if (prop === "toVarIntent") {
        return () => nodeObj;
      } else if (prop === "self") {
        return node;
      } else if (
        prop.endsWith("Assign") &&
        NodeElements.has(prop.slice(0, prop.length - "Assign".length))
      ) {
        const nodeElement = NodeElements.get(
          prop.slice(0, prop.length - "Assign".length)
        );
        return node.isStackNode
          ? (...params) => nodeObj.assign(params[0], nodeElement(...params))
          : (...params) => nodeObj.assign(nodeElement(nodeObj, ...params));
      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = parseSwizzle(prop);
        return nodeObject(new SplitNode(nodeObj, prop));
      } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {
        prop = parseSwizzleAndSort(prop.slice(3).toLowerCase());
        return (value) =>
          nodeObject(new SetNode(node, prop, nodeObject(value)));
      } else if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {
        prop = parseSwizzleAndSort(prop.slice(4).toLowerCase());
        return () => nodeObject(new FlipNode(nodeObject(node), prop));
      } else if (prop === "width" || prop === "height" || prop === "depth") {
        if (prop === "width") prop = "x";
        else if (prop === "height") prop = "y";
        else if (prop === "depth") prop = "z";
        return nodeObject(new SplitNode(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return nodeObject(
          new ArrayElementNode(nodeObj, new ConstNode(Number(prop), "uint"))
        );
      } else if (/^get$/.test(prop) === true) {
        return (value) => nodeObject(new MemberNode(nodeObj, value));
      }
    }
    return Reflect.get(node, prop, nodeObj);
  },
  set(node, prop, value, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (
        /^[xyzwrgbastpq]{1,4}$/.test(prop) === true ||
        prop === "width" ||
        prop === "height" ||
        prop === "depth" ||
        /^\d+$/.test(prop) === true
      ) {
        nodeObj[prop].assign(value);
        return true;
      }
    }
    return Reflect.set(node, prop, value, nodeObj);
  },
};
const nodeObjectsCacheMap = /* @__PURE__ */ new WeakMap();
const nodeBuilderFunctionsCacheMap = /* @__PURE__ */ new WeakMap();
const ShaderNodeObject = function (obj, altType = null) {
  const type = getValueType(obj);
  if (type === "node") {
    let nodeObject2 = nodeObjectsCacheMap.get(obj);
    if (nodeObject2 === void 0) {
      nodeObject2 = new Proxy(obj, shaderNodeHandler);
      nodeObjectsCacheMap.set(obj, nodeObject2);
      nodeObjectsCacheMap.set(nodeObject2, nodeObject2);
    }
    return nodeObject2;
  } else if (
    (altType === null && (type === "float" || type === "boolean")) ||
    (type && type !== "shader" && type !== "string")
  ) {
    return nodeObject(getConstNode(obj, altType));
  } else if (type === "shader") {
    return obj.isFn ? obj : Fn(obj);
  }
  return obj;
};
const ShaderNodeObjects = function (objects, altType = null) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name], altType);
  }
  return objects;
};
const ShaderNodeArray = function (array2, altType = null) {
  const len = array2.length;
  for (let i2 = 0; i2 < len; i2++) {
    array2[i2] = nodeObject(array2[i2], altType);
  }
  return array2;
};
const ShaderNodeProxy = function (
  NodeClass,
  scope = null,
  factor = null,
  settings = null
) {
  function assignNode(node) {
    if (settings !== null) {
      node = nodeObject(Object.assign(node, settings));
      if (settings.intent === true) {
        node = node.toVarIntent();
      }
    } else {
      node = nodeObject(node);
    }
    return node;
  }
  let fn,
    name = scope,
    minParams,
    maxParams;
  function verifyParamsLimit(params) {
    let tslName;
    if (name) tslName = /[a-z]/i.test(name) ? name + "()" : name;
    else tslName = NodeClass.type;
    if (minParams !== void 0 && params.length < minParams) {
      console.error(
        `THREE.TSL: "${tslName}" parameter length is less than minimum required.`
      );
      return params.concat(new Array(minParams - params.length).fill(0));
    } else if (maxParams !== void 0 && params.length > maxParams) {
      console.error(`THREE.TSL: "${tslName}" parameter length exceeds limit.`);
      return params.slice(0, maxParams);
    }
    return params;
  }
  if (scope === null) {
    fn = (...params) => {
      return assignNode(new NodeClass(...nodeArray(verifyParamsLimit(params))));
    };
  } else if (factor !== null) {
    factor = nodeObject(factor);
    fn = (...params) => {
      return assignNode(
        new NodeClass(scope, ...nodeArray(verifyParamsLimit(params)), factor)
      );
    };
  } else {
    fn = (...params) => {
      return assignNode(
        new NodeClass(scope, ...nodeArray(verifyParamsLimit(params)))
      );
    };
  }
  fn.setParameterLength = (...params) => {
    if (params.length === 1) minParams = maxParams = params[0];
    else if (params.length === 2) [minParams, maxParams] = params;
    return fn;
  };
  fn.setName = (value) => {
    name = value;
    return fn;
  };
  return fn;
};
const ShaderNodeImmutable = function (NodeClass, ...params) {
  return nodeObject(new NodeClass(...nodeArray(params)));
};
class ShaderCallNodeInternal extends Node {
  constructor(shaderNode, inputNodes) {
    super();
    this.shaderNode = shaderNode;
    this.inputNodes = inputNodes;
    this.isShaderCallNodeInternal = true;
  }
  getNodeType(builder) {
    return (
      this.shaderNode.nodeType ||
      this.getOutputNode(builder).getNodeType(builder)
    );
  }
  getMemberType(builder, name) {
    return this.getOutputNode(builder).getMemberType(builder, name);
  }
  call(builder) {
    const { shaderNode, inputNodes } = this;
    const properties = builder.getNodeProperties(shaderNode);
    const subBuild2 = builder.getClosestSubBuild(shaderNode.subBuilds) || "";
    const subBuildProperty = subBuild2 || "default";
    if (properties[subBuildProperty]) {
      return properties[subBuildProperty];
    }
    const previousSubBuildFn = builder.subBuildFn;
    builder.subBuildFn = subBuild2;
    let result = null;
    if (shaderNode.layout) {
      let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(
        builder.constructor
      );
      if (functionNodesCacheMap === void 0) {
        functionNodesCacheMap = /* @__PURE__ */ new WeakMap();
        nodeBuilderFunctionsCacheMap.set(
          builder.constructor,
          functionNodesCacheMap
        );
      }
      let functionNode = functionNodesCacheMap.get(shaderNode);
      if (functionNode === void 0) {
        functionNode = nodeObject(builder.buildFunctionNode(shaderNode));
        functionNodesCacheMap.set(shaderNode, functionNode);
      }
      builder.addInclude(functionNode);
      result = nodeObject(functionNode.call(inputNodes));
    } else {
      let inputs = inputNodes;
      if (Array.isArray(inputs)) {
        let index = 0;
        inputs = new Proxy(inputs, {
          get: (target, property2, receiver) => {
            if (target[property2] === void 0) {
              return target[index++];
            } else {
              return Reflect.get(target, property2, receiver);
            }
          },
        });
      }
      const jsFunc = shaderNode.jsFunc;
      const outputNode =
        inputs !== null || jsFunc.length > 1
          ? jsFunc(inputs || [], builder)
          : jsFunc(builder);
      result = nodeObject(outputNode);
    }
    builder.subBuildFn = previousSubBuildFn;
    if (shaderNode.once) {
      properties[subBuildProperty] = result;
    }
    return result;
  }
  setupOutput(builder) {
    builder.addStack();
    builder.stack.outputNode = this.call(builder);
    return builder.removeStack();
  }
  getOutputNode(builder) {
    const properties = builder.getNodeProperties(this);
    const subBuildOutput = builder.getSubBuildOutput(this);
    properties[subBuildOutput] =
      properties[subBuildOutput] || this.setupOutput(builder);
    properties[subBuildOutput].subBuild = builder.getClosestSubBuild(this);
    return properties[subBuildOutput];
  }
  build(builder, output2 = null) {
    let result = null;
    const buildStage = builder.getBuildStage();
    const properties = builder.getNodeProperties(this);
    const subBuildOutput = builder.getSubBuildOutput(this);
    const outputNode = this.getOutputNode(builder);
    if (buildStage === "setup") {
      const subBuildInitialized = builder.getSubBuildProperty(
        "initialized",
        this
      );
      if (properties[subBuildInitialized] !== true) {
        properties[subBuildInitialized] = true;
        properties[subBuildOutput] = this.getOutputNode(builder);
        properties[subBuildOutput].build(builder);
        if (this.shaderNode.subBuilds) {
          for (const node of builder.chaining) {
            const nodeData = builder.getDataFromNode(node, "any");
            nodeData.subBuilds =
              nodeData.subBuilds || /* @__PURE__ */ new Set();
            for (const subBuild2 of this.shaderNode.subBuilds) {
              nodeData.subBuilds.add(subBuild2);
            }
          }
        }
      }
      result = properties[subBuildOutput];
    } else if (buildStage === "analyze") {
      outputNode.build(builder, output2);
    } else if (buildStage === "generate") {
      result = outputNode.build(builder, output2) || "";
    }
    return result;
  }
}
class ShaderNodeInternal extends Node {
  constructor(jsFunc, nodeType) {
    super(nodeType);
    this.jsFunc = jsFunc;
    this.layout = null;
    this.global = true;
    this.once = false;
  }
  setLayout(layout) {
    this.layout = layout;
    return this;
  }
  call(inputs = null) {
    nodeObjects(inputs);
    return nodeObject(new ShaderCallNodeInternal(this, inputs));
  }
  setup() {
    return this.call();
  }
}
const bools = [false, true];
const uints = [0, 1, 2, 3];
const ints = [-1, -2];
const floats = [
  0.5,
  1.5,
  1 / 3,
  1e-6,
  1e6,
  Math.PI,
  Math.PI * 2,
  1 / Math.PI,
  2 / Math.PI,
  1 / (Math.PI * 2),
  Math.PI / 2,
];
const boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool2 of bools) boolsCacheMap.set(bool2, new ConstNode(bool2));
const uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint2 of uints)
  uintsCacheMap.set(uint2, new ConstNode(uint2, "uint"));
const intsCacheMap = new Map(
  [...uintsCacheMap].map((el) => new ConstNode(el.value, "int"))
);
for (const int2 of ints) intsCacheMap.set(int2, new ConstNode(int2, "int"));
const floatsCacheMap = new Map(
  [...intsCacheMap].map((el) => new ConstNode(el.value))
);
for (const float2 of floats) floatsCacheMap.set(float2, new ConstNode(float2));
for (const float2 of floats)
  floatsCacheMap.set(-float2, new ConstNode(-float2));
const cacheMaps = {
  bool: boolsCacheMap,
  uint: uintsCacheMap,
  ints: intsCacheMap,
  float: floatsCacheMap,
};
const constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
const getConstNode = (value, type) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode(value, type);
  }
};
const ConvertType = function (type, cacheMap = null) {
  return (...params) => {
    if (
      params.length === 0 ||
      (!["bool", "float", "int", "uint"].includes(type) &&
        params.every((param) => typeof param !== "object"))
    ) {
      params = [getValueFromType(type, ...params)];
    }
    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
      return nodeObjectIntent(cacheMap.get(params[0]));
    }
    if (params.length === 1) {
      const node = getConstNode(params[0], type);
      if (node.nodeType === type) return nodeObjectIntent(node);
      return nodeObjectIntent(new ConvertNode(node, type));
    }
    const nodes = params.map((param) => getConstNode(param));
    return nodeObjectIntent(new JoinNode(nodes, type));
  };
};
const defined = (v) => (typeof v === "object" && v !== null ? v.value : v);
const getConstNodeType = (value) =>
  value !== void 0 && value !== null
    ? value.nodeType ||
      value.convertTo ||
      (typeof value === "string" ? value : null)
    : null;
function ShaderNode(jsFunc, nodeType) {
  return new Proxy(new ShaderNodeInternal(jsFunc, nodeType), shaderNodeHandler);
}
const nodeObject = (val, altType = null) =>
  /* new */
  ShaderNodeObject(val, altType);
const nodeObjectIntent = (val, altType = null) =>
  /* new */
  nodeObject(val, altType).toVarIntent();
const nodeObjects = (val, altType = null) =>
  new ShaderNodeObjects(val, altType);
const nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
const nodeProxy = (NodeClass, scope = null, factor = null, settings = null) =>
  new ShaderNodeProxy(NodeClass, scope, factor, settings);
const nodeImmutable = (NodeClass, ...params) =>
  new ShaderNodeImmutable(NodeClass, ...params);
const nodeProxyIntent = (
  NodeClass,
  scope = null,
  factor = null,
  settings = {}
) =>
  new ShaderNodeProxy(NodeClass, scope, factor, { intent: true, ...settings });
let fnId = 0;
const Fn = (jsFunc, layout = null) => {
  let nodeType = null;
  if (layout !== null) {
    if (typeof layout === "object") {
      nodeType = layout.return;
    } else {
      if (typeof layout === "string") {
        nodeType = layout;
      } else {
        console.error("THREE.TSL: Invalid layout type.");
      }
      layout = null;
    }
  }
  const shaderNode = new ShaderNode(jsFunc, nodeType);
  const fn = (...params) => {
    let inputs;
    nodeObjects(params);
    const isArrayAsParameter =
      params[0] &&
      (params[0].isNode ||
        Object.getPrototypeOf(params[0]) !== Object.prototype);
    if (isArrayAsParameter) {
      inputs = [...params];
    } else {
      inputs = params[0];
    }
    const fnCall = shaderNode.call(inputs);
    if (nodeType === "void") fnCall.toStack();
    return fnCall.toVarIntent();
  };
  fn.shaderNode = shaderNode;
  fn.id = shaderNode.id;
  fn.isFn = true;
  fn.getNodeType = (...params) => shaderNode.getNodeType(...params);
  fn.getCacheKey = (...params) => shaderNode.getCacheKey(...params);
  fn.setLayout = (layout2) => {
    shaderNode.setLayout(layout2);
    return fn;
  };
  fn.once = (subBuilds = null) => {
    shaderNode.once = true;
    shaderNode.subBuilds = subBuilds;
    return fn;
  };
  if (layout !== null) {
    if (typeof layout.inputs !== "object") {
      const fullLayout = {
        name: "fn" + fnId++,
        type: nodeType,
        inputs: [],
      };
      for (const name in layout) {
        if (name === "return") continue;
        fullLayout.inputs.push({
          name,
          type: layout[name],
        });
      }
      layout = fullLayout;
    }
    fn.setLayout(layout);
  }
  return fn;
};
const setCurrentStack = (stack2) => {
  currentStack = stack2;
};
const getCurrentStack = () => currentStack;
const If = (...params) => currentStack.If(...params);
const Switch = (...params) => currentStack.Switch(...params);
function Stack(node) {
  if (currentStack) currentStack.add(node);
  return node;
}
addMethodChaining("toStack", Stack);
const color$1 = new ConvertType("color");
const float = new ConvertType("float", cacheMaps.float);
const int = new ConvertType("int", cacheMaps.ints);
const uint = new ConvertType("uint", cacheMaps.uint);
const bool = new ConvertType("bool", cacheMaps.bool);
const vec2 = new ConvertType("vec2");
const ivec2 = new ConvertType("ivec2");
const uvec2 = new ConvertType("uvec2");
const bvec2 = new ConvertType("bvec2");
const vec3 = new ConvertType("vec3");
const ivec3 = new ConvertType("ivec3");
const uvec3 = new ConvertType("uvec3");
const bvec3 = new ConvertType("bvec3");
const vec4 = new ConvertType("vec4");
const ivec4 = new ConvertType("ivec4");
const uvec4 = new ConvertType("uvec4");
const bvec4 = new ConvertType("bvec4");
const mat2 = new ConvertType("mat2");
const mat3 = new ConvertType("mat3");
const mat4 = new ConvertType("mat4");
const string = (value = "") => nodeObject(new ConstNode(value, "string"));
const arrayBuffer = (value) => nodeObject(new ConstNode(value, "ArrayBuffer"));
addMethodChaining("toColor", color$1);
addMethodChaining("toFloat", float);
addMethodChaining("toInt", int);
addMethodChaining("toUint", uint);
addMethodChaining("toBool", bool);
addMethodChaining("toVec2", vec2);
addMethodChaining("toIVec2", ivec2);
addMethodChaining("toUVec2", uvec2);
addMethodChaining("toBVec2", bvec2);
addMethodChaining("toVec3", vec3);
addMethodChaining("toIVec3", ivec3);
addMethodChaining("toUVec3", uvec3);
addMethodChaining("toBVec3", bvec3);
addMethodChaining("toVec4", vec4);
addMethodChaining("toIVec4", ivec4);
addMethodChaining("toUVec4", uvec4);
addMethodChaining("toBVec4", bvec4);
addMethodChaining("toMat2", mat2);
addMethodChaining("toMat3", mat3);
addMethodChaining("toMat4", mat4);
const element =
  /* @__PURE__ */ nodeProxy(ArrayElementNode).setParameterLength(2);
const convert = (node, types) =>
  nodeObject(new ConvertNode(nodeObject(node), types));
const split = (node, channels) =>
  nodeObject(new SplitNode(nodeObject(node), channels));
addMethodChaining("element", element);
addMethodChaining("convert", convert);
const append = (node) => {
  console.warn("THREE.TSL: append() has been renamed to Stack().");
  return Stack(node);
};
addMethodChaining("append", (node) => {
  console.warn("THREE.TSL: .append() has been renamed to .toStack().");
  return Stack(node);
});
class PropertyNode extends Node {
  static get type() {
    return "PropertyNode";
  }
  /**
   * Constructs a new property node.
   *
   * @param {string} nodeType - The type of the node.
   * @param {?string} [name=null] - The name of the property in the shader.
   * @param {boolean} [varying=false] - Whether this property is a varying or not.
   */
  constructor(nodeType, name = null, varying2 = false) {
    super(nodeType);
    this.name = name;
    this.varying = varying2;
    this.isPropertyNode = true;
    this.global = true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  generate(builder) {
    let nodeVar;
    if (this.varying === true) {
      nodeVar = builder.getVaryingFromNode(this, this.name);
      nodeVar.needsInterpolation = true;
    } else {
      nodeVar = builder.getVarFromNode(this, this.name);
    }
    return builder.getPropertyName(nodeVar);
  }
}
const property = (type, name) => nodeObject(new PropertyNode(type, name));
const varyingProperty = (type, name) =>
  nodeObject(new PropertyNode(type, name, true));
const diffuseColor = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "vec4",
  "DiffuseColor"
);
const emissive = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "vec3",
  "EmissiveColor"
);
const roughness = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "Roughness"
);
const metalness = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "Metalness"
);
const clearcoat = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "Clearcoat"
);
const clearcoatRoughness = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "ClearcoatRoughness"
);
const sheen = /* @__PURE__ */ nodeImmutable(PropertyNode, "vec3", "Sheen");
const sheenRoughness = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "SheenRoughness"
);
const iridescence = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "Iridescence"
);
const iridescenceIOR = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "IridescenceIOR"
);
const iridescenceThickness = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "IridescenceThickness"
);
const alphaT = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "AlphaT");
const anisotropy = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "Anisotropy"
);
const anisotropyT = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "vec3",
  "AnisotropyT"
);
const anisotropyB = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "vec3",
  "AnisotropyB"
);
const specularColor = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "color",
  "SpecularColor"
);
const specularF90 = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "SpecularF90"
);
const shininess = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "Shininess"
);
const output = /* @__PURE__ */ nodeImmutable(PropertyNode, "vec4", "Output");
const dashSize = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "dashSize"
);
const gapSize = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "gapSize");
const pointWidth = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "pointWidth"
);
const ior = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "IOR");
const transmission = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "Transmission"
);
const thickness = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "Thickness"
);
const attenuationDistance = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "AttenuationDistance"
);
const attenuationColor = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "color",
  "AttenuationColor"
);
const dispersion = /* @__PURE__ */ nodeImmutable(
  PropertyNode,
  "float",
  "Dispersion"
);
class UniformGroupNode extends Node {
  static get type() {
    return "UniformGroupNode";
  }
  /**
   * Constructs a new uniform group node.
   *
   * @param {string} name - The name of the uniform group node.
   * @param {boolean} [shared=false] - Whether this uniform group node is shared or not.
   * @param {number} [order=1] - Influences the internal sorting.
   */
  constructor(name, shared = false, order = 1) {
    super("string");
    this.name = name;
    this.shared = shared;
    this.order = order;
    this.isUniformGroup = true;
  }
  serialize(data) {
    super.serialize(data);
    data.name = this.name;
    data.version = this.version;
    data.shared = this.shared;
  }
  deserialize(data) {
    super.deserialize(data);
    this.name = data.name;
    this.version = data.version;
    this.shared = data.shared;
  }
}
const uniformGroup = (name) => new UniformGroupNode(name);
const sharedUniformGroup = (name, order = 0) =>
  new UniformGroupNode(name, true, order);
const frameGroup = /* @__PURE__ */ sharedUniformGroup("frame");
const renderGroup = /* @__PURE__ */ sharedUniformGroup("render");
const objectGroup = /* @__PURE__ */ uniformGroup("object");
class UniformNode extends InputNode {
  static get type() {
    return "UniformNode";
  }
  /**
   * Constructs a new uniform node.
   *
   * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isUniformNode = true;
    this.name = "";
    this.groupNode = objectGroup;
  }
  /**
   * Sets the {@link UniformNode#name} property.
   *
   * @param {string} name - The name of the uniform.
   * @return {UniformNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the {@link UniformNode#name} property.
   *
   * @deprecated
   * @param {string} name - The name of the uniform.
   * @return {UniformNode} A reference to this node.
   */
  label(name) {
    console.warn(
      'THREE.TSL: "label()" has been deprecated. Use "setName()" instead.'
    );
    return this.setName(name);
  }
  /**
   * Sets the {@link UniformNode#groupNode} property.
   *
   * @param {UniformGroupNode} group - The uniform group.
   * @return {UniformNode} A reference to this node.
   */
  setGroup(group) {
    this.groupNode = group;
    return this;
  }
  /**
   * Returns the {@link UniformNode#groupNode}.
   *
   * @return {UniformGroupNode} The uniform group.
   */
  getGroup() {
    return this.groupNode;
  }
  /**
   * By default, this method returns the result of {@link Node#getHash} but derived
   * classes might overwrite this method with a different implementation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The uniform hash.
   */
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  onUpdate(callback, updateType) {
    const self2 = this.getSelf();
    callback = callback.bind(self2);
    return super.onUpdate((frame) => {
      const value = callback(frame, self2);
      if (value !== void 0) {
        this.value = value;
      }
    }, updateType);
  }
  getInputType(builder) {
    let type = super.getInputType(builder);
    if (type === "bool") {
      type = "uint";
    }
    return type;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const hash2 = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash2);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash2);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(
      sharedNode,
      sharedNodeType,
      builder.shaderStage,
      this.name || builder.context.nodeName
    );
    const uniformName = builder.getPropertyName(nodeUniform);
    if (builder.context.nodeName !== void 0) delete builder.context.nodeName;
    let snippet = uniformName;
    if (type === "bool") {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const nodeVar = builder.getVarFromNode(this, null, "bool");
        propertyName = builder.getPropertyName(nodeVar);
        nodeData.propertyName = propertyName;
        snippet = builder.format(uniformName, sharedNodeType, type);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
      }
      snippet = propertyName;
    }
    return builder.format(snippet, type, output2);
  }
}
const uniform$1 = (arg1, arg2) => {
  const nodeType = getConstNodeType(arg2 || arg1);
  const value =
    arg1 && arg1.isNode === true
      ? (arg1.node && arg1.node.value) || arg1.value
      : arg1;
  return nodeObject(new UniformNode(value, nodeType));
};
class ArrayNode extends TempNode {
  static get type() {
    return "ArrayNode";
  }
  /**
   * Constructs a new array node.
   *
   * @param {?string} nodeType - The data type of the elements.
   * @param {number} count - Size of the array.
   * @param {?Array<Node>} [values=null] - Array default values.
   */
  constructor(nodeType, count, values = null) {
    super(nodeType);
    this.count = count;
    this.values = values;
    this.isArrayNode = true;
  }
  /**
   * Returns the number of elements in the node array.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {number} The number of elements in the node array.
   */
  getArrayCount() {
    return this.count;
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getNodeType(builder) {
    if (this.nodeType === null) {
      this.nodeType = this.values[0].getNodeType(builder);
    }
    return this.nodeType;
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getElementType(builder) {
    return this.getNodeType(builder);
  }
  /**
   * This method builds the output node and returns the resulting array as a shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated shader string.
   */
  generate(builder) {
    const type = this.getNodeType(builder);
    return builder.generateArray(type, this.count, this.values);
  }
}
const array = (...params) => {
  let node;
  if (params.length === 1) {
    const values = params[0];
    node = new ArrayNode(null, values.length, values);
  } else {
    const nodeType = params[0];
    const count = params[1];
    node = new ArrayNode(nodeType, count);
  }
  return nodeObject(node);
};
addMethodChaining("toArray", (node, count) => array(Array(count).fill(node)));
class AssignNode extends TempNode {
  static get type() {
    return "AssignNode";
  }
  /**
   * Constructs a new assign node.
   *
   * @param {Node} targetNode - The target node.
   * @param {Node} sourceNode - The source type.
   */
  constructor(targetNode, sourceNode) {
    super();
    this.targetNode = targetNode;
    this.sourceNode = sourceNode;
    this.isAssignNode = true;
  }
  /**
   * Whether this node is used more than once in context of other nodes. This method
   * is overwritten since it always returns `false` (assigns are unique).
   *
   * @return {boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.
   */
  hasDependencies() {
    return false;
  }
  getNodeType(builder, output2) {
    return output2 !== "void" ? this.targetNode.getNodeType(builder) : "void";
  }
  /**
   * Whether a split is required when assigning source to target. This can happen when the component length of
   * target and source data type does not match.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether a split is required when assigning source to target.
   */
  needsSplitAssign(builder) {
    const { targetNode } = this;
    if (
      builder.isAvailable("swizzleAssign") === false &&
      targetNode.isSplitNode &&
      targetNode.components.length > 1
    ) {
      const targetLength = builder.getTypeLength(
        targetNode.node.getNodeType(builder)
      );
      const assignDifferentVector =
        vectorComponents.join("").slice(0, targetLength) !==
        targetNode.components;
      return assignDifferentVector;
    }
    return false;
  }
  setup(builder) {
    const { targetNode, sourceNode } = this;
    const targetProperties = builder.getNodeProperties(targetNode);
    targetProperties.assign = true;
    const properties = builder.getNodeProperties(this);
    properties.sourceNode = sourceNode;
    properties.targetNode = targetNode.context({ assign: true });
  }
  generate(builder, output2) {
    const { targetNode, sourceNode } = builder.getNodeProperties(this);
    const needsSplitAssign = this.needsSplitAssign(builder);
    const targetType = targetNode.getNodeType(builder);
    const target = targetNode.build(builder);
    const source = sourceNode.build(builder, targetType);
    const sourceType = sourceNode.getNodeType(builder);
    const nodeData = builder.getDataFromNode(this);
    let snippet;
    if (nodeData.initialized === true) {
      if (output2 !== "void") {
        snippet = target;
      }
    } else if (needsSplitAssign) {
      const sourceVar = builder.getVarFromNode(this, null, targetType);
      const sourceProperty = builder.getPropertyName(sourceVar);
      builder.addLineFlowCode(`${sourceProperty} = ${source}`, this);
      const splitNode = targetNode.node;
      const splitTargetNode = splitNode.node.context({ assign: true });
      const targetRoot = splitTargetNode.build(builder);
      for (let i2 = 0; i2 < splitNode.components.length; i2++) {
        const component = splitNode.components[i2];
        builder.addLineFlowCode(
          `${targetRoot}.${component} = ${sourceProperty}[ ${i2} ]`,
          this
        );
      }
      if (output2 !== "void") {
        snippet = target;
      }
    } else {
      snippet = `${target} = ${source}`;
      if (output2 === "void" || sourceType === "void") {
        builder.addLineFlowCode(snippet, this);
        if (output2 !== "void") {
          snippet = target;
        }
      }
    }
    nodeData.initialized = true;
    return builder.format(snippet, targetType, output2);
  }
}
const assign = /* @__PURE__ */ nodeProxy(AssignNode).setParameterLength(2);
addMethodChaining("assign", assign);
class FunctionCallNode extends TempNode {
  static get type() {
    return "FunctionCallNode";
  }
  /**
   * Constructs a new function call node.
   *
   * @param {?FunctionNode} functionNode - The function node.
   * @param {Object<string, Node>} [parameters={}] - The parameters for the function call.
   */
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  /**
   * Sets the parameters of the function call node.
   *
   * @param {Object<string, Node>} parameters - The parameters to set.
   * @return {FunctionCallNode} A reference to this node.
   */
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  /**
   * Returns the parameters of the function call node.
   *
   * @return {Object<string, Node>} The parameters of this node.
   */
  getParameters() {
    return this.parameters;
  }
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    const generateInput = (node, inputNode) => {
      const type = inputNode.type;
      const pointer = type === "pointer";
      let output2;
      if (pointer) output2 = "&" + node.build(builder);
      else output2 = node.build(builder, type);
      return output2;
    };
    if (Array.isArray(parameters)) {
      if (parameters.length > inputs.length) {
        console.error(
          "THREE.TSL: The number of provided parameters exceeds the expected number of inputs in 'Fn()'."
        );
        parameters.length = inputs.length;
      } else if (parameters.length < inputs.length) {
        console.error(
          "THREE.TSL: The number of provided parameters is less than the expected number of inputs in 'Fn()'."
        );
        while (parameters.length < inputs.length) {
          parameters.push(float(0));
        }
      }
      for (let i2 = 0; i2 < parameters.length; i2++) {
        params.push(generateInput(parameters[i2], inputs[i2]));
      }
    } else {
      for (const inputNode of inputs) {
        const node = parameters[inputNode.name];
        if (node !== void 0) {
          params.push(generateInput(node, inputNode));
        } else {
          console.error(
            `THREE.TSL: Input '${inputNode.name}' not found in 'Fn()'.`
          );
          params.push(generateInput(float(0), inputNode));
        }
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
}
const call = (func, ...params) => {
  params =
    params.length > 1 || (params[0] && params[0].isNode === true)
      ? nodeArray(params)
      : nodeObjects(params[0]);
  return nodeObject(new FunctionCallNode(nodeObject(func), params));
};
addMethodChaining("call", call);
const _vectorOperators = {
  "==": "equal",
  "!=": "notEqual",
  "<": "lessThan",
  ">": "greaterThan",
  "<=": "lessThanEqual",
  ">=": "greaterThanEqual",
  "%": "mod",
};
class OperatorNode extends TempNode {
  static get type() {
    return "OperatorNode";
  }
  /**
   * Constructs a new operator node.
   *
   * @param {string} op - The operator.
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @param {...Node} params - Additional input parameters.
   */
  constructor(op, aNode, bNode, ...params) {
    super();
    if (params.length > 0) {
      let finalOp = new OperatorNode(op, aNode, bNode);
      for (let i2 = 0; i2 < params.length - 1; i2++) {
        finalOp = new OperatorNode(op, finalOp, params[i2]);
      }
      aNode = finalOp;
      bNode = params[params.length - 1];
    }
    this.op = op;
    this.aNode = aNode;
    this.bNode = bNode;
    this.isOperatorNode = true;
  }
  /**
   * Returns the operator method name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The output type.
   * @returns {string} The operator method name.
   */
  getOperatorMethod(builder, output2) {
    return builder.getMethod(_vectorOperators[this.op], output2);
  }
  /**
   * This method is overwritten since the node type is inferred from the operator
   * and the input node types.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode ? bNode.getNodeType(builder) : null;
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "%") {
      return typeA;
    } else if (
      op === "~" ||
      op === "&" ||
      op === "|" ||
      op === "^" ||
      op === ">>" ||
      op === "<<"
    ) {
      return builder.getIntegerType(typeA);
    } else if (op === "!" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (
      op === "==" ||
      op === "!=" ||
      op === "<" ||
      op === ">" ||
      op === "<=" ||
      op === ">="
    ) {
      const typeLength = Math.max(
        builder.getTypeLength(typeA),
        builder.getTypeLength(typeB)
      );
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (builder.isMatrix(typeA)) {
        if (typeB === "float") {
          return typeA;
        } else if (builder.isVector(typeB)) {
          return builder.getVectorFromMatrix(typeA);
        } else if (builder.isMatrix(typeB)) {
          return typeA;
        }
      } else if (builder.isMatrix(typeB)) {
        if (typeA === "float") {
          return typeB;
        } else if (builder.isVector(typeA)) {
          return builder.getVectorFromMatrix(typeB);
        }
      }
      if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output2) {
    const op = this.op;
    const { aNode, bNode } = this;
    const type = this.getNodeType(builder);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode ? bNode.getNodeType(builder) : null;
      if (
        op === "<" ||
        op === ">" ||
        op === "<=" ||
        op === ">=" ||
        op === "==" ||
        op === "!="
      ) {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else if (builder.isVector(typeB)) {
          typeA = typeB;
        } else if (typeA !== typeB) {
          typeA = typeB = "float";
        }
      } else if (op === ">>" || op === "<<") {
        typeA = type;
        typeB = builder.changeComponentType(typeB, "uint");
      } else if (op === "%") {
        typeA = type;
        typeB =
          builder.isInteger(typeA) && builder.isInteger(typeB) ? typeB : typeA;
      } else if (builder.isMatrix(typeA)) {
        if (typeB === "float") {
          typeB = "float";
        } else if (builder.isVector(typeB)) {
          typeB = builder.getVectorFromMatrix(typeA);
        } else if (builder.isMatrix(typeB));
        else {
          typeA = typeB = type;
        }
      } else if (builder.isMatrix(typeB)) {
        if (typeA === "float") {
          typeA = "float";
        } else if (builder.isVector(typeA)) {
          typeA = builder.getVectorFromMatrix(typeB);
        } else {
          typeA = typeB = type;
        }
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a2 = aNode.build(builder, typeA);
    const b = bNode ? bNode.build(builder, typeB) : null;
    const fnOpSnippet = builder.getFunctionOperator(op);
    if (output2 !== "void") {
      const isGLSL =
        builder.renderer.coordinateSystem === WebGLCoordinateSystem;
      if (
        op === "==" ||
        op === "!=" ||
        op === "<" ||
        op === ">" ||
        op === "<=" ||
        op === ">="
      ) {
        if (isGLSL) {
          if (builder.isVector(typeA)) {
            return builder.format(
              `${this.getOperatorMethod(builder, output2)}( ${a2}, ${b} )`,
              type,
              output2
            );
          } else {
            return builder.format(`( ${a2} ${op} ${b} )`, type, output2);
          }
        } else {
          return builder.format(`( ${a2} ${op} ${b} )`, type, output2);
        }
      } else if (op === "%") {
        if (builder.isInteger(typeB)) {
          return builder.format(`( ${a2} % ${b} )`, type, output2);
        } else {
          return builder.format(
            `${this.getOperatorMethod(builder, type)}( ${a2}, ${b} )`,
            type,
            output2
          );
        }
      } else if (op === "!" || op === "~") {
        return builder.format(`(${op}${a2})`, typeA, output2);
      } else if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a2}, ${b} )`, type, output2);
      } else {
        if (builder.isMatrix(typeA) && typeB === "float") {
          return builder.format(`( ${b} ${op} ${a2} )`, type, output2);
        } else if (typeA === "float" && builder.isMatrix(typeB)) {
          return builder.format(`${a2} ${op} ${b}`, type, output2);
        } else {
          let snippet = `( ${a2} ${op} ${b} )`;
          if (
            !isGLSL &&
            type === "bool" &&
            builder.isVector(typeA) &&
            builder.isVector(typeB)
          ) {
            snippet = `all${snippet}`;
          }
          return builder.format(snippet, type, output2);
        }
      }
    } else if (typeA !== "void") {
      if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a2}, ${b} )`, type, output2);
      } else {
        if (builder.isMatrix(typeA) && typeB === "float") {
          return builder.format(`${b} ${op} ${a2}`, type, output2);
        } else {
          return builder.format(`${a2} ${op} ${b}`, type, output2);
        }
      }
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
}
const add = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "+")
  .setParameterLength(2, Infinity)
  .setName("add");
const sub = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "-")
  .setParameterLength(2, Infinity)
  .setName("sub");
const mul = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "*")
  .setParameterLength(2, Infinity)
  .setName("mul");
const div = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "/")
  .setParameterLength(2, Infinity)
  .setName("div");
const mod = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "%")
  .setParameterLength(2)
  .setName("mod");
const equal = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "==")
  .setParameterLength(2)
  .setName("equal");
const notEqual = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "!=")
  .setParameterLength(2)
  .setName("notEqual");
const lessThan = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "<")
  .setParameterLength(2)
  .setName("lessThan");
const greaterThan = /* @__PURE__ */ nodeProxyIntent(OperatorNode, ">")
  .setParameterLength(2)
  .setName("greaterThan");
const lessThanEqual = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "<=")
  .setParameterLength(2)
  .setName("lessThanEqual");
const greaterThanEqual = /* @__PURE__ */ nodeProxyIntent(OperatorNode, ">=")
  .setParameterLength(2)
  .setName("greaterThanEqual");
const and = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "&&")
  .setParameterLength(2, Infinity)
  .setName("and");
const or = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "||")
  .setParameterLength(2, Infinity)
  .setName("or");
const not = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "!")
  .setParameterLength(1)
  .setName("not");
const xor = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "^^")
  .setParameterLength(2)
  .setName("xor");
const bitAnd = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "&")
  .setParameterLength(2)
  .setName("bitAnd");
const bitNot = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "~")
  .setParameterLength(2)
  .setName("bitNot");
const bitOr = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "|")
  .setParameterLength(2)
  .setName("bitOr");
const bitXor = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "^")
  .setParameterLength(2)
  .setName("bitXor");
const shiftLeft = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "<<")
  .setParameterLength(2)
  .setName("shiftLeft");
const shiftRight = /* @__PURE__ */ nodeProxyIntent(OperatorNode, ">>")
  .setParameterLength(2)
  .setName("shiftRight");
const incrementBefore = Fn(([a2]) => {
  a2.addAssign(1);
  return a2;
});
const decrementBefore = Fn(([a2]) => {
  a2.subAssign(1);
  return a2;
});
const increment = /* @__PURE__ */ Fn(([a2]) => {
  const temp2 = int(a2).toConst();
  a2.addAssign(1);
  return temp2;
});
const decrement = /* @__PURE__ */ Fn(([a2]) => {
  const temp2 = int(a2).toConst();
  a2.subAssign(1);
  return temp2;
});
addMethodChaining("add", add);
addMethodChaining("sub", sub);
addMethodChaining("mul", mul);
addMethodChaining("div", div);
addMethodChaining("mod", mod);
addMethodChaining("equal", equal);
addMethodChaining("notEqual", notEqual);
addMethodChaining("lessThan", lessThan);
addMethodChaining("greaterThan", greaterThan);
addMethodChaining("lessThanEqual", lessThanEqual);
addMethodChaining("greaterThanEqual", greaterThanEqual);
addMethodChaining("and", and);
addMethodChaining("or", or);
addMethodChaining("not", not);
addMethodChaining("xor", xor);
addMethodChaining("bitAnd", bitAnd);
addMethodChaining("bitNot", bitNot);
addMethodChaining("bitOr", bitOr);
addMethodChaining("bitXor", bitXor);
addMethodChaining("shiftLeft", shiftLeft);
addMethodChaining("shiftRight", shiftRight);
addMethodChaining("incrementBefore", incrementBefore);
addMethodChaining("decrementBefore", decrementBefore);
addMethodChaining("increment", increment);
addMethodChaining("decrement", decrement);
const modInt = (a2, b) => {
  console.warn(
    'THREE.TSL: "modInt()" is deprecated. Use "mod( int( ... ) )" instead.'
  );
  return mod(int(a2), int(b));
};
addMethodChaining("modInt", modInt);
class MathNode extends TempNode {
  static get type() {
    return "MathNode";
  }
  /**
   * Constructs a new math node.
   *
   * @param {string} method - The method name.
   * @param {Node} aNode - The first input.
   * @param {?Node} [bNode=null] - The second input.
   * @param {?Node} [cNode=null] - The third input.
   */
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    if (
      (method === MathNode.MAX || method === MathNode.MIN) &&
      arguments.length > 3
    ) {
      let finalOp = new MathNode(method, aNode, bNode);
      for (let i2 = 2; i2 < arguments.length - 1; i2++) {
        finalOp = new MathNode(method, finalOp, arguments[i2]);
      }
      aNode = finalOp;
      bNode = arguments[arguments.length - 1];
      cNode = null;
    }
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
    this.isMathNode = true;
  }
  /**
   * The input type is inferred from the node types of the input nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  /**
   * The selected method as well as the input type determine the node type of this node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const method = this.method;
    if (
      method === MathNode.LENGTH ||
      method === MathNode.DISTANCE ||
      method === MathNode.DOT
    ) {
      return "float";
    } else if (method === MathNode.CROSS) {
      return "vec3";
    } else if (method === MathNode.ALL || method === MathNode.ANY) {
      return "bool";
    } else if (method === MathNode.EQUALS) {
      return builder.changeComponentType(
        this.aNode.getNodeType(builder),
        "bool"
      );
    } else {
      return this.getInputType(builder);
    }
  }
  setup(builder) {
    const { aNode, bNode, method } = this;
    let outputNode = null;
    if (method === MathNode.ONE_MINUS) {
      outputNode = sub(1, aNode);
    } else if (method === MathNode.RECIPROCAL) {
      outputNode = div(1, aNode);
    } else if (method === MathNode.DIFFERENCE) {
      outputNode = abs(sub(aNode, bNode));
    } else if (method === MathNode.TRANSFORM_DIRECTION) {
      let tA = aNode;
      let tB = bNode;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = vec4(vec3(tB), 0);
      } else {
        tA = vec4(vec3(tA), 0);
      }
      const mulNode = mul(tA, tB).xyz;
      outputNode = normalize(mulNode);
    }
    if (outputNode !== null) {
      return outputNode;
    } else {
      return super.setup(builder);
    }
  }
  generate(builder, output2) {
    const properties = builder.getNodeProperties(this);
    if (properties.outputNode) {
      return super.generate(builder, output2);
    }
    let method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a2 = this.aNode;
    const b = this.bNode;
    const c2 = this.cNode;
    const coordinateSystem = builder.renderer.coordinateSystem;
    if (method === MathNode.NEGATE) {
      return builder.format(
        "( - " + a2.build(builder, inputType) + " )",
        type,
        output2
      );
    } else {
      const params = [];
      if (method === MathNode.CROSS) {
        params.push(a2.build(builder, type), b.build(builder, type));
      } else if (
        coordinateSystem === WebGLCoordinateSystem &&
        method === MathNode.STEP
      ) {
        params.push(
          a2.build(
            builder,
            builder.getTypeLength(a2.getNodeType(builder)) === 1
              ? "float"
              : inputType
          ),
          b.build(builder, inputType)
        );
      } else if (
        coordinateSystem === WebGLCoordinateSystem &&
        (method === MathNode.MIN || method === MathNode.MAX)
      ) {
        params.push(
          a2.build(builder, inputType),
          b.build(
            builder,
            builder.getTypeLength(b.getNodeType(builder)) === 1
              ? "float"
              : inputType
          )
        );
      } else if (method === MathNode.REFRACT) {
        params.push(
          a2.build(builder, inputType),
          b.build(builder, inputType),
          c2.build(builder, "float")
        );
      } else if (method === MathNode.MIX) {
        params.push(
          a2.build(builder, inputType),
          b.build(builder, inputType),
          c2.build(
            builder,
            builder.getTypeLength(c2.getNodeType(builder)) === 1
              ? "float"
              : inputType
          )
        );
      } else {
        if (
          coordinateSystem === WebGPUCoordinateSystem &&
          method === MathNode.ATAN &&
          b !== null
        ) {
          method = "atan2";
        }
        if (
          builder.shaderStage !== "fragment" &&
          (method === MathNode.DFDX || method === MathNode.DFDY)
        ) {
          console.warn(
            `THREE.TSL: '${method}' is not supported in the ${builder.shaderStage} stage.`
          );
          method = "/*" + method + "*/";
        }
        params.push(a2.build(builder, inputType));
        if (b !== null) params.push(b.build(builder, inputType));
        if (c2 !== null) params.push(c2.build(builder, inputType));
      }
      return builder.format(
        `${builder.getMethod(method, type)}( ${params.join(", ")} )`,
        type,
        output2
      );
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
}
MathNode.ALL = "all";
MathNode.ANY = "any";
MathNode.RADIANS = "radians";
MathNode.DEGREES = "degrees";
MathNode.EXP = "exp";
MathNode.EXP2 = "exp2";
MathNode.LOG = "log";
MathNode.LOG2 = "log2";
MathNode.SQRT = "sqrt";
MathNode.INVERSE_SQRT = "inversesqrt";
MathNode.FLOOR = "floor";
MathNode.CEIL = "ceil";
MathNode.NORMALIZE = "normalize";
MathNode.FRACT = "fract";
MathNode.SIN = "sin";
MathNode.COS = "cos";
MathNode.TAN = "tan";
MathNode.ASIN = "asin";
MathNode.ACOS = "acos";
MathNode.ATAN = "atan";
MathNode.ABS = "abs";
MathNode.SIGN = "sign";
MathNode.LENGTH = "length";
MathNode.NEGATE = "negate";
MathNode.ONE_MINUS = "oneMinus";
MathNode.DFDX = "dFdx";
MathNode.DFDY = "dFdy";
MathNode.ROUND = "round";
MathNode.RECIPROCAL = "reciprocal";
MathNode.TRUNC = "trunc";
MathNode.FWIDTH = "fwidth";
MathNode.TRANSPOSE = "transpose";
MathNode.DETERMINANT = "determinant";
MathNode.INVERSE = "inverse";
MathNode.BITCAST = "bitcast";
MathNode.EQUALS = "equals";
MathNode.MIN = "min";
MathNode.MAX = "max";
MathNode.STEP = "step";
MathNode.REFLECT = "reflect";
MathNode.DISTANCE = "distance";
MathNode.DIFFERENCE = "difference";
MathNode.DOT = "dot";
MathNode.CROSS = "cross";
MathNode.POW = "pow";
MathNode.TRANSFORM_DIRECTION = "transformDirection";
MathNode.MIX = "mix";
MathNode.CLAMP = "clamp";
MathNode.REFRACT = "refract";
MathNode.SMOOTHSTEP = "smoothstep";
MathNode.FACEFORWARD = "faceforward";
const EPSILON = /* @__PURE__ */ float(1e-6);
const INFINITY = /* @__PURE__ */ float(1e6);
const PI = /* @__PURE__ */ float(Math.PI);
const PI2 = /* @__PURE__ */ float(Math.PI * 2);
const all = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.ALL
).setParameterLength(1);
const any = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.ANY
).setParameterLength(1);
const radians = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.RADIANS
).setParameterLength(1);
const degrees = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.DEGREES
).setParameterLength(1);
const exp = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.EXP
).setParameterLength(1);
const exp2 = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.EXP2
).setParameterLength(1);
const log = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.LOG
).setParameterLength(1);
const log2 = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.LOG2
).setParameterLength(1);
const sqrt = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.SQRT
).setParameterLength(1);
const inverseSqrt = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.INVERSE_SQRT
).setParameterLength(1);
const floor = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.FLOOR
).setParameterLength(1);
const ceil = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.CEIL
).setParameterLength(1);
const normalize = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.NORMALIZE
).setParameterLength(1);
const fract = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.FRACT
).setParameterLength(1);
const sin = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.SIN
).setParameterLength(1);
const cos = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.COS
).setParameterLength(1);
const tan = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.TAN
).setParameterLength(1);
const asin = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.ASIN
).setParameterLength(1);
const acos = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.ACOS
).setParameterLength(1);
const atan = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.ATAN
).setParameterLength(1, 2);
const abs = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.ABS
).setParameterLength(1);
const sign = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.SIGN
).setParameterLength(1);
const length = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.LENGTH
).setParameterLength(1);
const negate = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.NEGATE
).setParameterLength(1);
const oneMinus = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.ONE_MINUS
).setParameterLength(1);
const dFdx = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.DFDX
).setParameterLength(1);
const dFdy = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.DFDY
).setParameterLength(1);
const round = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.ROUND
).setParameterLength(1);
const reciprocal = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.RECIPROCAL
).setParameterLength(1);
const trunc = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.TRUNC
).setParameterLength(1);
const fwidth = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.FWIDTH
).setParameterLength(1);
const transpose = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.TRANSPOSE
).setParameterLength(1);
const determinant = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.DETERMINANT
).setParameterLength(1);
const inverse = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.INVERSE
).setParameterLength(1);
const bitcast = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.BITCAST
).setParameterLength(2);
const equals = (x, y) => {
  console.warn(
    'THREE.TSL: "equals" is deprecated. Use "equal" inside a vector instead, like: "bvec*( equal( ... ) )"'
  );
  return equal(x, y);
};
const min$1 = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.MIN
).setParameterLength(2, Infinity);
const max$1 = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.MAX
).setParameterLength(2, Infinity);
const step = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.STEP
).setParameterLength(2);
const reflect = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.REFLECT
).setParameterLength(2);
const distance = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.DISTANCE
).setParameterLength(2);
const difference = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.DIFFERENCE
).setParameterLength(2);
const dot = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.DOT
).setParameterLength(2);
const cross = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.CROSS
).setParameterLength(2);
const pow = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.POW
).setParameterLength(2);
const pow2 = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.POW,
  2
).setParameterLength(1);
const pow3 = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.POW,
  3
).setParameterLength(1);
const pow4 = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.POW,
  4
).setParameterLength(1);
const transformDirection = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.TRANSFORM_DIRECTION
).setParameterLength(2);
const cbrt = (a2) => mul(sign(a2), pow(abs(a2), 1 / 3));
const lengthSq = (a2) => dot(a2, a2);
const mix$1 = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.MIX
).setParameterLength(3);
const clamp = (value, low = 0, high = 1) =>
  nodeObject(
    new MathNode(
      MathNode.CLAMP,
      nodeObject(value),
      nodeObject(low),
      nodeObject(high)
    )
  );
const saturate = (value) => clamp(value);
const refract = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.REFRACT
).setParameterLength(3);
const smoothstep = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.SMOOTHSTEP
).setParameterLength(3);
const faceForward = /* @__PURE__ */ nodeProxyIntent(
  MathNode,
  MathNode.FACEFORWARD
).setParameterLength(3);
const rand = /* @__PURE__ */ Fn(([uv2]) => {
  const a2 = 12.9898,
    b = 78.233,
    c2 = 43758.5453;
  const dt = dot(uv2.xy, vec2(a2, b)),
    sn = mod(dt, PI);
  return fract(sin(sn).mul(c2));
});
const mixElement = (t2, e1, e2) => mix$1(e1, e2, t2);
const smoothstepElement = (x, low, high) => smoothstep(low, high, x);
const stepElement = (x, edge) => step(edge, x);
const atan2 = (y, x) => {
  console.warn('THREE.TSL: "atan2" is overloaded. Use "atan" instead.');
  return atan(y, x);
};
const faceforward = faceForward;
const inversesqrt = inverseSqrt;
addMethodChaining("all", all);
addMethodChaining("any", any);
addMethodChaining("equals", equals);
addMethodChaining("radians", radians);
addMethodChaining("degrees", degrees);
addMethodChaining("exp", exp);
addMethodChaining("exp2", exp2);
addMethodChaining("log", log);
addMethodChaining("log2", log2);
addMethodChaining("sqrt", sqrt);
addMethodChaining("inverseSqrt", inverseSqrt);
addMethodChaining("floor", floor);
addMethodChaining("ceil", ceil);
addMethodChaining("normalize", normalize);
addMethodChaining("fract", fract);
addMethodChaining("sin", sin);
addMethodChaining("cos", cos);
addMethodChaining("tan", tan);
addMethodChaining("asin", asin);
addMethodChaining("acos", acos);
addMethodChaining("atan", atan);
addMethodChaining("abs", abs);
addMethodChaining("sign", sign);
addMethodChaining("length", length);
addMethodChaining("lengthSq", lengthSq);
addMethodChaining("negate", negate);
addMethodChaining("oneMinus", oneMinus);
addMethodChaining("dFdx", dFdx);
addMethodChaining("dFdy", dFdy);
addMethodChaining("round", round);
addMethodChaining("reciprocal", reciprocal);
addMethodChaining("trunc", trunc);
addMethodChaining("fwidth", fwidth);
addMethodChaining("atan2", atan2);
addMethodChaining("min", min$1);
addMethodChaining("max", max$1);
addMethodChaining("step", stepElement);
addMethodChaining("reflect", reflect);
addMethodChaining("distance", distance);
addMethodChaining("dot", dot);
addMethodChaining("cross", cross);
addMethodChaining("pow", pow);
addMethodChaining("pow2", pow2);
addMethodChaining("pow3", pow3);
addMethodChaining("pow4", pow4);
addMethodChaining("transformDirection", transformDirection);
addMethodChaining("mix", mixElement);
addMethodChaining("clamp", clamp);
addMethodChaining("refract", refract);
addMethodChaining("smoothstep", smoothstepElement);
addMethodChaining("faceForward", faceForward);
addMethodChaining("difference", difference);
addMethodChaining("saturate", saturate);
addMethodChaining("cbrt", cbrt);
addMethodChaining("transpose", transpose);
addMethodChaining("determinant", determinant);
addMethodChaining("inverse", inverse);
addMethodChaining("rand", rand);
class ConditionalNode extends Node {
  static get type() {
    return "ConditionalNode";
  }
  /**
   * Constructs a new conditional node.
   *
   * @param {Node} condNode - The node that defines the condition.
   * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
   * @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
   */
  constructor(condNode, ifNode, elseNode = null) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  /**
   * This method is overwritten since the node type is inferred from the if/else
   * nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const { ifNode, elseNode } = builder.getNodeProperties(this);
    if (ifNode === void 0) {
      builder.flowBuildStage(this, "setup");
      return this.getNodeType(builder);
    }
    const ifType = ifNode.getNodeType(builder);
    if (elseNode !== null) {
      const elseType = elseNode.getNodeType(builder);
      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
        return elseType;
      }
    }
    return ifType;
  }
  setup(builder) {
    const condNode = this.condNode.cache();
    const ifNode = this.ifNode.cache();
    const elseNode = this.elseNode ? this.elseNode.cache() : null;
    const currentNodeBlock = builder.context.nodeBlock;
    builder.getDataFromNode(ifNode).parentNodeBlock = currentNodeBlock;
    if (elseNode !== null)
      builder.getDataFromNode(elseNode).parentNodeBlock = currentNodeBlock;
    const properties = builder.getNodeProperties(this);
    properties.condNode = condNode;
    properties.ifNode = ifNode.context({ nodeBlock: ifNode });
    properties.elseNode = elseNode
      ? elseNode.context({ nodeBlock: elseNode })
      : null;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const nodeData = builder.getDataFromNode(this);
    if (nodeData.nodeProperty !== void 0) {
      return nodeData.nodeProperty;
    }
    const { condNode, ifNode, elseNode } = builder.getNodeProperties(this);
    const functionNode = builder.currentFunctionNode;
    const needsOutput = output2 !== "void";
    const nodeProperty = needsOutput ? property(type).build(builder) : "";
    nodeData.nodeProperty = nodeProperty;
    const nodeSnippet = condNode.build(builder, "bool");
    builder
      .addFlowCode(
        `
${builder.tab}if ( ${nodeSnippet} ) {

`
      )
      .addFlowTab();
    let ifSnippet = ifNode.build(builder, type);
    if (ifSnippet) {
      if (needsOutput) {
        ifSnippet = nodeProperty + " = " + ifSnippet + ";";
      } else {
        ifSnippet = "return " + ifSnippet + ";";
        if (functionNode === null) {
          console.warn(
            "THREE.TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values."
          );
          ifSnippet = "// " + ifSnippet;
        }
      }
    }
    builder
      .removeFlowTab()
      .addFlowCode(builder.tab + "	" + ifSnippet + "\n\n" + builder.tab + "}");
    if (elseNode !== null) {
      builder.addFlowCode(" else {\n\n").addFlowTab();
      let elseSnippet = elseNode.build(builder, type);
      if (elseSnippet) {
        if (needsOutput) {
          elseSnippet = nodeProperty + " = " + elseSnippet + ";";
        } else {
          elseSnippet = "return " + elseSnippet + ";";
          if (functionNode === null) {
            console.warn(
              "THREE.TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values."
            );
            elseSnippet = "// " + elseSnippet;
          }
        }
      }
      builder
        .removeFlowTab()
        .addFlowCode(
          builder.tab + "	" + elseSnippet + "\n\n" + builder.tab + "}\n\n"
        );
    } else {
      builder.addFlowCode("\n\n");
    }
    return builder.format(nodeProperty, type, output2);
  }
}
const select = /* @__PURE__ */ nodeProxy(ConditionalNode).setParameterLength(
  2,
  3
);
addMethodChaining("select", select);
class ContextNode extends Node {
  static get type() {
    return "ContextNode";
  }
  /**
   * Constructs a new context node.
   *
   * @param {Node} node - The node whose context should be modified.
   * @param {Object} [value={}] - The modified context data.
   */
  constructor(node, value = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.value = value;
  }
  /**
   * This method is overwritten to ensure it returns the reference to {@link ContextNode#node}.
   *
   * @return {Node} A reference to {@link ContextNode#node}.
   */
  getScope() {
    return this.node.getScope();
  }
  /**
   * This method is overwritten to ensure it returns the type of {@link ContextNode#node}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  analyze(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.value });
    this.node.build(builder);
    builder.setContext(previousContext);
  }
  setup(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.value });
    this.node.build(builder);
    builder.setContext(previousContext);
  }
  generate(builder, output2) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.value });
    const snippet = this.node.build(builder, output2);
    builder.setContext(previousContext);
    return snippet;
  }
}
const context = /* @__PURE__ */ nodeProxy(ContextNode).setParameterLength(1, 2);
const setName = (node, name) => context(node, { nodeName: name });
function label(node, name) {
  console.warn(
    'THREE.TSL: "label()" has been deprecated. Use "setName()" instead.'
  );
  return setName(node, name);
}
addMethodChaining("context", context);
addMethodChaining("label", label);
addMethodChaining("setName", setName);
class VarNode extends Node {
  static get type() {
    return "VarNode";
  }
  /**
   * Constructs a new variable node.
   *
   * @param {Node} node - The node for which a variable should be created.
   * @param {?string} [name=null] - The name of the variable in the shader.
   * @param {boolean} [readOnly=false] - The read-only flag.
   */
  constructor(node, name = null, readOnly = false) {
    super();
    this.node = node;
    this.name = name;
    this.global = true;
    this.isVarNode = true;
    this.readOnly = readOnly;
    this.parents = true;
    this.intent = false;
  }
  /**
   * Sets the intent flag for this node.
   *
   * This flag is used to indicate that this node is used for intent
   * and should not be built directly. Instead, it is used to indicate that
   * the node should be treated as a variable intent.
   *
   * It's useful for assigning variables without needing creating a new variable node.
   *
   * @param {boolean} value - The value to set for the intent flag.
   * @returns {VarNode} This node.
   */
  setIntent(value) {
    this.intent = value;
    return this;
  }
  /**
   * Returns the intent flag of this node.
   *
   * @return {boolean} The intent flag.
   */
  getIntent() {
    return this.intent;
  }
  getMemberType(builder, name) {
    return this.node.getMemberType(builder, name);
  }
  getElementType(builder) {
    return this.node.getElementType(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  getArrayCount(builder) {
    return this.node.getArrayCount(builder);
  }
  build(...params) {
    if (this.intent === true) {
      const builder = params[0];
      const properties = builder.getNodeProperties(this);
      if (properties.assign !== true) {
        return this.node.build(...params);
      }
    }
    return super.build(...params);
  }
  generate(builder) {
    const { node, name, readOnly } = this;
    const { renderer: renderer2 } = builder;
    const isWebGPUBackend = renderer2.backend.isWebGPUBackend === true;
    let isDeterministic = false;
    let shouldTreatAsReadOnly = false;
    if (readOnly) {
      isDeterministic = builder.isDeterministic(node);
      shouldTreatAsReadOnly = isWebGPUBackend ? readOnly : isDeterministic;
    }
    const vectorType = builder.getVectorType(this.getNodeType(builder));
    const snippet = node.build(builder, vectorType);
    const nodeVar = builder.getVarFromNode(
      this,
      name,
      vectorType,
      void 0,
      shouldTreatAsReadOnly
    );
    const propertyName = builder.getPropertyName(nodeVar);
    let declarationPrefix = propertyName;
    if (shouldTreatAsReadOnly) {
      if (isWebGPUBackend) {
        declarationPrefix = isDeterministic
          ? `const ${propertyName}`
          : `let ${propertyName}`;
      } else {
        const count = node.getArrayCount(builder);
        declarationPrefix = `const ${builder.getVar(
          nodeVar.type,
          propertyName,
          count
        )}`;
      }
    }
    builder.addLineFlowCode(`${declarationPrefix} = ${snippet}`, this);
    return propertyName;
  }
}
const createVar = /* @__PURE__ */ nodeProxy(VarNode);
const Var = (node, name = null) => createVar(node, name).toStack();
const Const = (node, name = null) => createVar(node, name, true).toStack();
const VarIntent = (node) => {
  if (getCurrentStack() === null) {
    return node;
  }
  return createVar(node).setIntent(true).toStack();
};
addMethodChaining("toVar", Var);
addMethodChaining("toConst", Const);
addMethodChaining("toVarIntent", VarIntent);
const temp = (node) => {
  console.warn(
    'TSL: "temp( node )" is deprecated. Use "Var( node )" or "node.toVar()" instead.'
  );
  return createVar(node);
};
addMethodChaining("temp", temp);
class SubBuildNode extends Node {
  static get type() {
    return "SubBuild";
  }
  constructor(node, name, nodeType = null) {
    super(nodeType);
    this.node = node;
    this.name = name;
    this.isSubBuildNode = true;
  }
  getNodeType(builder) {
    if (this.nodeType !== null) return this.nodeType;
    builder.addSubBuild(this.name);
    const nodeType = this.node.getNodeType(builder);
    builder.removeSubBuild();
    return nodeType;
  }
  build(builder, ...params) {
    builder.addSubBuild(this.name);
    const data = this.node.build(builder, ...params);
    builder.removeSubBuild();
    return data;
  }
}
const subBuild = (node, name, type = null) =>
  nodeObject(new SubBuildNode(nodeObject(node), name, type));
class VaryingNode extends Node {
  static get type() {
    return "VaryingNode";
  }
  /**
   * Constructs a new varying node.
   *
   * @param {Node} node - The node for which a varying should be created.
   * @param {?string} name - The name of the varying in the shader.
   */
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
    this.isVaryingNode = true;
    this.interpolationType = null;
    this.interpolationSampling = null;
    this.global = true;
  }
  /**
   * Defines the interpolation type of the varying.
   *
   * @param {string} type - The interpolation type.
   * @param {?string} sampling - The interpolation sampling type
   * @return {VaryingNode} A reference to this node.
   */
  setInterpolation(type, sampling = null) {
    this.interpolationType = type;
    this.interpolationSampling = sampling;
    return this;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  /**
   * This method performs the setup of a varying node with the current node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeVarying} The node varying from the node builder.
   */
  setupVarying(builder) {
    const properties = builder.getNodeProperties(this);
    let varying2 = properties.varying;
    if (varying2 === void 0) {
      const name = this.name;
      const type = this.getNodeType(builder);
      const interpolationType = this.interpolationType;
      const interpolationSampling = this.interpolationSampling;
      properties.varying = varying2 = builder.getVaryingFromNode(
        this,
        name,
        type,
        interpolationType,
        interpolationSampling
      );
      properties.node = subBuild(this.node, "VERTEX");
    }
    varying2.needsInterpolation ||
      (varying2.needsInterpolation = builder.shaderStage === "fragment");
    return varying2;
  }
  setup(builder) {
    this.setupVarying(builder);
    builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node);
  }
  analyze(builder) {
    this.setupVarying(builder);
    builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node);
  }
  generate(builder) {
    const propertyKey = builder.getSubBuildProperty(
      "property",
      builder.currentStack
    );
    const properties = builder.getNodeProperties(this);
    const varying2 = this.setupVarying(builder);
    if (properties[propertyKey] === void 0) {
      const type = this.getNodeType(builder);
      const propertyName = builder.getPropertyName(
        varying2,
        NodeShaderStage.VERTEX
      );
      builder.flowNodeFromShaderStage(
        NodeShaderStage.VERTEX,
        properties.node,
        type,
        propertyName
      );
      properties[propertyKey] = propertyName;
    }
    return builder.getPropertyName(varying2);
  }
}
const varying = /* @__PURE__ */ nodeProxy(VaryingNode).setParameterLength(1, 2);
const vertexStage = (node) => varying(node);
addMethodChaining("toVarying", varying);
addMethodChaining("toVertexStage", vertexStage);
addMethodChaining("varying", (...params) => {
  console.warn("THREE.TSL: .varying() has been renamed to .toVarying().");
  return varying(...params);
});
addMethodChaining("vertexStage", (...params) => {
  console.warn(
    "THREE.TSL: .vertexStage() has been renamed to .toVertexStage()."
  );
  return varying(...params);
});
const sRGBTransferEOTF = /* @__PURE__ */ Fn(([color2]) => {
  const a2 = color2.mul(0.9478672986).add(0.0521327014).pow(2.4);
  const b = color2.mul(0.0773993808);
  const factor = color2.lessThanEqual(0.04045);
  const rgbResult = mix$1(a2, b, factor);
  return rgbResult;
}).setLayout({
  name: "sRGBTransferEOTF",
  type: "vec3",
  inputs: [{ name: "color", type: "vec3" }],
});
const sRGBTransferOETF = /* @__PURE__ */ Fn(([color2]) => {
  const a2 = color2.pow(0.41666).mul(1.055).sub(0.055);
  const b = color2.mul(12.92);
  const factor = color2.lessThanEqual(31308e-7);
  const rgbResult = mix$1(a2, b, factor);
  return rgbResult;
}).setLayout({
  name: "sRGBTransferOETF",
  type: "vec3",
  inputs: [{ name: "color", type: "vec3" }],
});
const WORKING_COLOR_SPACE = "WorkingColorSpace";
const OUTPUT_COLOR_SPACE = "OutputColorSpace";
class ColorSpaceNode extends TempNode {
  static get type() {
    return "ColorSpaceNode";
  }
  /**
   * Constructs a new color space node.
   *
   * @param {Node} colorNode - Represents the color to convert.
   * @param {string} source - The source color space.
   * @param {string} target - The target color space.
   */
  constructor(colorNode, source, target) {
    super("vec4");
    this.colorNode = colorNode;
    this.source = source;
    this.target = target;
  }
  /**
   * This method resolves the constants `WORKING_COLOR_SPACE` and
   * `OUTPUT_COLOR_SPACE` based on the current configuration of the
   * color management and renderer.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} colorSpace - The color space to resolve.
   * @return {string} The resolved color space.
   */
  resolveColorSpace(builder, colorSpace) {
    if (colorSpace === WORKING_COLOR_SPACE) {
      return ColorManagement.workingColorSpace;
    } else if (colorSpace === OUTPUT_COLOR_SPACE) {
      return (
        builder.context.outputColorSpace || builder.renderer.outputColorSpace
      );
    }
    return colorSpace;
  }
  setup(builder) {
    const { colorNode } = this;
    const source = this.resolveColorSpace(builder, this.source);
    const target = this.resolveColorSpace(builder, this.target);
    let outputNode = colorNode;
    if (
      ColorManagement.enabled === false ||
      source === target ||
      !source ||
      !target
    ) {
      return outputNode;
    }
    if (ColorManagement.getTransfer(source) === SRGBTransfer) {
      outputNode = vec4(sRGBTransferEOTF(outputNode.rgb), outputNode.a);
    }
    if (
      ColorManagement.getPrimaries(source) !==
      ColorManagement.getPrimaries(target)
    ) {
      outputNode = vec4(
        mat3(ColorManagement._getMatrix(new Matrix3(), source, target)).mul(
          outputNode.rgb
        ),
        outputNode.a
      );
    }
    if (ColorManagement.getTransfer(target) === SRGBTransfer) {
      outputNode = vec4(sRGBTransferOETF(outputNode.rgb), outputNode.a);
    }
    return outputNode;
  }
}
const workingToColorSpace = (node, targetColorSpace) =>
  nodeObject(
    new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, targetColorSpace)
  );
const colorSpaceToWorking = (node, sourceColorSpace) =>
  nodeObject(
    new ColorSpaceNode(nodeObject(node), sourceColorSpace, WORKING_COLOR_SPACE)
  );
const convertColorSpace = (node, sourceColorSpace, targetColorSpace) =>
  nodeObject(
    new ColorSpaceNode(nodeObject(node), sourceColorSpace, targetColorSpace)
  );
addMethodChaining("workingToColorSpace", workingToColorSpace);
addMethodChaining("colorSpaceToWorking", colorSpaceToWorking);
let ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {
  static get type() {
    return "ReferenceElementNode";
  }
  /**
   * Constructs a new reference element node.
   *
   * @param {ReferenceBaseNode} referenceNode - The reference node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(referenceNode, indexNode) {
    super(referenceNode, indexNode);
    this.referenceNode = referenceNode;
    this.isReferenceElementNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the uniform type of the reference node.
   *
   * @return {string} The node type.
   */
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const arrayType = this.referenceNode.getNodeType();
    const elementType = this.getNodeType();
    return builder.format(snippet, arrayType, elementType);
  }
};
class ReferenceBaseNode extends Node {
  static get type() {
    return "ReferenceBaseNode";
  }
  /**
   * Constructs a new reference base node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} uniformType - The uniform type that should be used to represent the property value.
   * @param {?Object} [object=null] - The object the property belongs to.
   * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
   */
  constructor(property2, uniformType, object = null, count = null) {
    super();
    this.property = property2;
    this.uniformType = uniformType;
    this.object = object;
    this.count = count;
    this.properties = property2.split(".");
    this.reference = object;
    this.node = null;
    this.group = null;
    this.updateType = NodeUpdateType.OBJECT;
  }
  /**
   * Sets the uniform group for this reference node.
   *
   * @param {UniformGroupNode} group - The uniform group to set.
   * @return {ReferenceBaseNode} A reference to this node.
   */
  setGroup(group) {
    this.group = group;
    return this;
  }
  /**
   * When the referred property is array-like, this method can be used
   * to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {ReferenceElementNode} A reference to an element.
   */
  element(indexNode) {
    return nodeObject(new ReferenceElementNode$1(this, nodeObject(indexNode)));
  }
  /**
   * Sets the node type which automatically defines the internal
   * uniform type.
   *
   * @param {string} uniformType - The type to set.
   */
  setNodeType(uniformType) {
    const node = uniform$1(null, uniformType).getSelf();
    if (this.group !== null) {
      node.setGroup(this.group);
    }
    this.node = node;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the type of the reference node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.node === null) {
      this.updateReference(builder);
      this.updateValue();
    }
    return this.node.getNodeType(builder);
  }
  /**
   * Returns the property value from the given referred object.
   *
   * @param {Object} [object=this.reference] - The object to retrieve the property value from.
   * @return {any} The value.
   */
  getValueFromReference(object = this.reference) {
    const { properties } = this;
    let value = object[properties[0]];
    for (let i2 = 1; i2 < properties.length; i2++) {
      value = value[properties[i2]];
    }
    return value;
  }
  /**
   * Allows to update the reference based on the given state. The state is only
   * evaluated {@link ReferenceBaseNode#object} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.object !== null ? this.object : state.object;
    return this.reference;
  }
  /**
   * The output of the reference node is the internal uniform node.
   *
   * @return {UniformNode} The output node.
   */
  setup() {
    this.updateValue();
    return this.node;
  }
  /**
   * Overwritten to update the internal uniform value.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    this.updateValue();
  }
  /**
   * Retrieves the value from the referred object property and uses it
   * to updated the internal uniform.
   */
  updateValue() {
    if (this.node === null) this.setNodeType(this.uniformType);
    const value = this.getValueFromReference();
    if (Array.isArray(value)) {
      this.node.array = value;
    } else {
      this.node.value = value;
    }
  }
}
const reference$1 = (name, type, object) =>
  nodeObject(new ReferenceBaseNode(name, type, object));
class RendererReferenceNode extends ReferenceBaseNode {
  static get type() {
    return "RendererReferenceNode";
  }
  /**
   * Constructs a new renderer reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} inputType - The uniform type that should be used to represent the property value.
   * @param {?Renderer} [renderer=null] - The renderer the property belongs to. When no renderer is set,
   * the node refers to the renderer of the current state.
   */
  constructor(property2, inputType, renderer2 = null) {
    super(property2, inputType, renderer2);
    this.renderer = renderer2;
    this.setGroup(renderGroup);
  }
  /**
   * Updates the reference based on the given state. The state is only evaluated
   * {@link RendererReferenceNode#renderer} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.renderer !== null ? this.renderer : state.renderer;
    return this.reference;
  }
}
const rendererReference = (name, type, renderer2 = null) =>
  nodeObject(new RendererReferenceNode(name, type, renderer2));
class ToneMappingNode extends TempNode {
  static get type() {
    return "ToneMappingNode";
  }
  /**
   * Constructs a new tone mapping node.
   *
   * @param {number} toneMapping - The tone mapping type.
   * @param {Node} exposureNode - The tone mapping exposure.
   * @param {Node} [colorNode=null] - The color node to process.
   */
  constructor(
    toneMapping2,
    exposureNode = toneMappingExposure,
    colorNode = null
  ) {
    super("vec3");
    this.toneMapping = toneMapping2;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  /**
   * Overwrites the default `customCacheKey()` implementation by including the tone
   * mapping type into the cache key.
   *
   * @return {number} The hash.
   */
  customCacheKey() {
    return hash$1(this.toneMapping);
  }
  setup(builder) {
    const colorNode = this.colorNode || builder.context.color;
    const toneMapping2 = this.toneMapping;
    if (toneMapping2 === NoToneMapping) return colorNode;
    let outputNode = null;
    const toneMappingFn =
      builder.renderer.library.getToneMappingFunction(toneMapping2);
    if (toneMappingFn !== null) {
      outputNode = vec4(
        toneMappingFn(colorNode.rgb, this.exposureNode),
        colorNode.a
      );
    } else {
      console.error(
        "ToneMappingNode: Unsupported Tone Mapping configuration.",
        toneMapping2
      );
      outputNode = colorNode;
    }
    return outputNode;
  }
}
const toneMapping = (mapping, exposure, color2) =>
  nodeObject(
    new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color2))
  );
const toneMappingExposure = /* @__PURE__ */ rendererReference(
  "toneMappingExposure",
  "float"
);
addMethodChaining("toneMapping", (color2, mapping, exposure) =>
  toneMapping(mapping, exposure, color2)
);
class BufferAttributeNode extends InputNode {
  static get type() {
    return "BufferAttributeNode";
  }
  /**
   * Constructs a new buffer attribute node.
   *
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.
   * @param {?string} [bufferType=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [bufferStride=0] - The buffer stride.
   * @param {number} [bufferOffset=0] - The buffer offset.
   */
  constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferStride = bufferStride;
    this.bufferOffset = bufferOffset;
    this.usage = StaticDrawUsage;
    this.instanced = false;
    this.attribute = null;
    this.global = true;
    if (value && value.isBufferAttribute === true) {
      this.attribute = value;
      this.usage = value.usage;
      this.instanced = value.isInstancedBufferAttribute;
    }
  }
  /**
   * This method is overwritten since the attribute data might be shared
   * and thus the hash should be shared as well.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(builder) {
    if (this.bufferStride === 0 && this.bufferOffset === 0) {
      let bufferData = builder.globalCache.getData(this.value);
      if (bufferData === void 0) {
        bufferData = {
          node: this,
        };
        builder.globalCache.setData(this.value, bufferData);
      }
      return bufferData.node.uuid;
    }
    return this.uuid;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the buffer attribute.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.bufferType === null) {
      this.bufferType = builder.getTypeFromAttribute(this.attribute);
    }
    return this.bufferType;
  }
  /**
   * Depending on which value was passed to the node, `setup()` behaves
   * differently. If no instance of `BufferAttribute` was passed, the method
   * creates an internal attribute and configures it respectively.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    if (this.attribute !== null) return;
    const type = this.getNodeType(builder);
    const array2 = this.value;
    const itemSize = builder.getTypeLength(type);
    const stride = this.bufferStride || itemSize;
    const offset = this.bufferOffset;
    const buffer2 =
      array2.isInterleavedBuffer === true
        ? array2
        : new InterleavedBuffer(array2, stride);
    const bufferAttribute2 = new InterleavedBufferAttribute(
      buffer2,
      itemSize,
      offset
    );
    buffer2.setUsage(this.usage);
    this.attribute = bufferAttribute2;
    this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  /**
   * Generates the code snippet of the buffer attribute node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
    const propertyName = builder.getPropertyName(nodeAttribute);
    let output2 = null;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      this.name = propertyName;
      output2 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output2 = nodeVarying.build(builder, nodeType);
    }
    return output2;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "bufferAttribute";
  }
  /**
   * Sets the `usage` property to the given value.
   *
   * @param {number} value - The usage to set.
   * @return {BufferAttributeNode} A reference to this node.
   */
  setUsage(value) {
    this.usage = value;
    if (this.attribute && this.attribute.isBufferAttribute === true) {
      this.attribute.usage = value;
    }
    return this;
  }
  /**
   * Sets the `instanced` property to the given value.
   *
   * @param {boolean} value - The value to set.
   * @return {BufferAttributeNode} A reference to this node.
   */
  setInstanced(value) {
    this.instanced = value;
    return this;
  }
}
const bufferAttribute = (array2, type = null, stride = 0, offset = 0) =>
  nodeObject(new BufferAttributeNode(array2, type, stride, offset));
const dynamicBufferAttribute = (array2, type = null, stride = 0, offset = 0) =>
  bufferAttribute(array2, type, stride, offset).setUsage(DynamicDrawUsage);
const instancedBufferAttribute = (
  array2,
  type = null,
  stride = 0,
  offset = 0
) => bufferAttribute(array2, type, stride, offset).setInstanced(true);
const instancedDynamicBufferAttribute = (
  array2,
  type = null,
  stride = 0,
  offset = 0
) => dynamicBufferAttribute(array2, type, stride, offset).setInstanced(true);
addMethodChaining("toAttribute", (bufferNode) =>
  bufferAttribute(bufferNode.value)
);
class ComputeNode extends Node {
  static get type() {
    return "ComputeNode";
  }
  /**
   * Constructs a new compute node.
   *
   * @param {Node} computeNode - TODO
   * @param {Array<number>} workgroupSize - TODO.
   */
  constructor(computeNode, workgroupSize) {
    super("void");
    this.isComputeNode = true;
    this.computeNode = computeNode;
    this.workgroupSize = workgroupSize;
    this.count = null;
    this.version = 1;
    this.name = "";
    this.updateBeforeType = NodeUpdateType.OBJECT;
    this.onInitFunction = null;
  }
  setCount(count) {
    this.count = count;
    return this;
  }
  getCount() {
    return this.count;
  }
  /**
   * Executes the `dispose` event for this node.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Sets the {@link ComputeNode#name} property.
   *
   * @param {string} name - The name of the uniform.
   * @return {ComputeNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the {@link ComputeNode#name} property.
   *
   * @deprecated
   * @param {string} name - The name of the uniform.
   * @return {ComputeNode} A reference to this node.
   */
  label(name) {
    console.warn(
      'THREE.TSL: "label()" has been deprecated. Use "setName()" instead.'
    );
    return this.setName(name);
  }
  /**
   * TODO
   *
   * @param {Function} callback - TODO.
   * @return {ComputeNode} A reference to this node.
   */
  onInit(callback) {
    this.onInitFunction = callback;
    return this;
  }
  /**
   * The method execute the compute for this node.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateBefore({ renderer: renderer2 }) {
    renderer2.compute(this);
  }
  setup(builder) {
    const result = this.computeNode.build(builder);
    if (result) {
      const properties = builder.getNodeProperties(this);
      properties.outputComputeNode = result.outputNode;
      result.outputNode = null;
    }
    return result;
  }
  generate(builder, output2) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addLineFlowCode(snippet, this);
      }
    } else {
      const properties = builder.getNodeProperties(this);
      const outputComputeNode = properties.outputComputeNode;
      if (outputComputeNode) {
        return outputComputeNode.build(builder, output2);
      }
    }
  }
}
const computeKernel = (node, workgroupSize = [64]) => {
  if (workgroupSize.length === 0 || workgroupSize.length > 3) {
    console.error(
      "THREE.TSL: compute() workgroupSize must have 1, 2, or 3 elements"
    );
  }
  for (let i2 = 0; i2 < workgroupSize.length; i2++) {
    const val = workgroupSize[i2];
    if (typeof val !== "number" || val <= 0 || !Number.isInteger(val)) {
      console.error(
        `THREE.TSL: compute() workgroupSize element at index [ ${i2} ] must be a positive integer`
      );
    }
  }
  while (workgroupSize.length < 3) workgroupSize.push(1);
  return nodeObject(new ComputeNode(nodeObject(node), workgroupSize));
};
const compute = (node, count, workgroupSize) =>
  computeKernel(node, workgroupSize).setCount(count);
addMethodChaining("compute", compute);
addMethodChaining("computeKernel", computeKernel);
class CacheNode extends Node {
  static get type() {
    return "CacheNode";
  }
  /**
   * Constructs a new cache node.
   *
   * @param {Node} node - The node that should be cached.
   * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
   */
  constructor(node, parent = true) {
    super();
    this.node = node;
    this.parent = parent;
    this.isCacheNode = true;
  }
  getNodeType(builder) {
    const previousCache = builder.getCache();
    const cache2 = builder.getCacheFromNode(this, this.parent);
    builder.setCache(cache2);
    const nodeType = this.node.getNodeType(builder);
    builder.setCache(previousCache);
    return nodeType;
  }
  build(builder, ...params) {
    const previousCache = builder.getCache();
    const cache2 = builder.getCacheFromNode(this, this.parent);
    builder.setCache(cache2);
    const data = this.node.build(builder, ...params);
    builder.setCache(previousCache);
    return data;
  }
}
const cache = (node, parent) =>
  nodeObject(new CacheNode(nodeObject(node), parent));
addMethodChaining("cache", cache);
class BypassNode extends Node {
  static get type() {
    return "BypassNode";
  }
  /**
   * Constructs a new bypass node.
   *
   * @param {Node} outputNode - The output node.
   * @param {Node} callNode - The call node.
   */
  constructor(outputNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = outputNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addLineFlowCode(snippet, this);
    }
    return this.outputNode.build(builder);
  }
}
const bypass = /* @__PURE__ */ nodeProxy(BypassNode).setParameterLength(2);
addMethodChaining("bypass", bypass);
class RemapNode extends Node {
  static get type() {
    return "RemapNode";
  }
  /**
   * Constructs a new remap node.
   *
   * @param {Node} node - The node that should be remapped.
   * @param {Node} inLowNode - The source or current lower bound of the range.
   * @param {Node} inHighNode - The source or current upper bound of the range.
   * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
   * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
   */
  constructor(
    node,
    inLowNode,
    inHighNode,
    outLowNode = float(0),
    outHighNode = float(1)
  ) {
    super();
    this.node = node;
    this.inLowNode = inLowNode;
    this.inHighNode = inHighNode;
    this.outLowNode = outLowNode;
    this.outHighNode = outHighNode;
    this.doClamp = true;
  }
  setup() {
    const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } =
      this;
    let t2 = node.sub(inLowNode).div(inHighNode.sub(inLowNode));
    if (doClamp === true) t2 = t2.clamp();
    return t2.mul(outHighNode.sub(outLowNode)).add(outLowNode);
  }
}
const remap = /* @__PURE__ */ nodeProxy(RemapNode, null, null, {
  doClamp: false,
}).setParameterLength(3, 5);
const remapClamp = /* @__PURE__ */ nodeProxy(RemapNode).setParameterLength(
  3,
  5
);
addMethodChaining("remap", remap);
addMethodChaining("remapClamp", remapClamp);
class ExpressionNode extends Node {
  static get type() {
    return "ExpressionNode";
  }
  /**
   * Constructs a new expression node.
   *
   * @param {string} [snippet=''] - The native code snippet.
   * @param {string} [nodeType='void'] - The node type.
   */
  constructor(snippet = "", nodeType = "void") {
    super(nodeType);
    this.snippet = snippet;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const snippet = this.snippet;
    if (type === "void") {
      builder.addLineFlowCode(snippet, this);
    } else {
      return builder.format(snippet, type, output2);
    }
  }
}
const expression = /* @__PURE__ */ nodeProxy(ExpressionNode).setParameterLength(
  1,
  2
);
const Discard = (conditional) =>
  (conditional
    ? select(conditional, expression("discard"))
    : expression("discard")
  ).toStack();
const Return = () => expression("return").toStack();
addMethodChaining("discard", Discard);
class RenderOutputNode extends TempNode {
  static get type() {
    return "RenderOutputNode";
  }
  /**
   * Constructs a new render output node.
   *
   * @param {Node} colorNode - The color node to process.
   * @param {?number} toneMapping - The tone mapping type.
   * @param {?string} outputColorSpace - The output color space.
   */
  constructor(colorNode, toneMapping2, outputColorSpace) {
    super("vec4");
    this.colorNode = colorNode;
    this.toneMapping = toneMapping2;
    this.outputColorSpace = outputColorSpace;
    this.isRenderOutputNode = true;
  }
  setup({ context: context2 }) {
    let outputNode = this.colorNode || context2.color;
    const toneMapping2 =
      (this.toneMapping !== null ? this.toneMapping : context2.toneMapping) ||
      NoToneMapping;
    const outputColorSpace =
      (this.outputColorSpace !== null
        ? this.outputColorSpace
        : context2.outputColorSpace) || NoColorSpace;
    if (toneMapping2 !== NoToneMapping) {
      outputNode = outputNode.toneMapping(toneMapping2);
    }
    if (
      outputColorSpace !== NoColorSpace &&
      outputColorSpace !== ColorManagement.workingColorSpace
    ) {
      outputNode = outputNode.workingToColorSpace(outputColorSpace);
    }
    return outputNode;
  }
}
const renderOutput = (color2, toneMapping2 = null, outputColorSpace = null) =>
  nodeObject(
    new RenderOutputNode(nodeObject(color2), toneMapping2, outputColorSpace)
  );
addMethodChaining("renderOutput", renderOutput);
class DebugNode extends TempNode {
  static get type() {
    return "DebugNode";
  }
  constructor(node, callback = null) {
    super();
    this.node = node;
    this.callback = callback;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  setup(builder) {
    return this.node.build(builder);
  }
  analyze(builder) {
    return this.node.build(builder);
  }
  generate(builder) {
    const callback = this.callback;
    const snippet = this.node.build(builder);
    const title = "--- TSL debug - " + builder.shaderStage + " shader ---";
    const border = "-".repeat(title.length);
    let code2 = "";
    code2 += "// #" + title + "#\n";
    code2 += builder.flow.code.replace(/^\t/gm, "") + "\n";
    code2 += "/* ... */ " + snippet + " /* ... */\n";
    code2 += "// #" + border + "#\n";
    if (callback !== null) {
      callback(builder, code2);
    } else {
      console.log(code2);
    }
    return snippet;
  }
}
const debug = (node, callback = null) =>
  nodeObject(new DebugNode(nodeObject(node), callback)).toStack();
addMethodChaining("debug", debug);
function addNodeElement(name) {
  console.warn(
    "THREE.TSL: AddNodeElement has been removed in favor of tree-shaking. Trying add",
    name
  );
}
class AttributeNode extends Node {
  static get type() {
    return "AttributeNode";
  }
  /**
   * Constructs a new attribute node.
   *
   * @param {string} attributeName - The name of the attribute.
   * @param {?string} nodeType - The node type.
   */
  constructor(attributeName, nodeType = null) {
    super(nodeType);
    this.global = true;
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  getNodeType(builder) {
    let nodeType = this.nodeType;
    if (nodeType === null) {
      const attributeName = this.getAttributeName(builder);
      if (builder.hasGeometryAttribute(attributeName)) {
        const attribute2 = builder.geometry.getAttribute(attributeName);
        nodeType = builder.getTypeFromAttribute(attribute2);
      } else {
        nodeType = "float";
      }
    }
    return nodeType;
  }
  /**
   * Sets the attribute name to the given value. The method can be
   * overwritten in derived classes if the final name must be computed
   * analytically.
   *
   * @param {string} attributeName - The name of the attribute.
   * @return {AttributeNode} A reference to this node.
   */
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  /**
   * Returns the attribute name of this node. The method can be
   * overwritten in derived classes if the final name must be computed
   * analytically.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The attribute name.
   */
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const nodeType = this.getNodeType(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    if (geometryAttribute === true) {
      const attribute2 = builder.geometry.getAttribute(attributeName);
      const attributeType = builder.getTypeFromAttribute(attribute2);
      const nodeAttribute = builder.getAttribute(attributeName, attributeType);
      if (builder.shaderStage === "vertex") {
        return builder.format(nodeAttribute.name, attributeType, nodeType);
      } else {
        const nodeVarying = varying(this);
        return nodeVarying.build(builder, nodeType);
      }
    } else {
      console.warn(
        `AttributeNode: Vertex attribute "${attributeName}" not found on geometry.`
      );
      return builder.generateConst(nodeType);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.global = this.global;
    data._attributeName = this._attributeName;
  }
  deserialize(data) {
    super.deserialize(data);
    this.global = data.global;
    this._attributeName = data._attributeName;
  }
}
const attribute = (name, nodeType = null) =>
  nodeObject(new AttributeNode(name, nodeType));
const uv$1 = (index = 0) => attribute("uv" + (index > 0 ? index : ""), "vec2");
class TextureSizeNode extends Node {
  static get type() {
    return "TextureSizeNode";
  }
  /**
   * Constructs a new texture size node.
   *
   * @param {TextureNode} textureNode - A texture node which size should be retrieved.
   * @param {?Node<int>} [levelNode=null] - A level node which defines the requested mip.
   */
  constructor(textureNode, levelNode = null) {
    super("uvec2");
    this.isTextureSizeNode = true;
    this.textureNode = textureNode;
    this.levelNode = levelNode;
  }
  generate(builder, output2) {
    const textureProperty = this.textureNode.build(builder, "property");
    const level =
      this.levelNode === null ? "0" : this.levelNode.build(builder, "int");
    return builder.format(
      `${builder.getMethod(
        "textureDimensions"
      )}( ${textureProperty}, ${level} )`,
      this.getNodeType(builder),
      output2
    );
  }
}
const textureSize = /* @__PURE__ */ nodeProxy(
  TextureSizeNode
).setParameterLength(1, 2);
class MaxMipLevelNode extends UniformNode {
  static get type() {
    return "MaxMipLevelNode";
  }
  /**
   * Constructs a new max mip level node.
   *
   * @param {TextureNode} textureNode - The texture node to compute the max mip level for.
   */
  constructor(textureNode) {
    super(0);
    this._textureNode = textureNode;
    this.updateType = NodeUpdateType.FRAME;
  }
  /**
   * The texture node to compute the max mip level for.
   *
   * @readonly
   * @type {TextureNode}
   */
  get textureNode() {
    return this._textureNode;
  }
  /**
   * The texture.
   *
   * @readonly
   * @type {Texture}
   */
  get texture() {
    return this._textureNode.value;
  }
  update() {
    const texture2 = this.texture;
    const images = texture2.images;
    const image =
      images && images.length > 0
        ? (images[0] && images[0].image) || images[0]
        : texture2.image;
    if (image && image.width !== void 0) {
      const { width, height } = image;
      this.value = Math.log2(Math.max(width, height));
    }
  }
}
const maxMipLevel =
  /* @__PURE__ */ nodeProxy(MaxMipLevelNode).setParameterLength(1);
const EmptyTexture$1 = /* @__PURE__ */ new Texture();
class TextureNode extends UniformNode {
  static get type() {
    return "TextureNode";
  }
  /**
   * Constructs a new texture node.
   *
   * @param {Texture} [value=EmptyTexture] - The texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   */
  constructor(
    value = EmptyTexture$1,
    uvNode = null,
    levelNode = null,
    biasNode = null
  ) {
    super(value);
    this.isTextureNode = true;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this.biasNode = biasNode;
    this.compareNode = null;
    this.depthNode = null;
    this.gradNode = null;
    this.sampler = true;
    this.updateMatrix = false;
    this.updateType = NodeUpdateType.NONE;
    this.referenceNode = null;
    this._value = value;
    this._matrixUniform = null;
    this.setUpdateMatrix(uvNode === null);
  }
  set value(value) {
    if (this.referenceNode) {
      this.referenceNode.value = value;
    } else {
      this._value = value;
    }
  }
  /**
   * The texture value.
   *
   * @type {Texture}
   */
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value;
  }
  /**
   * Overwritten since the uniform hash is defined by the texture's UUID.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The uniform hash.
   */
  getUniformHash() {
    return this.value.uuid;
  }
  /**
   * Overwritten since the node type is inferred from the texture type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    if (this.value.isDepthTexture === true) return "float";
    if (this.value.type === UnsignedIntType) {
      return "uvec4";
    } else if (this.value.type === IntType) {
      return "ivec4";
    }
    return "vec4";
  }
  /**
   * Overwrites the default implementation to return a fixed value `'texture'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "texture";
  }
  /**
   * Returns a default uvs based on the current texture's channel.
   *
   * @return {AttributeNode<vec2>} The default uvs.
   */
  getDefaultUV() {
    return uv$1(this.value.channel);
  }
  /**
   * Overwritten to always return the texture reference of the node.
   *
   * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
   * @return {Texture} The texture reference.
   */
  updateReference() {
    return this.value;
  }
  /**
   * Transforms the given uv node with the texture transformation matrix.
   *
   * @param {Node} uvNode - The uv node to transform.
   * @return {Node} The transformed uv node.
   */
  getTransformedUV(uvNode) {
    if (this._matrixUniform === null)
      this._matrixUniform = uniform$1(this.value.matrix);
    return this._matrixUniform.mul(vec3(uvNode, 1)).xy;
  }
  /**
   * Defines whether the uv transformation matrix should automatically be updated or not.
   *
   * @param {boolean} value - The update toggle.
   * @return {TextureNode} A reference to this node.
   */
  setUpdateMatrix(value) {
    this.updateMatrix = value;
    this.updateType = value ? NodeUpdateType.OBJECT : NodeUpdateType.NONE;
    return this;
  }
  /**
   * Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary
   * to modify the uv node for correct sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The updated uv node.
   */
  setupUV(builder, uvNode) {
    const texture2 = this.value;
    if (
      builder.isFlipY() &&
      ((texture2.image instanceof ImageBitmap && texture2.flipY === true) ||
        texture2.isRenderTargetTexture === true ||
        texture2.isFramebufferTexture === true ||
        texture2.isDepthTexture === true)
    ) {
      if (this.sampler) {
        uvNode = uvNode.flipY();
      } else {
        uvNode = uvNode.setY(
          int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1)
        );
      }
    }
    return uvNode;
  }
  /**
   * Setups texture node by preparing the internal nodes for code generation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    const properties = builder.getNodeProperties(this);
    properties.referenceNode = this.referenceNode;
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error(
        "THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture()."
      );
    }
    let uvNode = this.uvNode;
    if (
      (uvNode === null || builder.context.forceUVContext === true) &&
      builder.context.getUV
    ) {
      uvNode = builder.context.getUV(this, builder);
    }
    if (!uvNode) uvNode = this.getDefaultUV();
    if (this.updateMatrix === true) {
      uvNode = this.getTransformedUV(uvNode);
    }
    uvNode = this.setupUV(builder, uvNode);
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    properties.uvNode = uvNode;
    properties.levelNode = levelNode;
    properties.biasNode = this.biasNode;
    properties.compareNode = this.compareNode;
    properties.gradNode = this.gradNode;
    properties.depthNode = this.depthNode;
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(builder, uvNode) {
    return uvNode.build(builder, this.sampler === true ? "vec2" : "ivec2");
  }
  /**
   * Generates the snippet for the texture sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} textureProperty - The texture property.
   * @param {string} uvSnippet - The uv snippet.
   * @param {?string} levelSnippet - The level snippet.
   * @param {?string} biasSnippet - The bias snippet.
   * @param {?string} depthSnippet - The depth snippet.
   * @param {?string} compareSnippet - The compare snippet.
   * @param {?Array<string>} gradSnippet - The grad snippet.
   * @return {string} The generated code snippet.
   */
  generateSnippet(
    builder,
    textureProperty,
    uvSnippet,
    levelSnippet,
    biasSnippet,
    depthSnippet,
    compareSnippet,
    gradSnippet
  ) {
    const texture2 = this.value;
    let snippet;
    if (levelSnippet) {
      snippet = builder.generateTextureLevel(
        texture2,
        textureProperty,
        uvSnippet,
        levelSnippet,
        depthSnippet
      );
    } else if (biasSnippet) {
      snippet = builder.generateTextureBias(
        texture2,
        textureProperty,
        uvSnippet,
        biasSnippet,
        depthSnippet
      );
    } else if (gradSnippet) {
      snippet = builder.generateTextureGrad(
        texture2,
        textureProperty,
        uvSnippet,
        gradSnippet,
        depthSnippet
      );
    } else if (compareSnippet) {
      snippet = builder.generateTextureCompare(
        texture2,
        textureProperty,
        uvSnippet,
        compareSnippet,
        depthSnippet
      );
    } else if (this.sampler === false) {
      snippet = builder.generateTextureLoad(
        texture2,
        textureProperty,
        uvSnippet,
        depthSnippet
      );
    } else {
      snippet = builder.generateTexture(
        texture2,
        textureProperty,
        uvSnippet,
        depthSnippet
      );
    }
    return snippet;
  }
  /**
   * Generates the code snippet of the texture node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(builder, output2) {
    const texture2 = this.value;
    const properties = builder.getNodeProperties(this);
    const textureProperty = super.generate(builder, "property");
    if (/^sampler/.test(output2)) {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output2)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const {
          uvNode,
          levelNode,
          biasNode,
          compareNode,
          depthNode,
          gradNode,
        } = properties;
        const uvSnippet = this.generateUV(builder, uvNode);
        const levelSnippet = levelNode
          ? levelNode.build(builder, "float")
          : null;
        const biasSnippet = biasNode ? biasNode.build(builder, "float") : null;
        const depthSnippet = depthNode ? depthNode.build(builder, "int") : null;
        const compareSnippet = compareNode
          ? compareNode.build(builder, "float")
          : null;
        const gradSnippet = gradNode
          ? [
              gradNode[0].build(builder, "vec2"),
              gradNode[1].build(builder, "vec2"),
            ]
          : null;
        const nodeVar = builder.getVarFromNode(this);
        propertyName = builder.getPropertyName(nodeVar);
        const snippet2 = this.generateSnippet(
          builder,
          textureProperty,
          uvSnippet,
          levelSnippet,
          biasSnippet,
          depthSnippet,
          compareSnippet,
          gradSnippet
        );
        builder.addLineFlowCode(`${propertyName} = ${snippet2}`, this);
        nodeData.snippet = snippet2;
        nodeData.propertyName = propertyName;
      }
      let snippet = propertyName;
      const nodeType = this.getNodeType(builder);
      if (builder.needsToWorkingColorSpace(texture2)) {
        snippet = colorSpaceToWorking(
          expression(snippet, nodeType),
          texture2.colorSpace
        )
          .setup(builder)
          .build(builder, nodeType);
      }
      return builder.format(snippet, nodeType, output2);
    }
  }
  /**
   * Sets the sampler value.
   *
   * @param {boolean} value - The sampler value to set.
   * @return {TextureNode} A reference to this texture node.
   */
  setSampler(value) {
    this.sampler = value;
    return this;
  }
  /**
   * Returns the sampler value.
   *
   * @return {boolean} The sampler value.
   */
  getSampler() {
    return this.sampler;
  }
  // @TODO: Move to TSL
  /**
   * @function
   * @deprecated since r172. Use {@link TextureNode#sample} instead.
   *
   * @param {Node} uvNode - The uv node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  uv(uvNode) {
    console.warn(
      "THREE.TextureNode: .uv() has been renamed. Use .sample() instead."
    );
    return this.sample(uvNode);
  }
  /**
   * Samples the texture with the given uv node.
   *
   * @param {Node} uvNode - The uv node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  sample(uvNode) {
    const textureNode = this.clone();
    textureNode.uvNode = nodeObject(uvNode);
    textureNode.referenceNode = this.getSelf();
    return nodeObject(textureNode);
  }
  /**
   * TSL function for creating a texture node that fetches/loads texels without interpolation.
   *
   * @param {Node<uvec2>} uvNode - The uv node.
   * @returns {TextureNode} A texture node representing the texture load.
   */
  load(uvNode) {
    return this.sample(uvNode).setSampler(false);
  }
  /**
   * Samples a blurred version of the texture by defining an internal bias.
   *
   * @param {Node<float>} amountNode - How blurred the texture should be.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  blur(amountNode) {
    const textureNode = this.clone();
    textureNode.biasNode = nodeObject(amountNode).mul(maxMipLevel(textureNode));
    textureNode.referenceNode = this.getSelf();
    const map = textureNode.value;
    if (
      textureNode.generateMipmaps === false &&
      ((map && map.generateMipmaps === false) ||
        map.minFilter === NearestFilter ||
        map.magFilter === NearestFilter)
    ) {
      console.warn(
        "THREE.TSL: texture().blur() requires mipmaps and sampling. Use .generateMipmaps=true and .minFilter/.magFilter=THREE.LinearFilter in the Texture."
      );
      textureNode.biasNode = null;
    }
    return nodeObject(textureNode);
  }
  /**
   * Samples a specific mip of the texture.
   *
   * @param {Node<int>} levelNode - The mip level to sample.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  level(levelNode) {
    const textureNode = this.clone();
    textureNode.levelNode = nodeObject(levelNode);
    textureNode.referenceNode = this.getSelf();
    return nodeObject(textureNode);
  }
  /**
   * Returns the texture size of the requested level.
   *
   * @param {Node<int>} levelNode - The level to compute the size for.
   * @return {TextureSizeNode} The texture size.
   */
  size(levelNode) {
    return textureSize(this, levelNode);
  }
  /**
   * Samples the texture with the given bias.
   *
   * @param {Node<float>} biasNode - The bias node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  bias(biasNode) {
    const textureNode = this.clone();
    textureNode.biasNode = nodeObject(biasNode);
    textureNode.referenceNode = this.getSelf();
    return nodeObject(textureNode);
  }
  /**
   * Samples the texture by executing a compare operation.
   *
   * @param {Node<float>} compareNode - The node that defines the compare value.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  compare(compareNode) {
    const textureNode = this.clone();
    textureNode.compareNode = nodeObject(compareNode);
    textureNode.referenceNode = this.getSelf();
    return nodeObject(textureNode);
  }
  /**
   * Samples the texture using an explicit gradient.
   *
   * @param {Node<vec2>} gradNodeX - The gradX node.
   * @param {Node<vec2>} gradNodeY - The gradY node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  grad(gradNodeX, gradNodeY) {
    const textureNode = this.clone();
    textureNode.gradNode = [nodeObject(gradNodeX), nodeObject(gradNodeY)];
    textureNode.referenceNode = this.getSelf();
    return nodeObject(textureNode);
  }
  /**
   * Samples the texture by defining a depth node.
   *
   * @param {Node<int>} depthNode - The depth node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  depth(depthNode) {
    const textureNode = this.clone();
    textureNode.depthNode = nodeObject(depthNode);
    textureNode.referenceNode = this.getSelf();
    return nodeObject(textureNode);
  }
  // --
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
    data.sampler = this.sampler;
    data.updateMatrix = this.updateMatrix;
    data.updateType = this.updateType;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
    this.sampler = data.sampler;
    this.updateMatrix = data.updateMatrix;
    this.updateType = data.updateType;
  }
  /**
   * The update is used to implement the update of the uv transformation matrix.
   */
  update() {
    const texture2 = this.value;
    const matrixUniform = this._matrixUniform;
    if (matrixUniform !== null) matrixUniform.value = texture2.matrix;
    if (texture2.matrixAutoUpdate === true) {
      texture2.updateMatrix();
    }
  }
  /**
   * Clones the texture node.
   *
   * @return {TextureNode} The cloned texture node.
   */
  clone() {
    const newNode = new this.constructor(
      this.value,
      this.uvNode,
      this.levelNode,
      this.biasNode
    );
    newNode.sampler = this.sampler;
    newNode.depthNode = this.depthNode;
    newNode.compareNode = this.compareNode;
    newNode.gradNode = this.gradNode;
    return newNode;
  }
}
const textureBase = /* @__PURE__ */ nodeProxy(TextureNode)
  .setParameterLength(1, 4)
  .setName("texture");
const texture$1 = (
  value = EmptyTexture$1,
  uvNode = null,
  levelNode = null,
  biasNode = null
) => {
  let textureNode;
  if (value && value.isTextureNode === true) {
    textureNode = nodeObject(value.clone());
    textureNode.referenceNode = value.getSelf();
    if (uvNode !== null) textureNode.uvNode = nodeObject(uvNode);
    if (levelNode !== null) textureNode.levelNode = nodeObject(levelNode);
    if (biasNode !== null) textureNode.biasNode = nodeObject(biasNode);
  } else {
    textureNode = textureBase(value, uvNode, levelNode, biasNode);
  }
  return textureNode;
};
const uniformTexture = (value = EmptyTexture$1) => texture$1(value);
const textureLoad = (...params) => texture$1(...params).setSampler(false);
const sampler = (value) =>
  (value.isNode === true ? value : texture$1(value)).convert("sampler");
const samplerComparison = (value) =>
  (value.isNode === true ? value : texture$1(value)).convert(
    "samplerComparison"
  );
class BufferNode extends UniformNode {
  static get type() {
    return "BufferNode";
  }
  /**
   * Constructs a new buffer node.
   *
   * @param {Array<number>} value - Array-like buffer data.
   * @param {string} bufferType - The data type of the buffer.
   * @param {number} [bufferCount=0] - The count of buffer elements.
   */
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  /**
   * The data type of the buffer elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The element type.
   */
  getElementType(builder) {
    return this.getNodeType(builder);
  }
  /**
   * Overwrites the default implementation to return a fixed value `'buffer'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "buffer";
  }
}
const buffer = (value, type, count) =>
  nodeObject(new BufferNode(value, type, count));
class UniformArrayElementNode extends ArrayElementNode {
  static get type() {
    return "UniformArrayElementNode";
  }
  /**
   * Constructs a new buffer node.
   *
   * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.
   * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.
   */
  constructor(uniformArrayNode, indexNode) {
    super(uniformArrayNode, indexNode);
    this.isArrayBufferElementNode = true;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const type = this.getNodeType();
    const paddedType = this.node.getPaddedType();
    return builder.format(snippet, paddedType, type);
  }
}
class UniformArrayNode extends BufferNode {
  static get type() {
    return "UniformArrayNode";
  }
  /**
   * Constructs a new uniform array node.
   *
   * @param {Array<any>} value - Array holding the buffer data.
   * @param {?string} [elementType=null] - The data type of a buffer element.
   */
  constructor(value, elementType = null) {
    super(null);
    this.array = value;
    this.elementType =
      elementType === null ? getValueType(value[0]) : elementType;
    this.paddedType = this.getPaddedType();
    this.updateType = NodeUpdateType.RENDER;
    this.isArrayBufferNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from the
   * {@link UniformArrayNode#paddedType}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.paddedType;
  }
  /**
   * The data type of the array elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The element type.
   */
  getElementType() {
    return this.elementType;
  }
  /**
   * Returns the padded type based on the element type.
   *
   * @return {string} The padded type.
   */
  getPaddedType() {
    const elementType = this.elementType;
    let paddedType = "vec4";
    if (elementType === "mat2") {
      paddedType = "mat2";
    } else if (/mat/.test(elementType) === true) {
      paddedType = "mat4";
    } else if (elementType.charAt(0) === "i") {
      paddedType = "ivec4";
    } else if (elementType.charAt(0) === "u") {
      paddedType = "uvec4";
    }
    return paddedType;
  }
  /**
   * The update makes sure to correctly transfer the data from the (complex) objects
   * in the array to the internal, correctly padded value buffer.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    const { array: array2, value } = this;
    const elementType = this.elementType;
    if (
      elementType === "float" ||
      elementType === "int" ||
      elementType === "uint"
    ) {
      for (let i2 = 0; i2 < array2.length; i2++) {
        const index = i2 * 4;
        value[index] = array2[i2];
      }
    } else if (elementType === "color") {
      for (let i2 = 0; i2 < array2.length; i2++) {
        const index = i2 * 4;
        const vector = array2[i2];
        value[index] = vector.r;
        value[index + 1] = vector.g;
        value[index + 2] = vector.b || 0;
      }
    } else if (elementType === "mat2") {
      for (let i2 = 0; i2 < array2.length; i2++) {
        const index = i2 * 4;
        const matrix = array2[i2];
        value[index] = matrix.elements[0];
        value[index + 1] = matrix.elements[1];
        value[index + 2] = matrix.elements[2];
        value[index + 3] = matrix.elements[3];
      }
    } else if (elementType === "mat3") {
      for (let i2 = 0; i2 < array2.length; i2++) {
        const index = i2 * 16;
        const matrix = array2[i2];
        value[index] = matrix.elements[0];
        value[index + 1] = matrix.elements[1];
        value[index + 2] = matrix.elements[2];
        value[index + 4] = matrix.elements[3];
        value[index + 5] = matrix.elements[4];
        value[index + 6] = matrix.elements[5];
        value[index + 8] = matrix.elements[6];
        value[index + 9] = matrix.elements[7];
        value[index + 10] = matrix.elements[8];
        value[index + 15] = 1;
      }
    } else if (elementType === "mat4") {
      for (let i2 = 0; i2 < array2.length; i2++) {
        const index = i2 * 16;
        const matrix = array2[i2];
        for (let i3 = 0; i3 < matrix.elements.length; i3++) {
          value[index + i3] = matrix.elements[i3];
        }
      }
    } else {
      for (let i2 = 0; i2 < array2.length; i2++) {
        const index = i2 * 4;
        const vector = array2[i2];
        value[index] = vector.x;
        value[index + 1] = vector.y;
        value[index + 2] = vector.z || 0;
        value[index + 3] = vector.w || 0;
      }
    }
  }
  /**
   * Implement the value buffer creation based on the array data.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {null}
   */
  setup(builder) {
    const length2 = this.array.length;
    const elementType = this.elementType;
    let arrayType = Float32Array;
    const paddedType = this.paddedType;
    const paddedElementLength = builder.getTypeLength(paddedType);
    if (elementType.charAt(0) === "i") arrayType = Int32Array;
    if (elementType.charAt(0) === "u") arrayType = Uint32Array;
    this.value = new arrayType(length2 * paddedElementLength);
    this.bufferCount = length2;
    this.bufferType = paddedType;
    return super.setup(builder);
  }
  /**
   * Overwrites the default `element()` method to provide element access
   * based on {@link UniformArrayNode}.
   *
   * @param {IndexNode} indexNode - The index node.
   * @return {UniformArrayElementNode}
   */
  element(indexNode) {
    return nodeObject(new UniformArrayElementNode(this, nodeObject(indexNode)));
  }
}
const uniformArray = (values, nodeType) =>
  nodeObject(new UniformArrayNode(values, nodeType));
class BuiltinNode extends Node {
  /**
   * Constructs a new builtin node.
   *
   * @param {string} name - The name of the built-in shader variable.
   */
  constructor(name) {
    super("float");
    this.name = name;
    this.isBuiltinNode = true;
  }
  /**
   * Generates the code snippet of the builtin node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate() {
    return this.name;
  }
}
const builtin = nodeProxy(BuiltinNode).setParameterLength(1);
const cameraIndex = /* @__PURE__ */ uniform$1(0, "uint")
  .setName("u_cameraIndex")
  .setGroup(sharedUniformGroup("cameraIndex"))
  .toVarying("v_cameraIndex");
const cameraNear = /* @__PURE__ */ uniform$1("float")
  .setName("cameraNear")
  .setGroup(renderGroup)
  .onRenderUpdate(({ camera: camera2 }) => camera2.near);
const cameraFar = /* @__PURE__ */ uniform$1("float")
  .setName("cameraFar")
  .setGroup(renderGroup)
  .onRenderUpdate(({ camera: camera2 }) => camera2.far);
const cameraProjectionMatrix = /* @__PURE__ */ Fn(({ camera: camera2 }) => {
  let cameraProjectionMatrix2;
  if (camera2.isArrayCamera && camera2.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera2.cameras) {
      matrices.push(subCamera.projectionMatrix);
    }
    const cameraProjectionMatrices = uniformArray(matrices)
      .setGroup(renderGroup)
      .setName("cameraProjectionMatrices");
    cameraProjectionMatrix2 = cameraProjectionMatrices
      .element(
        camera2.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex
      )
      .toVar("cameraProjectionMatrix");
  } else {
    cameraProjectionMatrix2 = uniform$1("mat4")
      .setName("cameraProjectionMatrix")
      .setGroup(renderGroup)
      .onRenderUpdate(({ camera: camera3 }) => camera3.projectionMatrix);
  }
  return cameraProjectionMatrix2;
}).once()();
const cameraProjectionMatrixInverse = /* @__PURE__ */ Fn(
  ({ camera: camera2 }) => {
    let cameraProjectionMatrixInverse2;
    if (camera2.isArrayCamera && camera2.cameras.length > 0) {
      const matrices = [];
      for (const subCamera of camera2.cameras) {
        matrices.push(subCamera.projectionMatrixInverse);
      }
      const cameraProjectionMatricesInverse = uniformArray(matrices)
        .setGroup(renderGroup)
        .setName("cameraProjectionMatricesInverse");
      cameraProjectionMatrixInverse2 = cameraProjectionMatricesInverse
        .element(
          camera2.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex
        )
        .toVar("cameraProjectionMatrixInverse");
    } else {
      cameraProjectionMatrixInverse2 = uniform$1("mat4")
        .setName("cameraProjectionMatrixInverse")
        .setGroup(renderGroup)
        .onRenderUpdate(
          ({ camera: camera3 }) => camera3.projectionMatrixInverse
        );
    }
    return cameraProjectionMatrixInverse2;
  }
).once()();
const cameraViewMatrix = /* @__PURE__ */ Fn(({ camera: camera2 }) => {
  let cameraViewMatrix2;
  if (camera2.isArrayCamera && camera2.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera2.cameras) {
      matrices.push(subCamera.matrixWorldInverse);
    }
    const cameraViewMatrices = uniformArray(matrices)
      .setGroup(renderGroup)
      .setName("cameraViewMatrices");
    cameraViewMatrix2 = cameraViewMatrices
      .element(
        camera2.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex
      )
      .toVar("cameraViewMatrix");
  } else {
    cameraViewMatrix2 = uniform$1("mat4")
      .setName("cameraViewMatrix")
      .setGroup(renderGroup)
      .onRenderUpdate(({ camera: camera3 }) => camera3.matrixWorldInverse);
  }
  return cameraViewMatrix2;
}).once()();
const cameraWorldMatrix = /* @__PURE__ */ uniform$1("mat4")
  .setName("cameraWorldMatrix")
  .setGroup(renderGroup)
  .onRenderUpdate(({ camera: camera2 }) => camera2.matrixWorld);
const cameraNormalMatrix = /* @__PURE__ */ uniform$1("mat3")
  .setName("cameraNormalMatrix")
  .setGroup(renderGroup)
  .onRenderUpdate(({ camera: camera2 }) => camera2.normalMatrix);
const cameraPosition = /* @__PURE__ */ uniform$1(new Vector3())
  .setName("cameraPosition")
  .setGroup(renderGroup)
  .onRenderUpdate(({ camera: camera2 }, self2) =>
    self2.value.setFromMatrixPosition(camera2.matrixWorld)
  );
const _sphere = /* @__PURE__ */ new Sphere();
class Object3DNode extends Node {
  static get type() {
    return "Object3DNode";
  }
  /**
   * Constructs a new object 3D node.
   *
   * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
   * @param {?Object3D} [object3d=null] - The 3D object.
   */
  constructor(scope, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.OBJECT;
    this.uniformNode = new UniformNode(null);
  }
  /**
   * Overwritten since the node type is inferred from the scope.
   *
   * @return {string} The node type.
   */
  getNodeType() {
    const scope = this.scope;
    if (scope === Object3DNode.WORLD_MATRIX) {
      return "mat4";
    } else if (
      scope === Object3DNode.POSITION ||
      scope === Object3DNode.VIEW_POSITION ||
      scope === Object3DNode.DIRECTION ||
      scope === Object3DNode.SCALE
    ) {
      return "vec3";
    } else if (scope === Object3DNode.RADIUS) {
      return "float";
    }
  }
  /**
   * Updates the uniform value depending on the scope.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(frame) {
    const object = this.object3d;
    const uniformNode = this.uniformNode;
    const scope = this.scope;
    if (scope === Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === Object3DNode.POSITION) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === Object3DNode.SCALE) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixScale(object.matrixWorld);
    } else if (scope === Object3DNode.DIRECTION) {
      uniformNode.value = uniformNode.value || new Vector3();
      object.getWorldDirection(uniformNode.value);
    } else if (scope === Object3DNode.VIEW_POSITION) {
      const camera2 = frame.camera;
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera2.matrixWorldInverse);
    } else if (scope === Object3DNode.RADIUS) {
      const geometry = frame.object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      uniformNode.value = _sphere.radius;
    }
  }
  /**
   * Generates the code snippet of the uniform node. The node type of the uniform
   * node also depends on the selected scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(builder) {
    const scope = this.scope;
    if (scope === Object3DNode.WORLD_MATRIX) {
      this.uniformNode.nodeType = "mat4";
    } else if (
      scope === Object3DNode.POSITION ||
      scope === Object3DNode.VIEW_POSITION ||
      scope === Object3DNode.DIRECTION ||
      scope === Object3DNode.SCALE
    ) {
      this.uniformNode.nodeType = "vec3";
    } else if (scope === Object3DNode.RADIUS) {
      this.uniformNode.nodeType = "float";
    }
    return this.uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
}
Object3DNode.WORLD_MATRIX = "worldMatrix";
Object3DNode.POSITION = "position";
Object3DNode.SCALE = "scale";
Object3DNode.VIEW_POSITION = "viewPosition";
Object3DNode.DIRECTION = "direction";
Object3DNode.RADIUS = "radius";
const objectDirection = /* @__PURE__ */ nodeProxy(
  Object3DNode,
  Object3DNode.DIRECTION
).setParameterLength(1);
const objectWorldMatrix = /* @__PURE__ */ nodeProxy(
  Object3DNode,
  Object3DNode.WORLD_MATRIX
).setParameterLength(1);
const objectPosition = /* @__PURE__ */ nodeProxy(
  Object3DNode,
  Object3DNode.POSITION
).setParameterLength(1);
const objectScale = /* @__PURE__ */ nodeProxy(
  Object3DNode,
  Object3DNode.SCALE
).setParameterLength(1);
const objectViewPosition = /* @__PURE__ */ nodeProxy(
  Object3DNode,
  Object3DNode.VIEW_POSITION
).setParameterLength(1);
const objectRadius = /* @__PURE__ */ nodeProxy(
  Object3DNode,
  Object3DNode.RADIUS
).setParameterLength(1);
class ModelNode extends Object3DNode {
  static get type() {
    return "ModelNode";
  }
  /**
   * Constructs a new object model node.
   *
   * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
   */
  constructor(scope) {
    super(scope);
  }
  /**
   * Extracts the model reference from the frame state and then
   * updates the uniform value depending on the scope.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(frame) {
    this.object3d = frame.object;
    super.update(frame);
  }
}
const modelDirection = /* @__PURE__ */ nodeImmutable(
  ModelNode,
  ModelNode.DIRECTION
);
const modelWorldMatrix = /* @__PURE__ */ nodeImmutable(
  ModelNode,
  ModelNode.WORLD_MATRIX
);
const modelPosition = /* @__PURE__ */ nodeImmutable(
  ModelNode,
  ModelNode.POSITION
);
const modelScale = /* @__PURE__ */ nodeImmutable(ModelNode, ModelNode.SCALE);
const modelViewPosition = /* @__PURE__ */ nodeImmutable(
  ModelNode,
  ModelNode.VIEW_POSITION
);
const modelRadius = /* @__PURE__ */ nodeImmutable(ModelNode, ModelNode.RADIUS);
const modelNormalMatrix = /* @__PURE__ */ uniform$1(
  new Matrix3()
).onObjectUpdate(({ object }, self2) =>
  self2.value.getNormalMatrix(object.matrixWorld)
);
const modelWorldMatrixInverse = /* @__PURE__ */ uniform$1(
  new Matrix4()
).onObjectUpdate(({ object }, self2) =>
  self2.value.copy(object.matrixWorld).invert()
);
const modelViewMatrix = /* @__PURE__ */ Fn((builder) => {
  return (
    builder.renderer.overrideNodes.modelViewMatrix || mediumpModelViewMatrix
  );
})
  .once()()
  .toVar("modelViewMatrix");
const mediumpModelViewMatrix =
  /* @__PURE__ */ cameraViewMatrix.mul(modelWorldMatrix);
const highpModelViewMatrix = /* @__PURE__ */ Fn((builder) => {
  builder.context.isHighPrecisionModelViewMatrix = true;
  return uniform$1("mat4").onObjectUpdate(({ object, camera: camera2 }) => {
    return object.modelViewMatrix.multiplyMatrices(
      camera2.matrixWorldInverse,
      object.matrixWorld
    );
  });
})
  .once()()
  .toVar("highpModelViewMatrix");
const highpModelNormalViewMatrix = /* @__PURE__ */ Fn((builder) => {
  const isHighPrecisionModelViewMatrix =
    builder.context.isHighPrecisionModelViewMatrix;
  return uniform$1("mat3").onObjectUpdate(({ object, camera: camera2 }) => {
    if (isHighPrecisionModelViewMatrix !== true) {
      object.modelViewMatrix.multiplyMatrices(
        camera2.matrixWorldInverse,
        object.matrixWorld
      );
    }
    return object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
  });
})
  .once()()
  .toVar("highpModelNormalViewMatrix");
const positionGeometry = /* @__PURE__ */ attribute("position", "vec3");
const positionLocal$1 =
  /* @__PURE__ */ positionGeometry.toVarying("positionLocal");
const positionPrevious =
  /* @__PURE__ */ positionGeometry.toVarying("positionPrevious");
const positionWorld = /* @__PURE__ */ Fn((builder) => {
  return modelWorldMatrix
    .mul(positionLocal$1)
    .xyz.toVarying(builder.getSubBuildProperty("v_positionWorld"));
}, "vec3").once(["POSITION"])();
const positionWorldDirection = /* @__PURE__ */ Fn(() => {
  const vertexPWD = positionLocal$1
    .transformDirection(modelWorldMatrix)
    .toVarying("v_positionWorldDirection");
  return vertexPWD.normalize().toVar("positionWorldDirection");
}, "vec3").once(["POSITION"])();
const positionView = /* @__PURE__ */ Fn((builder) => {
  return builder.context.setupPositionView().toVarying("v_positionView");
}, "vec3").once(["POSITION"])();
const positionViewDirection = /* @__PURE__ */ positionView
  .negate()
  .toVarying("v_positionViewDirection")
  .normalize()
  .toVar("positionViewDirection");
class FrontFacingNode extends Node {
  static get type() {
    return "FrontFacingNode";
  }
  /**
   * Constructs a new front facing node.
   */
  constructor() {
    super("bool");
    this.isFrontFacingNode = true;
  }
  generate(builder) {
    if (builder.shaderStage !== "fragment") return "true";
    const { renderer: renderer2, material } = builder;
    if (renderer2.coordinateSystem === WebGLCoordinateSystem) {
      if (material.side === BackSide) {
        return "false";
      }
    }
    return builder.getFrontFacing();
  }
}
const frontFacing = /* @__PURE__ */ nodeImmutable(FrontFacingNode);
const faceDirection = /* @__PURE__ */ float(frontFacing).mul(2).sub(1);
const directionToFaceDirection = /* @__PURE__ */ Fn(
  ([direction], { material }) => {
    const side = material.side;
    if (side === BackSide) {
      direction = direction.mul(-1);
    } else if (side === DoubleSide) {
      direction = direction.mul(faceDirection);
    }
    return direction;
  }
);
const normalGeometry = /* @__PURE__ */ attribute("normal", "vec3");
const normalLocal = /* @__PURE__ */ Fn((builder) => {
  if (builder.geometry.hasAttribute("normal") === false) {
    console.warn('THREE.TSL: Vertex attribute "normal" not found on geometry.');
    return vec3(0, 1, 0);
  }
  return normalGeometry;
}, "vec3")
  .once()()
  .toVar("normalLocal");
const normalFlat = /* @__PURE__ */ positionView
  .dFdx()
  .cross(positionView.dFdy())
  .normalize()
  .toVar("normalFlat");
const normalViewGeometry = /* @__PURE__ */ Fn((builder) => {
  let node;
  if (builder.material.flatShading === true) {
    node = normalFlat;
  } else {
    node = transformNormalToView(normalLocal)
      .toVarying("v_normalViewGeometry")
      .normalize();
  }
  return node;
}, "vec3")
  .once()()
  .toVar("normalViewGeometry");
const normalWorldGeometry = /* @__PURE__ */ Fn((builder) => {
  let normal2 = normalViewGeometry.transformDirection(cameraViewMatrix);
  if (builder.material.flatShading !== true) {
    normal2 = normal2.toVarying("v_normalWorldGeometry");
  }
  return normal2.normalize().toVar("normalWorldGeometry");
}, "vec3").once()();
const normalView = /* @__PURE__ */ Fn(
  ({ subBuildFn, material, context: context2 }) => {
    let node;
    if (subBuildFn === "NORMAL" || subBuildFn === "VERTEX") {
      node = normalViewGeometry;
      if (material.flatShading !== true) {
        node = directionToFaceDirection(node);
      }
    } else {
      node = context2.setupNormal().context({ getUV: null });
    }
    return node;
  },
  "vec3"
)
  .once(["NORMAL", "VERTEX"])()
  .toVar("normalView");
const normalWorld = /* @__PURE__ */ normalView
  .transformDirection(cameraViewMatrix)
  .toVar("normalWorld");
const clearcoatNormalView = /* @__PURE__ */ Fn(
  ({ subBuildFn, context: context2 }) => {
    let node;
    if (subBuildFn === "NORMAL" || subBuildFn === "VERTEX") {
      node = normalView;
    } else {
      node = context2.setupClearcoatNormal().context({ getUV: null });
    }
    return node;
  },
  "vec3"
)
  .once(["NORMAL", "VERTEX"])()
  .toVar("clearcoatNormalView");
const transformNormal = /* @__PURE__ */ Fn(
  ([normal2, matrix = modelWorldMatrix]) => {
    const m = mat3(matrix);
    const transformedNormal = normal2.div(
      vec3(m[0].dot(m[0]), m[1].dot(m[1]), m[2].dot(m[2]))
    );
    return m.mul(transformedNormal).xyz;
  }
);
const transformNormalToView = /* @__PURE__ */ Fn(([normal2], builder) => {
  const modelNormalViewMatrix =
    builder.renderer.overrideNodes.modelNormalViewMatrix;
  if (modelNormalViewMatrix !== null) {
    return modelNormalViewMatrix.transformDirection(normal2);
  }
  const transformedNormal = modelNormalMatrix.mul(normal2);
  return cameraViewMatrix.transformDirection(transformedNormal);
});
const transformedNormalView = Fn(() => {
  console.warn(
    'THREE.TSL: "transformedNormalView" is deprecated. Use "normalView" instead.'
  );
  return normalView;
}).once(["NORMAL", "VERTEX"])();
const transformedNormalWorld = Fn(() => {
  console.warn(
    'THREE.TSL: "transformedNormalWorld" is deprecated. Use "normalWorld" instead.'
  );
  return normalWorld;
}).once(["NORMAL", "VERTEX"])();
const transformedClearcoatNormalView = Fn(() => {
  console.warn(
    'THREE.TSL: "transformedClearcoatNormalView" is deprecated. Use "clearcoatNormalView" instead.'
  );
  return clearcoatNormalView;
}).once(["NORMAL", "VERTEX"])();
const _e1$1 = /* @__PURE__ */ new Euler();
const _m1$1 = /* @__PURE__ */ new Matrix4();
const materialRefractionRatio = /* @__PURE__ */ uniform$1(0)
  .onReference(({ material }) => material)
  .onObjectUpdate(({ material }) => material.refractionRatio);
const materialEnvIntensity = /* @__PURE__ */ uniform$1(1)
  .onReference(({ material }) => material)
  .onObjectUpdate(function ({ material, scene: scene2 }) {
    return material.envMap
      ? material.envMapIntensity
      : scene2.environmentIntensity;
  });
const materialEnvRotation = /* @__PURE__ */ uniform$1(new Matrix4())
  .onReference(function (frame) {
    return frame.material;
  })
  .onObjectUpdate(function ({ material, scene: scene2 }) {
    const rotation =
      scene2.environment !== null && material.envMap === null
        ? scene2.environmentRotation
        : material.envMapRotation;
    if (rotation) {
      _e1$1.copy(rotation);
      _m1$1.makeRotationFromEuler(_e1$1);
    } else {
      _m1$1.identity();
    }
    return _m1$1;
  });
const reflectView = /* @__PURE__ */ positionViewDirection
  .negate()
  .reflect(normalView);
const refractView = /* @__PURE__ */ positionViewDirection
  .negate()
  .refract(normalView, materialRefractionRatio);
const reflectVector = /* @__PURE__ */ reflectView
  .transformDirection(cameraViewMatrix)
  .toVar("reflectVector");
const refractVector = /* @__PURE__ */ refractView
  .transformDirection(cameraViewMatrix)
  .toVar("reflectVector");
const EmptyTexture = /* @__PURE__ */ new CubeTexture();
class CubeTextureNode extends TextureNode {
  static get type() {
    return "CubeTextureNode";
  }
  /**
   * Constructs a new cube texture node.
   *
   * @param {CubeTexture} value - The cube texture.
   * @param {?Node<vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   */
  constructor(value, uvNode = null, levelNode = null, biasNode = null) {
    super(value, uvNode, levelNode, biasNode);
    this.isCubeTextureNode = true;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'cubeTexture'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "cubeTexture";
  }
  /**
   * Returns a default uvs based on the mapping type of the cube texture.
   *
   * @return {Node<vec3>} The default uv attribute.
   */
  getDefaultUV() {
    const texture2 = this.value;
    if (texture2.mapping === CubeReflectionMapping) {
      return reflectVector;
    } else if (texture2.mapping === CubeRefractionMapping) {
      return refractVector;
    } else {
      console.error(
        'THREE.CubeTextureNode: Mapping "%s" not supported.',
        texture2.mapping
      );
      return vec3(0, 0, 0);
    }
  }
  /**
   * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
   * for cube textures. The uv transformation matrix is not applied to cube textures.
   *
   * @param {boolean} value - The update toggle.
   */
  setUpdateMatrix() {}
  // Ignore .updateMatrix for CubeTextureNode
  /**
   * Setups the uv node. Depending on the backend as well as the texture type, it might be necessary
   * to modify the uv node for correct sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The updated uv node.
   */
  setupUV(builder, uvNode) {
    const texture2 = this.value;
    if (
      builder.renderer.coordinateSystem === WebGPUCoordinateSystem ||
      !texture2.isRenderTargetTexture
    ) {
      uvNode = vec3(uvNode.x.negate(), uvNode.yz);
    }
    return materialEnvRotation.mul(uvNode);
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} cubeUV - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(builder, cubeUV) {
    return cubeUV.build(builder, "vec3");
  }
}
const cubeTextureBase = /* @__PURE__ */ nodeProxy(CubeTextureNode)
  .setParameterLength(1, 4)
  .setName("cubeTexture");
const cubeTexture = (
  value = EmptyTexture,
  uvNode = null,
  levelNode = null,
  biasNode = null
) => {
  let textureNode;
  if (value && value.isCubeTextureNode === true) {
    textureNode = nodeObject(value.clone());
    textureNode.referenceNode = value.getSelf();
    if (uvNode !== null) textureNode.uvNode = nodeObject(uvNode);
    if (levelNode !== null) textureNode.levelNode = nodeObject(levelNode);
    if (biasNode !== null) textureNode.biasNode = nodeObject(biasNode);
  } else {
    textureNode = cubeTextureBase(value, uvNode, levelNode, biasNode);
  }
  return textureNode;
};
const uniformCubeTexture = (value = EmptyTexture) => cubeTextureBase(value);
class ReferenceElementNode2 extends ArrayElementNode {
  static get type() {
    return "ReferenceElementNode";
  }
  /**
   * Constructs a new reference element node.
   *
   * @param {?ReferenceNode} referenceNode - The reference node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(referenceNode, indexNode) {
    super(referenceNode, indexNode);
    this.referenceNode = referenceNode;
    this.isReferenceElementNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the uniform type of the reference node.
   *
   * @return {string} The node type.
   */
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const arrayType = this.referenceNode.getNodeType();
    const elementType = this.getNodeType();
    return builder.format(snippet, arrayType, elementType);
  }
}
class ReferenceNode extends Node {
  static get type() {
    return "ReferenceNode";
  }
  /**
   * Constructs a new reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} uniformType - The uniform type that should be used to represent the property value.
   * @param {?Object} [object=null] - The object the property belongs to.
   * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
   */
  constructor(property2, uniformType, object = null, count = null) {
    super();
    this.property = property2;
    this.uniformType = uniformType;
    this.object = object;
    this.count = count;
    this.properties = property2.split(".");
    this.reference = object;
    this.node = null;
    this.group = null;
    this.name = null;
    this.updateType = NodeUpdateType.OBJECT;
  }
  /**
   * When the referred property is array-like, this method can be used
   * to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {ReferenceElementNode} A reference to an element.
   */
  element(indexNode) {
    return nodeObject(new ReferenceElementNode2(this, nodeObject(indexNode)));
  }
  /**
   * Sets the uniform group for this reference node.
   *
   * @param {UniformGroupNode} group - The uniform group to set.
   * @return {ReferenceNode} A reference to this node.
   */
  setGroup(group) {
    this.group = group;
    return this;
  }
  /**
   * Sets the name for the internal uniform.
   *
   * @param {string} name - The label to set.
   * @return {ReferenceNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the label for the internal uniform.
   *
   * @deprecated
   * @param {string} name - The label to set.
   * @return {ReferenceNode} A reference to this node.
   */
  label(name) {
    console.warn(
      'THREE.TSL: "label()" has been deprecated. Use "setName()" instead.'
    );
    return this.setName(name);
  }
  /**
   * Sets the node type which automatically defines the internal
   * uniform type.
   *
   * @param {string} uniformType - The type to set.
   */
  setNodeType(uniformType) {
    let node = null;
    if (this.count !== null) {
      node = buffer(null, uniformType, this.count);
    } else if (Array.isArray(this.getValueFromReference())) {
      node = uniformArray(null, uniformType);
    } else if (uniformType === "texture") {
      node = texture$1(null);
    } else if (uniformType === "cubeTexture") {
      node = cubeTexture(null);
    } else {
      node = uniform$1(null, uniformType);
    }
    if (this.group !== null) {
      node.setGroup(this.group);
    }
    if (this.name !== null) node.setName(this.name);
    this.node = node.getSelf();
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the type of the reference node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.node === null) {
      this.updateReference(builder);
      this.updateValue();
    }
    return this.node.getNodeType(builder);
  }
  /**
   * Returns the property value from the given referred object.
   *
   * @param {Object} [object=this.reference] - The object to retrieve the property value from.
   * @return {any} The value.
   */
  getValueFromReference(object = this.reference) {
    const { properties } = this;
    let value = object[properties[0]];
    for (let i2 = 1; i2 < properties.length; i2++) {
      value = value[properties[i2]];
    }
    return value;
  }
  /**
   * Allows to update the reference based on the given state. The state is only
   * evaluated {@link ReferenceNode#object} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.object !== null ? this.object : state.object;
    return this.reference;
  }
  /**
   * The output of the reference node is the internal uniform node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {UniformNode} The output node.
   */
  setup() {
    this.updateValue();
    return this.node;
  }
  /**
   * Overwritten to update the internal uniform value.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    this.updateValue();
  }
  /**
   * Retrieves the value from the referred object property and uses it
   * to updated the internal uniform.
   */
  updateValue() {
    if (this.node === null) this.setNodeType(this.uniformType);
    const value = this.getValueFromReference();
    if (Array.isArray(value)) {
      this.node.array = value;
    } else {
      this.node.value = value;
    }
  }
}
const reference = (name, type, object) =>
  nodeObject(new ReferenceNode(name, type, object));
const referenceBuffer = (name, type, count, object) =>
  nodeObject(new ReferenceNode(name, type, object, count));
class MaterialReferenceNode extends ReferenceNode {
  static get type() {
    return "MaterialReferenceNode";
  }
  /**
   * Constructs a new material reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} inputType - The uniform type that should be used to represent the property value.
   * @param {?Material} [material=null] - The material the property belongs to. When no material is set,
   * the node refers to the material of the current rendered object.
   */
  constructor(property2, inputType, material = null) {
    super(property2, inputType, material);
    this.material = material;
    this.isMaterialReferenceNode = true;
  }
  /**
   * Updates the reference based on the given state. The state is only evaluated
   * {@link MaterialReferenceNode#material} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.material !== null ? this.material : state.material;
    return this.reference;
  }
}
const materialReference = (name, type, material = null) =>
  nodeObject(new MaterialReferenceNode(name, type, material));
const uv$2 = uv$1();
const q0 = positionView.dFdx();
const q1 = positionView.dFdy();
const st0 = uv$2.dFdx();
const st1 = uv$2.dFdy();
const N = normalView;
const q1perp = q1.cross(N);
const q0perp = N.cross(q0);
const T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));
const B = q1perp.mul(st0.y).add(q0perp.mul(st1.y));
const det = T.dot(T).max(B.dot(B));
const scale = det.equal(0).select(0, det.inverseSqrt());
const tangentViewFrame = /* @__PURE__ */ T.mul(scale).toVar("tangentViewFrame");
const bitangentViewFrame =
  /* @__PURE__ */ B.mul(scale).toVar("bitangentViewFrame");
const tangentGeometry = /* @__PURE__ */ Fn((builder) => {
  if (builder.geometry.hasAttribute("tangent") === false) {
    builder.geometry.computeTangents();
  }
  return attribute("tangent", "vec4");
})();
const tangentLocal = /* @__PURE__ */ tangentGeometry.xyz.toVar("tangentLocal");
const tangentView = /* @__PURE__ */ Fn(({ subBuildFn, geometry, material }) => {
  let node;
  if (subBuildFn === "VERTEX" || geometry.hasAttribute("tangent")) {
    node = modelViewMatrix
      .mul(vec4(tangentLocal, 0))
      .xyz.toVarying("v_tangentView")
      .normalize();
  } else {
    node = tangentViewFrame;
  }
  if (material.flatShading !== true) {
    node = directionToFaceDirection(node);
  }
  return node;
}, "vec3")
  .once(["NORMAL", "VERTEX"])()
  .toVar("tangentView");
const tangentWorld = /* @__PURE__ */ tangentView
  .transformDirection(cameraViewMatrix)
  .toVarying("v_tangentWorld")
  .normalize()
  .toVar("tangentWorld");
const getBitangent = /* @__PURE__ */ Fn(
  ([crossNormalTangent, varyingName], { subBuildFn, material }) => {
    let bitangent = crossNormalTangent.mul(tangentGeometry.w).xyz;
    if (subBuildFn === "NORMAL" && material.flatShading !== true) {
      bitangent = bitangent.toVarying(varyingName);
    }
    return bitangent;
  }
).once(["NORMAL"]);
const bitangentGeometry = /* @__PURE__ */ getBitangent(
  normalGeometry.cross(tangentGeometry),
  "v_bitangentGeometry"
)
  .normalize()
  .toVar("bitangentGeometry");
const bitangentLocal = /* @__PURE__ */ getBitangent(
  normalLocal.cross(tangentLocal),
  "v_bitangentLocal"
)
  .normalize()
  .toVar("bitangentLocal");
const bitangentView = /* @__PURE__ */ Fn(
  ({ subBuildFn, geometry, material }) => {
    let node;
    if (subBuildFn === "VERTEX" || geometry.hasAttribute("tangent")) {
      node = getBitangent(
        normalView.cross(tangentView),
        "v_bitangentView"
      ).normalize();
    } else {
      node = bitangentViewFrame;
    }
    if (material.flatShading !== true) {
      node = directionToFaceDirection(node);
    }
    return node;
  },
  "vec3"
)
  .once(["NORMAL", "VERTEX"])()
  .toVar("bitangentView");
const bitangentWorld = /* @__PURE__ */ getBitangent(
  normalWorld.cross(tangentWorld),
  "v_bitangentWorld"
)
  .normalize()
  .toVar("bitangentWorld");
const TBNViewMatrix = /* @__PURE__ */ mat3(
  tangentView,
  bitangentView,
  normalView
).toVar("TBNViewMatrix");
const parallaxDirection =
  /* @__PURE__ */ positionViewDirection.mul(TBNViewMatrix);
const parallaxUV = (uv2, scale2) => uv2.sub(parallaxDirection.mul(scale2));
const bentNormalView = /* @__PURE__ */ Fn(() => {
  let bentNormal = anisotropyB.cross(positionViewDirection);
  bentNormal = bentNormal.cross(anisotropyB).normalize();
  bentNormal = mix$1(
    bentNormal,
    normalView,
    anisotropy.mul(roughness.oneMinus()).oneMinus().pow2().pow2()
  ).normalize();
  return bentNormal;
}).once()();
class NormalMapNode extends TempNode {
  static get type() {
    return "NormalMapNode";
  }
  /**
   * Constructs a new normal map node.
   *
   * @param {Node<vec3>} node - Represents the normal map data.
   * @param {?Node<vec2>} [scaleNode=null] - Controls the intensity of the effect.
   */
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
  }
  setup({ material }) {
    const { normalMapType, scaleNode } = this;
    let normalMap2 = this.node.mul(2).sub(1);
    if (scaleNode !== null) {
      let scale2 = scaleNode;
      if (material.flatShading === true) {
        scale2 = directionToFaceDirection(scale2);
      }
      normalMap2 = vec3(normalMap2.xy.mul(scale2), normalMap2.z);
    }
    let output2 = null;
    if (normalMapType === ObjectSpaceNormalMap) {
      output2 = transformNormalToView(normalMap2);
    } else if (normalMapType === TangentSpaceNormalMap) {
      output2 = TBNViewMatrix.mul(normalMap2).normalize();
    } else {
      console.error(
        `THREE.NodeMaterial: Unsupported normal map type: ${normalMapType}`
      );
      output2 = normalView;
    }
    return output2;
  }
}
const normalMap = /* @__PURE__ */ nodeProxy(NormalMapNode).setParameterLength(
  1,
  2
);
const dHdxy_fwd = Fn(({ textureNode, bumpScale }) => {
  const sampleTexture = (callback) =>
    textureNode.cache().context({
      getUV: (texNode) => callback(texNode.uvNode || uv$1()),
      forceUVContext: true,
    });
  const Hll = float(sampleTexture((uvNode) => uvNode));
  return vec2(
    float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdx()))).sub(Hll),
    float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdy()))).sub(Hll)
  ).mul(bumpScale);
});
const perturbNormalArb = Fn((inputs) => {
  const { surf_pos, surf_norm, dHdxy } = inputs;
  const vSigmaX = surf_pos.dFdx().normalize();
  const vSigmaY = surf_pos.dFdy().normalize();
  const vN = surf_norm;
  const R1 = vSigmaY.cross(vN);
  const R2 = vN.cross(vSigmaX);
  const fDet = vSigmaX.dot(R1).mul(faceDirection);
  const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));
  return fDet.abs().mul(surf_norm).sub(vGrad).normalize();
});
class BumpMapNode extends TempNode {
  static get type() {
    return "BumpMapNode";
  }
  /**
   * Constructs a new bump map node.
   *
   * @param {Node<float>} textureNode - Represents the bump map data.
   * @param {?Node<float>} [scaleNode=null] - Controls the intensity of the bump effect.
   */
  constructor(textureNode, scaleNode = null) {
    super("vec3");
    this.textureNode = textureNode;
    this.scaleNode = scaleNode;
  }
  setup() {
    const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
    const dHdxy = dHdxy_fwd({ textureNode: this.textureNode, bumpScale });
    return perturbNormalArb({
      surf_pos: positionView,
      surf_norm: normalView,
      dHdxy,
    });
  }
}
const bumpMap = /* @__PURE__ */ nodeProxy(BumpMapNode).setParameterLength(1, 2);
const _propertyCache = /* @__PURE__ */ new Map();
class MaterialNode extends Node {
  static get type() {
    return "MaterialNode";
  }
  /**
   * Constructs a new material node.
   *
   * @param {string} scope - The scope defines what kind of material property is referred by the node.
   */
  constructor(scope) {
    super();
    this.scope = scope;
  }
  /**
   * Returns a cached reference node for the given property and type.
   *
   * @param {string} property - The name of the material property.
   * @param {string} type - The uniform type of the property.
   * @return {MaterialReferenceNode} A material reference node representing the property access.
   */
  getCache(property2, type) {
    let node = _propertyCache.get(property2);
    if (node === void 0) {
      node = materialReference(property2, type);
      _propertyCache.set(property2, node);
    }
    return node;
  }
  /**
   * Returns a float-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode<float>} A material reference node representing the property access.
   */
  getFloat(property2) {
    return this.getCache(property2, "float");
  }
  /**
   * Returns a color-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode<color>} A material reference node representing the property access.
   */
  getColor(property2) {
    return this.getCache(property2, "color");
  }
  /**
   * Returns a texture-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode} A material reference node representing the property access.
   */
  getTexture(property2) {
    return this.getCache(
      property2 === "map" ? "map" : property2 + "Map",
      "texture"
    );
  }
  /**
   * The node setup is done depending on the selected scope. Multiple material properties
   * might be grouped into a single node composition if they logically belong together.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The node representing the selected scope.
   */
  setup(builder) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === MaterialNode.COLOR) {
      const colorNode =
        material.color !== void 0 ? this.getColor(scope) : vec3();
      if (material.map && material.map.isTexture === true) {
        node = colorNode.mul(this.getTexture("map"));
      } else {
        node = colorNode;
      }
    } else if (scope === MaterialNode.OPACITY) {
      const opacityNode = this.getFloat(scope);
      if (material.alphaMap && material.alphaMap.isTexture === true) {
        node = opacityNode.mul(this.getTexture("alpha"));
      } else {
        node = opacityNode;
      }
    } else if (scope === MaterialNode.SPECULAR_STRENGTH) {
      if (material.specularMap && material.specularMap.isTexture === true) {
        node = this.getTexture("specular").r;
      } else {
        node = float(1);
      }
    } else if (scope === MaterialNode.SPECULAR_INTENSITY) {
      const specularIntensityNode = this.getFloat(scope);
      if (
        material.specularIntensityMap &&
        material.specularIntensityMap.isTexture === true
      ) {
        node = specularIntensityNode.mul(this.getTexture(scope).a);
      } else {
        node = specularIntensityNode;
      }
    } else if (scope === MaterialNode.SPECULAR_COLOR) {
      const specularColorNode = this.getColor(scope);
      if (
        material.specularColorMap &&
        material.specularColorMap.isTexture === true
      ) {
        node = specularColorNode.mul(this.getTexture(scope).rgb);
      } else {
        node = specularColorNode;
      }
    } else if (scope === MaterialNode.ROUGHNESS) {
      const roughnessNode = this.getFloat(scope);
      if (material.roughnessMap && material.roughnessMap.isTexture === true) {
        node = roughnessNode.mul(this.getTexture(scope).g);
      } else {
        node = roughnessNode;
      }
    } else if (scope === MaterialNode.METALNESS) {
      const metalnessNode = this.getFloat(scope);
      if (material.metalnessMap && material.metalnessMap.isTexture === true) {
        node = metalnessNode.mul(this.getTexture(scope).b);
      } else {
        node = metalnessNode;
      }
    } else if (scope === MaterialNode.EMISSIVE) {
      const emissiveIntensityNode = this.getFloat("emissiveIntensity");
      const emissiveNode = this.getColor(scope).mul(emissiveIntensityNode);
      if (material.emissiveMap && material.emissiveMap.isTexture === true) {
        node = emissiveNode.mul(this.getTexture(scope));
      } else {
        node = emissiveNode;
      }
    } else if (scope === MaterialNode.NORMAL) {
      if (material.normalMap) {
        node = normalMap(
          this.getTexture("normal"),
          this.getCache("normalScale", "vec2")
        );
        node.normalMapType = material.normalMapType;
      } else if (material.bumpMap) {
        node = bumpMap(this.getTexture("bump").r, this.getFloat("bumpScale"));
      } else {
        node = normalView;
      }
    } else if (scope === MaterialNode.CLEARCOAT) {
      const clearcoatNode = this.getFloat(scope);
      if (material.clearcoatMap && material.clearcoatMap.isTexture === true) {
        node = clearcoatNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatNode;
      }
    } else if (scope === MaterialNode.CLEARCOAT_ROUGHNESS) {
      const clearcoatRoughnessNode = this.getFloat(scope);
      if (
        material.clearcoatRoughnessMap &&
        material.clearcoatRoughnessMap.isTexture === true
      ) {
        node = clearcoatRoughnessNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatRoughnessNode;
      }
    } else if (scope === MaterialNode.CLEARCOAT_NORMAL) {
      if (material.clearcoatNormalMap) {
        node = normalMap(
          this.getTexture(scope),
          this.getCache(scope + "Scale", "vec2")
        );
      } else {
        node = normalView;
      }
    } else if (scope === MaterialNode.SHEEN) {
      const sheenNode = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      if (material.sheenColorMap && material.sheenColorMap.isTexture === true) {
        node = sheenNode.mul(this.getTexture("sheenColor").rgb);
      } else {
        node = sheenNode;
      }
    } else if (scope === MaterialNode.SHEEN_ROUGHNESS) {
      const sheenRoughnessNode = this.getFloat(scope);
      if (
        material.sheenRoughnessMap &&
        material.sheenRoughnessMap.isTexture === true
      ) {
        node = sheenRoughnessNode.mul(this.getTexture(scope).a);
      } else {
        node = sheenRoughnessNode;
      }
      node = node.clamp(0.07, 1);
    } else if (scope === MaterialNode.ANISOTROPY) {
      if (material.anisotropyMap && material.anisotropyMap.isTexture === true) {
        const anisotropyPolar = this.getTexture(scope);
        const anisotropyMat = mat2(
          materialAnisotropyVector.x,
          materialAnisotropyVector.y,
          materialAnisotropyVector.y.negate(),
          materialAnisotropyVector.x
        );
        node = anisotropyMat.mul(
          anisotropyPolar.rg
            .mul(2)
            .sub(vec2(1))
            .normalize()
            .mul(anisotropyPolar.b)
        );
      } else {
        node = materialAnisotropyVector;
      }
    } else if (scope === MaterialNode.IRIDESCENCE_THICKNESS) {
      const iridescenceThicknessMaximum = reference(
        "1",
        "float",
        material.iridescenceThicknessRange
      );
      if (material.iridescenceThicknessMap) {
        const iridescenceThicknessMinimum = reference(
          "0",
          "float",
          material.iridescenceThicknessRange
        );
        node = iridescenceThicknessMaximum
          .sub(iridescenceThicknessMinimum)
          .mul(this.getTexture(scope).g)
          .add(iridescenceThicknessMinimum);
      } else {
        node = iridescenceThicknessMaximum;
      }
    } else if (scope === MaterialNode.TRANSMISSION) {
      const transmissionNode = this.getFloat(scope);
      if (material.transmissionMap) {
        node = transmissionNode.mul(this.getTexture(scope).r);
      } else {
        node = transmissionNode;
      }
    } else if (scope === MaterialNode.THICKNESS) {
      const thicknessNode = this.getFloat(scope);
      if (material.thicknessMap) {
        node = thicknessNode.mul(this.getTexture(scope).g);
      } else {
        node = thicknessNode;
      }
    } else if (scope === MaterialNode.IOR) {
      node = this.getFloat(scope);
    } else if (scope === MaterialNode.LIGHT_MAP) {
      node = this.getTexture(scope).rgb.mul(this.getFloat("lightMapIntensity"));
    } else if (scope === MaterialNode.AO) {
      node = this.getTexture(scope)
        .r.sub(1)
        .mul(this.getFloat("aoMapIntensity"))
        .add(1);
    } else if (scope === MaterialNode.LINE_DASH_OFFSET) {
      node = material.dashOffset ? this.getFloat(scope) : float(0);
    } else {
      const outputType = this.getNodeType(builder);
      node = this.getCache(scope, outputType);
    }
    return node;
  }
}
MaterialNode.ALPHA_TEST = "alphaTest";
MaterialNode.COLOR = "color";
MaterialNode.OPACITY = "opacity";
MaterialNode.SHININESS = "shininess";
MaterialNode.SPECULAR = "specular";
MaterialNode.SPECULAR_STRENGTH = "specularStrength";
MaterialNode.SPECULAR_INTENSITY = "specularIntensity";
MaterialNode.SPECULAR_COLOR = "specularColor";
MaterialNode.REFLECTIVITY = "reflectivity";
MaterialNode.ROUGHNESS = "roughness";
MaterialNode.METALNESS = "metalness";
MaterialNode.NORMAL = "normal";
MaterialNode.CLEARCOAT = "clearcoat";
MaterialNode.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
MaterialNode.CLEARCOAT_NORMAL = "clearcoatNormal";
MaterialNode.EMISSIVE = "emissive";
MaterialNode.ROTATION = "rotation";
MaterialNode.SHEEN = "sheen";
MaterialNode.SHEEN_ROUGHNESS = "sheenRoughness";
MaterialNode.ANISOTROPY = "anisotropy";
MaterialNode.IRIDESCENCE = "iridescence";
MaterialNode.IRIDESCENCE_IOR = "iridescenceIOR";
MaterialNode.IRIDESCENCE_THICKNESS = "iridescenceThickness";
MaterialNode.IOR = "ior";
MaterialNode.TRANSMISSION = "transmission";
MaterialNode.THICKNESS = "thickness";
MaterialNode.ATTENUATION_DISTANCE = "attenuationDistance";
MaterialNode.ATTENUATION_COLOR = "attenuationColor";
MaterialNode.LINE_SCALE = "scale";
MaterialNode.LINE_DASH_SIZE = "dashSize";
MaterialNode.LINE_GAP_SIZE = "gapSize";
MaterialNode.LINE_WIDTH = "linewidth";
MaterialNode.LINE_DASH_OFFSET = "dashOffset";
MaterialNode.POINT_SIZE = "size";
MaterialNode.DISPERSION = "dispersion";
MaterialNode.LIGHT_MAP = "light";
MaterialNode.AO = "ao";
const materialAlphaTest = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.ALPHA_TEST
);
const materialColor = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.COLOR
);
const materialShininess = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.SHININESS
);
const materialEmissive = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.EMISSIVE
);
const materialOpacity = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.OPACITY
);
const materialSpecular = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.SPECULAR
);
const materialSpecularIntensity = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.SPECULAR_INTENSITY
);
const materialSpecularColor = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.SPECULAR_COLOR
);
const materialSpecularStrength = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.SPECULAR_STRENGTH
);
const materialReflectivity = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.REFLECTIVITY
);
const materialRoughness = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.ROUGHNESS
);
const materialMetalness = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.METALNESS
);
const materialNormal = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.NORMAL
);
const materialClearcoat = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.CLEARCOAT
);
const materialClearcoatRoughness = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.CLEARCOAT_ROUGHNESS
);
const materialClearcoatNormal = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.CLEARCOAT_NORMAL
);
const materialRotation = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.ROTATION
);
const materialSheen = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.SHEEN
);
const materialSheenRoughness = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.SHEEN_ROUGHNESS
);
const materialAnisotropy = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.ANISOTROPY
);
const materialIridescence = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.IRIDESCENCE
);
const materialIridescenceIOR = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.IRIDESCENCE_IOR
);
const materialIridescenceThickness = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.IRIDESCENCE_THICKNESS
);
const materialTransmission = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.TRANSMISSION
);
const materialThickness = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.THICKNESS
);
const materialIOR = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.IOR
);
const materialAttenuationDistance = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.ATTENUATION_DISTANCE
);
const materialAttenuationColor = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.ATTENUATION_COLOR
);
const materialLineScale = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.LINE_SCALE
);
const materialLineDashSize = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.LINE_DASH_SIZE
);
const materialLineGapSize = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.LINE_GAP_SIZE
);
const materialLineWidth = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.LINE_WIDTH
);
const materialLineDashOffset = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.LINE_DASH_OFFSET
);
const materialPointSize = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.POINT_SIZE
);
const materialDispersion = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.DISPERSION
);
const materialLightMap = /* @__PURE__ */ nodeImmutable(
  MaterialNode,
  MaterialNode.LIGHT_MAP
);
const materialAO = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.AO);
const materialAnisotropyVector = /* @__PURE__ */ uniform$1(new Vector2())
  .onReference(function (frame) {
    return frame.material;
  })
  .onRenderUpdate(function ({ material }) {
    this.value.set(
      material.anisotropy * Math.cos(material.anisotropyRotation),
      material.anisotropy * Math.sin(material.anisotropyRotation)
    );
  });
const modelViewProjection = /* @__PURE__ */ Fn((builder) => {
  return builder.context.setupModelViewProjection();
}, "vec4")
  .once()()
  .toVarying("v_modelViewProjection");
class IndexNode extends Node {
  static get type() {
    return "IndexNode";
  }
  /**
   * Constructs a new index node.
   *
   * @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.
   */
  constructor(scope) {
    super("uint");
    this.scope = scope;
    this.isIndexNode = true;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const scope = this.scope;
    let propertyName;
    if (scope === IndexNode.VERTEX) {
      propertyName = builder.getVertexIndex();
    } else if (scope === IndexNode.INSTANCE) {
      propertyName = builder.getInstanceIndex();
    } else if (scope === IndexNode.DRAW) {
      propertyName = builder.getDrawIndex();
    } else if (scope === IndexNode.INVOCATION_LOCAL) {
      propertyName = builder.getInvocationLocalIndex();
    } else if (scope === IndexNode.INVOCATION_SUBGROUP) {
      propertyName = builder.getInvocationSubgroupIndex();
    } else if (scope === IndexNode.SUBGROUP) {
      propertyName = builder.getSubgroupIndex();
    } else {
      throw new Error("THREE.IndexNode: Unknown scope: " + scope);
    }
    let output2;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      output2 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output2 = nodeVarying.build(builder, nodeType);
    }
    return output2;
  }
}
IndexNode.VERTEX = "vertex";
IndexNode.INSTANCE = "instance";
IndexNode.SUBGROUP = "subgroup";
IndexNode.INVOCATION_LOCAL = "invocationLocal";
IndexNode.INVOCATION_SUBGROUP = "invocationSubgroup";
IndexNode.DRAW = "draw";
const vertexIndex = /* @__PURE__ */ nodeImmutable(IndexNode, IndexNode.VERTEX);
const instanceIndex = /* @__PURE__ */ nodeImmutable(
  IndexNode,
  IndexNode.INSTANCE
);
const subgroupIndex = /* @__PURE__ */ nodeImmutable(
  IndexNode,
  IndexNode.SUBGROUP
);
const invocationSubgroupIndex = /* @__PURE__ */ nodeImmutable(
  IndexNode,
  IndexNode.INVOCATION_SUBGROUP
);
const invocationLocalIndex = /* @__PURE__ */ nodeImmutable(
  IndexNode,
  IndexNode.INVOCATION_LOCAL
);
const drawIndex = /* @__PURE__ */ nodeImmutable(IndexNode, IndexNode.DRAW);
class InstanceNode extends Node {
  static get type() {
    return "InstanceNode";
  }
  /**
   * Constructs a new instance node.
   *
   * @param {number} count - The number of instances.
   * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.
   * @param {?InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.
   */
  constructor(count, instanceMatrix, instanceColor = null) {
    super("void");
    this.count = count;
    this.instanceMatrix = instanceMatrix;
    this.instanceColor = instanceColor;
    this.instanceMatrixNode = null;
    this.instanceColorNode = null;
    this.updateType = NodeUpdateType.FRAME;
    this.buffer = null;
    this.bufferColor = null;
  }
  /**
   * Setups the internal buffers and nodes and assigns the transformed vertex data
   * to predefined node variables for accumulation. That follows the same patterns
   * like with morph and skinning nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    const { count, instanceMatrix, instanceColor } = this;
    let { instanceMatrixNode, instanceColorNode } = this;
    if (instanceMatrixNode === null) {
      if (count <= 1e3) {
        instanceMatrixNode = buffer(
          instanceMatrix.array,
          "mat4",
          Math.max(count, 1)
        ).element(instanceIndex);
      } else {
        const buffer2 = new InstancedInterleavedBuffer(
          instanceMatrix.array,
          16,
          1
        );
        this.buffer = buffer2;
        const bufferFn =
          instanceMatrix.usage === DynamicDrawUsage
            ? instancedDynamicBufferAttribute
            : instancedBufferAttribute;
        const instanceBuffers = [
          // F.Signature -> bufferAttribute( array, type, stride, offset )
          bufferFn(buffer2, "vec4", 16, 0),
          bufferFn(buffer2, "vec4", 16, 4),
          bufferFn(buffer2, "vec4", 16, 8),
          bufferFn(buffer2, "vec4", 16, 12),
        ];
        instanceMatrixNode = mat4(...instanceBuffers);
      }
      this.instanceMatrixNode = instanceMatrixNode;
    }
    if (instanceColor && instanceColorNode === null) {
      const buffer2 = new InstancedBufferAttribute(instanceColor.array, 3);
      const bufferFn =
        instanceColor.usage === DynamicDrawUsage
          ? instancedDynamicBufferAttribute
          : instancedBufferAttribute;
      this.bufferColor = buffer2;
      instanceColorNode = vec3(bufferFn(buffer2, "vec3", 3, 0));
      this.instanceColorNode = instanceColorNode;
    }
    const instancePosition = instanceMatrixNode.mul(positionLocal$1).xyz;
    positionLocal$1.assign(instancePosition);
    if (builder.hasGeometryAttribute("normal")) {
      const instanceNormal = transformNormal(normalLocal, instanceMatrixNode);
      normalLocal.assign(instanceNormal);
    }
    if (this.instanceColorNode !== null) {
      varyingProperty("vec3", "vInstanceColor").assign(this.instanceColorNode);
    }
  }
  /**
   * Checks if the internal buffers required an update.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update() {
    if (
      this.instanceMatrix.usage !== DynamicDrawUsage &&
      this.buffer !== null &&
      this.instanceMatrix.version !== this.buffer.version
    ) {
      this.buffer.version = this.instanceMatrix.version;
    }
    if (
      this.instanceColor &&
      this.instanceColor.usage !== DynamicDrawUsage &&
      this.bufferColor !== null &&
      this.instanceColor.version !== this.bufferColor.version
    ) {
      this.bufferColor.version = this.instanceColor.version;
    }
  }
}
const instance = /* @__PURE__ */ nodeProxy(InstanceNode).setParameterLength(
  2,
  3
);
class InstancedMeshNode extends InstanceNode {
  static get type() {
    return "InstancedMeshNode";
  }
  /**
   * Constructs a new instanced mesh node.
   *
   * @param {InstancedMesh} instancedMesh - The instanced mesh.
   */
  constructor(instancedMesh2) {
    const { count, instanceMatrix, instanceColor } = instancedMesh2;
    super(count, instanceMatrix, instanceColor);
    this.instancedMesh = instancedMesh2;
  }
}
const instancedMesh =
  /* @__PURE__ */ nodeProxy(InstancedMeshNode).setParameterLength(1);
class BatchNode extends Node {
  static get type() {
    return "BatchNode";
  }
  /**
   * Constructs a new batch node.
   *
   * @param {BatchedMesh} batchMesh - A reference to batched mesh.
   */
  constructor(batchMesh) {
    super("void");
    this.batchMesh = batchMesh;
    this.batchingIdNode = null;
  }
  /**
   * Setups the internal buffers and nodes and assigns the transformed vertex data
   * to predefined node variables for accumulation. That follows the same patterns
   * like with morph and skinning nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    if (this.batchingIdNode === null) {
      if (builder.getDrawIndex() === null) {
        this.batchingIdNode = instanceIndex;
      } else {
        this.batchingIdNode = drawIndex;
      }
    }
    const getIndirectIndex = Fn(([id]) => {
      const size2 = int(
        textureSize(textureLoad(this.batchMesh._indirectTexture), 0).x
      );
      const x2 = int(id).mod(size2);
      const y2 = int(id).div(size2);
      return textureLoad(this.batchMesh._indirectTexture, ivec2(x2, y2)).x;
    }).setLayout({
      name: "getIndirectIndex",
      type: "uint",
      inputs: [{ name: "id", type: "int" }],
    });
    const indirectId = getIndirectIndex(int(this.batchingIdNode));
    const matricesTexture = this.batchMesh._matricesTexture;
    const size = int(textureSize(textureLoad(matricesTexture), 0).x);
    const j = float(indirectId).mul(4).toInt().toVar();
    const x = j.mod(size);
    const y = j.div(size);
    const batchingMatrix = mat4(
      textureLoad(matricesTexture, ivec2(x, y)),
      textureLoad(matricesTexture, ivec2(x.add(1), y)),
      textureLoad(matricesTexture, ivec2(x.add(2), y)),
      textureLoad(matricesTexture, ivec2(x.add(3), y))
    );
    const colorsTexture = this.batchMesh._colorsTexture;
    if (colorsTexture !== null) {
      const getBatchingColor = Fn(([id]) => {
        const size2 = int(textureSize(textureLoad(colorsTexture), 0).x);
        const j2 = id;
        const x2 = j2.mod(size2);
        const y2 = j2.div(size2);
        return textureLoad(colorsTexture, ivec2(x2, y2)).rgb;
      }).setLayout({
        name: "getBatchingColor",
        type: "vec3",
        inputs: [{ name: "id", type: "int" }],
      });
      const color2 = getBatchingColor(indirectId);
      varyingProperty("vec3", "vBatchColor").assign(color2);
    }
    const bm = mat3(batchingMatrix);
    positionLocal$1.assign(batchingMatrix.mul(positionLocal$1));
    const transformedNormal = normalLocal.div(
      vec3(bm[0].dot(bm[0]), bm[1].dot(bm[1]), bm[2].dot(bm[2]))
    );
    const batchingNormal = bm.mul(transformedNormal).xyz;
    normalLocal.assign(batchingNormal);
    if (builder.hasGeometryAttribute("tangent")) {
      tangentLocal.mulAssign(bm);
    }
  }
}
const batch = /* @__PURE__ */ nodeProxy(BatchNode).setParameterLength(1);
class StorageArrayElementNode extends ArrayElementNode {
  static get type() {
    return "StorageArrayElementNode";
  }
  /**
   * Constructs storage buffer element node.
   *
   * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(storageBufferNode, indexNode) {
    super(storageBufferNode, indexNode);
    this.isStorageArrayElementNode = true;
  }
  /**
   * The storage buffer node.
   *
   * @param {Node} value
   * @type {StorageBufferNode}
   */
  set storageBufferNode(value) {
    this.node = value;
  }
  get storageBufferNode() {
    return this.node;
  }
  getMemberType(builder, name) {
    const structTypeNode = this.storageBufferNode.structTypeNode;
    if (structTypeNode) {
      return structTypeNode.getMemberType(builder, name);
    }
    return "void";
  }
  setup(builder) {
    if (builder.isAvailable("storageBuffer") === false) {
      if (this.node.isPBO === true) {
        builder.setupPBO(this.node);
      }
    }
    return super.setup(builder);
  }
  generate(builder, output2) {
    let snippet;
    const isAssignContext = builder.context.assign;
    if (builder.isAvailable("storageBuffer") === false) {
      if (
        this.node.isPBO === true &&
        isAssignContext !== true &&
        (this.node.value.isInstancedBufferAttribute ||
          builder.shaderStage !== "compute")
      ) {
        snippet = builder.generatePBO(this);
      } else {
        snippet = this.node.build(builder);
      }
    } else {
      snippet = super.generate(builder);
    }
    if (isAssignContext !== true) {
      const type = this.getNodeType(builder);
      snippet = builder.format(snippet, type, output2);
    }
    return snippet;
  }
}
const storageElement = /* @__PURE__ */ nodeProxy(
  StorageArrayElementNode
).setParameterLength(2);
class StorageBufferNode extends BufferNode {
  static get type() {
    return "StorageBufferNode";
  }
  /**
   * Constructs a new storage buffer node.
   *
   * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.
   * @param {?(string|Struct)} [bufferType=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [bufferCount=0] - The buffer count.
   */
  constructor(value, bufferType = null, bufferCount = 0) {
    let nodeType,
      structTypeNode = null;
    if (bufferType && bufferType.isStruct) {
      nodeType = "struct";
      structTypeNode = bufferType.layout;
      if (
        value.isStorageBufferAttribute ||
        value.isStorageInstancedBufferAttribute
      ) {
        bufferCount = value.count;
      }
    } else if (
      bufferType === null &&
      (value.isStorageBufferAttribute ||
        value.isStorageInstancedBufferAttribute)
    ) {
      nodeType = getTypeFromLength(value.itemSize);
      bufferCount = value.count;
    } else {
      nodeType = bufferType;
    }
    super(value, nodeType, bufferCount);
    this.isStorageBufferNode = true;
    this.structTypeNode = structTypeNode;
    this.access = NodeAccess.READ_WRITE;
    this.isAtomic = false;
    this.isPBO = false;
    this._attribute = null;
    this._varying = null;
    this.global = true;
    if (
      value.isStorageBufferAttribute !== true &&
      value.isStorageInstancedBufferAttribute !== true
    ) {
      if (value.isInstancedBufferAttribute)
        value.isStorageInstancedBufferAttribute = true;
      else value.isStorageBufferAttribute = true;
    }
  }
  /**
   * This method is overwritten since the buffer data might be shared
   * and thus the hash should be shared as well.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(builder) {
    if (this.bufferCount === 0) {
      let bufferData = builder.globalCache.getData(this.value);
      if (bufferData === void 0) {
        bufferData = {
          node: this,
        };
        builder.globalCache.setData(this.value, bufferData);
      }
      return bufferData.node.uuid;
    }
    return this.uuid;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'indirectStorageBuffer'` or `'storageBuffer'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return this.value.isIndirectStorageBufferAttribute
      ? "indirectStorageBuffer"
      : "storageBuffer";
  }
  /**
   * Enables element access with the given index node.
   *
   * @param {IndexNode} indexNode - The index node.
   * @return {StorageArrayElementNode} A node representing the element access.
   */
  element(indexNode) {
    return storageElement(this, indexNode);
  }
  /**
   * Defines whether this node is a PBO or not. Only relevant for WebGL.
   *
   * @param {boolean} value - The value so set.
   * @return {StorageBufferNode} A reference to this node.
   */
  setPBO(value) {
    this.isPBO = value;
    return this;
  }
  /**
   * Returns the `isPBO` value.
   *
   * @return {boolean} Whether the node represents a PBO or not.
   */
  getPBO() {
    return this.isPBO;
  }
  /**
   * Defines the node access.
   *
   * @param {string} value - The node access.
   * @return {StorageBufferNode} A reference to this node.
   */
  setAccess(value) {
    this.access = value;
    return this;
  }
  /**
   * Convenience method for configuring a read-only node access.
   *
   * @return {StorageBufferNode} A reference to this node.
   */
  toReadOnly() {
    return this.setAccess(NodeAccess.READ_ONLY);
  }
  /**
   * Defines whether the node is atomic or not.
   *
   * @param {boolean} value - The atomic flag.
   * @return {StorageBufferNode} A reference to this node.
   */
  setAtomic(value) {
    this.isAtomic = value;
    return this;
  }
  /**
   * Convenience method for making this node atomic.
   *
   * @return {StorageBufferNode} A reference to this node.
   */
  toAtomic() {
    return this.setAtomic(true);
  }
  /**
   * Returns attribute data for this storage buffer node.
   *
   * @return {{attribute: BufferAttributeNode, varying: VaryingNode}} The attribute data.
   */
  getAttributeData() {
    if (this._attribute === null) {
      this._attribute = bufferAttribute(this.value);
      this._varying = varying(this._attribute);
    }
    return {
      attribute: this._attribute,
      varying: this._varying,
    };
  }
  /**
   * This method is overwritten since the node type from the availability of storage buffers
   * and the attribute data.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.structTypeNode !== null) {
      return this.structTypeNode.getNodeType(builder);
    }
    if (
      builder.isAvailable("storageBuffer") ||
      builder.isAvailable("indirectStorageBuffer")
    ) {
      return super.getNodeType(builder);
    }
    const { attribute: attribute2 } = this.getAttributeData();
    return attribute2.getNodeType(builder);
  }
  /**
   * Returns the type of a member of the struct.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the member.
   */
  getMemberType(builder, name) {
    if (this.structTypeNode !== null) {
      return this.structTypeNode.getMemberType(builder, name);
    }
    return "void";
  }
  /**
   * Generates the code snippet of the storage buffer node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(builder) {
    if (this.structTypeNode !== null) this.structTypeNode.build(builder);
    if (
      builder.isAvailable("storageBuffer") ||
      builder.isAvailable("indirectStorageBuffer")
    ) {
      return super.generate(builder);
    }
    const { attribute: attribute2, varying: varying2 } =
      this.getAttributeData();
    const output2 = varying2.build(builder);
    builder.registerTransform(output2, attribute2);
    return output2;
  }
}
const storage = (value, type = null, count = 0) =>
  nodeObject(new StorageBufferNode(value, type, count));
const storageObject = (value, type, count) => {
  console.warn(
    'THREE.TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.'
  );
  return storage(value, type, count).setPBO(true);
};
const _frameId = /* @__PURE__ */ new WeakMap();
class SkinningNode extends Node {
  static get type() {
    return "SkinningNode";
  }
  /**
   * Constructs a new skinning node.
   *
   * @param {SkinnedMesh} skinnedMesh - The skinned mesh.
   */
  constructor(skinnedMesh) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.updateType = NodeUpdateType.OBJECT;
    this.skinIndexNode = attribute("skinIndex", "uvec4");
    this.skinWeightNode = attribute("skinWeight", "vec4");
    this.bindMatrixNode = reference("bindMatrix", "mat4");
    this.bindMatrixInverseNode = reference("bindMatrixInverse", "mat4");
    this.boneMatricesNode = referenceBuffer(
      "skeleton.boneMatrices",
      "mat4",
      skinnedMesh.skeleton.bones.length
    );
    this.positionNode = positionLocal$1;
    this.toPositionNode = positionLocal$1;
    this.previousBoneMatricesNode = null;
  }
  /**
   * Transforms the given vertex position via skinning.
   *
   * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
   * @param {Node<vec3>} [position=this.positionNode] - The vertex position in local space.
   * @return {Node<vec3>} The transformed vertex position.
   */
  getSkinnedPosition(
    boneMatrices = this.boneMatricesNode,
    position = this.positionNode
  ) {
    const {
      skinIndexNode,
      skinWeightNode,
      bindMatrixNode,
      bindMatrixInverseNode,
    } = this;
    const boneMatX = boneMatrices.element(skinIndexNode.x);
    const boneMatY = boneMatrices.element(skinIndexNode.y);
    const boneMatZ = boneMatrices.element(skinIndexNode.z);
    const boneMatW = boneMatrices.element(skinIndexNode.w);
    const skinVertex = bindMatrixNode.mul(position);
    const skinned = add(
      boneMatX.mul(skinWeightNode.x).mul(skinVertex),
      boneMatY.mul(skinWeightNode.y).mul(skinVertex),
      boneMatZ.mul(skinWeightNode.z).mul(skinVertex),
      boneMatW.mul(skinWeightNode.w).mul(skinVertex)
    );
    return bindMatrixInverseNode.mul(skinned).xyz;
  }
  /**
   * Transforms the given vertex normal via skinning.
   *
   * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
   * @param {Node<vec3>} [normal=normalLocal] - The vertex normal in local space.
   * @return {Node<vec3>} The transformed vertex normal.
   */
  getSkinnedNormal(
    boneMatrices = this.boneMatricesNode,
    normal2 = normalLocal
  ) {
    const {
      skinIndexNode,
      skinWeightNode,
      bindMatrixNode,
      bindMatrixInverseNode,
    } = this;
    const boneMatX = boneMatrices.element(skinIndexNode.x);
    const boneMatY = boneMatrices.element(skinIndexNode.y);
    const boneMatZ = boneMatrices.element(skinIndexNode.z);
    const boneMatW = boneMatrices.element(skinIndexNode.w);
    let skinMatrix = add(
      skinWeightNode.x.mul(boneMatX),
      skinWeightNode.y.mul(boneMatY),
      skinWeightNode.z.mul(boneMatZ),
      skinWeightNode.w.mul(boneMatW)
    );
    skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);
    return skinMatrix.transformDirection(normal2).xyz;
  }
  /**
   * Computes the transformed/skinned vertex position of the previous frame.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The skinned position from the previous frame.
   */
  getPreviousSkinnedPosition(builder) {
    const skinnedMesh = builder.object;
    if (this.previousBoneMatricesNode === null) {
      skinnedMesh.skeleton.previousBoneMatrices = new Float32Array(
        skinnedMesh.skeleton.boneMatrices
      );
      this.previousBoneMatricesNode = referenceBuffer(
        "skeleton.previousBoneMatrices",
        "mat4",
        skinnedMesh.skeleton.bones.length
      );
    }
    return this.getSkinnedPosition(
      this.previousBoneMatricesNode,
      positionPrevious
    );
  }
  /**
   * Returns `true` if bone matrices from the previous frame are required. Relevant
   * when computing motion vectors with {@link VelocityNode}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether bone matrices from the previous frame are required or not.
   */
  needsPreviousBoneMatrices(builder) {
    const mrt2 = builder.renderer.getMRT();
    return (
      (mrt2 && mrt2.has("velocity")) ||
      getDataFromObject(builder.object).useVelocity === true
    );
  }
  /**
   * Setups the skinning node by assigning the transformed vertex data to predefined node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The transformed vertex position.
   */
  setup(builder) {
    if (this.needsPreviousBoneMatrices(builder)) {
      positionPrevious.assign(this.getPreviousSkinnedPosition(builder));
    }
    const skinPosition = this.getSkinnedPosition();
    if (this.toPositionNode) this.toPositionNode.assign(skinPosition);
    if (builder.hasGeometryAttribute("normal")) {
      const skinNormal = this.getSkinnedNormal();
      normalLocal.assign(skinNormal);
      if (builder.hasGeometryAttribute("tangent")) {
        tangentLocal.assign(skinNormal);
      }
    }
    return skinPosition;
  }
  /**
   * Generates the code snippet of the skinning node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(builder, output2) {
    if (output2 !== "void") {
      return super.generate(builder, output2);
    }
  }
  /**
   * Updates the state of the skinned mesh by updating the skeleton once per frame.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(frame) {
    const skeleton =
      frame.object && frame.object.skeleton
        ? frame.object.skeleton
        : this.skinnedMesh.skeleton;
    if (_frameId.get(skeleton) === frame.frameId) return;
    _frameId.set(skeleton, frame.frameId);
    if (this.previousBoneMatricesNode !== null)
      skeleton.previousBoneMatrices.set(skeleton.boneMatrices);
    skeleton.update();
  }
}
const skinning = (skinnedMesh) => nodeObject(new SkinningNode(skinnedMesh));
const computeSkinning = (skinnedMesh, toPosition = null) => {
  const node = new SkinningNode(skinnedMesh);
  node.positionNode = storage(
    new InstancedBufferAttribute(
      skinnedMesh.geometry.getAttribute("position").array,
      3
    ),
    "vec3"
  )
    .setPBO(true)
    .toReadOnly()
    .element(instanceIndex)
    .toVar();
  node.skinIndexNode = storage(
    new InstancedBufferAttribute(
      new Uint32Array(skinnedMesh.geometry.getAttribute("skinIndex").array),
      4
    ),
    "uvec4"
  )
    .setPBO(true)
    .toReadOnly()
    .element(instanceIndex)
    .toVar();
  node.skinWeightNode = storage(
    new InstancedBufferAttribute(
      skinnedMesh.geometry.getAttribute("skinWeight").array,
      4
    ),
    "vec4"
  )
    .setPBO(true)
    .toReadOnly()
    .element(instanceIndex)
    .toVar();
  node.bindMatrixNode = uniform$1(skinnedMesh.bindMatrix, "mat4");
  node.bindMatrixInverseNode = uniform$1(skinnedMesh.bindMatrixInverse, "mat4");
  node.boneMatricesNode = buffer(
    skinnedMesh.skeleton.boneMatrices,
    "mat4",
    skinnedMesh.skeleton.bones.length
  );
  node.toPositionNode = toPosition;
  return nodeObject(node);
};
class LoopNode extends Node {
  static get type() {
    return "LoopNode";
  }
  /**
   * Constructs a new loop node.
   *
   * @param {Array<any>} params - Depending on the loop type, array holds different parameterization values for the loop.
   */
  constructor(params = []) {
    super();
    this.params = params;
  }
  /**
   * Returns a loop variable name based on an index. The pattern is
   * `0` = `i`, `1`= `j`, `2`= `k` and so on.
   *
   * @param {number} index - The index.
   * @return {string} The loop variable name.
   */
  getVarName(index) {
    return String.fromCharCode("i".charCodeAt(0) + index);
  }
  /**
   * Returns properties about this node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Object} The node properties.
   */
  getProperties(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.stackNode !== void 0) return properties;
    const inputs = {};
    for (let i2 = 0, l2 = this.params.length - 1; i2 < l2; i2++) {
      const param = this.params[i2];
      const name = (param.isNode !== true && param.name) || this.getVarName(i2);
      const type = (param.isNode !== true && param.type) || "int";
      inputs[name] = expression(name, type);
    }
    const stack2 = builder.addStack();
    properties.returnsNode = this.params[this.params.length - 1](
      inputs,
      builder
    );
    properties.stackNode = stack2;
    const baseParam = this.params[0];
    if (baseParam.isNode !== true && typeof baseParam.update === "function") {
      properties.updateNode = Fn(this.params[0].update)(inputs);
    }
    builder.removeStack();
    return properties;
  }
  /**
   * This method is overwritten since the node type is inferred based on the loop configuration.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const { returnsNode } = this.getProperties(builder);
    return returnsNode ? returnsNode.getNodeType(builder) : "void";
  }
  setup(builder) {
    this.getProperties(builder);
  }
  generate(builder) {
    const properties = this.getProperties(builder);
    const params = this.params;
    const stackNode = properties.stackNode;
    for (let i2 = 0, l2 = params.length - 1; i2 < l2; i2++) {
      const param = params[i2];
      let isWhile = false,
        start = null,
        end = null,
        name = null,
        type = null,
        condition = null,
        update = null;
      if (param.isNode) {
        if (param.getNodeType(builder) === "bool") {
          isWhile = true;
          type = "bool";
          end = param.build(builder, type);
        } else {
          type = "int";
          name = this.getVarName(i2);
          start = "0";
          end = param.build(builder, type);
          condition = "<";
        }
      } else {
        type = param.type || "int";
        name = param.name || this.getVarName(i2);
        start = param.start;
        end = param.end;
        condition = param.condition;
        update = param.update;
        if (typeof start === "number")
          start = builder.generateConst(type, start);
        else if (start && start.isNode) start = start.build(builder, type);
        if (typeof end === "number") end = builder.generateConst(type, end);
        else if (end && end.isNode) end = end.build(builder, type);
        if (start !== void 0 && end === void 0) {
          start = start + " - 1";
          end = "0";
          condition = ">=";
        } else if (end !== void 0 && start === void 0) {
          start = "0";
          condition = "<";
        }
        if (condition === void 0) {
          if (Number(start) > Number(end)) {
            condition = ">=";
          } else {
            condition = "<";
          }
        }
      }
      let loopSnippet;
      if (isWhile) {
        loopSnippet = `while ( ${end} )`;
      } else {
        const internalParam = { start, end };
        const startSnippet = internalParam.start;
        const endSnippet = internalParam.end;
        let updateSnippet;
        const deltaOperator = () => (condition.includes("<") ? "+=" : "-=");
        if (update !== void 0 && update !== null) {
          switch (typeof update) {
            case "function":
              const flow = builder.flowStagesNode(
                properties.updateNode,
                "void"
              );
              const snippet = flow.code.replace(/\t|;/g, "");
              updateSnippet = snippet;
              break;
            case "number":
              updateSnippet =
                name +
                " " +
                deltaOperator() +
                " " +
                builder.generateConst(type, update);
              break;
            case "string":
              updateSnippet = name + " " + update;
              break;
            default:
              if (update.isNode) {
                updateSnippet =
                  name + " " + deltaOperator() + " " + update.build(builder);
              } else {
                console.error(
                  "THREE.TSL: 'Loop( { update: ... } )' is not a function, string or number."
                );
                updateSnippet = "break /* invalid update */";
              }
          }
        } else {
          if (type === "int" || type === "uint") {
            update = condition.includes("<") ? "++" : "--";
          } else {
            update = deltaOperator() + " 1.";
          }
          updateSnippet = name + " " + update;
        }
        const declarationSnippet =
          builder.getVar(type, name) + " = " + startSnippet;
        const conditionalSnippet = name + " " + condition + " " + endSnippet;
        loopSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;
      }
      builder
        .addFlowCode(
          (i2 === 0 ? "\n" : "") + builder.tab + loopSnippet + " {\n\n"
        )
        .addFlowTab();
    }
    const stackSnippet = stackNode.build(builder, "void");
    const returnsSnippet = properties.returnsNode
      ? properties.returnsNode.build(builder)
      : "";
    builder.removeFlowTab().addFlowCode("\n" + builder.tab + stackSnippet);
    for (let i2 = 0, l2 = this.params.length - 1; i2 < l2; i2++) {
      builder
        .addFlowCode((i2 === 0 ? "" : builder.tab) + "}\n\n")
        .removeFlowTab();
    }
    builder.addFlowTab();
    return returnsSnippet;
  }
}
const Loop = (...params) =>
  nodeObject(new LoopNode(nodeArray(params, "int"))).toStack();
const Continue = () => expression("continue").toStack();
const Break = () => expression("break").toStack();
const _morphTextures = /* @__PURE__ */ new WeakMap();
const _morphVec4 = /* @__PURE__ */ new Vector4();
const getMorph = /* @__PURE__ */ Fn(
  ({ bufferMap, influence, stride, width, depth: depth2, offset }) => {
    const texelIndex = int(vertexIndex).mul(stride).add(offset);
    const y = texelIndex.div(width);
    const x = texelIndex.sub(y.mul(width));
    const bufferAttrib = textureLoad(bufferMap, ivec2(x, y)).depth(depth2).xyz;
    return bufferAttrib.mul(influence);
  }
);
function getEntry(geometry) {
  const hasMorphPosition = geometry.morphAttributes.position !== void 0;
  const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
  const hasMorphColors = geometry.morphAttributes.color !== void 0;
  const morphAttribute =
    geometry.morphAttributes.position ||
    geometry.morphAttributes.normal ||
    geometry.morphAttributes.color;
  const morphTargetsCount =
    morphAttribute !== void 0 ? morphAttribute.length : 0;
  let entry = _morphTextures.get(geometry);
  if (entry === void 0 || entry.count !== morphTargetsCount) {
    let disposeTexture = function () {
      bufferTexture.dispose();
      _morphTextures.delete(geometry);
      geometry.removeEventListener("dispose", disposeTexture);
    };
    if (entry !== void 0) entry.texture.dispose();
    const morphTargets = geometry.morphAttributes.position || [];
    const morphNormals = geometry.morphAttributes.normal || [];
    const morphColors = geometry.morphAttributes.color || [];
    let vertexDataCount = 0;
    if (hasMorphPosition === true) vertexDataCount = 1;
    if (hasMorphNormals === true) vertexDataCount = 2;
    if (hasMorphColors === true) vertexDataCount = 3;
    let width = geometry.attributes.position.count * vertexDataCount;
    let height = 1;
    const maxTextureSize = 4096;
    if (width > maxTextureSize) {
      height = Math.ceil(width / maxTextureSize);
      width = maxTextureSize;
    }
    const buffer2 = new Float32Array(width * height * 4 * morphTargetsCount);
    const bufferTexture = new DataArrayTexture(
      buffer2,
      width,
      height,
      morphTargetsCount
    );
    bufferTexture.type = FloatType;
    bufferTexture.needsUpdate = true;
    const vertexDataStride = vertexDataCount * 4;
    for (let i2 = 0; i2 < morphTargetsCount; i2++) {
      const morphTarget = morphTargets[i2];
      const morphNormal = morphNormals[i2];
      const morphColor = morphColors[i2];
      const offset = width * height * 4 * i2;
      for (let j = 0; j < morphTarget.count; j++) {
        const stride = j * vertexDataStride;
        if (hasMorphPosition === true) {
          _morphVec4.fromBufferAttribute(morphTarget, j);
          buffer2[offset + stride + 0] = _morphVec4.x;
          buffer2[offset + stride + 1] = _morphVec4.y;
          buffer2[offset + stride + 2] = _morphVec4.z;
          buffer2[offset + stride + 3] = 0;
        }
        if (hasMorphNormals === true) {
          _morphVec4.fromBufferAttribute(morphNormal, j);
          buffer2[offset + stride + 4] = _morphVec4.x;
          buffer2[offset + stride + 5] = _morphVec4.y;
          buffer2[offset + stride + 6] = _morphVec4.z;
          buffer2[offset + stride + 7] = 0;
        }
        if (hasMorphColors === true) {
          _morphVec4.fromBufferAttribute(morphColor, j);
          buffer2[offset + stride + 8] = _morphVec4.x;
          buffer2[offset + stride + 9] = _morphVec4.y;
          buffer2[offset + stride + 10] = _morphVec4.z;
          buffer2[offset + stride + 11] =
            morphColor.itemSize === 4 ? _morphVec4.w : 1;
        }
      }
    }
    entry = {
      count: morphTargetsCount,
      texture: bufferTexture,
      stride: vertexDataCount,
      size: new Vector2(width, height),
    };
    _morphTextures.set(geometry, entry);
    geometry.addEventListener("dispose", disposeTexture);
  }
  return entry;
}
class MorphNode extends Node {
  static get type() {
    return "MorphNode";
  }
  /**
   * Constructs a new morph node.
   *
   * @param {Mesh} mesh - The mesh holding the morph targets.
   */
  constructor(mesh) {
    super("void");
    this.mesh = mesh;
    this.morphBaseInfluence = uniform$1(1);
    this.updateType = NodeUpdateType.OBJECT;
  }
  /**
   * Setups the morph node by assigning the transformed vertex data to predefined node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    const { geometry } = builder;
    const hasMorphPosition = geometry.morphAttributes.position !== void 0;
    const hasMorphNormals =
      geometry.hasAttribute("normal") &&
      geometry.morphAttributes.normal !== void 0;
    const morphAttribute =
      geometry.morphAttributes.position ||
      geometry.morphAttributes.normal ||
      geometry.morphAttributes.color;
    const morphTargetsCount =
      morphAttribute !== void 0 ? morphAttribute.length : 0;
    const { texture: bufferMap, stride, size } = getEntry(geometry);
    if (hasMorphPosition === true)
      positionLocal$1.mulAssign(this.morphBaseInfluence);
    if (hasMorphNormals === true)
      normalLocal.mulAssign(this.morphBaseInfluence);
    const width = int(size.width);
    Loop(morphTargetsCount, ({ i: i2 }) => {
      const influence = float(0).toVar();
      if (
        this.mesh.count > 1 &&
        this.mesh.morphTexture !== null &&
        this.mesh.morphTexture !== void 0
      ) {
        influence.assign(
          textureLoad(
            this.mesh.morphTexture,
            ivec2(int(i2).add(1), int(instanceIndex))
          ).r
        );
      } else {
        influence.assign(
          reference("morphTargetInfluences", "float").element(i2).toVar()
        );
      }
      If(influence.notEqual(0), () => {
        if (hasMorphPosition === true) {
          positionLocal$1.addAssign(
            getMorph({
              bufferMap,
              influence,
              stride,
              width,
              depth: i2,
              offset: int(0),
            })
          );
        }
        if (hasMorphNormals === true) {
          normalLocal.addAssign(
            getMorph({
              bufferMap,
              influence,
              stride,
              width,
              depth: i2,
              offset: int(1),
            })
          );
        }
      });
    });
  }
  /**
   * Updates the state of the morphed mesh by updating the base influence.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update() {
    const morphBaseInfluence = this.morphBaseInfluence;
    if (this.mesh.geometry.morphTargetsRelative) {
      morphBaseInfluence.value = 1;
    } else {
      morphBaseInfluence.value =
        1 - this.mesh.morphTargetInfluences.reduce((a2, b) => a2 + b, 0);
    }
  }
}
const morphReference =
  /* @__PURE__ */ nodeProxy(MorphNode).setParameterLength(1);
class LightingNode extends Node {
  static get type() {
    return "LightingNode";
  }
  /**
   * Constructs a new lighting node.
   */
  constructor() {
    super("vec3");
    this.isLightingNode = true;
  }
}
class AONode extends LightingNode {
  static get type() {
    return "AONode";
  }
  /**
   * Constructs a new AO node.
   *
   * @param {?Node<float>} [aoNode=null] - The ambient occlusion node.
   */
  constructor(aoNode = null) {
    super();
    this.aoNode = aoNode;
  }
  setup(builder) {
    builder.context.ambientOcclusion.mulAssign(this.aoNode);
  }
}
class LightingContextNode extends ContextNode {
  static get type() {
    return "LightingContextNode";
  }
  /**
   * Constructs a new lighting context node.
   *
   * @param {LightsNode} lightsNode - The lights node.
   * @param {?LightingModel} [lightingModel=null] - The current lighting model.
   * @param {?Node<vec3>} [backdropNode=null] - A backdrop node.
   * @param {?Node<float>} [backdropAlphaNode=null] - A backdrop alpha node.
   */
  constructor(
    lightsNode,
    lightingModel = null,
    backdropNode = null,
    backdropAlphaNode = null
  ) {
    super(lightsNode);
    this.lightingModel = lightingModel;
    this.backdropNode = backdropNode;
    this.backdropAlphaNode = backdropAlphaNode;
    this._value = null;
  }
  /**
   * Returns a lighting context object.
   *
   * @return {{
   * radiance: Node<vec3>,
   * irradiance: Node<vec3>,
   * iblIrradiance: Node<vec3>,
   * ambientOcclusion: Node<float>,
   * reflectedLight: {directDiffuse: Node<vec3>, directSpecular: Node<vec3>, indirectDiffuse: Node<vec3>, indirectSpecular: Node<vec3>},
   * backdrop: Node<vec3>,
   * backdropAlpha: Node<float>
   * }} The lighting context object.
   */
  getContext() {
    const { backdropNode, backdropAlphaNode } = this;
    const directDiffuse = vec3().toVar("directDiffuse"),
      directSpecular = vec3().toVar("directSpecular"),
      indirectDiffuse = vec3().toVar("indirectDiffuse"),
      indirectSpecular = vec3().toVar("indirectSpecular");
    const reflectedLight = {
      directDiffuse,
      directSpecular,
      indirectDiffuse,
      indirectSpecular,
    };
    const context2 = {
      radiance: vec3().toVar("radiance"),
      irradiance: vec3().toVar("irradiance"),
      iblIrradiance: vec3().toVar("iblIrradiance"),
      ambientOcclusion: float(1).toVar("ambientOcclusion"),
      reflectedLight,
      backdrop: backdropNode,
      backdropAlpha: backdropAlphaNode,
    };
    return context2;
  }
  setup(builder) {
    this.value = this._value || (this._value = this.getContext());
    this.value.lightingModel =
      this.lightingModel || builder.context.lightingModel;
    return super.setup(builder);
  }
}
const lightingContext = /* @__PURE__ */ nodeProxy(LightingContextNode);
class IrradianceNode extends LightingNode {
  static get type() {
    return "IrradianceNode";
  }
  /**
   * Constructs a new irradiance node.
   *
   * @param {Node<vec3>} node - A node contributing irradiance.
   */
  constructor(node) {
    super();
    this.node = node;
  }
  setup(builder) {
    builder.context.irradiance.addAssign(this.node);
  }
}
let screenSizeVec, viewportVec;
class ScreenNode extends Node {
  static get type() {
    return "ScreenNode";
  }
  /**
   * Constructs a new screen node.
   *
   * @param {('coordinate'|'viewport'|'size'|'uv')} scope - The node's scope.
   */
  constructor(scope) {
    super();
    this.scope = scope;
    this.isViewportNode = true;
  }
  /**
   * This method is overwritten since the node type depends on the selected scope.
   *
   * @return {('vec2'|'vec4')} The node type.
   */
  getNodeType() {
    if (this.scope === ScreenNode.VIEWPORT) return "vec4";
    else return "vec2";
  }
  /**
   * This method is overwritten since the node's update type depends on the selected scope.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateType() {
    let updateType = NodeUpdateType.NONE;
    if (this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT) {
      updateType = NodeUpdateType.RENDER;
    }
    this.updateType = updateType;
    return updateType;
  }
  /**
   * `ScreenNode` implements {@link Node#update} to retrieve viewport and size information
   * from the current renderer.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update({ renderer: renderer2 }) {
    const renderTarget = renderer2.getRenderTarget();
    if (this.scope === ScreenNode.VIEWPORT) {
      if (renderTarget !== null) {
        viewportVec.copy(renderTarget.viewport);
      } else {
        renderer2.getViewport(viewportVec);
        viewportVec.multiplyScalar(renderer2.getPixelRatio());
      }
    } else {
      if (renderTarget !== null) {
        screenSizeVec.width = renderTarget.width;
        screenSizeVec.height = renderTarget.height;
      } else {
        renderer2.getDrawingBufferSize(screenSizeVec);
      }
    }
  }
  setup() {
    const scope = this.scope;
    let output2 = null;
    if (scope === ScreenNode.SIZE) {
      output2 = uniform$1(screenSizeVec || (screenSizeVec = new Vector2()));
    } else if (scope === ScreenNode.VIEWPORT) {
      output2 = uniform$1(viewportVec || (viewportVec = new Vector4()));
    } else {
      output2 = vec2(screenCoordinate.div(screenSize));
    }
    return output2;
  }
  generate(builder) {
    if (this.scope === ScreenNode.COORDINATE) {
      let coord = builder.getFragCoord();
      if (builder.isFlipY()) {
        const size = builder
          .getNodeProperties(screenSize)
          .outputNode.build(builder);
        coord = `${builder.getType(
          "vec2"
        )}( ${coord}.x, ${size}.y - ${coord}.y )`;
      }
      return coord;
    }
    return super.generate(builder);
  }
}
ScreenNode.COORDINATE = "coordinate";
ScreenNode.VIEWPORT = "viewport";
ScreenNode.SIZE = "size";
ScreenNode.UV = "uv";
const screenUV = /* @__PURE__ */ nodeImmutable(ScreenNode, ScreenNode.UV);
const screenSize = /* @__PURE__ */ nodeImmutable(ScreenNode, ScreenNode.SIZE);
const screenCoordinate = /* @__PURE__ */ nodeImmutable(
  ScreenNode,
  ScreenNode.COORDINATE
);
const viewport = /* @__PURE__ */ nodeImmutable(ScreenNode, ScreenNode.VIEWPORT);
const viewportSize = viewport.zw;
const viewportCoordinate = /* @__PURE__ */ screenCoordinate.sub(viewport.xy);
const viewportUV = /* @__PURE__ */ viewportCoordinate.div(viewportSize);
const viewportResolution = /* @__PURE__ */ Fn(() => {
  console.warn(
    'THREE.TSL: "viewportResolution" is deprecated. Use "screenSize" instead.'
  );
  return screenSize;
}, "vec2").once()();
const _size$4 = /* @__PURE__ */ new Vector2();
class ViewportTextureNode extends TextureNode {
  static get type() {
    return "ViewportTextureNode";
  }
  /**
   * Constructs a new viewport texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   * @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
   */
  constructor(uvNode = screenUV, levelNode = null, framebufferTexture = null) {
    let defaultFramebuffer = null;
    if (framebufferTexture === null) {
      defaultFramebuffer = new FramebufferTexture();
      defaultFramebuffer.minFilter = LinearMipmapLinearFilter;
      framebufferTexture = defaultFramebuffer;
    } else {
      defaultFramebuffer = framebufferTexture;
    }
    super(framebufferTexture, uvNode, levelNode);
    this.generateMipmaps = false;
    this.defaultFramebuffer = defaultFramebuffer;
    this.isOutputTextureNode = true;
    this.updateBeforeType = NodeUpdateType.RENDER;
    this._textures = /* @__PURE__ */ new WeakMap();
  }
  getFrameBufferTexture(reference2 = null) {
    const defaultFramebuffer = this.referenceNode
      ? this.referenceNode.defaultFramebuffer
      : this.defaultFramebuffer;
    if (reference2 === null) {
      return defaultFramebuffer;
    }
    if (this._textures.has(reference2) === false) {
      const framebufferTexture = defaultFramebuffer.clone();
      this._textures.set(reference2, framebufferTexture);
    }
    return this._textures.get(reference2);
  }
  updateBefore(frame) {
    const renderer2 = frame.renderer;
    const renderTarget = renderer2.getRenderTarget();
    if (renderTarget === null) {
      renderer2.getDrawingBufferSize(_size$4);
    } else {
      _size$4.set(renderTarget.width, renderTarget.height);
    }
    const framebufferTexture = this.getFrameBufferTexture(renderTarget);
    if (
      framebufferTexture.image.width !== _size$4.width ||
      framebufferTexture.image.height !== _size$4.height
    ) {
      framebufferTexture.image.width = _size$4.width;
      framebufferTexture.image.height = _size$4.height;
      framebufferTexture.needsUpdate = true;
    }
    const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
    framebufferTexture.generateMipmaps = this.generateMipmaps;
    renderer2.copyFramebufferToTexture(framebufferTexture);
    framebufferTexture.generateMipmaps = currentGenerateMipmaps;
    this.value = framebufferTexture;
  }
  clone() {
    const viewportTextureNode = new this.constructor(
      this.uvNode,
      this.levelNode,
      this.value
    );
    viewportTextureNode.generateMipmaps = this.generateMipmaps;
    return viewportTextureNode;
  }
}
const viewportTexture = /* @__PURE__ */ nodeProxy(
  ViewportTextureNode
).setParameterLength(0, 3);
const viewportMipTexture = /* @__PURE__ */ nodeProxy(
  ViewportTextureNode,
  null,
  null,
  { generateMipmaps: true }
).setParameterLength(0, 3);
let sharedDepthbuffer = null;
class ViewportDepthTextureNode extends ViewportTextureNode {
  static get type() {
    return "ViewportDepthTextureNode";
  }
  /**
   * Constructs a new viewport depth texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   */
  constructor(uvNode = screenUV, levelNode = null) {
    if (sharedDepthbuffer === null) {
      sharedDepthbuffer = new DepthTexture();
    }
    super(uvNode, levelNode, sharedDepthbuffer);
  }
}
const viewportDepthTexture = /* @__PURE__ */ nodeProxy(
  ViewportDepthTextureNode
).setParameterLength(0, 2);
class ViewportDepthNode extends Node {
  static get type() {
    return "ViewportDepthNode";
  }
  /**
   * Constructs a new viewport depth node.
   *
   * @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.
   * @param {?Node} [valueNode=null] - The value node.
   */
  constructor(scope, valueNode = null) {
    super("float");
    this.scope = scope;
    this.valueNode = valueNode;
    this.isViewportDepthNode = true;
  }
  generate(builder) {
    const { scope } = this;
    if (scope === ViewportDepthNode.DEPTH_BASE) {
      return builder.getFragDepth();
    }
    return super.generate(builder);
  }
  setup({ camera: camera2 }) {
    const { scope } = this;
    const value = this.valueNode;
    let node = null;
    if (scope === ViewportDepthNode.DEPTH_BASE) {
      if (value !== null) {
        node = depthBase().assign(value);
      }
    } else if (scope === ViewportDepthNode.DEPTH) {
      if (camera2.isPerspectiveCamera) {
        node = viewZToPerspectiveDepth(positionView.z, cameraNear, cameraFar);
      } else {
        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
      }
    } else if (scope === ViewportDepthNode.LINEAR_DEPTH) {
      if (value !== null) {
        if (camera2.isPerspectiveCamera) {
          const viewZ = perspectiveDepthToViewZ(value, cameraNear, cameraFar);
          node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
        } else {
          node = value;
        }
      } else {
        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
      }
    }
    return node;
  }
}
ViewportDepthNode.DEPTH_BASE = "depthBase";
ViewportDepthNode.DEPTH = "depth";
ViewportDepthNode.LINEAR_DEPTH = "linearDepth";
const viewZToOrthographicDepth = (viewZ, near, far) =>
  viewZ.add(near).div(near.sub(far));
const orthographicDepthToViewZ = (depth2, near, far) =>
  near.sub(far).mul(depth2).sub(near);
const viewZToPerspectiveDepth = (viewZ, near, far) =>
  near.add(viewZ).mul(far).div(far.sub(near).mul(viewZ));
const perspectiveDepthToViewZ = (depth2, near, far) =>
  near.mul(far).div(far.sub(near).mul(depth2).sub(far));
const viewZToLogarithmicDepth = (viewZ, near, far) => {
  near = near.max(1e-6).toVar();
  const numerator = log2(viewZ.negate().div(near));
  const denominator = log2(far.div(near));
  return numerator.div(denominator);
};
const logarithmicDepthToViewZ = (depth2, near, far) => {
  const exponent = depth2.mul(log(far.div(near)));
  return float(Math.E).pow(exponent).mul(near).negate();
};
const depthBase = /* @__PURE__ */ nodeProxy(
  ViewportDepthNode,
  ViewportDepthNode.DEPTH_BASE
);
const depth = /* @__PURE__ */ nodeImmutable(
  ViewportDepthNode,
  ViewportDepthNode.DEPTH
);
const linearDepth = /* @__PURE__ */ nodeProxy(
  ViewportDepthNode,
  ViewportDepthNode.LINEAR_DEPTH
).setParameterLength(0, 1);
const viewportLinearDepth = /* @__PURE__ */ linearDepth(viewportDepthTexture());
depth.assign = (value) => depthBase(value);
class ClippingNode extends Node {
  static get type() {
    return "ClippingNode";
  }
  /**
   * Constructs a new clipping node.
   *
   * @param {('default'|'hardware'|'alphaToCoverage')} [scope='default'] - The node's scope. Similar to other nodes,
   * the selected scope influences the behavior of the node and what type of code is generated.
   */
  constructor(scope = ClippingNode.DEFAULT) {
    super();
    this.scope = scope;
  }
  /**
   * Setups the node depending on the selected scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The result node.
   */
  setup(builder) {
    super.setup(builder);
    const clippingContext = builder.clippingContext;
    const { intersectionPlanes, unionPlanes } = clippingContext;
    this.hardwareClipping = builder.material.hardwareClipping;
    if (this.scope === ClippingNode.ALPHA_TO_COVERAGE) {
      return this.setupAlphaToCoverage(intersectionPlanes, unionPlanes);
    } else if (this.scope === ClippingNode.HARDWARE) {
      return this.setupHardwareClipping(unionPlanes, builder);
    } else {
      return this.setupDefault(intersectionPlanes, unionPlanes);
    }
  }
  /**
   * Setups alpha to coverage.
   *
   * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @return {Node} The result node.
   */
  setupAlphaToCoverage(intersectionPlanes, unionPlanes) {
    return Fn(() => {
      const distanceToPlane = float().toVar("distanceToPlane");
      const distanceGradient = float().toVar("distanceToGradient");
      const clipOpacity = float(1).toVar("clipOpacity");
      const numUnionPlanes = unionPlanes.length;
      if (this.hardwareClipping === false && numUnionPlanes > 0) {
        const clippingPlanes = uniformArray(unionPlanes);
        Loop(numUnionPlanes, ({ i: i2 }) => {
          const plane = clippingPlanes.element(i2);
          distanceToPlane.assign(
            positionView.dot(plane.xyz).negate().add(plane.w)
          );
          distanceGradient.assign(distanceToPlane.fwidth().div(2));
          clipOpacity.mulAssign(
            smoothstep(
              distanceGradient.negate(),
              distanceGradient,
              distanceToPlane
            )
          );
        });
      }
      const numIntersectionPlanes = intersectionPlanes.length;
      if (numIntersectionPlanes > 0) {
        const clippingPlanes = uniformArray(intersectionPlanes);
        const intersectionClipOpacity = float(1).toVar(
          "intersectionClipOpacity"
        );
        Loop(numIntersectionPlanes, ({ i: i2 }) => {
          const plane = clippingPlanes.element(i2);
          distanceToPlane.assign(
            positionView.dot(plane.xyz).negate().add(plane.w)
          );
          distanceGradient.assign(distanceToPlane.fwidth().div(2));
          intersectionClipOpacity.mulAssign(
            smoothstep(
              distanceGradient.negate(),
              distanceGradient,
              distanceToPlane
            ).oneMinus()
          );
        });
        clipOpacity.mulAssign(intersectionClipOpacity.oneMinus());
      }
      diffuseColor.a.mulAssign(clipOpacity);
      diffuseColor.a.equal(0).discard();
    })();
  }
  /**
   * Setups the default clipping.
   *
   * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @return {Node} The result node.
   */
  setupDefault(intersectionPlanes, unionPlanes) {
    return Fn(() => {
      const numUnionPlanes = unionPlanes.length;
      if (this.hardwareClipping === false && numUnionPlanes > 0) {
        const clippingPlanes = uniformArray(unionPlanes);
        Loop(numUnionPlanes, ({ i: i2 }) => {
          const plane = clippingPlanes.element(i2);
          positionView.dot(plane.xyz).greaterThan(plane.w).discard();
        });
      }
      const numIntersectionPlanes = intersectionPlanes.length;
      if (numIntersectionPlanes > 0) {
        const clippingPlanes = uniformArray(intersectionPlanes);
        const clipped = bool(true).toVar("clipped");
        Loop(numIntersectionPlanes, ({ i: i2 }) => {
          const plane = clippingPlanes.element(i2);
          clipped.assign(
            positionView.dot(plane.xyz).greaterThan(plane.w).and(clipped)
          );
        });
        clipped.discard();
      }
    })();
  }
  /**
   * Setups hardware clipping.
   *
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The result node.
   */
  setupHardwareClipping(unionPlanes, builder) {
    const numUnionPlanes = unionPlanes.length;
    builder.enableHardwareClipping(numUnionPlanes);
    return Fn(() => {
      const clippingPlanes = uniformArray(unionPlanes);
      const hw_clip_distances = builtin(builder.getClipDistance());
      Loop(numUnionPlanes, ({ i: i2 }) => {
        const plane = clippingPlanes.element(i2);
        const distance2 = positionView.dot(plane.xyz).sub(plane.w).negate();
        hw_clip_distances.element(i2).assign(distance2);
      });
    })();
  }
}
ClippingNode.ALPHA_TO_COVERAGE = "alphaToCoverage";
ClippingNode.DEFAULT = "default";
ClippingNode.HARDWARE = "hardware";
const clipping = () => nodeObject(new ClippingNode());
const clippingAlpha = () =>
  nodeObject(new ClippingNode(ClippingNode.ALPHA_TO_COVERAGE));
const hardwareClipping = () =>
  nodeObject(new ClippingNode(ClippingNode.HARDWARE));
const ALPHA_HASH_SCALE = 0.05;
const hash2D = /* @__PURE__ */ Fn(([value]) => {
  return fract(
    mul(1e4, sin(mul(17, value.x).add(mul(0.1, value.y)))).mul(
      add(0.1, abs(sin(mul(13, value.y).add(value.x))))
    )
  );
});
const hash3D = /* @__PURE__ */ Fn(([value]) => {
  return hash2D(vec2(hash2D(value.xy), value.z));
});
const getAlphaHashThreshold = /* @__PURE__ */ Fn(([position]) => {
  const maxDeriv = max$1(
    length(dFdx(position.xyz)),
    length(dFdy(position.xyz))
  );
  const pixScale = float(1)
    .div(float(ALPHA_HASH_SCALE).mul(maxDeriv))
    .toVar("pixScale");
  const pixScales = vec2(
    exp2(floor(log2(pixScale))),
    exp2(ceil(log2(pixScale)))
  );
  const alpha = vec2(
    hash3D(floor(pixScales.x.mul(position.xyz))),
    hash3D(floor(pixScales.y.mul(position.xyz)))
  );
  const lerpFactor = fract(log2(pixScale));
  const x = add(mul(lerpFactor.oneMinus(), alpha.x), mul(lerpFactor, alpha.y));
  const a2 = min$1(lerpFactor, lerpFactor.oneMinus());
  const cases = vec3(
    x.mul(x).div(mul(2, a2).mul(sub(1, a2))),
    x.sub(mul(0.5, a2)).div(sub(1, a2)),
    sub(
      1,
      sub(1, x)
        .mul(sub(1, x))
        .div(mul(2, a2).mul(sub(1, a2)))
    )
  );
  const threshold = x
    .lessThan(a2.oneMinus())
    .select(x.lessThan(a2).select(cases.x, cases.y), cases.z);
  return clamp(threshold, 1e-6, 1);
}).setLayout({
  name: "getAlphaHashThreshold",
  type: "float",
  inputs: [{ name: "position", type: "vec3" }],
});
class VertexColorNode extends AttributeNode {
  static get type() {
    return "VertexColorNode";
  }
  /**
   * Constructs a new vertex color node.
   *
   * @param {number} index - The attribute index.
   */
  constructor(index) {
    super(null, "vec4");
    this.isVertexColorNode = true;
    this.index = index;
  }
  /**
   * Overwrites the default implementation by honoring the attribute index.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The attribute name.
   */
  getAttributeName() {
    const index = this.index;
    return "color" + (index > 0 ? index : "");
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    let result;
    if (geometryAttribute === true) {
      result = super.generate(builder);
    } else {
      result = builder.generateConst(this.nodeType, new Vector4(1, 1, 1, 1));
    }
    return result;
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
}
const vertexColor = (index = 0) => nodeObject(new VertexColorNode(index));
const blendBurn = /* @__PURE__ */ Fn(([base, blend]) => {
  return min$1(1, base.oneMinus().div(blend)).oneMinus();
}).setLayout({
  name: "blendBurn",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" },
  ],
});
const blendDodge = /* @__PURE__ */ Fn(([base, blend]) => {
  return min$1(base.div(blend.oneMinus()), 1);
}).setLayout({
  name: "blendDodge",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" },
  ],
});
const blendScreen = /* @__PURE__ */ Fn(([base, blend]) => {
  return base.oneMinus().mul(blend.oneMinus()).oneMinus();
}).setLayout({
  name: "blendScreen",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" },
  ],
});
const blendOverlay = /* @__PURE__ */ Fn(([base, blend]) => {
  return mix$1(
    base.mul(2).mul(blend),
    base.oneMinus().mul(2).mul(blend.oneMinus()).oneMinus(),
    step(0.5, base)
  );
}).setLayout({
  name: "blendOverlay",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" },
  ],
});
const blendColor = /* @__PURE__ */ Fn(([base, blend]) => {
  const outAlpha = blend.a.add(base.a.mul(blend.a.oneMinus()));
  return vec4(
    blend.rgb
      .mul(blend.a)
      .add(base.rgb.mul(base.a).mul(blend.a.oneMinus()))
      .div(outAlpha),
    outAlpha
  );
}).setLayout({
  name: "blendColor",
  type: "vec4",
  inputs: [
    { name: "base", type: "vec4" },
    { name: "blend", type: "vec4" },
  ],
});
const premultiplyAlpha = /* @__PURE__ */ Fn(
  ([color2]) => {
    return vec4(color2.rgb.mul(color2.a), color2.a);
  },
  { color: "vec4", return: "vec4" }
);
const unpremultiplyAlpha = /* @__PURE__ */ Fn(
  ([color2]) => {
    If(color2.a.equal(0), () => vec4(0));
    return vec4(color2.rgb.div(color2.a), color2.a);
  },
  { color: "vec4", return: "vec4" }
);
const burn = (...params) => {
  console.warn('THREE.TSL: "burn" has been renamed. Use "blendBurn" instead.');
  return blendBurn(params);
};
const dodge = (...params) => {
  console.warn(
    'THREE.TSL: "dodge" has been renamed. Use "blendDodge" instead.'
  );
  return blendDodge(params);
};
const screen = (...params) => {
  console.warn(
    'THREE.TSL: "screen" has been renamed. Use "blendScreen" instead.'
  );
  return blendScreen(params);
};
const overlay = (...params) => {
  console.warn(
    'THREE.TSL: "overlay" has been renamed. Use "blendOverlay" instead.'
  );
  return blendOverlay(params);
};
class NodeMaterial extends Material {
  static get type() {
    return "NodeMaterial";
  }
  /**
   * Represents the type of the node material.
   *
   * @type {string}
   */
  get type() {
    return this.constructor.type;
  }
  set type(_value) {}
  /**
   * Constructs a new node material.
   */
  constructor() {
    super();
    this.isNodeMaterial = true;
    this.fog = true;
    this.lights = false;
    this.hardwareClipping = false;
    this.lightsNode = null;
    this.envNode = null;
    this.aoNode = null;
    this.colorNode = null;
    this.normalNode = null;
    this.opacityNode = null;
    this.backdropNode = null;
    this.backdropAlphaNode = null;
    this.alphaTestNode = null;
    this.maskNode = null;
    this.positionNode = null;
    this.geometryNode = null;
    this.depthNode = null;
    this.receivedShadowPositionNode = null;
    this.castShadowPositionNode = null;
    this.receivedShadowNode = null;
    this.castShadowNode = null;
    this.outputNode = null;
    this.mrtNode = null;
    this.fragmentNode = null;
    this.vertexNode = null;
    Object.defineProperty(this, "shadowPositionNode", {
      // @deprecated, r176
      get: () => {
        return this.receivedShadowPositionNode;
      },
      set: (value) => {
        console.warn(
          'THREE.NodeMaterial: ".shadowPositionNode" was renamed to ".receivedShadowPositionNode".'
        );
        this.receivedShadowPositionNode = value;
      },
    });
  }
  /**
   * Allows to define a custom cache key that influence the material key computation
   * for render objects.
   *
   * @return {string} The custom cache key.
   */
  customProgramCacheKey() {
    return this.type + getCacheKey$1(this);
  }
  /**
   * Builds this material with the given node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  build(builder) {
    this.setup(builder);
  }
  /**
   * Setups a node material observer with the given builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeMaterialObserver} The node material observer.
   */
  setupObserver(builder) {
    return new NodeMaterialObserver(builder);
  }
  /**
   * Setups the vertex and fragment stage of this node material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    builder.context.setupNormal = () =>
      subBuild(this.setupNormal(builder), "NORMAL", "vec3");
    builder.context.setupPositionView = () => this.setupPositionView(builder);
    builder.context.setupModelViewProjection = () =>
      this.setupModelViewProjection(builder);
    const renderer2 = builder.renderer;
    const renderTarget = renderer2.getRenderTarget();
    builder.addStack();
    const mvp = subBuild(this.setupVertex(builder), "VERTEX");
    const vertexNode = this.vertexNode || mvp;
    builder.stack.outputNode = vertexNode;
    this.setupHardwareClipping(builder);
    if (this.geometryNode !== null) {
      builder.stack.outputNode = builder.stack.outputNode.bypass(
        this.geometryNode
      );
    }
    builder.addFlow("vertex", builder.removeStack());
    builder.addStack();
    let resultNode;
    const clippingNode = this.setupClipping(builder);
    if (this.depthWrite === true || this.depthTest === true) {
      if (renderTarget !== null) {
        if (renderTarget.depthBuffer === true) this.setupDepth(builder);
      } else {
        if (renderer2.depth === true) this.setupDepth(builder);
      }
    }
    if (this.fragmentNode === null) {
      this.setupDiffuseColor(builder);
      this.setupVariants(builder);
      const outgoingLightNode = this.setupLighting(builder);
      if (clippingNode !== null) builder.stack.add(clippingNode);
      const basicOutput = vec4(outgoingLightNode, diffuseColor.a).max(0);
      resultNode = this.setupOutput(builder, basicOutput);
      output.assign(resultNode);
      const isCustomOutput = this.outputNode !== null;
      if (isCustomOutput) resultNode = this.outputNode;
      if (renderTarget !== null) {
        const mrt2 = renderer2.getMRT();
        const materialMRT = this.mrtNode;
        if (mrt2 !== null) {
          if (isCustomOutput) output.assign(resultNode);
          resultNode = mrt2;
          if (materialMRT !== null) {
            resultNode = mrt2.merge(materialMRT);
          }
        } else if (materialMRT !== null) {
          resultNode = materialMRT;
        }
      }
    } else {
      let fragmentNode = this.fragmentNode;
      if (fragmentNode.isOutputStructNode !== true) {
        fragmentNode = vec4(fragmentNode);
      }
      resultNode = this.setupOutput(builder, fragmentNode);
    }
    builder.stack.outputNode = resultNode;
    builder.addFlow("fragment", builder.removeStack());
    builder.observer = this.setupObserver(builder);
  }
  /**
   * Setups the clipping node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {ClippingNode} The clipping node.
   */
  setupClipping(builder) {
    if (builder.clippingContext === null) return null;
    const { unionPlanes, intersectionPlanes } = builder.clippingContext;
    let result = null;
    if (unionPlanes.length > 0 || intersectionPlanes.length > 0) {
      const samples = builder.renderer.samples;
      if (this.alphaToCoverage && samples > 1) {
        result = clippingAlpha();
      } else {
        builder.stack.add(clipping());
      }
    }
    return result;
  }
  /**
   * Setups the hardware clipping if available on the current device.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupHardwareClipping(builder) {
    this.hardwareClipping = false;
    if (builder.clippingContext === null) return;
    const candidateCount = builder.clippingContext.unionPlanes.length;
    if (
      candidateCount > 0 &&
      candidateCount <= 8 &&
      builder.isAvailable("clipDistance")
    ) {
      builder.stack.add(hardwareClipping());
      this.hardwareClipping = true;
    }
    return;
  }
  /**
   * Setups the depth of this material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupDepth(builder) {
    const { renderer: renderer2, camera: camera2 } = builder;
    let depthNode = this.depthNode;
    if (depthNode === null) {
      const mrt2 = renderer2.getMRT();
      if (mrt2 && mrt2.has("depth")) {
        depthNode = mrt2.get("depth");
      } else if (renderer2.logarithmicDepthBuffer === true) {
        if (camera2.isPerspectiveCamera) {
          depthNode = viewZToLogarithmicDepth(
            positionView.z,
            cameraNear,
            cameraFar
          );
        } else {
          depthNode = viewZToOrthographicDepth(
            positionView.z,
            cameraNear,
            cameraFar
          );
        }
      }
    }
    if (depthNode !== null) {
      depth.assign(depthNode).toStack();
    }
  }
  /**
   * Setups the position node in view space. This method exists
   * so derived node materials can modify the implementation e.g. sprite materials.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in view space.
   */
  setupPositionView() {
    return modelViewMatrix.mul(positionLocal$1).xyz;
  }
  /**
   * Setups the position in clip space.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The position in view space.
   */
  setupModelViewProjection() {
    return cameraProjectionMatrix.mul(positionView);
  }
  /**
   * Setups the logic for the vertex stage.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The position in clip space.
   */
  setupVertex(builder) {
    builder.addStack();
    this.setupPosition(builder);
    builder.context.vertex = builder.removeStack();
    return modelViewProjection;
  }
  /**
   * Setups the computation of the position in local space.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in local space.
   */
  setupPosition(builder) {
    const { object, geometry } = builder;
    if (
      geometry.morphAttributes.position ||
      geometry.morphAttributes.normal ||
      geometry.morphAttributes.color
    ) {
      morphReference(object).toStack();
    }
    if (object.isSkinnedMesh === true) {
      skinning(object).toStack();
    }
    if (this.displacementMap) {
      const displacementMap = materialReference("displacementMap", "texture");
      const displacementScale = materialReference("displacementScale", "float");
      const displacementBias = materialReference("displacementBias", "float");
      positionLocal$1.addAssign(
        normalLocal
          .normalize()
          .mul(displacementMap.x.mul(displacementScale).add(displacementBias))
      );
    }
    if (object.isBatchedMesh) {
      batch(object).toStack();
    }
    if (
      object.isInstancedMesh &&
      object.instanceMatrix &&
      object.instanceMatrix.isInstancedBufferAttribute === true
    ) {
      instancedMesh(object).toStack();
    }
    if (this.positionNode !== null) {
      positionLocal$1.assign(subBuild(this.positionNode, "POSITION", "vec3"));
    }
    return positionLocal$1;
  }
  /**
   * Setups the computation of the material's diffuse color.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {BufferGeometry} geometry - The geometry.
   */
  setupDiffuseColor({ object, geometry }) {
    if (this.maskNode !== null) {
      bool(this.maskNode).not().discard();
    }
    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;
    if (this.vertexColors === true && geometry.hasAttribute("color")) {
      colorNode = colorNode.mul(vertexColor());
    }
    if (object.instanceColor) {
      const instanceColor = varyingProperty("vec3", "vInstanceColor");
      colorNode = instanceColor.mul(colorNode);
    }
    if (object.isBatchedMesh && object._colorsTexture) {
      const batchColor = varyingProperty("vec3", "vBatchColor");
      colorNode = batchColor.mul(colorNode);
    }
    diffuseColor.assign(colorNode);
    const opacityNode = this.opacityNode
      ? float(this.opacityNode)
      : materialOpacity;
    diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));
    let alphaTestNode = null;
    if (this.alphaTestNode !== null || this.alphaTest > 0) {
      alphaTestNode =
        this.alphaTestNode !== null
          ? float(this.alphaTestNode)
          : materialAlphaTest;
      diffuseColor.a.lessThanEqual(alphaTestNode).discard();
    }
    if (this.alphaHash === true) {
      diffuseColor.a.lessThan(getAlphaHashThreshold(positionLocal$1)).discard();
    }
    const isOpaque =
      this.transparent === false &&
      this.blending === NormalBlending &&
      this.alphaToCoverage === false;
    if (isOpaque) {
      diffuseColor.a.assign(1);
    } else if (alphaTestNode === null) {
      diffuseColor.a.lessThanEqual(0).discard();
    }
  }
  /**
   * Abstract interface method that can be implemented by derived materials
   * to setup material-specific node variables.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {}
  /**
   * Setups the outgoing light node variable
   *
   * @return {Node<vec3>} The outgoing light node.
   */
  setupOutgoingLight() {
    return this.lights === true ? vec3(0) : diffuseColor.rgb;
  }
  /**
   * Setups the normal node from the material.
   *
   * @return {Node<vec3>} The normal node.
   */
  setupNormal() {
    return this.normalNode ? vec3(this.normalNode) : materialNormal;
  }
  /**
   * Setups the environment node from the material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The environment node.
   */
  setupEnvironment() {
    let node = null;
    if (this.envNode) {
      node = this.envNode;
    } else if (this.envMap) {
      node = this.envMap.isCubeTexture
        ? materialReference("envMap", "cubeTexture")
        : materialReference("envMap", "texture");
    }
    return node;
  }
  /**
   * Setups the light map node from the material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The light map node.
   */
  setupLightMap(builder) {
    let node = null;
    if (builder.material.lightMap) {
      node = new IrradianceNode(materialLightMap);
    }
    return node;
  }
  /**
   * Setups the lights node based on the scene, environment and material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {LightsNode} The lights node.
   */
  setupLights(builder) {
    const materialLightsNode = [];
    const envNode = this.setupEnvironment(builder);
    if (envNode && envNode.isLightingNode) {
      materialLightsNode.push(envNode);
    }
    const lightMapNode = this.setupLightMap(builder);
    if (lightMapNode && lightMapNode.isLightingNode) {
      materialLightsNode.push(lightMapNode);
    }
    if (this.aoNode !== null || builder.material.aoMap) {
      const aoNode = this.aoNode !== null ? this.aoNode : materialAO;
      materialLightsNode.push(new AONode(aoNode));
    }
    let lightsN = this.lightsNode || builder.lightsNode;
    if (materialLightsNode.length > 0) {
      lightsN = builder.renderer.lighting.createNode([
        ...lightsN.getLights(),
        ...materialLightsNode,
      ]);
    }
    return lightsN;
  }
  /**
   * This method should be implemented by most derived materials
   * since it defines the material's lighting model.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   * @return {LightingModel} The lighting model.
   */
  setupLightingModel() {}
  /**
   * Setups the outgoing light node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The outgoing light node.
   */
  setupLighting(builder) {
    const { material } = builder;
    const { backdropNode, backdropAlphaNode, emissiveNode } = this;
    const lights2 = this.lights === true || this.lightsNode !== null;
    const lightsNode = lights2 ? this.setupLights(builder) : null;
    let outgoingLightNode = this.setupOutgoingLight(builder);
    if (lightsNode && lightsNode.getScope().hasLights) {
      const lightingModel = this.setupLightingModel(builder) || null;
      outgoingLightNode = lightingContext(
        lightsNode,
        lightingModel,
        backdropNode,
        backdropAlphaNode
      );
    } else if (backdropNode !== null) {
      outgoingLightNode = vec3(
        backdropAlphaNode !== null
          ? mix$1(outgoingLightNode, backdropNode, backdropAlphaNode)
          : backdropNode
      );
    }
    if (
      (emissiveNode && emissiveNode.isNode === true) ||
      (material.emissive && material.emissive.isColor === true)
    ) {
      emissive.assign(vec3(emissiveNode ? emissiveNode : materialEmissive));
      outgoingLightNode = outgoingLightNode.add(emissive);
    }
    return outgoingLightNode;
  }
  /**
   * Setup the fog.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupFog(builder, outputNode) {
    const fogNode = builder.fogNode;
    if (fogNode) {
      output.assign(outputNode);
      outputNode = vec4(fogNode.toVar());
    }
    return outputNode;
  }
  /**
   * Setups premultiplied alpha.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupPremultipliedAlpha(builder, outputNode) {
    return premultiplyAlpha(outputNode);
  }
  /**
   * Setups the output node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupOutput(builder, outputNode) {
    if (this.fog === true) {
      outputNode = this.setupFog(builder, outputNode);
    }
    if (this.premultipliedAlpha === true) {
      outputNode = this.setupPremultipliedAlpha(builder, outputNode);
    }
    return outputNode;
  }
  /**
   * Most classic material types have a node pendant e.g. for `MeshBasicMaterial`
   * there is `MeshBasicNodeMaterial`. This utility method is intended for
   * defining all material properties of the classic type in the node type.
   *
   * @param {Material} material - The material to copy properties with their values to this node material.
   */
  setDefaultValues(material) {
    for (const property2 in material) {
      const value = material[property2];
      if (this[property2] === void 0) {
        this[property2] = value;
        if (value && value.clone) this[property2] = value.clone();
      }
    }
    const descriptors = Object.getOwnPropertyDescriptors(
      material.constructor.prototype
    );
    for (const key in descriptors) {
      if (
        Object.getOwnPropertyDescriptor(this.constructor.prototype, key) ===
          void 0 &&
        descriptors[key].get !== void 0
      ) {
        Object.defineProperty(
          this.constructor.prototype,
          key,
          descriptors[key]
        );
      }
    }
  }
  /**
   * Serializes this material to JSON.
   *
   * @param {?(Object|string)} meta - The meta information for serialization.
   * @return {Object} The serialized node.
   */
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {},
      };
    }
    const data = Material.prototype.toJSON.call(this, meta);
    const nodeChildren = getNodeChildren(this);
    data.inputNodes = {};
    for (const { property: property2, childNode } of nodeChildren) {
      data.inputNodes[property2] = childNode.toJSON(meta).uuid;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
      if (nodes.length > 0) data.nodes = nodes;
    }
    return data;
  }
  /**
   * Copies the properties of the given node material to this instance.
   *
   * @param {NodeMaterial} source - The material to copy.
   * @return {NodeMaterial} A reference to this node material.
   */
  copy(source) {
    this.lightsNode = source.lightsNode;
    this.envNode = source.envNode;
    this.colorNode = source.colorNode;
    this.normalNode = source.normalNode;
    this.opacityNode = source.opacityNode;
    this.backdropNode = source.backdropNode;
    this.backdropAlphaNode = source.backdropAlphaNode;
    this.alphaTestNode = source.alphaTestNode;
    this.maskNode = source.maskNode;
    this.positionNode = source.positionNode;
    this.geometryNode = source.geometryNode;
    this.depthNode = source.depthNode;
    this.receivedShadowPositionNode = source.receivedShadowPositionNode;
    this.castShadowPositionNode = source.castShadowPositionNode;
    this.receivedShadowNode = source.receivedShadowNode;
    this.castShadowNode = source.castShadowNode;
    this.outputNode = source.outputNode;
    this.mrtNode = source.mrtNode;
    this.fragmentNode = source.fragmentNode;
    this.vertexNode = source.vertexNode;
    return super.copy(source);
  }
}
const _defaultValues$d = /* @__PURE__ */ new LineBasicMaterial();
class LineBasicNodeMaterial extends NodeMaterial {
  static get type() {
    return "LineBasicNodeMaterial";
  }
  /**
   * Constructs a new line basic node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isLineBasicNodeMaterial = true;
    this.setDefaultValues(_defaultValues$d);
    this.setValues(parameters);
  }
}
const _defaultValues$c = /* @__PURE__ */ new LineDashedMaterial();
class LineDashedNodeMaterial extends NodeMaterial {
  static get type() {
    return "LineDashedNodeMaterial";
  }
  /**
   * Constructs a new line dashed node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isLineDashedNodeMaterial = true;
    this.setDefaultValues(_defaultValues$c);
    this.dashOffset = 0;
    this.offsetNode = null;
    this.dashScaleNode = null;
    this.dashSizeNode = null;
    this.gapSizeNode = null;
    this.setValues(parameters);
  }
  /**
   * Setups the dash specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const offsetNode = this.offsetNode
      ? float(this.offsetNode)
      : materialLineDashOffset;
    const dashScaleNode = this.dashScaleNode
      ? float(this.dashScaleNode)
      : materialLineScale;
    const dashSizeNode = this.dashSizeNode
      ? float(this.dashSizeNode)
      : materialLineDashSize;
    const gapSizeNode = this.gapSizeNode
      ? float(this.gapSizeNode)
      : materialLineGapSize;
    dashSize.assign(dashSizeNode);
    gapSize.assign(gapSizeNode);
    const vLineDistance = varying(attribute("lineDistance").mul(dashScaleNode));
    const vLineDistanceOffset = offsetNode
      ? vLineDistance.add(offsetNode)
      : vLineDistance;
    vLineDistanceOffset
      .mod(dashSize.add(gapSize))
      .greaterThan(dashSize)
      .discard();
  }
}
let _sharedFramebuffer = null;
class ViewportSharedTextureNode extends ViewportTextureNode {
  static get type() {
    return "ViewportSharedTextureNode";
  }
  /**
   * Constructs a new viewport shared texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   */
  constructor(uvNode = screenUV, levelNode = null) {
    if (_sharedFramebuffer === null) {
      _sharedFramebuffer = new FramebufferTexture();
    }
    super(uvNode, levelNode, _sharedFramebuffer);
  }
  updateReference() {
    return this;
  }
}
const viewportSharedTexture = /* @__PURE__ */ nodeProxy(
  ViewportSharedTextureNode
).setParameterLength(0, 2);
const directionToColor = (node) => nodeObject(node).mul(0.5).add(0.5);
const colorToDirection = (node) => nodeObject(node).mul(2).sub(1);
const _defaultValues$a = /* @__PURE__ */ new MeshNormalMaterial();
class MeshNormalNodeMaterial extends NodeMaterial {
  static get type() {
    return "MeshNormalNodeMaterial";
  }
  /**
   * Constructs a new mesh normal node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshNormalNodeMaterial = true;
    this.setDefaultValues(_defaultValues$a);
    this.setValues(parameters);
  }
  /**
   * Overwrites the default implementation by computing the diffuse color
   * based on the normal data.
   */
  setupDiffuseColor() {
    const opacityNode = this.opacityNode
      ? float(this.opacityNode)
      : materialOpacity;
    diffuseColor.assign(
      colorSpaceToWorking(
        vec4(directionToColor(normalView), opacityNode),
        SRGBColorSpace
      )
    );
  }
}
const equirectUV = /* @__PURE__ */ Fn(([dir = positionWorldDirection]) => {
  const u2 = dir.z
    .atan(dir.x)
    .mul(1 / (Math.PI * 2))
    .add(0.5);
  const v = dir.y
    .clamp(-1, 1)
    .asin()
    .mul(1 / Math.PI)
    .add(0.5);
  return vec2(u2, v);
});
class CubeRenderTarget extends WebGLCubeRenderTarget {
  /**
   * Constructs a new cube render target.
   *
   * @param {number} [size=1] - The size of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(size = 1, options = {}) {
    super(size, options);
    this.isCubeRenderTarget = true;
  }
  /**
   * Converts the given equirectangular texture to a cube map.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Texture} texture - The equirectangular texture.
   * @return {CubeRenderTarget} A reference to this cube render target.
   */
  fromEquirectangularTexture(renderer2, texture$1$1) {
    const currentMinFilter = texture$1$1.minFilter;
    const currentGenerateMipmaps = texture$1$1.generateMipmaps;
    texture$1$1.generateMipmaps = true;
    this.texture.type = texture$1$1.type;
    this.texture.colorSpace = texture$1$1.colorSpace;
    this.texture.generateMipmaps = texture$1$1.generateMipmaps;
    this.texture.minFilter = texture$1$1.minFilter;
    this.texture.magFilter = texture$1$1.magFilter;
    const geometry = new BoxGeometry(5, 5, 5);
    const uvNode = equirectUV(positionWorldDirection);
    const material = new NodeMaterial();
    material.colorNode = texture$1(texture$1$1, uvNode, 0);
    material.side = BackSide;
    material.blending = NoBlending;
    const mesh = new Mesh(geometry, material);
    const scene2 = new Scene();
    scene2.add(mesh);
    if (texture$1$1.minFilter === LinearMipmapLinearFilter)
      texture$1$1.minFilter = LinearFilter;
    const camera2 = new CubeCamera(1, 10, this);
    const currentMRT = renderer2.getMRT();
    renderer2.setMRT(null);
    camera2.update(renderer2, scene2);
    renderer2.setMRT(currentMRT);
    texture$1$1.minFilter = currentMinFilter;
    texture$1$1.currentGenerateMipmaps = currentGenerateMipmaps;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
}
const _cache$1 = /* @__PURE__ */ new WeakMap();
class CubeMapNode extends TempNode {
  static get type() {
    return "CubeMapNode";
  }
  /**
   * Constructs a new cube map node.
   *
   * @param {Node} envNode - The node representing the environment map.
   */
  constructor(envNode) {
    super("vec3");
    this.envNode = envNode;
    this._cubeTexture = null;
    this._cubeTextureNode = cubeTexture(null);
    const defaultTexture = new CubeTexture();
    defaultTexture.isRenderTargetTexture = true;
    this._defaultTexture = defaultTexture;
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  updateBefore(frame) {
    const { renderer: renderer2, material } = frame;
    const envNode = this.envNode;
    if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {
      const texture2 = envNode.isTextureNode
        ? envNode.value
        : material[envNode.property];
      if (texture2 && texture2.isTexture) {
        const mapping = texture2.mapping;
        if (
          mapping === EquirectangularReflectionMapping ||
          mapping === EquirectangularRefractionMapping
        ) {
          if (_cache$1.has(texture2)) {
            const cubeMap = _cache$1.get(texture2);
            mapTextureMapping(cubeMap, texture2.mapping);
            this._cubeTexture = cubeMap;
          } else {
            const image = texture2.image;
            if (isEquirectangularMapReady$1(image)) {
              const renderTarget = new CubeRenderTarget(image.height);
              renderTarget.fromEquirectangularTexture(renderer2, texture2);
              mapTextureMapping(renderTarget.texture, texture2.mapping);
              this._cubeTexture = renderTarget.texture;
              _cache$1.set(texture2, renderTarget.texture);
              texture2.addEventListener("dispose", onTextureDispose);
            } else {
              this._cubeTexture = this._defaultTexture;
            }
          }
          this._cubeTextureNode.value = this._cubeTexture;
        } else {
          this._cubeTextureNode = this.envNode;
        }
      }
    }
  }
  setup(builder) {
    this.updateBefore(builder);
    return this._cubeTextureNode;
  }
}
function isEquirectangularMapReady$1(image) {
  if (image === null || image === void 0) return false;
  return image.height > 0;
}
function onTextureDispose(event) {
  const texture2 = event.target;
  texture2.removeEventListener("dispose", onTextureDispose);
  const renderTarget = _cache$1.get(texture2);
  if (renderTarget !== void 0) {
    _cache$1.delete(texture2);
    renderTarget.dispose();
  }
}
function mapTextureMapping(texture2, mapping) {
  if (mapping === EquirectangularReflectionMapping) {
    texture2.mapping = CubeReflectionMapping;
  } else if (mapping === EquirectangularRefractionMapping) {
    texture2.mapping = CubeRefractionMapping;
  }
}
const cubeMapNode =
  /* @__PURE__ */ nodeProxy(CubeMapNode).setParameterLength(1);
class BasicEnvironmentNode extends LightingNode {
  static get type() {
    return "BasicEnvironmentNode";
  }
  /**
   * Constructs a new basic environment node.
   *
   * @param {Node} [envNode=null] - A node representing the environment.
   */
  constructor(envNode = null) {
    super();
    this.envNode = envNode;
  }
  setup(builder) {
    builder.context.environment = cubeMapNode(this.envNode);
  }
}
class BasicLightMapNode extends LightingNode {
  static get type() {
    return "BasicLightMapNode";
  }
  /**
   * Constructs a new basic light map node.
   *
   * @param {?Node<vec3>} [lightMapNode=null] - The light map node.
   */
  constructor(lightMapNode = null) {
    super();
    this.lightMapNode = lightMapNode;
  }
  setup(builder) {
    const RECIPROCAL_PI2 = float(1 / Math.PI);
    builder.context.irradianceLightMap = this.lightMapNode.mul(RECIPROCAL_PI2);
  }
}
class LightingModel {
  /**
   * This method is intended for setting up lighting model and context data
   * which are later used in the evaluation process.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  start(builder) {
    builder.lightsNode.setupLights(
      builder,
      builder.lightsNode.getLightNodes(builder)
    );
    this.indirect(builder);
  }
  /**
   * This method is intended for executing final tasks like final updates
   * to the outgoing light.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish() {}
  /**
   * This method is intended for implementing the direct light term and
   * executed during the build process of directional, point and spot light nodes.
   *
   * @abstract
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct() {}
  /**
   * This method is intended for implementing the direct light term for
   * rect area light nodes.
   *
   * @abstract
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  directRectArea() {}
  /**
   * This method is intended for implementing the indirect light term.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect() {}
  /**
   * This method is intended for implementing the ambient occlusion term.
   * Unlike other methods, this method must be called manually by the lighting
   * model in its indirect term.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  ambientOcclusion() {}
}
class BasicLightingModel extends LightingModel {
  /**
   * Constructs a new basic lighting model.
   */
  constructor() {
    super();
  }
  /**
   * Implements the baked indirect lighting with its modulation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect({ context: context2 }) {
    const ambientOcclusion = context2.ambientOcclusion;
    const reflectedLight = context2.reflectedLight;
    const irradianceLightMap = context2.irradianceLightMap;
    reflectedLight.indirectDiffuse.assign(vec4(0));
    if (irradianceLightMap) {
      reflectedLight.indirectDiffuse.addAssign(irradianceLightMap);
    } else {
      reflectedLight.indirectDiffuse.addAssign(vec4(1, 1, 1, 0));
    }
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
    reflectedLight.indirectDiffuse.mulAssign(diffuseColor.rgb);
  }
  /**
   * Implements the environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish(builder) {
    const { material, context: context2 } = builder;
    const outgoingLight = context2.outgoingLight;
    const envNode = builder.context.environment;
    if (envNode) {
      switch (material.combine) {
        case MultiplyOperation:
          outgoingLight.rgb.assign(
            mix$1(
              outgoingLight.rgb,
              outgoingLight.rgb.mul(envNode.rgb),
              materialSpecularStrength.mul(materialReflectivity)
            )
          );
          break;
        case MixOperation:
          outgoingLight.rgb.assign(
            mix$1(
              outgoingLight.rgb,
              envNode.rgb,
              materialSpecularStrength.mul(materialReflectivity)
            )
          );
          break;
        case AddOperation:
          outgoingLight.rgb.addAssign(
            envNode.rgb.mul(materialSpecularStrength.mul(materialReflectivity))
          );
          break;
        default:
          console.warn(
            "THREE.BasicLightingModel: Unsupported .combine value:",
            material.combine
          );
          break;
      }
    }
  }
}
const _defaultValues$9 = /* @__PURE__ */ new MeshBasicMaterial();
class MeshBasicNodeMaterial extends NodeMaterial {
  static get type() {
    return "MeshBasicNodeMaterial";
  }
  /**
   * Constructs a new mesh basic node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshBasicNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(_defaultValues$9);
    this.setValues(parameters);
  }
  /**
   * Basic materials are not affected by normal and bump maps so we
   * return by default {@link normalViewGeometry}.
   *
   * @return {Node<vec3>} The normal node.
   */
  setupNormal() {
    return directionToFaceDirection(normalViewGeometry);
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(builder) {
    const envNode = super.setupEnvironment(builder);
    return envNode ? new BasicEnvironmentNode(envNode) : null;
  }
  /**
   * This method must be overwritten since light maps are evaluated
   * with a special scaling factor for basic materials.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicLightMapNode<vec3>} The light map node.
   */
  setupLightMap(builder) {
    let node = null;
    if (builder.material.lightMap) {
      node = new BasicLightMapNode(materialLightMap);
    }
    return node;
  }
  /**
   * The material overwrites this method because `lights` is set to `true` but
   * we still want to return the diffuse color as the outgoing light.
   *
   * @return {Node<vec3>} The outgoing light node.
   */
  setupOutgoingLight() {
    return diffuseColor.rgb;
  }
  /**
   * Setups the lighting model.
   *
   * @return {BasicLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new BasicLightingModel();
  }
}
const F_Schlick = /* @__PURE__ */ Fn(({ f0, f90, dotVH }) => {
  const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();
  return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));
});
const BRDF_Lambert = /* @__PURE__ */ Fn((inputs) => {
  return inputs.diffuseColor.mul(1 / Math.PI);
});
const G_BlinnPhong_Implicit = () => float(0.25);
const D_BlinnPhong = /* @__PURE__ */ Fn(({ dotNH }) => {
  return shininess
    .mul(float(0.5))
    .add(1)
    .mul(float(1 / Math.PI))
    .mul(dotNH.pow(shininess));
});
const BRDF_BlinnPhong = /* @__PURE__ */ Fn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNH = normalView.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  const F = F_Schlick({ f0: specularColor, f90: 1, dotVH });
  const G = G_BlinnPhong_Implicit();
  const D = D_BlinnPhong({ dotNH });
  return F.mul(G).mul(D);
});
class PhongLightingModel extends BasicLightingModel {
  /**
   * Constructs a new phong lighting model.
   *
   * @param {boolean} [specular=true] - Whether specular is supported or not.
   */
  constructor(specular = true) {
    super();
    this.specular = specular;
  }
  /**
   * Implements the direct lighting. The specular portion is optional an can be controlled
   * with the {@link PhongLightingModel#specular} flag.
   *
   * @param {Object} lightData - The light data.
   */
  direct({ lightDirection, lightColor, reflectedLight }) {
    const dotNL = normalView.dot(lightDirection).clamp();
    const irradiance = dotNL.mul(lightColor);
    reflectedLight.directDiffuse.addAssign(
      irradiance.mul(BRDF_Lambert({ diffuseColor: diffuseColor.rgb }))
    );
    if (this.specular === true) {
      reflectedLight.directSpecular.addAssign(
        irradiance
          .mul(BRDF_BlinnPhong({ lightDirection }))
          .mul(materialSpecularStrength)
      );
    }
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(builder) {
    const { ambientOcclusion, irradiance, reflectedLight } = builder.context;
    reflectedLight.indirectDiffuse.addAssign(
      irradiance.mul(BRDF_Lambert({ diffuseColor }))
    );
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
  }
}
const _defaultValues$8 = /* @__PURE__ */ new MeshLambertMaterial();
class MeshLambertNodeMaterial extends NodeMaterial {
  static get type() {
    return "MeshLambertNodeMaterial";
  }
  /**
   * Constructs a new mesh lambert node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshLambertNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(_defaultValues$8);
    this.setValues(parameters);
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(builder) {
    const envNode = super.setupEnvironment(builder);
    return envNode ? new BasicEnvironmentNode(envNode) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhongLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new PhongLightingModel(false);
  }
}
const _defaultValues$7 = /* @__PURE__ */ new MeshPhongMaterial();
class MeshPhongNodeMaterial extends NodeMaterial {
  static get type() {
    return "MeshPhongNodeMaterial";
  }
  /**
   * Constructs a new mesh lambert node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshPhongNodeMaterial = true;
    this.lights = true;
    this.shininessNode = null;
    this.specularNode = null;
    this.setDefaultValues(_defaultValues$7);
    this.setValues(parameters);
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(builder) {
    const envNode = super.setupEnvironment(builder);
    return envNode ? new BasicEnvironmentNode(envNode) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhongLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new PhongLightingModel();
  }
  /**
   * Setups the phong specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const shininessNode = (
      this.shininessNode ? float(this.shininessNode) : materialShininess
    ).max(1e-4);
    shininess.assign(shininessNode);
    const specularNode = this.specularNode || materialSpecular;
    specularColor.assign(specularNode);
  }
  copy(source) {
    this.shininessNode = source.shininessNode;
    this.specularNode = source.specularNode;
    return super.copy(source);
  }
}
const getGeometryRoughness = /* @__PURE__ */ Fn((builder) => {
  if (builder.geometry.hasAttribute("normal") === false) {
    return float(0);
  }
  const dxy = normalViewGeometry
    .dFdx()
    .abs()
    .max(normalViewGeometry.dFdy().abs());
  const geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);
  return geometryRoughness;
});
const getRoughness = /* @__PURE__ */ Fn((inputs) => {
  const { roughness: roughness2 } = inputs;
  const geometryRoughness = getGeometryRoughness();
  let roughnessFactor = roughness2.max(0.0525);
  roughnessFactor = roughnessFactor.add(geometryRoughness);
  roughnessFactor = roughnessFactor.min(1);
  return roughnessFactor;
});
const V_GGX_SmithCorrelated = /* @__PURE__ */ Fn(({ alpha, dotNL, dotNV }) => {
  const a2 = alpha.pow2();
  const gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());
  const gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());
  return div(0.5, gv.add(gl).max(EPSILON));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" },
  ],
});
const V_GGX_SmithCorrelated_Anisotropic = /* @__PURE__ */ Fn(
  ({ alphaT: alphaT2, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL }) => {
    const gv = dotNL.mul(
      vec3(alphaT2.mul(dotTV), alphaB.mul(dotBV), dotNV).length()
    );
    const gl = dotNV.mul(
      vec3(alphaT2.mul(dotTL), alphaB.mul(dotBL), dotNL).length()
    );
    const v = div(0.5, gv.add(gl));
    return v.saturate();
  }
).setLayout({
  name: "V_GGX_SmithCorrelated_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotTV", type: "float", qualifier: "in" },
    { name: "dotBV", type: "float", qualifier: "in" },
    { name: "dotTL", type: "float", qualifier: "in" },
    { name: "dotBL", type: "float", qualifier: "in" },
    { name: "dotNV", type: "float", qualifier: "in" },
    { name: "dotNL", type: "float", qualifier: "in" },
  ],
});
const D_GGX = /* @__PURE__ */ Fn(({ alpha, dotNH }) => {
  const a2 = alpha.pow2();
  const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus();
  return a2.div(denom.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" },
  ],
});
const RECIPROCAL_PI = /* @__PURE__ */ float(1 / Math.PI);
const D_GGX_Anisotropic = /* @__PURE__ */ Fn(
  ({ alphaT: alphaT2, alphaB, dotNH, dotTH, dotBH }) => {
    const a2 = alphaT2.mul(alphaB);
    const v = vec3(alphaB.mul(dotTH), alphaT2.mul(dotBH), a2.mul(dotNH));
    const v2 = v.dot(v);
    const w22 = a2.div(v2);
    return RECIPROCAL_PI.mul(a2.mul(w22.pow2()));
  }
).setLayout({
  name: "D_GGX_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotNH", type: "float", qualifier: "in" },
    { name: "dotTH", type: "float", qualifier: "in" },
    { name: "dotBH", type: "float", qualifier: "in" },
  ],
});
const BRDF_GGX = /* @__PURE__ */ Fn(
  ({
    lightDirection,
    f0,
    f90,
    roughness: roughness2,
    f,
    normalView: normalView$1 = normalView,
    USE_IRIDESCENCE,
    USE_ANISOTROPY,
  }) => {
    const alpha = roughness2.pow2();
    const halfDir = lightDirection.add(positionViewDirection).normalize();
    const dotNL = normalView$1.dot(lightDirection).clamp();
    const dotNV = normalView$1.dot(positionViewDirection).clamp();
    const dotNH = normalView$1.dot(halfDir).clamp();
    const dotVH = positionViewDirection.dot(halfDir).clamp();
    let F = F_Schlick({ f0, f90, dotVH });
    let V, D;
    if (defined(USE_IRIDESCENCE)) {
      F = iridescence.mix(F, f);
    }
    if (defined(USE_ANISOTROPY)) {
      const dotTL = anisotropyT.dot(lightDirection);
      const dotTV = anisotropyT.dot(positionViewDirection);
      const dotTH = anisotropyT.dot(halfDir);
      const dotBL = anisotropyB.dot(lightDirection);
      const dotBV = anisotropyB.dot(positionViewDirection);
      const dotBH = anisotropyB.dot(halfDir);
      V = V_GGX_SmithCorrelated_Anisotropic({
        alphaT,
        alphaB: alpha,
        dotTV,
        dotBV,
        dotTL,
        dotBL,
        dotNV,
        dotNL,
      });
      D = D_GGX_Anisotropic({ alphaT, alphaB: alpha, dotNH, dotTH, dotBH });
    } else {
      V = V_GGX_SmithCorrelated({ alpha, dotNL, dotNV });
      D = D_GGX({ alpha, dotNH });
    }
    return F.mul(V).mul(D);
  }
);
const DFGApprox = /* @__PURE__ */ Fn(({ roughness: roughness2, dotNV }) => {
  const c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const c1 = vec4(1, 0.0425, 1.04, -0.04);
  const r2 = roughness2.mul(c0).add(c1);
  const a004 = r2.x.mul(r2.x).min(dotNV.mul(-9.28).exp2()).mul(r2.x).add(r2.y);
  const fab = vec2(-1.04, 1.04).mul(a004).add(r2.zw);
  return fab;
}).setLayout({
  name: "DFGApprox",
  type: "vec2",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNV", type: "vec3" },
  ],
});
const EnvironmentBRDF = /* @__PURE__ */ Fn((inputs) => {
  const {
    dotNV,
    specularColor: specularColor2,
    specularF90: specularF902,
    roughness: roughness2,
  } = inputs;
  const fab = DFGApprox({ dotNV, roughness: roughness2 });
  return specularColor2.mul(fab.x).add(specularF902.mul(fab.y));
});
const Schlick_to_F0 = /* @__PURE__ */ Fn(({ f, f90, dotVH }) => {
  const x = dotVH.oneMinus().saturate();
  const x2 = x.mul(x);
  const x5 = x.mul(x2, x2).clamp(0, 0.9999);
  return f.sub(vec3(f90).mul(x5)).div(x5.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" },
  ],
});
const D_Charlie = /* @__PURE__ */ Fn(({ roughness: roughness2, dotNH }) => {
  const alpha = roughness2.pow2();
  const invAlpha = float(1).div(alpha);
  const cos2h = dotNH.pow2();
  const sin2h = cos2h.oneMinus().max(78125e-7);
  return float(2)
    .add(invAlpha)
    .mul(sin2h.pow(invAlpha.mul(0.5)))
    .div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" },
  ],
});
const V_Neubelt = /* @__PURE__ */ Fn(({ dotNV, dotNL }) => {
  return float(1).div(float(4).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));
}).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" },
  ],
});
const BRDF_Sheen = /* @__PURE__ */ Fn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = normalView.dot(lightDirection).clamp();
  const dotNV = normalView.dot(positionViewDirection).clamp();
  const dotNH = normalView.dot(halfDir).clamp();
  const D = D_Charlie({ roughness: sheenRoughness, dotNH });
  const V = V_Neubelt({ dotNV, dotNL });
  return sheen.mul(D).mul(V);
});
const LTC_Uv = /* @__PURE__ */ Fn(({ N: N2, V, roughness: roughness2 }) => {
  const LUT_SIZE = 64;
  const LUT_SCALE = (LUT_SIZE - 1) / LUT_SIZE;
  const LUT_BIAS = 0.5 / LUT_SIZE;
  const dotNV = N2.dot(V).saturate();
  const uv2 = vec2(roughness2, dotNV.oneMinus().sqrt());
  uv2.assign(uv2.mul(LUT_SCALE).add(LUT_BIAS));
  return uv2;
}).setLayout({
  name: "LTC_Uv",
  type: "vec2",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "roughness", type: "float" },
  ],
});
const LTC_ClippedSphereFormFactor = /* @__PURE__ */ Fn(({ f }) => {
  const l2 = f.length();
  return max$1(l2.mul(l2).add(f.z).div(l2.add(1)), 0);
}).setLayout({
  name: "LTC_ClippedSphereFormFactor",
  type: "float",
  inputs: [{ name: "f", type: "vec3" }],
});
const LTC_EdgeVectorFormFactor = /* @__PURE__ */ Fn(({ v1, v2 }) => {
  const x = v1.dot(v2);
  const y = x.abs().toVar();
  const a2 = y.mul(0.0145206).add(0.4965155).mul(y).add(0.8543985).toVar();
  const b = y.add(4.1616724).mul(y).add(3.417594).toVar();
  const v = a2.div(b);
  const theta_sintheta = x
    .greaterThan(0)
    .select(v, max$1(x.mul(x).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(v));
  return v1.cross(v2).mul(theta_sintheta);
}).setLayout({
  name: "LTC_EdgeVectorFormFactor",
  type: "vec3",
  inputs: [
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
  ],
});
const LTC_Evaluate = /* @__PURE__ */ Fn(
  ({ N: N2, V, P, mInv, p0, p1, p2, p3 }) => {
    const v1 = p1.sub(p0).toVar();
    const v2 = p3.sub(p0).toVar();
    const lightNormal = v1.cross(v2);
    const result = vec3().toVar();
    If(lightNormal.dot(P.sub(p0)).greaterThanEqual(0), () => {
      const T1 = V.sub(N2.mul(V.dot(N2))).normalize();
      const T2 = N2.cross(T1).negate();
      const mat = mInv.mul(mat3(T1, T2, N2).transpose()).toVar();
      const coords0 = mat.mul(p0.sub(P)).normalize().toVar();
      const coords1 = mat.mul(p1.sub(P)).normalize().toVar();
      const coords2 = mat.mul(p2.sub(P)).normalize().toVar();
      const coords3 = mat.mul(p3.sub(P)).normalize().toVar();
      const vectorFormFactor = vec3(0).toVar();
      vectorFormFactor.addAssign(
        LTC_EdgeVectorFormFactor({ v1: coords0, v2: coords1 })
      );
      vectorFormFactor.addAssign(
        LTC_EdgeVectorFormFactor({ v1: coords1, v2: coords2 })
      );
      vectorFormFactor.addAssign(
        LTC_EdgeVectorFormFactor({ v1: coords2, v2: coords3 })
      );
      vectorFormFactor.addAssign(
        LTC_EdgeVectorFormFactor({ v1: coords3, v2: coords0 })
      );
      result.assign(vec3(LTC_ClippedSphereFormFactor({ f: vectorFormFactor })));
    });
    return result;
  }
).setLayout({
  name: "LTC_Evaluate",
  type: "vec3",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "P", type: "vec3" },
    { name: "mInv", type: "mat3" },
    { name: "p0", type: "vec3" },
    { name: "p1", type: "vec3" },
    { name: "p2", type: "vec3" },
    { name: "p3", type: "vec3" },
  ],
});
const bC = 1 / 6;
const w0 = (a2) => mul(bC, mul(a2, mul(a2, a2.negate().add(3)).sub(3)).add(1));
const w1 = (a2) => mul(bC, mul(a2, mul(a2, mul(3, a2).sub(6))).add(4));
const w2 = (a2) => mul(bC, mul(a2, mul(a2, mul(-3, a2).add(3)).add(3)).add(1));
const w3 = (a2) => mul(bC, pow(a2, 3));
const g0 = (a2) => w0(a2).add(w1(a2));
const g1 = (a2) => w2(a2).add(w3(a2));
const h0 = (a2) => add(-1, w1(a2).div(w0(a2).add(w1(a2))));
const h1 = (a2) => add(1, w3(a2).div(w2(a2).add(w3(a2))));
const bicubic = (textureNode, texelSize, lod) => {
  const uv2 = textureNode.uvNode;
  const uvScaled = mul(uv2, texelSize.zw).add(0.5);
  const iuv = floor(uvScaled);
  const fuv = fract(uvScaled);
  const g0x = g0(fuv.x);
  const g1x = g1(fuv.x);
  const h0x = h0(fuv.x);
  const h1x = h1(fuv.x);
  const h0y = h0(fuv.y);
  const h1y = h1(fuv.y);
  const p0 = vec2(iuv.x.add(h0x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p1 = vec2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p2 = vec2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const p3 = vec2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const a2 = g0(fuv.y).mul(
    add(
      g0x.mul(textureNode.sample(p0).level(lod)),
      g1x.mul(textureNode.sample(p1).level(lod))
    )
  );
  const b = g1(fuv.y).mul(
    add(
      g0x.mul(textureNode.sample(p2).level(lod)),
      g1x.mul(textureNode.sample(p3).level(lod))
    )
  );
  return a2.add(b);
};
const textureBicubicLevel = /* @__PURE__ */ Fn(([textureNode, lodNode]) => {
  const fLodSize = vec2(textureNode.size(int(lodNode)));
  const cLodSize = vec2(textureNode.size(int(lodNode.add(1))));
  const fLodSizeInv = div(1, fLodSize);
  const cLodSizeInv = div(1, cLodSize);
  const fSample = bicubic(
    textureNode,
    vec4(fLodSizeInv, fLodSize),
    floor(lodNode)
  );
  const cSample = bicubic(
    textureNode,
    vec4(cLodSizeInv, cLodSize),
    ceil(lodNode)
  );
  return fract(lodNode).mix(fSample, cSample);
});
const textureBicubic = /* @__PURE__ */ Fn(([textureNode, strength]) => {
  const lod = strength.mul(maxMipLevel(textureNode));
  return textureBicubicLevel(textureNode, lod);
});
const getVolumeTransmissionRay = /* @__PURE__ */ Fn(
  ([n2, v, thickness2, ior2, modelMatrix]) => {
    const refractionVector = vec3(
      refract(v.negate(), normalize(n2), div(1, ior2))
    );
    const modelScale2 = vec3(
      length(modelMatrix[0].xyz),
      length(modelMatrix[1].xyz),
      length(modelMatrix[2].xyz)
    );
    return normalize(refractionVector).mul(thickness2.mul(modelScale2));
  }
).setLayout({
  name: "getVolumeTransmissionRay",
  type: "vec3",
  inputs: [
    { name: "n", type: "vec3" },
    { name: "v", type: "vec3" },
    { name: "thickness", type: "float" },
    { name: "ior", type: "float" },
    { name: "modelMatrix", type: "mat4" },
  ],
});
const applyIorToRoughness = /* @__PURE__ */ Fn(([roughness2, ior2]) => {
  return roughness2.mul(clamp(ior2.mul(2).sub(2), 0, 1));
}).setLayout({
  name: "applyIorToRoughness",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "ior", type: "float" },
  ],
});
const viewportBackSideTexture = /* @__PURE__ */ viewportMipTexture();
const viewportFrontSideTexture = /* @__PURE__ */ viewportMipTexture();
const getTransmissionSample = /* @__PURE__ */ Fn(
  ([fragCoord, roughness2, ior2], { material }) => {
    const vTexture =
      material.side === BackSide
        ? viewportBackSideTexture
        : viewportFrontSideTexture;
    const transmissionSample = vTexture.sample(fragCoord);
    const lod = log2(screenSize.x).mul(applyIorToRoughness(roughness2, ior2));
    return textureBicubicLevel(transmissionSample, lod);
  }
);
const volumeAttenuation = /* @__PURE__ */ Fn(
  ([transmissionDistance, attenuationColor2, attenuationDistance2]) => {
    If(attenuationDistance2.notEqual(0), () => {
      const attenuationCoefficient = log(attenuationColor2)
        .negate()
        .div(attenuationDistance2);
      const transmittance = exp(
        attenuationCoefficient.negate().mul(transmissionDistance)
      );
      return transmittance;
    });
    return vec3(1);
  }
).setLayout({
  name: "volumeAttenuation",
  type: "vec3",
  inputs: [
    { name: "transmissionDistance", type: "float" },
    { name: "attenuationColor", type: "vec3" },
    { name: "attenuationDistance", type: "float" },
  ],
});
const getIBLVolumeRefraction = /* @__PURE__ */ Fn(
  ([
    n2,
    v,
    roughness2,
    diffuseColor2,
    specularColor2,
    specularF902,
    position,
    modelMatrix,
    viewMatrix,
    projMatrix,
    ior2,
    thickness2,
    attenuationColor2,
    attenuationDistance2,
    dispersion2,
  ]) => {
    let transmittedLight, transmittance;
    if (dispersion2) {
      transmittedLight = vec4().toVar();
      transmittance = vec3().toVar();
      const halfSpread = ior2.sub(1).mul(dispersion2.mul(0.025));
      const iors = vec3(ior2.sub(halfSpread), ior2, ior2.add(halfSpread));
      Loop({ start: 0, end: 3 }, ({ i: i2 }) => {
        const ior3 = iors.element(i2);
        const transmissionRay = getVolumeTransmissionRay(
          n2,
          v,
          thickness2,
          ior3,
          modelMatrix
        );
        const refractedRayExit = position.add(transmissionRay);
        const ndcPos = projMatrix.mul(
          viewMatrix.mul(vec4(refractedRayExit, 1))
        );
        const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
        refractionCoords.addAssign(1);
        refractionCoords.divAssign(2);
        refractionCoords.assign(
          vec2(refractionCoords.x, refractionCoords.y.oneMinus())
        );
        const transmissionSample = getTransmissionSample(
          refractionCoords,
          roughness2,
          ior3
        );
        transmittedLight.element(i2).assign(transmissionSample.element(i2));
        transmittedLight.a.addAssign(transmissionSample.a);
        transmittance
          .element(i2)
          .assign(
            diffuseColor2
              .element(i2)
              .mul(
                volumeAttenuation(
                  length(transmissionRay),
                  attenuationColor2,
                  attenuationDistance2
                ).element(i2)
              )
          );
      });
      transmittedLight.a.divAssign(3);
    } else {
      const transmissionRay = getVolumeTransmissionRay(
        n2,
        v,
        thickness2,
        ior2,
        modelMatrix
      );
      const refractedRayExit = position.add(transmissionRay);
      const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1)));
      const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
      refractionCoords.addAssign(1);
      refractionCoords.divAssign(2);
      refractionCoords.assign(
        vec2(refractionCoords.x, refractionCoords.y.oneMinus())
      );
      transmittedLight = getTransmissionSample(
        refractionCoords,
        roughness2,
        ior2
      );
      transmittance = diffuseColor2.mul(
        volumeAttenuation(
          length(transmissionRay),
          attenuationColor2,
          attenuationDistance2
        )
      );
    }
    const attenuatedColor = transmittance.rgb.mul(transmittedLight.rgb);
    const dotNV = n2.dot(v).clamp();
    const F = vec3(
      EnvironmentBRDF({
        // n, v, specularColor, specularF90, roughness
        dotNV,
        specularColor: specularColor2,
        specularF90: specularF902,
        roughness: roughness2,
      })
    );
    const transmittanceFactor = transmittance.r
      .add(transmittance.g, transmittance.b)
      .div(3);
    return vec4(
      F.oneMinus().mul(attenuatedColor),
      transmittedLight.a.oneMinus().mul(transmittanceFactor).oneMinus()
    );
  }
);
const XYZ_TO_REC709 = /* @__PURE__ */ mat3(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
);
const Fresnel0ToIor = (fresnel0) => {
  const sqrtF0 = fresnel0.sqrt();
  return vec3(1).add(sqrtF0).div(vec3(1).sub(sqrtF0));
};
const IorToFresnel0 = (transmittedIor, incidentIor) => {
  return transmittedIor
    .sub(incidentIor)
    .div(transmittedIor.add(incidentIor))
    .pow2();
};
const evalSensitivity = (OPD, shift) => {
  const phase = OPD.mul(2 * Math.PI * 1e-9);
  const val = vec3(54856e-17, 44201e-17, 52481e-17);
  const pos = vec3(1681e3, 1795300, 2208400);
  const VAR = vec3(43278e5, 93046e5, 66121e5);
  const x = float(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5))
    .mul(phase.mul(2239900).add(shift.x).cos())
    .mul(phase.pow2().mul(-45282e5).exp());
  let xyz = val
    .mul(VAR.mul(2 * Math.PI).sqrt())
    .mul(pos.mul(phase).add(shift).cos())
    .mul(phase.pow2().negate().mul(VAR).exp());
  xyz = vec3(xyz.x.add(x), xyz.y, xyz.z).div(10685e-11);
  const rgb = XYZ_TO_REC709.mul(xyz);
  return rgb;
};
const evalIridescence = /* @__PURE__ */ Fn(
  ({ outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 }) => {
    const iridescenceIOR2 = mix$1(
      outsideIOR,
      eta2,
      smoothstep(0, 0.03, thinFilmThickness)
    );
    const sinTheta2Sq = outsideIOR
      .div(iridescenceIOR2)
      .pow2()
      .mul(cosTheta1.pow2().oneMinus());
    const cosTheta2Sq = sinTheta2Sq.oneMinus();
    If(cosTheta2Sq.lessThan(0), () => {
      return vec3(1);
    });
    const cosTheta2 = cosTheta2Sq.sqrt();
    const R0 = IorToFresnel0(iridescenceIOR2, outsideIOR);
    const R12 = F_Schlick({ f0: R0, f90: 1, dotVH: cosTheta1 });
    const T121 = R12.oneMinus();
    const phi12 = iridescenceIOR2.lessThan(outsideIOR).select(Math.PI, 0);
    const phi21 = float(Math.PI).sub(phi12);
    const baseIOR = Fresnel0ToIor(baseF0.clamp(0, 0.9999));
    const R1 = IorToFresnel0(baseIOR, iridescenceIOR2.toVec3());
    const R23 = F_Schlick({ f0: R1, f90: 1, dotVH: cosTheta2 });
    const phi23 = vec3(
      baseIOR.x.lessThan(iridescenceIOR2).select(Math.PI, 0),
      baseIOR.y.lessThan(iridescenceIOR2).select(Math.PI, 0),
      baseIOR.z.lessThan(iridescenceIOR2).select(Math.PI, 0)
    );
    const OPD = iridescenceIOR2.mul(thinFilmThickness, cosTheta2, 2);
    const phi = vec3(phi21).add(phi23);
    const R123 = R12.mul(R23).clamp(1e-5, 0.9999);
    const r123 = R123.sqrt();
    const Rs = T121.pow2().mul(R23).div(vec3(1).sub(R123));
    const C0 = R12.add(Rs);
    const I = C0.toVar();
    const Cm = Rs.sub(T121).toVar();
    Loop({ start: 1, end: 2, condition: "<=", name: "m" }, ({ m }) => {
      Cm.mulAssign(r123);
      const Sm = evalSensitivity(float(m).mul(OPD), float(m).mul(phi)).mul(2);
      I.addAssign(Cm.mul(Sm));
    });
    return I.max(vec3(0));
  }
).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" },
  ],
});
const IBLSheenBRDF = /* @__PURE__ */ Fn(
  ({ normal: normal2, viewDir, roughness: roughness2 }) => {
    const dotNV = normal2.dot(viewDir).saturate();
    const r2 = roughness2.pow2();
    const a2 = select(
      roughness2.lessThan(0.25),
      float(-339.2).mul(r2).add(float(161.4).mul(roughness2)).sub(25.9),
      float(-8.48).mul(r2).add(float(14.3).mul(roughness2)).sub(9.95)
    );
    const b = select(
      roughness2.lessThan(0.25),
      float(44).mul(r2).sub(float(23.7).mul(roughness2)).add(3.26),
      float(1.97).mul(r2).sub(float(3.27).mul(roughness2)).add(0.72)
    );
    const DG = select(
      roughness2.lessThan(0.25),
      0,
      float(0.1).mul(roughness2).sub(0.025)
    ).add(a2.mul(dotNV).add(b).exp());
    return DG.mul(1 / Math.PI).saturate();
  }
);
const clearcoatF0 = vec3(0.04);
const clearcoatF90 = float(1);
class PhysicalLightingModel extends LightingModel {
  /**
   * Constructs a new physical lighting model.
   *
   * @param {boolean} [clearcoat=false] - Whether clearcoat is supported or not.
   * @param {boolean} [sheen=false] - Whether sheen is supported or not.
   * @param {boolean} [iridescence=false] - Whether iridescence is supported or not.
   * @param {boolean} [anisotropy=false] - Whether anisotropy is supported or not.
   * @param {boolean} [transmission=false] - Whether transmission is supported or not.
   * @param {boolean} [dispersion=false] - Whether dispersion is supported or not.
   */
  constructor(
    clearcoat2 = false,
    sheen2 = false,
    iridescence2 = false,
    anisotropy2 = false,
    transmission2 = false,
    dispersion2 = false
  ) {
    super();
    this.clearcoat = clearcoat2;
    this.sheen = sheen2;
    this.iridescence = iridescence2;
    this.anisotropy = anisotropy2;
    this.transmission = transmission2;
    this.dispersion = dispersion2;
    this.clearcoatRadiance = null;
    this.clearcoatSpecularDirect = null;
    this.clearcoatSpecularIndirect = null;
    this.sheenSpecularDirect = null;
    this.sheenSpecularIndirect = null;
    this.iridescenceFresnel = null;
    this.iridescenceF0 = null;
  }
  /**
   * Depending on what features are requested, the method prepares certain node variables
   * which are later used for lighting computations.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  start(builder) {
    if (this.clearcoat === true) {
      this.clearcoatRadiance = vec3().toVar("clearcoatRadiance");
      this.clearcoatSpecularDirect = vec3().toVar("clearcoatSpecularDirect");
      this.clearcoatSpecularIndirect = vec3().toVar(
        "clearcoatSpecularIndirect"
      );
    }
    if (this.sheen === true) {
      this.sheenSpecularDirect = vec3().toVar("sheenSpecularDirect");
      this.sheenSpecularIndirect = vec3().toVar("sheenSpecularIndirect");
    }
    if (this.iridescence === true) {
      const dotNVi = normalView.dot(positionViewDirection).clamp();
      this.iridescenceFresnel = evalIridescence({
        outsideIOR: float(1),
        eta2: iridescenceIOR,
        cosTheta1: dotNVi,
        thinFilmThickness: iridescenceThickness,
        baseF0: specularColor,
      });
      this.iridescenceF0 = Schlick_to_F0({
        f: this.iridescenceFresnel,
        f90: 1,
        dotVH: dotNVi,
      });
    }
    if (this.transmission === true) {
      const position = positionWorld;
      const v = cameraPosition.sub(positionWorld).normalize();
      const n2 = normalWorld;
      const context2 = builder.context;
      context2.backdrop = getIBLVolumeRefraction(
        n2,
        v,
        roughness,
        diffuseColor,
        specularColor,
        specularF90,
        // specularF90
        position,
        // positionWorld
        modelWorldMatrix,
        // modelMatrix
        cameraViewMatrix,
        // viewMatrix
        cameraProjectionMatrix,
        // projMatrix
        ior,
        thickness,
        attenuationColor,
        attenuationDistance,
        this.dispersion ? dispersion : null
      );
      context2.backdropAlpha = transmission;
      diffuseColor.a.mulAssign(mix$1(1, context2.backdrop.a, transmission));
    }
    super.start(builder);
  }
  // Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multi-scattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(singleScatter, multiScatter, specularF902) {
    const dotNV = normalView.dot(positionViewDirection).clamp();
    const fab = DFGApprox({ roughness, dotNV });
    const Fr = this.iridescenceF0
      ? iridescence.mix(specularColor, this.iridescenceF0)
      : specularColor;
    const FssEss = Fr.mul(fab.x).add(specularF902.mul(fab.y));
    const Ess = fab.x.add(fab.y);
    const Ems = Ess.oneMinus();
    const Favg = specularColor.add(specularColor.oneMinus().mul(0.047619));
    const Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());
    singleScatter.addAssign(FssEss);
    multiScatter.addAssign(Fms.mul(Ems));
  }
  /**
   * Implements the direct light.
   *
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct({ lightDirection, lightColor, reflectedLight }) {
    const dotNL = normalView.dot(lightDirection).clamp();
    const irradiance = dotNL.mul(lightColor);
    if (this.sheen === true) {
      this.sheenSpecularDirect.addAssign(
        irradiance.mul(BRDF_Sheen({ lightDirection }))
      );
    }
    if (this.clearcoat === true) {
      const dotNLcc = clearcoatNormalView.dot(lightDirection).clamp();
      const ccIrradiance = dotNLcc.mul(lightColor);
      this.clearcoatSpecularDirect.addAssign(
        ccIrradiance.mul(
          BRDF_GGX({
            lightDirection,
            f0: clearcoatF0,
            f90: clearcoatF90,
            roughness: clearcoatRoughness,
            normalView: clearcoatNormalView,
          })
        )
      );
    }
    reflectedLight.directDiffuse.addAssign(
      irradiance.mul(BRDF_Lambert({ diffuseColor: diffuseColor.rgb }))
    );
    reflectedLight.directSpecular.addAssign(
      irradiance.mul(
        BRDF_GGX({
          lightDirection,
          f0: specularColor,
          f90: 1,
          roughness,
          iridescence: this.iridescence,
          f: this.iridescenceFresnel,
          USE_IRIDESCENCE: this.iridescence,
          USE_ANISOTROPY: this.anisotropy,
        })
      )
    );
  }
  /**
   * This method is intended for implementing the direct light term for
   * rect area light nodes.
   *
   * @param {Object} input - The input data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  directRectArea({
    lightColor,
    lightPosition: lightPosition2,
    halfWidth,
    halfHeight,
    reflectedLight,
    ltc_1,
    ltc_2,
  }) {
    const p0 = lightPosition2.add(halfWidth).sub(halfHeight);
    const p1 = lightPosition2.sub(halfWidth).sub(halfHeight);
    const p2 = lightPosition2.sub(halfWidth).add(halfHeight);
    const p3 = lightPosition2.add(halfWidth).add(halfHeight);
    const N2 = normalView;
    const V = positionViewDirection;
    const P = positionView.toVar();
    const uv2 = LTC_Uv({ N: N2, V, roughness });
    const t1 = ltc_1.sample(uv2).toVar();
    const t2 = ltc_2.sample(uv2).toVar();
    const mInv = mat3(
      vec3(t1.x, 0, t1.y),
      vec3(0, 1, 0),
      vec3(t1.z, 0, t1.w)
    ).toVar();
    const fresnel = specularColor
      .mul(t2.x)
      .add(specularColor.oneMinus().mul(t2.y))
      .toVar();
    reflectedLight.directSpecular.addAssign(
      lightColor
        .mul(fresnel)
        .mul(LTC_Evaluate({ N: N2, V, P, mInv, p0, p1, p2, p3 }))
    );
    reflectedLight.directDiffuse.addAssign(
      lightColor.mul(diffuseColor).mul(
        LTC_Evaluate({
          N: N2,
          V,
          P,
          mInv: mat3(1, 0, 0, 0, 1, 0, 0, 0, 1),
          p0,
          p1,
          p2,
          p3,
        })
      )
    );
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(builder) {
    this.indirectDiffuse(builder);
    this.indirectSpecular(builder);
    this.ambientOcclusion(builder);
  }
  /**
   * Implements the indirect diffuse term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirectDiffuse(builder) {
    const { irradiance, reflectedLight } = builder.context;
    reflectedLight.indirectDiffuse.addAssign(
      irradiance.mul(BRDF_Lambert({ diffuseColor }))
    );
  }
  /**
   * Implements the indirect specular term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirectSpecular(builder) {
    const { radiance, iblIrradiance, reflectedLight } = builder.context;
    if (this.sheen === true) {
      this.sheenSpecularIndirect.addAssign(
        iblIrradiance.mul(
          sheen,
          IBLSheenBRDF({
            normal: normalView,
            viewDir: positionViewDirection,
            roughness: sheenRoughness,
          })
        )
      );
    }
    if (this.clearcoat === true) {
      const dotNVcc = clearcoatNormalView.dot(positionViewDirection).clamp();
      const clearcoatEnv = EnvironmentBRDF({
        dotNV: dotNVcc,
        specularColor: clearcoatF0,
        specularF90: clearcoatF90,
        roughness: clearcoatRoughness,
      });
      this.clearcoatSpecularIndirect.addAssign(
        this.clearcoatRadiance.mul(clearcoatEnv)
      );
    }
    const singleScattering = vec3().toVar("singleScattering");
    const multiScattering = vec3().toVar("multiScattering");
    const cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);
    this.computeMultiscattering(singleScattering, multiScattering, specularF90);
    const totalScattering = singleScattering.add(multiScattering);
    const diffuse = diffuseColor.mul(
      totalScattering.r.max(totalScattering.g).max(totalScattering.b).oneMinus()
    );
    reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));
    reflectedLight.indirectSpecular.addAssign(
      multiScattering.mul(cosineWeightedIrradiance)
    );
    reflectedLight.indirectDiffuse.addAssign(
      diffuse.mul(cosineWeightedIrradiance)
    );
  }
  /**
   * Implements the ambient occlusion term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  ambientOcclusion(builder) {
    const { ambientOcclusion, reflectedLight } = builder.context;
    const dotNV = normalView.dot(positionViewDirection).clamp();
    const aoNV = dotNV.add(ambientOcclusion);
    const aoExp = roughness.mul(-16).oneMinus().negate().exp2();
    const aoNode = ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();
    if (this.clearcoat === true) {
      this.clearcoatSpecularIndirect.mulAssign(ambientOcclusion);
    }
    if (this.sheen === true) {
      this.sheenSpecularIndirect.mulAssign(ambientOcclusion);
    }
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
    reflectedLight.indirectSpecular.mulAssign(aoNode);
  }
  /**
   * Used for final lighting accumulations depending on the requested features.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish({ context: context2 }) {
    const { outgoingLight } = context2;
    if (this.clearcoat === true) {
      const dotNVcc = clearcoatNormalView.dot(positionViewDirection).clamp();
      const Fcc = F_Schlick({
        dotVH: dotNVcc,
        f0: clearcoatF0,
        f90: clearcoatF90,
      });
      const clearcoatLight = outgoingLight
        .mul(clearcoat.mul(Fcc).oneMinus())
        .add(
          this.clearcoatSpecularDirect
            .add(this.clearcoatSpecularIndirect)
            .mul(clearcoat)
        );
      outgoingLight.assign(clearcoatLight);
    }
    if (this.sheen === true) {
      const sheenEnergyComp = sheen.r
        .max(sheen.g)
        .max(sheen.b)
        .mul(0.157)
        .oneMinus();
      const sheenLight = outgoingLight
        .mul(sheenEnergyComp)
        .add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
      outgoingLight.assign(sheenLight);
    }
  }
}
const cubeUV_r0 = /* @__PURE__ */ float(1);
const cubeUV_m0 = /* @__PURE__ */ float(-2);
const cubeUV_r1 = /* @__PURE__ */ float(0.8);
const cubeUV_m1 = /* @__PURE__ */ float(-1);
const cubeUV_r4 = /* @__PURE__ */ float(0.4);
const cubeUV_m4 = /* @__PURE__ */ float(2);
const cubeUV_r5 = /* @__PURE__ */ float(0.305);
const cubeUV_m5 = /* @__PURE__ */ float(3);
const cubeUV_r6 = /* @__PURE__ */ float(0.21);
const cubeUV_m6 = /* @__PURE__ */ float(4);
const cubeUV_minMipLevel = /* @__PURE__ */ float(4);
const cubeUV_minTileSize = /* @__PURE__ */ float(16);
const getFace = /* @__PURE__ */ Fn(([direction]) => {
  const absDirection = vec3(abs(direction)).toVar();
  const face = float(-1).toVar();
  If(absDirection.x.greaterThan(absDirection.z), () => {
    If(absDirection.x.greaterThan(absDirection.y), () => {
      face.assign(select(direction.x.greaterThan(0), 0, 3));
    }).Else(() => {
      face.assign(select(direction.y.greaterThan(0), 1, 4));
    });
  }).Else(() => {
    If(absDirection.z.greaterThan(absDirection.y), () => {
      face.assign(select(direction.z.greaterThan(0), 2, 5));
    }).Else(() => {
      face.assign(select(direction.y.greaterThan(0), 1, 4));
    });
  });
  return face;
}).setLayout({
  name: "getFace",
  type: "float",
  inputs: [{ name: "direction", type: "vec3" }],
});
const getUV = /* @__PURE__ */ Fn(([direction, face]) => {
  const uv2 = vec2().toVar();
  If(face.equal(0), () => {
    uv2.assign(vec2(direction.z, direction.y).div(abs(direction.x)));
  })
    .ElseIf(face.equal(1), () => {
      uv2.assign(
        vec2(direction.x.negate(), direction.z.negate()).div(abs(direction.y))
      );
    })
    .ElseIf(face.equal(2), () => {
      uv2.assign(vec2(direction.x.negate(), direction.y).div(abs(direction.z)));
    })
    .ElseIf(face.equal(3), () => {
      uv2.assign(vec2(direction.z.negate(), direction.y).div(abs(direction.x)));
    })
    .ElseIf(face.equal(4), () => {
      uv2.assign(vec2(direction.x.negate(), direction.z).div(abs(direction.y)));
    })
    .Else(() => {
      uv2.assign(vec2(direction.x, direction.y).div(abs(direction.z)));
    });
  return mul(0.5, uv2.add(1));
}).setLayout({
  name: "getUV",
  type: "vec2",
  inputs: [
    { name: "direction", type: "vec3" },
    { name: "face", type: "float" },
  ],
});
const roughnessToMip = /* @__PURE__ */ Fn(([roughness2]) => {
  const mip = float(0).toVar();
  If(roughness2.greaterThanEqual(cubeUV_r1), () => {
    mip.assign(
      cubeUV_r0
        .sub(roughness2)
        .mul(cubeUV_m1.sub(cubeUV_m0))
        .div(cubeUV_r0.sub(cubeUV_r1))
        .add(cubeUV_m0)
    );
  })
    .ElseIf(roughness2.greaterThanEqual(cubeUV_r4), () => {
      mip.assign(
        cubeUV_r1
          .sub(roughness2)
          .mul(cubeUV_m4.sub(cubeUV_m1))
          .div(cubeUV_r1.sub(cubeUV_r4))
          .add(cubeUV_m1)
      );
    })
    .ElseIf(roughness2.greaterThanEqual(cubeUV_r5), () => {
      mip.assign(
        cubeUV_r4
          .sub(roughness2)
          .mul(cubeUV_m5.sub(cubeUV_m4))
          .div(cubeUV_r4.sub(cubeUV_r5))
          .add(cubeUV_m4)
      );
    })
    .ElseIf(roughness2.greaterThanEqual(cubeUV_r6), () => {
      mip.assign(
        cubeUV_r5
          .sub(roughness2)
          .mul(cubeUV_m6.sub(cubeUV_m5))
          .div(cubeUV_r5.sub(cubeUV_r6))
          .add(cubeUV_m5)
      );
    })
    .Else(() => {
      mip.assign(float(-2).mul(log2(mul(1.16, roughness2))));
    });
  return mip;
}).setLayout({
  name: "roughnessToMip",
  type: "float",
  inputs: [{ name: "roughness", type: "float" }],
});
const getDirection = /* @__PURE__ */ Fn(([uv_immutable, face]) => {
  const uv2 = uv_immutable.toVar();
  uv2.assign(mul(2, uv2).sub(1));
  const direction = vec3(uv2, 1).toVar();
  If(face.equal(0), () => {
    direction.assign(direction.zyx);
  })
    .ElseIf(face.equal(1), () => {
      direction.assign(direction.xzy);
      direction.xz.mulAssign(-1);
    })
    .ElseIf(face.equal(2), () => {
      direction.x.mulAssign(-1);
    })
    .ElseIf(face.equal(3), () => {
      direction.assign(direction.zyx);
      direction.xz.mulAssign(-1);
    })
    .ElseIf(face.equal(4), () => {
      direction.assign(direction.xzy);
      direction.xy.mulAssign(-1);
    })
    .ElseIf(face.equal(5), () => {
      direction.z.mulAssign(-1);
    });
  return direction;
}).setLayout({
  name: "getDirection",
  type: "vec3",
  inputs: [
    { name: "uv", type: "vec2" },
    { name: "face", type: "float" },
  ],
});
const textureCubeUV = /* @__PURE__ */ Fn(
  ([
    envMap,
    sampleDir_immutable,
    roughness_immutable,
    CUBEUV_TEXEL_WIDTH,
    CUBEUV_TEXEL_HEIGHT,
    CUBEUV_MAX_MIP,
  ]) => {
    const roughness2 = float(roughness_immutable);
    const sampleDir = vec3(sampleDir_immutable);
    const mip = clamp(roughnessToMip(roughness2), cubeUV_m0, CUBEUV_MAX_MIP);
    const mipF = fract(mip);
    const mipInt = floor(mip);
    const color0 = vec3(
      bilinearCubeUV(
        envMap,
        sampleDir,
        mipInt,
        CUBEUV_TEXEL_WIDTH,
        CUBEUV_TEXEL_HEIGHT,
        CUBEUV_MAX_MIP
      )
    ).toVar();
    If(mipF.notEqual(0), () => {
      const color1 = vec3(
        bilinearCubeUV(
          envMap,
          sampleDir,
          mipInt.add(1),
          CUBEUV_TEXEL_WIDTH,
          CUBEUV_TEXEL_HEIGHT,
          CUBEUV_MAX_MIP
        )
      ).toVar();
      color0.assign(mix$1(color0, color1, mipF));
    });
    return color0;
  }
);
const bilinearCubeUV = /* @__PURE__ */ Fn(
  ([
    envMap,
    direction_immutable,
    mipInt_immutable,
    CUBEUV_TEXEL_WIDTH,
    CUBEUV_TEXEL_HEIGHT,
    CUBEUV_MAX_MIP,
  ]) => {
    const mipInt = float(mipInt_immutable).toVar();
    const direction = vec3(direction_immutable);
    const face = float(getFace(direction)).toVar();
    const filterInt = float(max$1(cubeUV_minMipLevel.sub(mipInt), 0)).toVar();
    mipInt.assign(max$1(mipInt, cubeUV_minMipLevel));
    const faceSize = float(exp2(mipInt)).toVar();
    const uv2 = vec2(
      getUV(direction, face).mul(faceSize.sub(2)).add(1)
    ).toVar();
    If(face.greaterThan(2), () => {
      uv2.y.addAssign(faceSize);
      face.subAssign(3);
    });
    uv2.x.addAssign(face.mul(faceSize));
    uv2.x.addAssign(filterInt.mul(mul(3, cubeUV_minTileSize)));
    uv2.y.addAssign(mul(4, exp2(CUBEUV_MAX_MIP).sub(faceSize)));
    uv2.x.mulAssign(CUBEUV_TEXEL_WIDTH);
    uv2.y.mulAssign(CUBEUV_TEXEL_HEIGHT);
    return envMap.sample(uv2).grad(vec2(), vec2());
  }
);
const getSample = /* @__PURE__ */ Fn(
  ({
    envMap,
    mipInt,
    outputDirection,
    theta,
    axis,
    CUBEUV_TEXEL_WIDTH,
    CUBEUV_TEXEL_HEIGHT,
    CUBEUV_MAX_MIP,
  }) => {
    const cosTheta = cos(theta);
    const sampleDirection = outputDirection
      .mul(cosTheta)
      .add(axis.cross(outputDirection).mul(sin(theta)))
      .add(axis.mul(axis.dot(outputDirection).mul(cosTheta.oneMinus())));
    return bilinearCubeUV(
      envMap,
      sampleDirection,
      mipInt,
      CUBEUV_TEXEL_WIDTH,
      CUBEUV_TEXEL_HEIGHT,
      CUBEUV_MAX_MIP
    );
  }
);
const blur = /* @__PURE__ */ Fn(
  ({
    n: n2,
    latitudinal,
    poleAxis,
    outputDirection,
    weights,
    samples,
    dTheta,
    mipInt,
    envMap,
    CUBEUV_TEXEL_WIDTH,
    CUBEUV_TEXEL_HEIGHT,
    CUBEUV_MAX_MIP,
  }) => {
    const axis = vec3(
      select(latitudinal, poleAxis, cross(poleAxis, outputDirection))
    ).toVar();
    If(axis.equal(vec3(0)), () => {
      axis.assign(vec3(outputDirection.z, 0, outputDirection.x.negate()));
    });
    axis.assign(normalize(axis));
    const gl_FragColor = vec3().toVar();
    gl_FragColor.addAssign(
      weights.element(0).mul(
        getSample({
          theta: 0,
          axis,
          outputDirection,
          mipInt,
          envMap,
          CUBEUV_TEXEL_WIDTH,
          CUBEUV_TEXEL_HEIGHT,
          CUBEUV_MAX_MIP,
        })
      )
    );
    Loop({ start: int(1), end: n2 }, ({ i: i2 }) => {
      If(i2.greaterThanEqual(samples), () => {
        Break();
      });
      const theta = float(dTheta.mul(float(i2))).toVar();
      gl_FragColor.addAssign(
        weights.element(i2).mul(
          getSample({
            theta: theta.mul(-1),
            axis,
            outputDirection,
            mipInt,
            envMap,
            CUBEUV_TEXEL_WIDTH,
            CUBEUV_TEXEL_HEIGHT,
            CUBEUV_MAX_MIP,
          })
        )
      );
      gl_FragColor.addAssign(
        weights.element(i2).mul(
          getSample({
            theta,
            axis,
            outputDirection,
            mipInt,
            envMap,
            CUBEUV_TEXEL_WIDTH,
            CUBEUV_TEXEL_HEIGHT,
            CUBEUV_MAX_MIP,
          })
        )
      );
    });
    return vec4(gl_FragColor, 1);
  }
);
const LOD_MIN = 4;
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const MAX_SAMPLES = 20;
const _flatCamera = /* @__PURE__ */ new OrthographicCamera(-1, 1, 1, -1, 0, 1);
const _cubeCamera = /* @__PURE__ */ new PerspectiveCamera(90, 1);
const _clearColor$2 = /* @__PURE__ */ new Color();
let _oldTarget = null;
let _oldActiveCubeFace = 0;
let _oldActiveMipmapLevel = 0;
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
const _axisDirections = [
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, 1),
];
const _origin = /* @__PURE__ */ new Vector3();
const _uniformsMap = /* @__PURE__ */ new WeakMap();
const _faceLib = [3, 1, 5, 0, 4, 2];
const _direction = /* @__PURE__ */ getDirection(
  uv$1(),
  attribute("faceIndex")
).normalize();
const _outputDirection = /* @__PURE__ */ vec3(
  _direction.x,
  _direction.y,
  _direction.z
);
class PMREMGenerator {
  /**
   * Constructs a new PMREM generator.
   *
   * @param {Renderer} renderer - The renderer.
   */
  constructor(renderer2) {
    this._renderer = renderer2;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._lodMeshes = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._backgroundBox = null;
  }
  get _hasInitialized() {
    return this._renderer.hasInitialized();
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety.
   *
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.
   * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromSceneAsync}
   */
  fromScene(scene2, sigma = 0, near = 0.1, far = 100, options = {}) {
    const { size = 256, position = _origin, renderTarget = null } = options;
    this._setSize(size);
    if (this._hasInitialized === false) {
      console.warn(
        "THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead."
      );
      const cubeUVRenderTarget2 = renderTarget || this._allocateTarget();
      options.renderTarget = cubeUVRenderTarget2;
      this.fromSceneAsync(scene2, sigma, near, far, options);
      return cubeUVRenderTarget2;
    }
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    const cubeUVRenderTarget = renderTarget || this._allocateTarget();
    cubeUVRenderTarget.depthBuffer = true;
    this._init(cubeUVRenderTarget);
    this._sceneToCubeUV(scene2, near, far, cubeUVRenderTarget, position);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   *
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.position=origin] - The position of the internal cube camera that renders the scene.
   * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} A Promise that resolve with the PMREM when the generation has been finished.
   * @see {@link PMREMGenerator#fromScene}
   */
  async fromSceneAsync(scene2, sigma = 0, near = 0.1, far = 100, options = {}) {
    if (this._hasInitialized === false) await this._renderer.init();
    return this.fromScene(scene2, sigma, near, far, options);
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromEquirectangularAsync}
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    if (this._hasInitialized === false) {
      console.warn(
        "THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead."
      );
      this._setSizeFromTexture(equirectangular);
      const cubeUVRenderTarget = renderTarget || this._allocateTarget();
      this.fromEquirectangularAsync(equirectangular, cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} The resulting PMREM.
   * @see {@link PMREMGenerator#fromEquirectangular}
   */
  async fromEquirectangularAsync(equirectangular, renderTarget = null) {
    if (this._hasInitialized === false) await this._renderer.init();
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromCubemapAsync}
   */
  fromCubemap(cubemap, renderTarget = null) {
    if (this._hasInitialized === false) {
      console.warn(
        "THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead."
      );
      this._setSizeFromTexture(cubemap);
      const cubeUVRenderTarget = renderTarget || this._allocateTarget();
      this.fromCubemapAsync(cubemap, renderTarget);
      return cubeUVRenderTarget;
    }
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * with the 256 x 256 cubemap output.
   *
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} The resulting PMREM.
   * @see {@link PMREMGenerator#fromCubemap}
   */
  async fromCubemapAsync(cubemap, renderTarget = null) {
    if (this._hasInitialized === false) await this._renderer.init();
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   *
   * @returns {Promise}
   */
  async compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      await this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   *
   * @returns {Promise}
   */
  async compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      await this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
    if (this._backgroundBox !== null) {
      this._backgroundBox.geometry.dispose();
      this._backgroundBox.material.dispose();
    }
  }
  // private interface
  _setSizeFromTexture(texture2) {
    if (
      texture2.mapping === CubeReflectionMapping ||
      texture2.mapping === CubeRefractionMapping
    ) {
      this._setSize(
        texture2.image.length === 0
          ? 16
          : texture2.image[0].width || texture2.image[0].image.width
      );
    } else {
      this._setSize(texture2.image.width / 4);
    }
  }
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null) this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null)
      this._pingPongRenderTarget.dispose();
    for (let i2 = 0; i2 < this._lodPlanes.length; i2++) {
      this._lodPlanes[i2].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(
      _oldTarget,
      _oldActiveCubeFace,
      _oldActiveMipmapLevel
    );
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture2, renderTarget) {
    this._setSizeFromTexture(texture2);
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    const cubeUVRenderTarget = renderTarget || this._allocateTarget();
    this._init(cubeUVRenderTarget);
    this._textureToCubeUV(texture2, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTarget() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const cubeUVRenderTarget = _createRenderTarget(width, height);
    return cubeUVRenderTarget;
  }
  _init(renderTarget) {
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== renderTarget.width ||
      this._pingPongRenderTarget.height !== renderTarget.height
    ) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(
        renderTarget.width,
        renderTarget.height
      );
      const { _lodMax } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
        lodMeshes: this._lodMeshes,
      } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(
        _lodMax,
        renderTarget.width,
        renderTarget.height
      );
    }
  }
  async _compileMaterial(material) {
    const tmpMesh = new Mesh(this._lodPlanes[0], material);
    await this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene2, near, far, cubeUVRenderTarget, position) {
    const cubeCamera = _cubeCamera;
    cubeCamera.near = near;
    cubeCamera.far = far;
    const upSign = [1, 1, 1, 1, -1, 1];
    const forwardSign = [1, -1, 1, -1, 1, -1];
    const renderer2 = this._renderer;
    const originalAutoClear = renderer2.autoClear;
    renderer2.getClearColor(_clearColor$2);
    renderer2.autoClear = false;
    let backgroundBox = this._backgroundBox;
    if (backgroundBox === null) {
      const backgroundMaterial = new MeshBasicMaterial({
        name: "PMREM.Background",
        side: BackSide,
        depthWrite: false,
        depthTest: false,
      });
      backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    }
    let useSolidColor = false;
    const background = scene2.background;
    if (background) {
      if (background.isColor) {
        backgroundBox.material.color.copy(background);
        scene2.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundBox.material.color.copy(_clearColor$2);
      useSolidColor = true;
    }
    renderer2.setRenderTarget(cubeUVRenderTarget);
    renderer2.clear();
    if (useSolidColor) {
      renderer2.render(backgroundBox, cubeCamera);
    }
    for (let i2 = 0; i2 < 6; i2++) {
      const col = i2 % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x + forwardSign[i2], position.y, position.z);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i2]);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x, position.y + forwardSign[i2], position.z);
      } else {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x, position.y, position.z + forwardSign[i2]);
      }
      const size = this._cubeSize;
      _setViewport(
        cubeUVRenderTarget,
        col * size,
        i2 > 2 ? size : 0,
        size,
        size
      );
      renderer2.render(scene2, cubeCamera);
    }
    renderer2.autoClear = originalAutoClear;
    scene2.background = background;
  }
  _textureToCubeUV(texture2, cubeUVRenderTarget) {
    const renderer2 = this._renderer;
    const isCubeTexture =
      texture2.mapping === CubeReflectionMapping ||
      texture2.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial(texture2);
      }
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial(texture2);
      }
    }
    const material = isCubeTexture
      ? this._cubemapMaterial
      : this._equirectMaterial;
    material.fragmentNode.value = texture2;
    const mesh = this._lodMeshes[0];
    mesh.material = material;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer2.setRenderTarget(cubeUVRenderTarget);
    renderer2.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer2 = this._renderer;
    const autoClear = renderer2.autoClear;
    renderer2.autoClear = false;
    const n2 = this._lodPlanes.length;
    for (let i2 = 1; i2 < n2; i2++) {
      const sigma = Math.sqrt(
        this._sigmas[i2] * this._sigmas[i2] -
          this._sigmas[i2 - 1] * this._sigmas[i2 - 1]
      );
      const poleAxis = _axisDirections[(n2 - i2 - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
    }
    renderer2.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   *
   * @private
   * @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.
   * @param {number} lodIn - The input level-of-detail.
   * @param {number} lodOut - The output level-of-detail.
   * @param {number} sigma - The blur radius in radians.
   * @param {Vector3} [poleAxis] - The pole axis.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(
    targetIn,
    targetOut,
    lodIn,
    lodOut,
    sigmaRadians,
    direction,
    poleAxis
  ) {
    const renderer2 = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = this._lodMeshes[lodOut];
    blurMesh.material = blurMaterial;
    const blurUniforms = _uniformsMap.get(blurMaterial);
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians)
      ? Math.PI / (2 * pixels)
      : (2 * Math.PI) / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians)
      ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels)
      : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(
        `sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`
      );
    }
    const weights = [];
    let sum = 0;
    for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
      const x2 = i2 / sigmaPixels;
      const weight = Math.exp((-x2 * x2) / 2);
      weights.push(weight);
      if (i2 === 0) {
        sum += weight;
      } else if (i2 < samples) {
        sum += 2 * weight;
      }
    }
    for (let i2 = 0; i2 < weights.length; i2++) {
      weights[i2] = weights[i2] / sum;
    }
    targetIn.texture.frame = (targetIn.texture.frame || 0) + 1;
    blurUniforms.envMap.value = targetIn.texture;
    blurUniforms.samples.value = samples;
    blurUniforms.weights.array = weights;
    blurUniforms.latitudinal.value = direction === "latitudinal" ? 1 : 0;
    if (poleAxis) {
      blurUniforms.poleAxis.value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms.dTheta.value = radiansPerPixel;
    blurUniforms.mipInt.value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x =
      3 *
      outputSize *
      (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
    renderer2.setRenderTarget(targetOut);
    renderer2.render(blurMesh, _flatCamera);
  }
}
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  const lodMeshes = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i2 = 0; i2 < totalLods; i2++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i2 > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i2 - lodMax + LOD_MIN - 1];
    } else if (i2 === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min2 = -texelSize;
    const max2 = 1 + texelSize;
    const uv1 = [
      min2,
      min2,
      max2,
      min2,
      max2,
      max2,
      min2,
      min2,
      max2,
      max2,
      min2,
      max2,
    ];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv2 = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = ((face % 3) * 2) / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [
        x,
        y,
        0,
        x + 2 / 3,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y + 1,
        0,
      ];
      const faceIdx = _faceLib[face];
      position.set(coordinates, positionSize * vertices * faceIdx);
      uv2.set(uv1, uvSize * vertices * faceIdx);
      const fill = [faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx];
      faceIndex.set(fill, faceIndexSize * vertices * faceIdx);
    }
    const planes = new BufferGeometry();
    planes.setAttribute(
      "position",
      new BufferAttribute(position, positionSize)
    );
    planes.setAttribute("uv", new BufferAttribute(uv2, uvSize));
    planes.setAttribute(
      "faceIndex",
      new BufferAttribute(faceIndex, faceIndexSize)
    );
    lodPlanes.push(planes);
    lodMeshes.push(new Mesh(planes, null));
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas, lodMeshes };
}
function _createRenderTarget(width, height) {
  const params = {
    magFilter: LinearFilter,
    minFilter: LinearFilter,
    generateMipmaps: false,
    type: HalfFloatType,
    format: RGBAFormat,
    colorSpace: LinearSRGBColorSpace,
    //depthBuffer: false
  };
  const cubeUVRenderTarget = new RenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.texture.isPMREMTexture = true;
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height);
  target.scissor.set(x, y, width, height);
}
function _getMaterial(type) {
  const material = new NodeMaterial();
  material.depthTest = false;
  material.depthWrite = false;
  material.blending = NoBlending;
  material.name = `PMREM_${type}`;
  return material;
}
function _getBlurShader(lodMax, width, height) {
  const weights = uniformArray(new Array(MAX_SAMPLES).fill(0));
  const poleAxis = uniform$1(new Vector3(0, 1, 0));
  const dTheta = uniform$1(0);
  const n2 = float(MAX_SAMPLES);
  const latitudinal = uniform$1(0);
  const samples = uniform$1(1);
  const envMap = texture$1(null);
  const mipInt = uniform$1(0);
  const CUBEUV_TEXEL_WIDTH = float(1 / width);
  const CUBEUV_TEXEL_HEIGHT = float(1 / height);
  const CUBEUV_MAX_MIP = float(lodMax);
  const materialUniforms = {
    n: n2,
    latitudinal,
    weights,
    poleAxis,
    outputDirection: _outputDirection,
    dTheta,
    samples,
    envMap,
    mipInt,
    CUBEUV_TEXEL_WIDTH,
    CUBEUV_TEXEL_HEIGHT,
    CUBEUV_MAX_MIP,
  };
  const material = _getMaterial("blur");
  material.fragmentNode = blur({
    ...materialUniforms,
    latitudinal: latitudinal.equal(1),
  });
  _uniformsMap.set(material, materialUniforms);
  return material;
}
function _getCubemapMaterial(envTexture) {
  const material = _getMaterial("cubemap");
  material.fragmentNode = cubeTexture(envTexture, _outputDirection);
  return material;
}
function _getEquirectMaterial(envTexture) {
  const material = _getMaterial("equirect");
  material.fragmentNode = texture$1(
    envTexture,
    equirectUV(_outputDirection),
    0
  );
  return material;
}
const _cache = /* @__PURE__ */ new WeakMap();
function _generateCubeUVSize(imageHeight) {
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function _getPMREMFromTexture(texture2, renderer2, generator) {
  const cache2 = _getCache(renderer2);
  let cacheTexture = cache2.get(texture2);
  const pmremVersion = cacheTexture !== void 0 ? cacheTexture.pmremVersion : -1;
  if (pmremVersion !== texture2.pmremVersion) {
    const image = texture2.image;
    if (texture2.isCubeTexture) {
      if (isCubeMapReady(image)) {
        cacheTexture = generator.fromCubemap(texture2, cacheTexture);
      } else {
        return null;
      }
    } else {
      if (isEquirectangularMapReady(image)) {
        cacheTexture = generator.fromEquirectangular(texture2, cacheTexture);
      } else {
        return null;
      }
    }
    cacheTexture.pmremVersion = texture2.pmremVersion;
    cache2.set(texture2, cacheTexture);
  }
  return cacheTexture.texture;
}
function _getCache(renderer2) {
  let rendererCache2 = _cache.get(renderer2);
  if (rendererCache2 === void 0) {
    rendererCache2 = /* @__PURE__ */ new WeakMap();
    _cache.set(renderer2, rendererCache2);
  }
  return rendererCache2;
}
class PMREMNode extends TempNode {
  static get type() {
    return "PMREMNode";
  }
  /**
   * Constructs a new function overloading node.
   *
   * @param {Texture} value - The input texture.
   * @param {Node<vec2>} [uvNode=null] - The uv node.
   * @param {Node<float>} [levelNode=null] - The level node.
   */
  constructor(value, uvNode = null, levelNode = null) {
    super("vec3");
    this._value = value;
    this._pmrem = null;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this._generator = null;
    const defaultTexture = new Texture();
    defaultTexture.isRenderTargetTexture = true;
    this._texture = texture$1(defaultTexture);
    this._width = uniform$1(0);
    this._height = uniform$1(0);
    this._maxMip = uniform$1(0);
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  set value(value) {
    this._value = value;
    this._pmrem = null;
  }
  /**
   * The node's texture value.
   *
   * @type {Texture}
   */
  get value() {
    return this._value;
  }
  /**
   * Uses the given PMREM texture to update internal values.
   *
   * @param {Texture} texture - The PMREM texture.
   */
  updateFromTexture(texture2) {
    const cubeUVSize = _generateCubeUVSize(texture2.image.height);
    this._texture.value = texture2;
    this._width.value = cubeUVSize.texelWidth;
    this._height.value = cubeUVSize.texelHeight;
    this._maxMip.value = cubeUVSize.maxMip;
  }
  updateBefore(frame) {
    let pmrem = this._pmrem;
    const pmremVersion = pmrem ? pmrem.pmremVersion : -1;
    const texture2 = this._value;
    if (pmremVersion !== texture2.pmremVersion) {
      if (texture2.isPMREMTexture === true) {
        pmrem = texture2;
      } else {
        pmrem = _getPMREMFromTexture(texture2, frame.renderer, this._generator);
      }
      if (pmrem !== null) {
        this._pmrem = pmrem;
        this.updateFromTexture(pmrem);
      }
    }
  }
  setup(builder) {
    if (this._generator === null) {
      this._generator = new PMREMGenerator(builder.renderer);
    }
    this.updateBefore(builder);
    let uvNode = this.uvNode;
    if (uvNode === null && builder.context.getUV) {
      uvNode = builder.context.getUV(this);
    }
    uvNode = materialEnvRotation.mul(
      vec3(uvNode.x, uvNode.y.negate(), uvNode.z)
    );
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    return textureCubeUV(
      this._texture,
      uvNode,
      levelNode,
      this._width,
      this._height,
      this._maxMip
    );
  }
  dispose() {
    super.dispose();
    if (this._generator !== null) this._generator.dispose();
  }
}
function isCubeMapReady(image) {
  if (image === null || image === void 0) return false;
  let count = 0;
  const length2 = 6;
  for (let i2 = 0; i2 < length2; i2++) {
    if (image[i2] !== void 0) count++;
  }
  return count === length2;
}
function isEquirectangularMapReady(image) {
  if (image === null || image === void 0) return false;
  return image.height > 0;
}
const pmremTexture = /* @__PURE__ */ nodeProxy(PMREMNode).setParameterLength(
  1,
  3
);
const _envNodeCache = /* @__PURE__ */ new WeakMap();
class EnvironmentNode extends LightingNode {
  static get type() {
    return "EnvironmentNode";
  }
  /**
   * Constructs a new environment node.
   *
   * @param {Node} [envNode=null] - A node representing the environment.
   */
  constructor(envNode = null) {
    super();
    this.envNode = envNode;
  }
  setup(builder) {
    const { material } = builder;
    let envNode = this.envNode;
    if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {
      const value = envNode.isTextureNode
        ? envNode.value
        : material[envNode.property];
      let cacheEnvNode = _envNodeCache.get(value);
      if (cacheEnvNode === void 0) {
        cacheEnvNode = pmremTexture(value);
        _envNodeCache.set(value, cacheEnvNode);
      }
      envNode = cacheEnvNode;
    }
    const useAnisotropy =
      material.useAnisotropy === true || material.anisotropy > 0;
    const radianceNormalView = useAnisotropy ? bentNormalView : normalView;
    const radiance = envNode
      .context(createRadianceContext(roughness, radianceNormalView))
      .mul(materialEnvIntensity);
    const irradiance = envNode
      .context(createIrradianceContext(normalWorld))
      .mul(Math.PI)
      .mul(materialEnvIntensity);
    const isolateRadiance = cache(radiance);
    const isolateIrradiance = cache(irradiance);
    builder.context.radiance.addAssign(isolateRadiance);
    builder.context.iblIrradiance.addAssign(isolateIrradiance);
    const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;
    if (clearcoatRadiance) {
      const clearcoatRadianceContext = envNode
        .context(createRadianceContext(clearcoatRoughness, clearcoatNormalView))
        .mul(materialEnvIntensity);
      const isolateClearcoatRadiance = cache(clearcoatRadianceContext);
      clearcoatRadiance.addAssign(isolateClearcoatRadiance);
    }
  }
}
const createRadianceContext = (roughnessNode, normalViewNode) => {
  let reflectVec = null;
  return {
    getUV: () => {
      if (reflectVec === null) {
        reflectVec = positionViewDirection.negate().reflect(normalViewNode);
        reflectVec = roughnessNode
          .mul(roughnessNode)
          .mix(reflectVec, normalViewNode)
          .normalize();
        reflectVec = reflectVec.transformDirection(cameraViewMatrix);
      }
      return reflectVec;
    },
    getTextureLevel: () => {
      return roughnessNode;
    },
  };
};
const createIrradianceContext = (normalWorldNode) => {
  return {
    getUV: () => {
      return normalWorldNode;
    },
    getTextureLevel: () => {
      return float(1);
    },
  };
};
const _defaultValues$6 = /* @__PURE__ */ new MeshStandardMaterial();
class MeshStandardNodeMaterial extends NodeMaterial {
  static get type() {
    return "MeshStandardNodeMaterial";
  }
  /**
   * Constructs a new mesh standard node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshStandardNodeMaterial = true;
    this.lights = true;
    this.emissiveNode = null;
    this.metalnessNode = null;
    this.roughnessNode = null;
    this.setDefaultValues(_defaultValues$6);
    this.setValues(parameters);
  }
  /**
   * Overwritten since this type of material uses {@link EnvironmentNode}
   * to implement the PBR (PMREM based) environment mapping. Besides, the
   * method honors `Scene.environment`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?EnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(builder) {
    let envNode = super.setupEnvironment(builder);
    if (envNode === null && builder.environmentNode) {
      envNode = builder.environmentNode;
    }
    return envNode ? new EnvironmentNode(envNode) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhysicalLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new PhysicalLightingModel();
  }
  /**
   * Setups the specular related node variables.
   */
  setupSpecular() {
    const specularColorNode = mix$1(vec3(0.04), diffuseColor.rgb, metalness);
    specularColor.assign(specularColorNode);
    specularF90.assign(1);
  }
  /**
   * Setups the standard specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const metalnessNode = this.metalnessNode
      ? float(this.metalnessNode)
      : materialMetalness;
    metalness.assign(metalnessNode);
    let roughnessNode = this.roughnessNode
      ? float(this.roughnessNode)
      : materialRoughness;
    roughnessNode = getRoughness({ roughness: roughnessNode });
    roughness.assign(roughnessNode);
    this.setupSpecular();
    diffuseColor.assign(
      vec4(diffuseColor.rgb.mul(metalnessNode.oneMinus()), diffuseColor.a)
    );
  }
  copy(source) {
    this.emissiveNode = source.emissiveNode;
    this.metalnessNode = source.metalnessNode;
    this.roughnessNode = source.roughnessNode;
    return super.copy(source);
  }
}
const _defaultValues$5 = /* @__PURE__ */ new MeshPhysicalMaterial();
class MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {
  static get type() {
    return "MeshPhysicalNodeMaterial";
  }
  /**
   * Constructs a new mesh physical node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshPhysicalNodeMaterial = true;
    this.clearcoatNode = null;
    this.clearcoatRoughnessNode = null;
    this.clearcoatNormalNode = null;
    this.sheenNode = null;
    this.sheenRoughnessNode = null;
    this.iridescenceNode = null;
    this.iridescenceIORNode = null;
    this.iridescenceThicknessNode = null;
    this.specularIntensityNode = null;
    this.specularColorNode = null;
    this.iorNode = null;
    this.transmissionNode = null;
    this.thicknessNode = null;
    this.attenuationDistanceNode = null;
    this.attenuationColorNode = null;
    this.dispersionNode = null;
    this.anisotropyNode = null;
    this.setDefaultValues(_defaultValues$5);
    this.setValues(parameters);
  }
  /**
   * Whether the lighting model should use clearcoat or not.
   *
   * @type {boolean}
   * @default true
   */
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  /**
   * Whether the lighting model should use iridescence or not.
   *
   * @type {boolean}
   * @default true
   */
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  /**
   * Whether the lighting model should use sheen or not.
   *
   * @type {boolean}
   * @default true
   */
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  /**
   * Whether the lighting model should use anisotropy or not.
   *
   * @type {boolean}
   * @default true
   */
  get useAnisotropy() {
    return this.anisotropy > 0 || this.anisotropyNode !== null;
  }
  /**
   * Whether the lighting model should use transmission or not.
   *
   * @type {boolean}
   * @default true
   */
  get useTransmission() {
    return this.transmission > 0 || this.transmissionNode !== null;
  }
  /**
   * Whether the lighting model should use dispersion or not.
   *
   * @type {boolean}
   * @default true
   */
  get useDispersion() {
    return this.dispersion > 0 || this.dispersionNode !== null;
  }
  /**
   * Setups the specular related node variables.
   */
  setupSpecular() {
    const iorNode = this.iorNode ? float(this.iorNode) : materialIOR;
    ior.assign(iorNode);
    specularColor.assign(
      mix$1(
        min$1(
          pow2(ior.sub(1).div(ior.add(1))).mul(materialSpecularColor),
          vec3(1)
        ).mul(materialSpecularIntensity),
        diffuseColor.rgb,
        metalness
      )
    );
    specularF90.assign(mix$1(materialSpecularIntensity, 1, metalness));
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhysicalLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new PhysicalLightingModel(
      this.useClearcoat,
      this.useSheen,
      this.useIridescence,
      this.useAnisotropy,
      this.useTransmission,
      this.useDispersion
    );
  }
  /**
   * Setups the physical specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants(builder) {
    super.setupVariants(builder);
    if (this.useClearcoat) {
      const clearcoatNode = this.clearcoatNode
        ? float(this.clearcoatNode)
        : materialClearcoat;
      const clearcoatRoughnessNode = this.clearcoatRoughnessNode
        ? float(this.clearcoatRoughnessNode)
        : materialClearcoatRoughness;
      clearcoat.assign(clearcoatNode);
      clearcoatRoughness.assign(
        getRoughness({ roughness: clearcoatRoughnessNode })
      );
    }
    if (this.useSheen) {
      const sheenNode = this.sheenNode ? vec3(this.sheenNode) : materialSheen;
      const sheenRoughnessNode = this.sheenRoughnessNode
        ? float(this.sheenRoughnessNode)
        : materialSheenRoughness;
      sheen.assign(sheenNode);
      sheenRoughness.assign(sheenRoughnessNode);
    }
    if (this.useIridescence) {
      const iridescenceNode = this.iridescenceNode
        ? float(this.iridescenceNode)
        : materialIridescence;
      const iridescenceIORNode = this.iridescenceIORNode
        ? float(this.iridescenceIORNode)
        : materialIridescenceIOR;
      const iridescenceThicknessNode = this.iridescenceThicknessNode
        ? float(this.iridescenceThicknessNode)
        : materialIridescenceThickness;
      iridescence.assign(iridescenceNode);
      iridescenceIOR.assign(iridescenceIORNode);
      iridescenceThickness.assign(iridescenceThicknessNode);
    }
    if (this.useAnisotropy) {
      const anisotropyV = (
        this.anisotropyNode ? vec2(this.anisotropyNode) : materialAnisotropy
      ).toVar();
      anisotropy.assign(anisotropyV.length());
      If(anisotropy.equal(0), () => {
        anisotropyV.assign(vec2(1, 0));
      }).Else(() => {
        anisotropyV.divAssign(vec2(anisotropy));
        anisotropy.assign(anisotropy.saturate());
      });
      alphaT.assign(anisotropy.pow2().mix(roughness.pow2(), 1));
      anisotropyT.assign(
        TBNViewMatrix[0]
          .mul(anisotropyV.x)
          .add(TBNViewMatrix[1].mul(anisotropyV.y))
      );
      anisotropyB.assign(
        TBNViewMatrix[1]
          .mul(anisotropyV.x)
          .sub(TBNViewMatrix[0].mul(anisotropyV.y))
      );
    }
    if (this.useTransmission) {
      const transmissionNode = this.transmissionNode
        ? float(this.transmissionNode)
        : materialTransmission;
      const thicknessNode = this.thicknessNode
        ? float(this.thicknessNode)
        : materialThickness;
      const attenuationDistanceNode = this.attenuationDistanceNode
        ? float(this.attenuationDistanceNode)
        : materialAttenuationDistance;
      const attenuationColorNode = this.attenuationColorNode
        ? vec3(this.attenuationColorNode)
        : materialAttenuationColor;
      transmission.assign(transmissionNode);
      thickness.assign(thicknessNode);
      attenuationDistance.assign(attenuationDistanceNode);
      attenuationColor.assign(attenuationColorNode);
      if (this.useDispersion) {
        const dispersionNode = this.dispersionNode
          ? float(this.dispersionNode)
          : materialDispersion;
        dispersion.assign(dispersionNode);
      }
    }
  }
  /**
   * Setups the clearcoat normal node.
   *
   * @return {Node<vec3>} The clearcoat normal.
   */
  setupClearcoatNormal() {
    return this.clearcoatNormalNode
      ? vec3(this.clearcoatNormalNode)
      : materialClearcoatNormal;
  }
  setup(builder) {
    builder.context.setupClearcoatNormal = () =>
      subBuild(this.setupClearcoatNormal(builder), "NORMAL", "vec3");
    super.setup(builder);
  }
  copy(source) {
    this.clearcoatNode = source.clearcoatNode;
    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
    this.clearcoatNormalNode = source.clearcoatNormalNode;
    this.sheenNode = source.sheenNode;
    this.sheenRoughnessNode = source.sheenRoughnessNode;
    this.iridescenceNode = source.iridescenceNode;
    this.iridescenceIORNode = source.iridescenceIORNode;
    this.iridescenceThicknessNode = source.iridescenceThicknessNode;
    this.specularIntensityNode = source.specularIntensityNode;
    this.specularColorNode = source.specularColorNode;
    this.transmissionNode = source.transmissionNode;
    this.thicknessNode = source.thicknessNode;
    this.attenuationDistanceNode = source.attenuationDistanceNode;
    this.attenuationColorNode = source.attenuationColorNode;
    this.dispersionNode = source.dispersionNode;
    this.anisotropyNode = source.anisotropyNode;
    return super.copy(source);
  }
}
const getGradientIrradiance = /* @__PURE__ */ Fn(
  ({ normal: normal2, lightDirection, builder }) => {
    const dotNL = normal2.dot(lightDirection);
    const coord = vec2(dotNL.mul(0.5).add(0.5), 0);
    if (builder.material.gradientMap) {
      const gradientMap = materialReference("gradientMap", "texture").context({
        getUV: () => coord,
      });
      return vec3(gradientMap.r);
    } else {
      const fw = coord.fwidth().mul(0.5);
      return mix$1(
        vec3(0.7),
        vec3(1),
        smoothstep(float(0.7).sub(fw.x), float(0.7).add(fw.x), coord.x)
      );
    }
  }
);
class ToonLightingModel extends LightingModel {
  /**
   * Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is
   * reduced to a small number of discrete shades to create a comic-like, flat look.
   *
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct({ lightDirection, lightColor, reflectedLight }, builder) {
    const irradiance = getGradientIrradiance({
      normal: normalGeometry,
      lightDirection,
      builder,
    }).mul(lightColor);
    reflectedLight.directDiffuse.addAssign(
      irradiance.mul(BRDF_Lambert({ diffuseColor: diffuseColor.rgb }))
    );
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(builder) {
    const { ambientOcclusion, irradiance, reflectedLight } = builder.context;
    reflectedLight.indirectDiffuse.addAssign(
      irradiance.mul(BRDF_Lambert({ diffuseColor }))
    );
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
  }
}
const _defaultValues$4 = /* @__PURE__ */ new MeshToonMaterial();
class MeshToonNodeMaterial extends NodeMaterial {
  static get type() {
    return "MeshToonNodeMaterial";
  }
  /**
   * Constructs a new mesh toon node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshToonNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(_defaultValues$4);
    this.setValues(parameters);
  }
  /**
   * Setups the lighting model.
   *
   * @return {ToonLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new ToonLightingModel();
  }
}
const matcapUV = /* @__PURE__ */ Fn(() => {
  const x = vec3(
    positionViewDirection.z,
    0,
    positionViewDirection.x.negate()
  ).normalize();
  const y = positionViewDirection.cross(x);
  return vec2(x.dot(normalView), y.dot(normalView)).mul(0.495).add(0.5);
})
  .once(["NORMAL", "VERTEX"])()
  .toVar("matcapUV");
const _defaultValues$3 = /* @__PURE__ */ new MeshMatcapMaterial();
class MeshMatcapNodeMaterial extends NodeMaterial {
  static get type() {
    return "MeshMatcapNodeMaterial";
  }
  /**
   * Constructs a new mesh normal node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshMatcapNodeMaterial = true;
    this.setDefaultValues(_defaultValues$3);
    this.setValues(parameters);
  }
  /**
   * Setups the matcap specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants(builder) {
    const uv2 = matcapUV;
    let matcapColor;
    if (builder.material.matcap) {
      matcapColor = materialReference("matcap", "texture").context({
        getUV: () => uv2,
      });
    } else {
      matcapColor = vec3(mix$1(0.2, 0.8, uv2.y));
    }
    diffuseColor.rgb.mulAssign(matcapColor.rgb);
  }
}
class RotateNode extends TempNode {
  static get type() {
    return "RotateNode";
  }
  /**
   * Constructs a new rotate node.
   *
   * @param {Node} positionNode - The position node.
   * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending
   * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
   */
  constructor(positionNode, rotationNode) {
    super();
    this.positionNode = positionNode;
    this.rotationNode = rotationNode;
  }
  /**
   * The type of the {@link RotateNode#positionNode} defines the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node's type.
   */
  getNodeType(builder) {
    return this.positionNode.getNodeType(builder);
  }
  setup(builder) {
    const { rotationNode, positionNode } = this;
    const nodeType = this.getNodeType(builder);
    if (nodeType === "vec2") {
      const cosAngle = rotationNode.cos();
      const sinAngle = rotationNode.sin();
      const rotationMatrix = mat2(
        cosAngle,
        sinAngle,
        sinAngle.negate(),
        cosAngle
      );
      return rotationMatrix.mul(positionNode);
    } else {
      const rotation = rotationNode;
      const rotationXMatrix = mat4(
        vec4(1, 0, 0, 0),
        vec4(0, cos(rotation.x), sin(rotation.x).negate(), 0),
        vec4(0, sin(rotation.x), cos(rotation.x), 0),
        vec4(0, 0, 0, 1)
      );
      const rotationYMatrix = mat4(
        vec4(cos(rotation.y), 0, sin(rotation.y), 0),
        vec4(0, 1, 0, 0),
        vec4(sin(rotation.y).negate(), 0, cos(rotation.y), 0),
        vec4(0, 0, 0, 1)
      );
      const rotationZMatrix = mat4(
        vec4(cos(rotation.z), sin(rotation.z).negate(), 0, 0),
        vec4(sin(rotation.z), cos(rotation.z), 0, 0),
        vec4(0, 0, 1, 0),
        vec4(0, 0, 0, 1)
      );
      return rotationXMatrix
        .mul(rotationYMatrix)
        .mul(rotationZMatrix)
        .mul(vec4(positionNode, 1)).xyz;
    }
  }
}
const rotate = /* @__PURE__ */ nodeProxy(RotateNode).setParameterLength(2);
const _defaultValues$2 = /* @__PURE__ */ new SpriteMaterial();
class SpriteNodeMaterial extends NodeMaterial {
  static get type() {
    return "SpriteNodeMaterial";
  }
  /**
   * Constructs a new sprite node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isSpriteNodeMaterial = true;
    this._useSizeAttenuation = true;
    this.positionNode = null;
    this.rotationNode = null;
    this.scaleNode = null;
    this.transparent = true;
    this.setDefaultValues(_defaultValues$2);
    this.setValues(parameters);
  }
  /**
   * Setups the position node in view space. This method implements
   * the sprite specific vertex shader.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in view space.
   */
  setupPositionView(builder) {
    const { object, camera: camera2 } = builder;
    const sizeAttenuation = this.sizeAttenuation;
    const { positionNode, rotationNode, scaleNode } = this;
    const mvPosition = modelViewMatrix.mul(vec3(positionNode || 0));
    let scale2 = vec2(
      modelWorldMatrix[0].xyz.length(),
      modelWorldMatrix[1].xyz.length()
    );
    if (scaleNode !== null) {
      scale2 = scale2.mul(vec2(scaleNode));
    }
    if (sizeAttenuation === false) {
      if (camera2.isPerspectiveCamera) {
        scale2 = scale2.mul(mvPosition.z.negate());
      } else {
        const orthoScale = float(2).div(
          cameraProjectionMatrix.element(1).element(1)
        );
        scale2 = scale2.mul(orthoScale.mul(2));
      }
    }
    let alignedPosition = positionGeometry.xy;
    if (object.center && object.center.isVector2 === true) {
      const center = reference$1("center", "vec2", object);
      alignedPosition = alignedPosition.sub(center.sub(0.5));
    }
    alignedPosition = alignedPosition.mul(scale2);
    const rotation = float(rotationNode || materialRotation);
    const rotatedPosition = rotate(alignedPosition, rotation);
    return vec4(mvPosition.xy.add(rotatedPosition), mvPosition.zw);
  }
  copy(source) {
    this.positionNode = source.positionNode;
    this.rotationNode = source.rotationNode;
    this.scaleNode = source.scaleNode;
    return super.copy(source);
  }
  /**
   * Whether to use size attenuation or not.
   *
   * @type {boolean}
   * @default true
   */
  get sizeAttenuation() {
    return this._useSizeAttenuation;
  }
  set sizeAttenuation(value) {
    if (this._useSizeAttenuation !== value) {
      this._useSizeAttenuation = value;
      this.needsUpdate = true;
    }
  }
}
const _defaultValues$1 = /* @__PURE__ */ new PointsMaterial();
class PointsNodeMaterial extends SpriteNodeMaterial {
  static get type() {
    return "PointsNodeMaterial";
  }
  /**
   * Constructs a new points node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.sizeNode = null;
    this.isPointsNodeMaterial = true;
    this.setDefaultValues(_defaultValues$1);
    this.setValues(parameters);
  }
  setupPositionView() {
    const { positionNode } = this;
    return modelViewMatrix.mul(vec3(positionNode || positionLocal$1)).xyz;
  }
  setupVertex(builder) {
    const mvp = super.setupVertex(builder);
    if (builder.material.isNodeMaterial !== true) {
      return mvp;
    }
    const { rotationNode, scaleNode, sizeNode } = this;
    const alignedPosition = positionGeometry.xy.toVar();
    const aspect2 = viewport.z.div(viewport.w);
    if (rotationNode && rotationNode.isNode) {
      const rotation = float(rotationNode);
      alignedPosition.assign(rotate(alignedPosition, rotation));
    }
    let pointSize = sizeNode !== null ? vec2(sizeNode) : materialPointSize;
    if (this.sizeAttenuation === true) {
      pointSize = pointSize.mul(pointSize.div(positionView.z.negate()));
    }
    if (scaleNode && scaleNode.isNode) {
      pointSize = pointSize.mul(vec2(scaleNode));
    }
    alignedPosition.mulAssign(pointSize.mul(2));
    alignedPosition.assign(alignedPosition.div(viewport.z));
    alignedPosition.y.assign(alignedPosition.y.mul(aspect2));
    alignedPosition.assign(alignedPosition.mul(mvp.w));
    mvp.addAssign(vec4(alignedPosition, 0, 0));
    return mvp;
  }
  /**
   * Whether alpha to coverage should be used or not.
   *
   * @type {boolean}
   * @default true
   */
  get alphaToCoverage() {
    return this._useAlphaToCoverage;
  }
  set alphaToCoverage(value) {
    if (this._useAlphaToCoverage !== value) {
      this._useAlphaToCoverage = value;
      this.needsUpdate = true;
    }
  }
}
class ShadowMaskModel extends LightingModel {
  /**
   * Constructs a new shadow mask model.
   */
  constructor() {
    super();
    this.shadowNode = float(1).toVar("shadowMask");
  }
  /**
   * Only used to save the shadow mask.
   *
   * @param {Object} input - The input data.
   */
  direct({ lightNode }) {
    if (lightNode.shadowNode !== null) {
      this.shadowNode.mulAssign(lightNode.shadowNode);
    }
  }
  /**
   * Uses the shadow mask to produce the final color.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish({ context: context2 }) {
    diffuseColor.a.mulAssign(this.shadowNode.oneMinus());
    context2.outgoingLight.rgb.assign(diffuseColor.rgb);
  }
}
const _defaultValues = /* @__PURE__ */ new ShadowMaterial();
class ShadowNodeMaterial extends NodeMaterial {
  static get type() {
    return "ShadowNodeMaterial";
  }
  /**
   * Constructs a new shadow node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isShadowNodeMaterial = true;
    this.lights = true;
    this.transparent = true;
    this.setDefaultValues(_defaultValues);
    this.setValues(parameters);
  }
  /**
   * Setups the lighting model.
   *
   * @return {ShadowMaskModel} The lighting model.
   */
  setupLightingModel() {
    return new ShadowMaskModel();
  }
}
property("vec3");
property("vec3");
property("vec3");
class Animation {
  /**
   * Constructs a new animation loop management component.
   *
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(nodes, info) {
    this.nodes = nodes;
    this.info = info;
    this._context = typeof self !== "undefined" ? self : null;
    this._animationLoop = null;
    this._requestId = null;
  }
  /**
   * Starts the internal animation loop.
   */
  start() {
    const update = (time2, xrFrame) => {
      this._requestId = this._context.requestAnimationFrame(update);
      if (this.info.autoReset === true) this.info.reset();
      this.nodes.nodeFrame.update();
      this.info.frame = this.nodes.nodeFrame.frameId;
      if (this._animationLoop !== null) this._animationLoop(time2, xrFrame);
    };
    update();
  }
  /**
   * Stops the internal animation loop.
   */
  stop() {
    this._context.cancelAnimationFrame(this._requestId);
    this._requestId = null;
  }
  /**
   * Returns the user-level animation loop.
   *
   * @return {?Function} The animation loop.
   */
  getAnimationLoop() {
    return this._animationLoop;
  }
  /**
   * Defines the user-level animation loop.
   *
   * @param {?Function} callback - The animation loop.
   */
  setAnimationLoop(callback) {
    this._animationLoop = callback;
  }
  /**
   * Returns the animation context.
   *
   * @return {Window|XRSession} The animation context.
   */
  getContext() {
    return this._context;
  }
  /**
   * Defines the context in which `requestAnimationFrame()` is executed.
   *
   * @param {Window|XRSession} context - The context to set.
   */
  setContext(context2) {
    this._context = context2;
  }
  /**
   * Frees all internal resources and stops the animation loop.
   */
  dispose() {
    this.stop();
  }
}
class ChainMap {
  /**
   * Constructs a new Chain Map.
   */
  constructor() {
    this.weakMap = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Returns the value for the given array of keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @return {any} The value. Returns `undefined` if no value was found.
   */
  get(keys) {
    let map = this.weakMap;
    for (let i2 = 0; i2 < keys.length - 1; i2++) {
      map = map.get(keys[i2]);
      if (map === void 0) return void 0;
    }
    return map.get(keys[keys.length - 1]);
  }
  /**
   * Sets the value for the given keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @param {any} value - The value to set.
   * @return {ChainMap} A reference to this Chain Map.
   */
  set(keys, value) {
    let map = this.weakMap;
    for (let i2 = 0; i2 < keys.length - 1; i2++) {
      const key = keys[i2];
      if (map.has(key) === false) map.set(key, /* @__PURE__ */ new WeakMap());
      map = map.get(key);
    }
    map.set(keys[keys.length - 1], value);
    return this;
  }
  /**
   * Deletes a value for the given keys.
   *
   * @param {Array<Object>} keys - The keys.
   * @return {boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.
   */
  delete(keys) {
    let map = this.weakMap;
    for (let i2 = 0; i2 < keys.length - 1; i2++) {
      map = map.get(keys[i2]);
      if (map === void 0) return false;
    }
    return map.delete(keys[keys.length - 1]);
  }
}
let _id$9 = 0;
function getKeys(obj) {
  const keys = Object.keys(obj);
  let proto = Object.getPrototypeOf(obj);
  while (proto) {
    const descriptors = Object.getOwnPropertyDescriptors(proto);
    for (const key in descriptors) {
      if (descriptors[key] !== void 0) {
        const descriptor = descriptors[key];
        if (descriptor && typeof descriptor.get === "function") {
          keys.push(key);
        }
      }
    }
    proto = Object.getPrototypeOf(proto);
  }
  return keys;
}
class RenderObject {
  /**
   * Constructs a new render object.
   *
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Renderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The 3D object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   */
  constructor(
    nodes,
    geometries,
    renderer2,
    object,
    material,
    scene2,
    camera2,
    lightsNode,
    renderContext,
    clippingContext
  ) {
    this.id = _id$9++;
    this._nodes = nodes;
    this._geometries = geometries;
    this.renderer = renderer2;
    this.object = object;
    this.material = material;
    this.scene = scene2;
    this.camera = camera2;
    this.lightsNode = lightsNode;
    this.context = renderContext;
    this.geometry = object.geometry;
    this.version = material.version;
    this.drawRange = null;
    this.attributes = null;
    this.attributesId = null;
    this.pipeline = null;
    this.group = null;
    this.vertexBuffers = null;
    this.drawParams = null;
    this.bundle = null;
    this.clippingContext = clippingContext;
    this.clippingContextCacheKey =
      clippingContext !== null ? clippingContext.cacheKey : "";
    this.initialNodesCacheKey = this.getDynamicCacheKey();
    this.initialCacheKey = this.getCacheKey();
    this._nodeBuilderState = null;
    this._bindings = null;
    this._monitor = null;
    this.onDispose = null;
    this.isRenderObject = true;
    this.onMaterialDispose = () => {
      this.dispose();
    };
    this.onGeometryDispose = () => {
      this.attributes = null;
      this.attributesId = null;
    };
    this.material.addEventListener("dispose", this.onMaterialDispose);
    this.geometry.addEventListener("dispose", this.onGeometryDispose);
  }
  /**
   * Updates the clipping context.
   *
   * @param {ClippingContext} context - The clipping context to set.
   */
  updateClipping(context2) {
    this.clippingContext = context2;
  }
  /**
   * Whether the clipping requires an update or not.
   *
   * @type {boolean}
   * @readonly
   */
  get clippingNeedsUpdate() {
    if (
      this.clippingContext === null ||
      this.clippingContext.cacheKey === this.clippingContextCacheKey
    )
      return false;
    this.clippingContextCacheKey = this.clippingContext.cacheKey;
    return true;
  }
  /**
   * The number of clipping planes defined in context of hardware clipping.
   *
   * @type {number}
   * @readonly
   */
  get hardwareClippingPlanes() {
    return this.material.hardwareClipping === true
      ? this.clippingContext.unionClippingCount
      : 0;
  }
  /**
   * Returns the node builder state of this render object.
   *
   * @return {NodeBuilderState} The node builder state.
   */
  getNodeBuilderState() {
    return (
      this._nodeBuilderState ||
      (this._nodeBuilderState = this._nodes.getForRender(this))
    );
  }
  /**
   * Returns the node material observer of this render object.
   *
   * @return {NodeMaterialObserver} The node material observer.
   */
  getMonitor() {
    return (
      this._monitor || (this._monitor = this.getNodeBuilderState().observer)
    );
  }
  /**
   * Returns an array of bind groups of this render object.
   *
   * @return {Array<BindGroup>} The bindings.
   */
  getBindings() {
    return (
      this._bindings ||
      (this._bindings = this.getNodeBuilderState().createBindings())
    );
  }
  /**
   * Returns a binding group by group name of this render object.
   *
   * @param {string} name - The name of the binding group.
   * @return {?BindGroup} The bindings.
   */
  getBindingGroup(name) {
    for (const bindingGroup of this.getBindings()) {
      if (bindingGroup.name === name) {
        return bindingGroup;
      }
    }
  }
  /**
   * Returns the index of the render object's geometry.
   *
   * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
   */
  getIndex() {
    return this._geometries.getIndex(this);
  }
  /**
   * Returns the indirect buffer attribute.
   *
   * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
   */
  getIndirect() {
    return this._geometries.getIndirect(this);
  }
  /**
   * Returns an array that acts as a key for identifying the render object in a chain map.
   *
   * @return {Array<Object>} An array with object references.
   */
  getChainArray() {
    return [this.object, this.material, this.context, this.lightsNode];
  }
  /**
   * This method is used when the geometry of a 3D object has been exchanged and the
   * respective render object now requires an update.
   *
   * @param {BufferGeometry} geometry - The geometry to set.
   */
  setGeometry(geometry) {
    this.geometry = geometry;
    this.attributes = null;
    this.attributesId = null;
  }
  /**
   * Returns the buffer attributes of the render object. The returned array holds
   * attribute definitions on geometry and node level.
   *
   * @return {Array<BufferAttribute>} An array with buffer attributes.
   */
  getAttributes() {
    if (this.attributes !== null) return this.attributes;
    const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
    const geometry = this.geometry;
    const attributes = [];
    const vertexBuffers = /* @__PURE__ */ new Set();
    const attributesId = {};
    for (const nodeAttribute of nodeAttributes) {
      let attribute2;
      if (nodeAttribute.node && nodeAttribute.node.attribute) {
        attribute2 = nodeAttribute.node.attribute;
      } else {
        attribute2 = geometry.getAttribute(nodeAttribute.name);
        attributesId[nodeAttribute.name] = attribute2.version;
      }
      if (attribute2 === void 0) continue;
      attributes.push(attribute2);
      const bufferAttribute2 = attribute2.isInterleavedBufferAttribute
        ? attribute2.data
        : attribute2;
      vertexBuffers.add(bufferAttribute2);
    }
    this.attributes = attributes;
    this.attributesId = attributesId;
    this.vertexBuffers = Array.from(vertexBuffers.values());
    return attributes;
  }
  /**
   * Returns the vertex buffers of the render object.
   *
   * @return {Array<BufferAttribute|InterleavedBuffer>} An array with buffer attribute or interleaved buffers.
   */
  getVertexBuffers() {
    if (this.vertexBuffers === null) this.getAttributes();
    return this.vertexBuffers;
  }
  /**
   * Returns the draw parameters for the render object.
   *
   * @return {?{vertexCount: number, firstVertex: number, instanceCount: number, firstInstance: number}} The draw parameters.
   */
  getDrawParameters() {
    const { object, material, geometry, group, drawRange } = this;
    const drawParams =
      this.drawParams ||
      (this.drawParams = {
        vertexCount: 0,
        firstVertex: 0,
        instanceCount: 0,
        firstInstance: 0,
      });
    const index = this.getIndex();
    const hasIndex = index !== null;
    let instanceCount = 1;
    if (geometry.isInstancedBufferGeometry === true) {
      instanceCount = geometry.instanceCount;
    } else if (object.count !== void 0) {
      instanceCount = Math.max(0, object.count);
    }
    if (instanceCount === 0) return null;
    drawParams.instanceCount = instanceCount;
    if (object.isBatchedMesh === true) return drawParams;
    let rangeFactor = 1;
    if (
      material.wireframe === true &&
      !object.isPoints &&
      !object.isLineSegments &&
      !object.isLine &&
      !object.isLineLoop
    ) {
      rangeFactor = 2;
    }
    let firstVertex = drawRange.start * rangeFactor;
    let lastVertex = (drawRange.start + drawRange.count) * rangeFactor;
    if (group !== null) {
      firstVertex = Math.max(firstVertex, group.start * rangeFactor);
      lastVertex = Math.min(
        lastVertex,
        (group.start + group.count) * rangeFactor
      );
    }
    const position = geometry.attributes.position;
    let itemCount = Infinity;
    if (hasIndex) {
      itemCount = index.count;
    } else if (position !== void 0 && position !== null) {
      itemCount = position.count;
    }
    firstVertex = Math.max(firstVertex, 0);
    lastVertex = Math.min(lastVertex, itemCount);
    const count = lastVertex - firstVertex;
    if (count < 0 || count === Infinity) return null;
    drawParams.vertexCount = count;
    drawParams.firstVertex = firstVertex;
    return drawParams;
  }
  /**
   * Returns the render object's geometry cache key.
   *
   * The geometry cache key is part of the material cache key.
   *
   * @return {string} The geometry cache key.
   */
  getGeometryCacheKey() {
    const { geometry } = this;
    let cacheKey = "";
    for (const name of Object.keys(geometry.attributes).sort()) {
      const attribute2 = geometry.attributes[name];
      cacheKey += name + ",";
      if (attribute2.data) cacheKey += attribute2.data.stride + ",";
      if (attribute2.offset) cacheKey += attribute2.offset + ",";
      if (attribute2.itemSize) cacheKey += attribute2.itemSize + ",";
      if (attribute2.normalized) cacheKey += "n,";
    }
    for (const name of Object.keys(geometry.morphAttributes).sort()) {
      const targets = geometry.morphAttributes[name];
      cacheKey += "morph-" + name + ",";
      for (let i2 = 0, l2 = targets.length; i2 < l2; i2++) {
        const attribute2 = targets[i2];
        cacheKey += attribute2.id + ",";
      }
    }
    if (geometry.index) {
      cacheKey += "index,";
    }
    return cacheKey;
  }
  /**
   * Returns the render object's material cache key.
   *
   * The material cache key is part of the render object cache key.
   *
   * @return {number} The material cache key.
   */
  getMaterialCacheKey() {
    const { object, material } = this;
    let cacheKey = material.customProgramCacheKey();
    for (const property2 of getKeys(material)) {
      if (
        /^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(
          property2
        )
      )
        continue;
      const value = material[property2];
      let valueKey;
      if (value !== null) {
        const type = typeof value;
        if (type === "number") {
          valueKey = value !== 0 ? "1" : "0";
        } else if (type === "object") {
          valueKey = "{";
          if (value.isTexture) {
            valueKey += value.mapping;
          }
          valueKey += "}";
        } else {
          valueKey = String(value);
        }
      } else {
        valueKey = String(value);
      }
      cacheKey += /*property + ':' +*/ valueKey + ",";
    }
    cacheKey += this.clippingContextCacheKey + ",";
    if (object.geometry) {
      cacheKey += this.getGeometryCacheKey();
    }
    if (object.skeleton) {
      cacheKey += object.skeleton.bones.length + ",";
    }
    if (object.isBatchedMesh) {
      cacheKey += object._matricesTexture.uuid + ",";
      if (object._colorsTexture !== null) {
        cacheKey += object._colorsTexture.uuid + ",";
      }
    }
    if (object.count > 1) {
      cacheKey += object.uuid + ",";
    }
    cacheKey += object.receiveShadow + ",";
    return hashString(cacheKey);
  }
  /**
   * Whether the geometry requires an update or not.
   *
   * @type {boolean}
   * @readonly
   */
  get needsGeometryUpdate() {
    if (this.geometry.id !== this.object.geometry.id) return true;
    if (this.attributes !== null) {
      const attributesId = this.attributesId;
      for (const name in attributesId) {
        const attribute2 = this.geometry.getAttribute(name);
        if (attribute2 === void 0 || attributesId[name] !== attribute2.id) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Whether the render object requires an update or not.
   *
   * Note: There are two distinct places where render objects are checked for an update.
   *
   * 1. In `RenderObjects.get()` which is executed when the render object is request. This
   * method checks the `needsUpdate` flag and recreates the render object if necessary.
   * 2. In `Renderer._renderObjectDirect()` right after getting the render object via
   * `RenderObjects.get()`. The render object's NodeMaterialObserver is then used to detect
   * a need for a refresh due to material, geometry or object related value changes.
   *
   * TODO: Investigate if it's possible to merge both steps so there is only a single place
   * that performs the 'needsUpdate' check.
   *
   * @type {boolean}
   * @readonly
   */
  get needsUpdate() {
    return (
      /*this.object.static !== true &&*/
      this.initialNodesCacheKey !== this.getDynamicCacheKey() ||
      this.clippingNeedsUpdate
    );
  }
  /**
   * Returns the dynamic cache key which represents a key that is computed per draw command.
   *
   * @return {number} The cache key.
   */
  getDynamicCacheKey() {
    let cacheKey = 0;
    if (this.material.isShadowPassMaterial !== true) {
      cacheKey = this._nodes.getCacheKey(this.scene, this.lightsNode);
    }
    if (this.camera.isArrayCamera) {
      cacheKey = hash$1(cacheKey, this.camera.cameras.length);
    }
    if (this.object.receiveShadow) {
      cacheKey = hash$1(cacheKey, 1);
    }
    return cacheKey;
  }
  /**
   * Returns the render object's cache key.
   *
   * @return {number} The cache key.
   */
  getCacheKey() {
    return this.getMaterialCacheKey() + this.getDynamicCacheKey();
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.material.removeEventListener("dispose", this.onMaterialDispose);
    this.geometry.removeEventListener("dispose", this.onGeometryDispose);
    this.onDispose();
  }
}
const _chainKeys$5 = [];
class RenderObjects {
  /**
   * Constructs a new render object management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Pipelines} pipelines - Renderer component for managing pipelines.
   * @param {Bindings} bindings - Renderer component for managing bindings.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(renderer2, nodes, geometries, pipelines, bindings, info) {
    this.renderer = renderer2;
    this.nodes = nodes;
    this.geometries = geometries;
    this.pipelines = pipelines;
    this.bindings = bindings;
    this.info = info;
    this.chainMaps = {};
  }
  /**
   * Returns a render object for the given object and state data.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The 3D object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the 3D object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   * @return {RenderObject} The render object.
   */
  get(
    object,
    material,
    scene2,
    camera2,
    lightsNode,
    renderContext,
    clippingContext,
    passId
  ) {
    const chainMap = this.getChainMap(passId);
    _chainKeys$5[0] = object;
    _chainKeys$5[1] = material;
    _chainKeys$5[2] = renderContext;
    _chainKeys$5[3] = lightsNode;
    let renderObject = chainMap.get(_chainKeys$5);
    if (renderObject === void 0) {
      renderObject = this.createRenderObject(
        this.nodes,
        this.geometries,
        this.renderer,
        object,
        material,
        scene2,
        camera2,
        lightsNode,
        renderContext,
        clippingContext,
        passId
      );
      chainMap.set(_chainKeys$5, renderObject);
    } else {
      renderObject.updateClipping(clippingContext);
      if (renderObject.needsGeometryUpdate) {
        renderObject.setGeometry(object.geometry);
      }
      if (
        renderObject.version !== material.version ||
        renderObject.needsUpdate
      ) {
        if (renderObject.initialCacheKey !== renderObject.getCacheKey()) {
          renderObject.dispose();
          renderObject = this.get(
            object,
            material,
            scene2,
            camera2,
            lightsNode,
            renderContext,
            clippingContext,
            passId
          );
        } else {
          renderObject.version = material.version;
        }
      }
    }
    _chainKeys$5.length = 0;
    return renderObject;
  }
  /**
   * Returns a chain map for the given pass ID.
   *
   * @param {string} [passId='default'] - The pass ID.
   * @return {ChainMap} The chain map.
   */
  getChainMap(passId = "default") {
    return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.chainMaps = {};
  }
  /**
   * Factory method for creating render objects with the given list of parameters.
   *
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Renderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   * @return {RenderObject} The render object.
   */
  createRenderObject(
    nodes,
    geometries,
    renderer2,
    object,
    material,
    scene2,
    camera2,
    lightsNode,
    renderContext,
    clippingContext,
    passId
  ) {
    const chainMap = this.getChainMap(passId);
    const renderObject = new RenderObject(
      nodes,
      geometries,
      renderer2,
      object,
      material,
      scene2,
      camera2,
      lightsNode,
      renderContext,
      clippingContext
    );
    renderObject.onDispose = () => {
      this.pipelines.delete(renderObject);
      this.bindings.delete(renderObject);
      this.nodes.delete(renderObject);
      chainMap.delete(renderObject.getChainArray());
    };
    return renderObject;
  }
}
class DataMap {
  /**
   * Constructs a new data map.
   */
  constructor() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Returns the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {Object} The dictionary.
   */
  get(object) {
    let map = this.data.get(object);
    if (map === void 0) {
      map = {};
      this.data.set(object, map);
    }
    return map;
  }
  /**
   * Deletes the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {?Object} The deleted dictionary.
   */
  delete(object) {
    let map = null;
    if (this.data.has(object)) {
      map = this.data.get(object);
      this.data.delete(object);
    }
    return map;
  }
  /**
   * Returns `true` if the given object has a dictionary defined.
   *
   * @param {Object} object - The object to test.
   * @return {boolean} Whether a dictionary is defined or not.
   */
  has(object) {
    return this.data.has(object);
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
}
const AttributeType = {
  VERTEX: 1,
  INDEX: 2,
  STORAGE: 3,
  INDIRECT: 4,
};
const GPU_CHUNK_BYTES = 16;
const BlendColorFactor = 211;
const OneMinusBlendColorFactor = 212;
class Attributes extends DataMap {
  /**
   * Constructs a new attribute management component.
   *
   * @param {Backend} backend - The renderer's backend.
   */
  constructor(backend) {
    super();
    this.backend = backend;
  }
  /**
   * Deletes the data for the given attribute.
   *
   * @param {BufferAttribute} attribute - The attribute.
   * @return {Object|null} The deleted attribute data.
   */
  delete(attribute2) {
    const attributeData = super.delete(attribute2);
    if (attributeData !== null) {
      this.backend.destroyAttribute(attribute2);
    }
    return attributeData;
  }
  /**
   * Updates the given attribute. This method creates attribute buffers
   * for new attributes and updates data for existing ones.
   *
   * @param {BufferAttribute} attribute - The attribute to update.
   * @param {number} type - The attribute type.
   */
  update(attribute2, type) {
    const data = this.get(attribute2);
    if (data.version === void 0) {
      if (type === AttributeType.VERTEX) {
        this.backend.createAttribute(attribute2);
      } else if (type === AttributeType.INDEX) {
        this.backend.createIndexAttribute(attribute2);
      } else if (type === AttributeType.STORAGE) {
        this.backend.createStorageAttribute(attribute2);
      } else if (type === AttributeType.INDIRECT) {
        this.backend.createIndirectStorageAttribute(attribute2);
      }
      data.version = this._getBufferAttribute(attribute2).version;
    } else {
      const bufferAttribute2 = this._getBufferAttribute(attribute2);
      if (
        data.version < bufferAttribute2.version ||
        bufferAttribute2.usage === DynamicDrawUsage
      ) {
        this.backend.updateAttribute(attribute2);
        data.version = bufferAttribute2.version;
      }
    }
  }
  /**
   * Utility method for handling interleaved buffer attributes correctly.
   * To process them, their `InterleavedBuffer` is returned.
   *
   * @param {BufferAttribute} attribute - The attribute.
   * @return {BufferAttribute|InterleavedBuffer}
   */
  _getBufferAttribute(attribute2) {
    if (attribute2.isInterleavedBufferAttribute) attribute2 = attribute2.data;
    return attribute2;
  }
}
function getWireframeVersion(geometry) {
  return geometry.index !== null
    ? geometry.index.version
    : geometry.attributes.position.version;
}
function getWireframeIndex(geometry) {
  const indices = [];
  const geometryIndex = geometry.index;
  const geometryPosition = geometry.attributes.position;
  if (geometryIndex !== null) {
    const array2 = geometryIndex.array;
    for (let i2 = 0, l2 = array2.length; i2 < l2; i2 += 3) {
      const a2 = array2[i2 + 0];
      const b = array2[i2 + 1];
      const c2 = array2[i2 + 2];
      indices.push(a2, b, b, c2, c2, a2);
    }
  } else {
    const array2 = geometryPosition.array;
    for (let i2 = 0, l2 = array2.length / 3 - 1; i2 < l2; i2 += 3) {
      const a2 = i2 + 0;
      const b = i2 + 1;
      const c2 = i2 + 2;
      indices.push(a2, b, b, c2, c2, a2);
    }
  }
  const attribute2 = new (
    arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute
  )(indices, 1);
  attribute2.version = getWireframeVersion(geometry);
  return attribute2;
}
class Geometries extends DataMap {
  /**
   * Constructs a new geometry management component.
   *
   * @param {Attributes} attributes - Renderer component for managing attributes.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(attributes, info) {
    super();
    this.attributes = attributes;
    this.info = info;
    this.wireframes = /* @__PURE__ */ new WeakMap();
    this.attributeCall = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Returns `true` if the given render object has an initialized geometry.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether if the given render object has an initialized geometry or not.
   */
  has(renderObject) {
    const geometry = renderObject.geometry;
    return super.has(geometry) && this.get(geometry).initialized === true;
  }
  /**
   * Prepares the geometry of the given render object for rendering.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(renderObject) {
    if (this.has(renderObject) === false) this.initGeometry(renderObject);
    this.updateAttributes(renderObject);
  }
  /**
   * Initializes the geometry of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  initGeometry(renderObject) {
    const geometry = renderObject.geometry;
    const geometryData = this.get(geometry);
    geometryData.initialized = true;
    this.info.memory.geometries++;
    const onDispose = () => {
      this.info.memory.geometries--;
      const index = geometry.index;
      const geometryAttributes = renderObject.getAttributes();
      if (index !== null) {
        this.attributes.delete(index);
      }
      for (const geometryAttribute of geometryAttributes) {
        this.attributes.delete(geometryAttribute);
      }
      const wireframeAttribute = this.wireframes.get(geometry);
      if (wireframeAttribute !== void 0) {
        this.attributes.delete(wireframeAttribute);
      }
      geometry.removeEventListener("dispose", onDispose);
    };
    geometry.addEventListener("dispose", onDispose);
  }
  /**
   * Updates the geometry attributes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateAttributes(renderObject) {
    const attributes = renderObject.getAttributes();
    for (const attribute2 of attributes) {
      if (
        attribute2.isStorageBufferAttribute ||
        attribute2.isStorageInstancedBufferAttribute
      ) {
        this.updateAttribute(attribute2, AttributeType.STORAGE);
      } else {
        this.updateAttribute(attribute2, AttributeType.VERTEX);
      }
    }
    const index = this.getIndex(renderObject);
    if (index !== null) {
      this.updateAttribute(index, AttributeType.INDEX);
    }
    const indirect = renderObject.geometry.indirect;
    if (indirect !== null) {
      this.updateAttribute(indirect, AttributeType.INDIRECT);
    }
  }
  /**
   * Updates the given attribute.
   *
   * @param {BufferAttribute} attribute - The attribute to update.
   * @param {number} type - The attribute type.
   */
  updateAttribute(attribute2, type) {
    const callId = this.info.render.calls;
    if (!attribute2.isInterleavedBufferAttribute) {
      if (this.attributeCall.get(attribute2) !== callId) {
        this.attributes.update(attribute2, type);
        this.attributeCall.set(attribute2, callId);
      }
    } else {
      if (this.attributeCall.get(attribute2) === void 0) {
        this.attributes.update(attribute2, type);
        this.attributeCall.set(attribute2, callId);
      } else if (this.attributeCall.get(attribute2.data) !== callId) {
        this.attributes.update(attribute2, type);
        this.attributeCall.set(attribute2.data, callId);
        this.attributeCall.set(attribute2, callId);
      }
    }
  }
  /**
   * Returns the indirect buffer attribute of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
   */
  getIndirect(renderObject) {
    return renderObject.geometry.indirect;
  }
  /**
   * Returns the index of the given render object's geometry. This is implemented
   * in a method to return a wireframe index if necessary.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
   */
  getIndex(renderObject) {
    const { geometry, material } = renderObject;
    let index = geometry.index;
    if (material.wireframe === true) {
      const wireframes = this.wireframes;
      let wireframeAttribute = wireframes.get(geometry);
      if (wireframeAttribute === void 0) {
        wireframeAttribute = getWireframeIndex(geometry);
        wireframes.set(geometry, wireframeAttribute);
      } else if (wireframeAttribute.version !== getWireframeVersion(geometry)) {
        this.attributes.delete(wireframeAttribute);
        wireframeAttribute = getWireframeIndex(geometry);
        wireframes.set(geometry, wireframeAttribute);
      }
      index = wireframeAttribute;
    }
    return index;
  }
}
class Info {
  /**
   * Constructs a new info component.
   */
  constructor() {
    this.autoReset = true;
    this.frame = 0;
    this.calls = 0;
    this.render = {
      calls: 0,
      frameCalls: 0,
      drawCalls: 0,
      triangles: 0,
      points: 0,
      lines: 0,
      timestamp: 0,
    };
    this.compute = {
      calls: 0,
      frameCalls: 0,
      timestamp: 0,
    };
    this.memory = {
      geometries: 0,
      textures: 0,
    };
  }
  /**
   * This method should be executed per draw call and updates the corresponding metrics.
   *
   * @param {Object3D} object - The 3D object that is going to be rendered.
   * @param {number} count - The vertex or index count.
   * @param {number} instanceCount - The instance count.
   */
  update(object, count, instanceCount) {
    this.render.drawCalls++;
    if (object.isMesh || object.isSprite) {
      this.render.triangles += instanceCount * (count / 3);
    } else if (object.isPoints) {
      this.render.points += instanceCount * count;
    } else if (object.isLineSegments) {
      this.render.lines += instanceCount * (count / 2);
    } else if (object.isLine) {
      this.render.lines += instanceCount * (count - 1);
    } else {
      console.error("THREE.WebGPUInfo: Unknown object type.");
    }
  }
  /**
   * Resets frame related metrics.
   */
  reset() {
    this.render.drawCalls = 0;
    this.render.frameCalls = 0;
    this.compute.frameCalls = 0;
    this.render.triangles = 0;
    this.render.points = 0;
    this.render.lines = 0;
  }
  /**
   * Performs a complete reset of the object.
   */
  dispose() {
    this.reset();
    this.calls = 0;
    this.render.calls = 0;
    this.compute.calls = 0;
    this.render.timestamp = 0;
    this.compute.timestamp = 0;
    this.memory.geometries = 0;
    this.memory.textures = 0;
  }
}
class Pipeline {
  /**
   * Constructs a new pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   */
  constructor(cacheKey) {
    this.cacheKey = cacheKey;
    this.usedTimes = 0;
  }
}
class RenderPipeline extends Pipeline {
  /**
   * Constructs a new render pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   * @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.
   * @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.
   */
  constructor(cacheKey, vertexProgram, fragmentProgram) {
    super(cacheKey);
    this.vertexProgram = vertexProgram;
    this.fragmentProgram = fragmentProgram;
  }
}
class ComputePipeline extends Pipeline {
  /**
   * Constructs a new render pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   * @param {ProgrammableStage} computeProgram - The pipeline's compute shader.
   */
  constructor(cacheKey, computeProgram) {
    super(cacheKey);
    this.computeProgram = computeProgram;
    this.isComputePipeline = true;
  }
}
let _id$8 = 0;
class ProgrammableStage {
  /**
   * Constructs a new programmable stage.
   *
   * @param {string} code - The shader code.
   * @param {('vertex'|'fragment'|'compute')} stage - The type of stage.
   * @param {string} name - The name of the shader.
   * @param {?Array<Object>} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
   * @param {?Array<Object>} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
   */
  constructor(code2, stage, name, transforms = null, attributes = null) {
    this.id = _id$8++;
    this.code = code2;
    this.stage = stage;
    this.name = name;
    this.transforms = transforms;
    this.attributes = attributes;
    this.usedTimes = 0;
  }
}
class Pipelines extends DataMap {
  /**
   * Constructs a new pipeline management component.
   *
   * @param {Backend} backend - The renderer's backend.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   */
  constructor(backend, nodes) {
    super();
    this.backend = backend;
    this.nodes = nodes;
    this.bindings = null;
    this.caches = /* @__PURE__ */ new Map();
    this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map(),
    };
  }
  /**
   * Returns a compute pipeline for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @return {ComputePipeline} The compute pipeline.
   */
  getForCompute(computeNode, bindings) {
    const { backend } = this;
    const data = this.get(computeNode);
    if (this._needsComputeUpdate(computeNode)) {
      const previousPipeline = data.pipeline;
      if (previousPipeline) {
        previousPipeline.usedTimes--;
        previousPipeline.computeProgram.usedTimes--;
      }
      const nodeBuilderState = this.nodes.getForCompute(computeNode);
      let stageCompute = this.programs.compute.get(
        nodeBuilderState.computeShader
      );
      if (stageCompute === void 0) {
        if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0)
          this._releaseProgram(previousPipeline.computeProgram);
        stageCompute = new ProgrammableStage(
          nodeBuilderState.computeShader,
          "compute",
          computeNode.name,
          nodeBuilderState.transforms,
          nodeBuilderState.nodeAttributes
        );
        this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);
        backend.createProgram(stageCompute);
      }
      const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);
      let pipeline = this.caches.get(cacheKey);
      if (pipeline === void 0) {
        if (previousPipeline && previousPipeline.usedTimes === 0)
          this._releasePipeline(previousPipeline);
        pipeline = this._getComputePipeline(
          computeNode,
          stageCompute,
          cacheKey,
          bindings
        );
      }
      pipeline.usedTimes++;
      stageCompute.usedTimes++;
      data.version = computeNode.version;
      data.pipeline = pipeline;
    }
    return data.pipeline;
  }
  /**
   * Returns a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {?Array<Promise>} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
   * @return {RenderPipeline} The render pipeline.
   */
  getForRender(renderObject, promises = null) {
    const { backend } = this;
    const data = this.get(renderObject);
    if (this._needsRenderUpdate(renderObject)) {
      const previousPipeline = data.pipeline;
      if (previousPipeline) {
        previousPipeline.usedTimes--;
        previousPipeline.vertexProgram.usedTimes--;
        previousPipeline.fragmentProgram.usedTimes--;
      }
      const nodeBuilderState = renderObject.getNodeBuilderState();
      const name = renderObject.material ? renderObject.material.name : "";
      let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);
      if (stageVertex === void 0) {
        if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0)
          this._releaseProgram(previousPipeline.vertexProgram);
        stageVertex = new ProgrammableStage(
          nodeBuilderState.vertexShader,
          "vertex",
          name
        );
        this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);
        backend.createProgram(stageVertex);
      }
      let stageFragment = this.programs.fragment.get(
        nodeBuilderState.fragmentShader
      );
      if (stageFragment === void 0) {
        if (
          previousPipeline &&
          previousPipeline.fragmentProgram.usedTimes === 0
        )
          this._releaseProgram(previousPipeline.fragmentProgram);
        stageFragment = new ProgrammableStage(
          nodeBuilderState.fragmentShader,
          "fragment",
          name
        );
        this.programs.fragment.set(
          nodeBuilderState.fragmentShader,
          stageFragment
        );
        backend.createProgram(stageFragment);
      }
      const cacheKey = this._getRenderCacheKey(
        renderObject,
        stageVertex,
        stageFragment
      );
      let pipeline = this.caches.get(cacheKey);
      if (pipeline === void 0) {
        if (previousPipeline && previousPipeline.usedTimes === 0)
          this._releasePipeline(previousPipeline);
        pipeline = this._getRenderPipeline(
          renderObject,
          stageVertex,
          stageFragment,
          cacheKey,
          promises
        );
      } else {
        renderObject.pipeline = pipeline;
      }
      pipeline.usedTimes++;
      stageVertex.usedTimes++;
      stageFragment.usedTimes++;
      data.pipeline = pipeline;
    }
    return data.pipeline;
  }
  /**
   * Deletes the pipeline for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @return {?Object} The deleted dictionary.
   */
  delete(object) {
    const pipeline = this.get(object).pipeline;
    if (pipeline) {
      pipeline.usedTimes--;
      if (pipeline.usedTimes === 0) this._releasePipeline(pipeline);
      if (pipeline.isComputePipeline) {
        pipeline.computeProgram.usedTimes--;
        if (pipeline.computeProgram.usedTimes === 0)
          this._releaseProgram(pipeline.computeProgram);
      } else {
        pipeline.fragmentProgram.usedTimes--;
        pipeline.vertexProgram.usedTimes--;
        if (pipeline.vertexProgram.usedTimes === 0)
          this._releaseProgram(pipeline.vertexProgram);
        if (pipeline.fragmentProgram.usedTimes === 0)
          this._releaseProgram(pipeline.fragmentProgram);
      }
    }
    return super.delete(object);
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    super.dispose();
    this.caches = /* @__PURE__ */ new Map();
    this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map(),
    };
  }
  /**
   * Updates the pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(renderObject) {
    this.getForRender(renderObject);
  }
  /**
   * Returns a compute pipeline for the given parameters.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
   * @param {string} cacheKey - The cache key.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @return {ComputePipeline} The compute pipeline.
   */
  _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {
    cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);
    let pipeline = this.caches.get(cacheKey);
    if (pipeline === void 0) {
      pipeline = new ComputePipeline(cacheKey, stageCompute);
      this.caches.set(cacheKey, pipeline);
      this.backend.createComputePipeline(pipeline, bindings);
    }
    return pipeline;
  }
  /**
   * Returns a render pipeline for the given parameters.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
   * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
   * @param {string} cacheKey - The cache key.
   * @param {?Array<Promise>} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
   * @return {ComputePipeline} The compute pipeline.
   */
  _getRenderPipeline(
    renderObject,
    stageVertex,
    stageFragment,
    cacheKey,
    promises
  ) {
    cacheKey =
      cacheKey ||
      this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
    let pipeline = this.caches.get(cacheKey);
    if (pipeline === void 0) {
      pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);
      this.caches.set(cacheKey, pipeline);
      renderObject.pipeline = pipeline;
      this.backend.createRenderPipeline(renderObject, promises);
    }
    return pipeline;
  }
  /**
   * Computes a cache key representing a compute pipeline.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
   * @return {string} The cache key.
   */
  _getComputeCacheKey(computeNode, stageCompute) {
    return computeNode.id + "," + stageCompute.id;
  }
  /**
   * Computes a cache key representing a render pipeline.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
   * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
   * @return {string} The cache key.
   */
  _getRenderCacheKey(renderObject, stageVertex, stageFragment) {
    return (
      stageVertex.id +
      "," +
      stageFragment.id +
      "," +
      this.backend.getRenderCacheKey(renderObject)
    );
  }
  /**
   * Releases the given pipeline.
   *
   * @private
   * @param {Pipeline} pipeline - The pipeline to release.
   */
  _releasePipeline(pipeline) {
    this.caches.delete(pipeline.cacheKey);
  }
  /**
   * Releases the shader program.
   *
   * @private
   * @param {Object} program - The shader program to release.
   */
  _releaseProgram(program2) {
    const code2 = program2.code;
    const stage = program2.stage;
    this.programs[stage].delete(code2);
  }
  /**
   * Returns `true` if the compute pipeline for the given compute node requires an update.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @return {boolean} Whether the compute pipeline for the given compute node requires an update or not.
   */
  _needsComputeUpdate(computeNode) {
    const data = this.get(computeNode);
    return data.pipeline === void 0 || data.version !== computeNode.version;
  }
  /**
   * Returns `true` if the render pipeline for the given render object requires an update.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render object for the given render object requires an update or not.
   */
  _needsRenderUpdate(renderObject) {
    const data = this.get(renderObject);
    return (
      data.pipeline === void 0 || this.backend.needsRenderUpdate(renderObject)
    );
  }
}
class Bindings extends DataMap {
  /**
   * Constructs a new bindings management component.
   *
   * @param {Backend} backend - The renderer's backend.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Textures} textures - Renderer component for managing textures.
   * @param {Attributes} attributes - Renderer component for managing attributes.
   * @param {Pipelines} pipelines - Renderer component for managing pipelines.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(backend, nodes, textures, attributes, pipelines, info) {
    super();
    this.backend = backend;
    this.textures = textures;
    this.pipelines = pipelines;
    this.attributes = attributes;
    this.nodes = nodes;
    this.info = info;
    this.pipelines.bindings = this;
  }
  /**
   * Returns the bind groups for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Array<BindGroup>} The bind groups.
   */
  getForRender(renderObject) {
    const bindings = renderObject.getBindings();
    for (const bindGroup of bindings) {
      const groupData = this.get(bindGroup);
      if (groupData.bindGroup === void 0) {
        this._init(bindGroup);
        this.backend.createBindings(bindGroup, bindings, 0);
        groupData.bindGroup = bindGroup;
      }
    }
    return bindings;
  }
  /**
   * Returns the bind groups for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @return {Array<BindGroup>} The bind groups.
   */
  getForCompute(computeNode) {
    const bindings = this.nodes.getForCompute(computeNode).bindings;
    for (const bindGroup of bindings) {
      const groupData = this.get(bindGroup);
      if (groupData.bindGroup === void 0) {
        this._init(bindGroup);
        this.backend.createBindings(bindGroup, bindings, 0);
        groupData.bindGroup = bindGroup;
      }
    }
    return bindings;
  }
  /**
   * Updates the bindings for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   */
  updateForCompute(computeNode) {
    this._updateBindings(this.getForCompute(computeNode));
  }
  /**
   * Updates the bindings for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(renderObject) {
    this._updateBindings(this.getForRender(renderObject));
  }
  /**
   * Updates the given array of bindings.
   *
   * @param {Array<BindGroup>} bindings - The bind groups.
   */
  _updateBindings(bindings) {
    for (const bindGroup of bindings) {
      this._update(bindGroup, bindings);
    }
  }
  /**
   * Initializes the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group to initialize.
   */
  _init(bindGroup) {
    for (const binding of bindGroup.bindings) {
      if (binding.isSampledTexture) {
        this.textures.updateTexture(binding.texture);
      } else if (binding.isStorageBuffer) {
        const attribute2 = binding.attribute;
        const attributeType = attribute2.isIndirectStorageBufferAttribute
          ? AttributeType.INDIRECT
          : AttributeType.STORAGE;
        this.attributes.update(attribute2, attributeType);
      }
    }
  }
  /**
   * Updates the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group to update.
   * @param {Array<BindGroup>} bindings - The bind groups.
   */
  _update(bindGroup, bindings) {
    const { backend } = this;
    let needsBindingsUpdate = false;
    let cacheBindings = true;
    let cacheIndex = 0;
    let version = 0;
    for (const binding of bindGroup.bindings) {
      if (binding.isNodeUniformsGroup) {
        const updated = this.nodes.updateGroup(binding);
        if (updated === false) continue;
      }
      if (binding.isStorageBuffer) {
        const attribute2 = binding.attribute;
        const attributeType = attribute2.isIndirectStorageBufferAttribute
          ? AttributeType.INDIRECT
          : AttributeType.STORAGE;
        this.attributes.update(attribute2, attributeType);
      }
      if (binding.isUniformBuffer) {
        const updated = binding.update();
        if (updated) {
          backend.updateBinding(binding);
        }
      } else if (binding.isSampledTexture) {
        const updated = binding.update();
        const texture2 = binding.texture;
        const texturesTextureData = this.textures.get(texture2);
        if (updated) {
          this.textures.updateTexture(texture2);
          if (binding.generation !== texturesTextureData.generation) {
            binding.generation = texturesTextureData.generation;
            needsBindingsUpdate = true;
          }
        }
        const textureData = backend.get(texture2);
        if (
          textureData.externalTexture !== void 0 ||
          texturesTextureData.isDefaultTexture
        ) {
          cacheBindings = false;
        } else {
          cacheIndex = cacheIndex * 10 + texture2.id;
          version += texture2.version;
        }
        if (texture2.isStorageTexture === true) {
          const textureData2 = this.get(texture2);
          if (binding.store === true) {
            textureData2.needsMipmap = true;
          } else if (
            this.textures.needsMipmaps(texture2) &&
            textureData2.needsMipmap === true
          ) {
            this.backend.generateMipmaps(texture2);
            textureData2.needsMipmap = false;
          }
        }
      } else if (binding.isSampler) {
        binding.update();
      }
    }
    if (needsBindingsUpdate === true) {
      this.backend.updateBindings(
        bindGroup,
        bindings,
        cacheBindings ? cacheIndex : 0,
        version
      );
    }
  }
}
function painterSortStable(a2, b) {
  if (a2.groupOrder !== b.groupOrder) {
    return a2.groupOrder - b.groupOrder;
  } else if (a2.renderOrder !== b.renderOrder) {
    return a2.renderOrder - b.renderOrder;
  } else if (a2.z !== b.z) {
    return a2.z - b.z;
  } else {
    return a2.id - b.id;
  }
}
function reversePainterSortStable(a2, b) {
  if (a2.groupOrder !== b.groupOrder) {
    return a2.groupOrder - b.groupOrder;
  } else if (a2.renderOrder !== b.renderOrder) {
    return a2.renderOrder - b.renderOrder;
  } else if (a2.z !== b.z) {
    return b.z - a2.z;
  } else {
    return a2.id - b.id;
  }
}
function needsDoublePass(material) {
  const hasTransmission =
    material.transmission > 0 || material.transmissionNode;
  return (
    hasTransmission &&
    material.side === DoubleSide &&
    material.forceSinglePass === false
  );
}
class RenderList {
  /**
   * Constructs a render list.
   *
   * @param {Lighting} lighting - The lighting management component.
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera the scene is rendered with.
   */
  constructor(lighting, scene2, camera2) {
    this.renderItems = [];
    this.renderItemsIndex = 0;
    this.opaque = [];
    this.transparentDoublePass = [];
    this.transparent = [];
    this.bundles = [];
    this.lightsNode = lighting.getNode(scene2, camera2);
    this.lightsArray = [];
    this.scene = scene2;
    this.camera = camera2;
    this.occlusionQueryCount = 0;
  }
  /**
   * This method is called right at the beginning of a render call
   * before the scene is analyzed. It prepares the internal data
   * structures for the upcoming render lists generation.
   *
   * @return {RenderList} A reference to this render list.
   */
  begin() {
    this.renderItemsIndex = 0;
    this.opaque.length = 0;
    this.transparentDoublePass.length = 0;
    this.transparent.length = 0;
    this.bundles.length = 0;
    this.lightsArray.length = 0;
    this.occlusionQueryCount = 0;
    return this;
  }
  /**
   * Returns a render item for the giving render item state. The state is defined
   * by a series of object-related parameters.
   *
   * The method avoids object creation by holding render items and reusing them in
   * subsequent render calls (just with different property values).
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   * @return {Object} The render item.
   */
  getNextRenderItem(
    object,
    geometry,
    material,
    groupOrder,
    z,
    group,
    clippingContext
  ) {
    let renderItem = this.renderItems[this.renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group,
        clippingContext,
      };
      this.renderItems[this.renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
      renderItem.clippingContext = clippingContext;
    }
    this.renderItemsIndex++;
    return renderItem;
  }
  /**
   * Pushes the given object as a render item to the internal render lists.
   * The selected lists depend on the object properties.
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  push(object, geometry, material, groupOrder, z, group, clippingContext) {
    const renderItem = this.getNextRenderItem(
      object,
      geometry,
      material,
      groupOrder,
      z,
      group,
      clippingContext
    );
    if (object.occlusionTest === true) this.occlusionQueryCount++;
    if (material.transparent === true || material.transmission > 0) {
      if (needsDoublePass(material))
        this.transparentDoublePass.push(renderItem);
      this.transparent.push(renderItem);
    } else {
      this.opaque.push(renderItem);
    }
  }
  /**
   * Inserts the given object as a render item at the start of the internal render lists.
   * The selected lists depend on the object properties.
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  unshift(object, geometry, material, groupOrder, z, group, clippingContext) {
    const renderItem = this.getNextRenderItem(
      object,
      geometry,
      material,
      groupOrder,
      z,
      group,
      clippingContext
    );
    if (material.transparent === true || material.transmission > 0) {
      if (needsDoublePass(material))
        this.transparentDoublePass.unshift(renderItem);
      this.transparent.unshift(renderItem);
    } else {
      this.opaque.unshift(renderItem);
    }
  }
  /**
   * Pushes render bundle group data into the render list.
   *
   * @param {Object} group - Bundle group data.
   */
  pushBundle(group) {
    this.bundles.push(group);
  }
  /**
   * Pushes a light into the render list.
   *
   * @param {Light} light - The light.
   */
  pushLight(light) {
    this.lightsArray.push(light);
  }
  /**
   * Sorts the internal render lists.
   *
   * @param {?function(any, any): number} customOpaqueSort - A custom sort function for opaque objects.
   * @param {?function(any, any): number} customTransparentSort -  A custom sort function for transparent objects.
   */
  sort(customOpaqueSort, customTransparentSort) {
    if (this.opaque.length > 1)
      this.opaque.sort(customOpaqueSort || painterSortStable);
    if (this.transparentDoublePass.length > 1)
      this.transparentDoublePass.sort(
        customTransparentSort || reversePainterSortStable
      );
    if (this.transparent.length > 1)
      this.transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  /**
   * This method performs finalizing tasks right after the render lists
   * have been generated.
   */
  finish() {
    this.lightsNode.setLights(this.lightsArray);
    for (
      let i2 = this.renderItemsIndex, il = this.renderItems.length;
      i2 < il;
      i2++
    ) {
      const renderItem = this.renderItems[i2];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.groupOrder = null;
      renderItem.renderOrder = null;
      renderItem.z = null;
      renderItem.group = null;
      renderItem.clippingContext = null;
    }
  }
}
const _chainKeys$4 = [];
class RenderLists {
  /**
   * Constructs a render lists management component.
   *
   * @param {Lighting} lighting - The lighting management component.
   */
  constructor(lighting) {
    this.lighting = lighting;
    this.lists = new ChainMap();
  }
  /**
   * Returns a render list for the given scene and camera.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera.
   * @return {RenderList} The render list.
   */
  get(scene2, camera2) {
    const lists = this.lists;
    _chainKeys$4[0] = scene2;
    _chainKeys$4[1] = camera2;
    let list = lists.get(_chainKeys$4);
    if (list === void 0) {
      list = new RenderList(this.lighting, scene2, camera2);
      lists.set(_chainKeys$4, list);
    }
    _chainKeys$4.length = 0;
    return list;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    this.lists = new ChainMap();
  }
}
let _id$7 = 0;
class RenderContext {
  /**
   * Constructs a new render context.
   */
  constructor() {
    this.id = _id$7++;
    this.color = true;
    this.clearColor = true;
    this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };
    this.depth = true;
    this.clearDepth = true;
    this.clearDepthValue = 1;
    this.stencil = false;
    this.clearStencil = true;
    this.clearStencilValue = 1;
    this.viewport = false;
    this.viewportValue = new Vector4();
    this.scissor = false;
    this.scissorValue = new Vector4();
    this.renderTarget = null;
    this.textures = null;
    this.depthTexture = null;
    this.activeCubeFace = 0;
    this.activeMipmapLevel = 0;
    this.sampleCount = 1;
    this.width = 0;
    this.height = 0;
    this.occlusionQueryCount = 0;
    this.clippingContext = null;
    this.isRenderContext = true;
  }
  /**
   * Returns the cache key of this render context.
   *
   * @return {number} The cache key.
   */
  getCacheKey() {
    return getCacheKey(this);
  }
}
function getCacheKey(renderContext) {
  const { textures, activeCubeFace } = renderContext;
  const values = [activeCubeFace];
  for (const texture2 of textures) {
    values.push(texture2.id);
  }
  return hashArray(values);
}
const _chainKeys$3 = [];
const _defaultScene = /* @__PURE__ */ new Scene();
const _defaultCamera = /* @__PURE__ */ new Camera();
class RenderContexts {
  /**
   * Constructs a new render context management component.
   */
  constructor() {
    this.chainMaps = {};
  }
  /**
   * Returns a render context for the given scene, camera and render target.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {?RenderTarget} [renderTarget=null] - The active render target.
   * @return {RenderContext} The render context.
   */
  get(scene2, camera2, renderTarget = null) {
    _chainKeys$3[0] = scene2;
    _chainKeys$3[1] = camera2;
    let attachmentState;
    if (renderTarget === null) {
      attachmentState = "default";
    } else {
      const format = renderTarget.texture.format;
      const count = renderTarget.textures.length;
      attachmentState = `${count}:${format}:${renderTarget.samples}:${renderTarget.depthBuffer}:${renderTarget.stencilBuffer}`;
    }
    const chainMap = this._getChainMap(attachmentState);
    let renderState = chainMap.get(_chainKeys$3);
    if (renderState === void 0) {
      renderState = new RenderContext();
      chainMap.set(_chainKeys$3, renderState);
    }
    _chainKeys$3.length = 0;
    if (renderTarget !== null)
      renderState.sampleCount =
        renderTarget.samples === 0 ? 1 : renderTarget.samples;
    return renderState;
  }
  /**
   * Returns a render context intended for clear operations.
   *
   * @param {?RenderTarget} [renderTarget=null] - The active render target.
   * @return {RenderContext} The render context.
   */
  getForClear(renderTarget = null) {
    return this.get(_defaultScene, _defaultCamera, renderTarget);
  }
  /**
   * Returns a chain map for the given attachment state.
   *
   * @private
   * @param {string} attachmentState - The attachment state.
   * @return {ChainMap} The chain map.
   */
  _getChainMap(attachmentState) {
    return (
      this.chainMaps[attachmentState] ||
      (this.chainMaps[attachmentState] = new ChainMap())
    );
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.chainMaps = {};
  }
}
const _size$3 = /* @__PURE__ */ new Vector3();
class Textures extends DataMap {
  /**
   * Constructs a new texture management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Backend} backend - The renderer's backend.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(renderer2, backend, info) {
    super();
    this.renderer = renderer2;
    this.backend = backend;
    this.info = info;
  }
  /**
   * Updates the given render target. Based on the given render target configuration,
   * it updates the texture states representing the attachments of the framebuffer.
   *
   * @param {RenderTarget} renderTarget - The render target to update.
   * @param {number} [activeMipmapLevel=0] - The active mipmap level.
   */
  updateRenderTarget(renderTarget, activeMipmapLevel = 0) {
    const renderTargetData = this.get(renderTarget);
    const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
    const depthTextureMips =
      renderTargetData.depthTextureMips ||
      (renderTargetData.depthTextureMips = {});
    const textures = renderTarget.textures;
    const size = this.getSize(textures[0]);
    const mipWidth = size.width >> activeMipmapLevel;
    const mipHeight = size.height >> activeMipmapLevel;
    let depthTexture =
      renderTarget.depthTexture || depthTextureMips[activeMipmapLevel];
    const useDepthTexture =
      renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;
    let textureNeedsUpdate = false;
    if (depthTexture === void 0 && useDepthTexture) {
      depthTexture = new DepthTexture();
      depthTexture.format = renderTarget.stencilBuffer
        ? DepthStencilFormat
        : DepthFormat;
      depthTexture.type = renderTarget.stencilBuffer
        ? UnsignedInt248Type
        : UnsignedIntType;
      depthTexture.image.width = mipWidth;
      depthTexture.image.height = mipHeight;
      depthTexture.image.depth = size.depth;
      depthTexture.isArrayTexture =
        renderTarget.multiview === true && size.depth > 1;
      depthTextureMips[activeMipmapLevel] = depthTexture;
    }
    if (
      renderTargetData.width !== size.width ||
      size.height !== renderTargetData.height
    ) {
      textureNeedsUpdate = true;
      if (depthTexture) {
        depthTexture.needsUpdate = true;
        depthTexture.image.width = mipWidth;
        depthTexture.image.height = mipHeight;
        depthTexture.image.depth = depthTexture.isArrayTexture
          ? depthTexture.image.depth
          : 1;
      }
    }
    renderTargetData.width = size.width;
    renderTargetData.height = size.height;
    renderTargetData.textures = textures;
    renderTargetData.depthTexture = depthTexture || null;
    renderTargetData.depth = renderTarget.depthBuffer;
    renderTargetData.stencil = renderTarget.stencilBuffer;
    renderTargetData.renderTarget = renderTarget;
    if (renderTargetData.sampleCount !== sampleCount) {
      textureNeedsUpdate = true;
      if (depthTexture) {
        depthTexture.needsUpdate = true;
      }
      renderTargetData.sampleCount = sampleCount;
    }
    const options = { sampleCount };
    if (renderTarget.isXRRenderTarget !== true) {
      for (let i2 = 0; i2 < textures.length; i2++) {
        const texture2 = textures[i2];
        if (textureNeedsUpdate) texture2.needsUpdate = true;
        this.updateTexture(texture2, options);
      }
      if (depthTexture) {
        this.updateTexture(depthTexture, options);
      }
    }
    if (renderTargetData.initialized !== true) {
      renderTargetData.initialized = true;
      const onDispose = () => {
        renderTarget.removeEventListener("dispose", onDispose);
        for (let i2 = 0; i2 < textures.length; i2++) {
          this._destroyTexture(textures[i2]);
        }
        if (depthTexture) {
          this._destroyTexture(depthTexture);
        }
        this.delete(renderTarget);
      };
      renderTarget.addEventListener("dispose", onDispose);
    }
  }
  /**
   * Updates the given texture. Depending on the texture state, this method
   * triggers the upload of texture data to the GPU memory. If the texture data are
   * not yet ready for the upload, it uses default texture data for as a placeholder.
   *
   * @param {Texture} texture - The texture to update.
   * @param {Object} [options={}] - The options.
   */
  updateTexture(texture2, options = {}) {
    const textureData = this.get(texture2);
    if (
      textureData.initialized === true &&
      textureData.version === texture2.version
    )
      return;
    const isRenderTarget =
      texture2.isRenderTargetTexture ||
      texture2.isDepthTexture ||
      texture2.isFramebufferTexture;
    const backend = this.backend;
    if (isRenderTarget && textureData.initialized === true) {
      backend.destroySampler(texture2);
      backend.destroyTexture(texture2);
    }
    if (texture2.isFramebufferTexture) {
      const renderTarget = this.renderer.getRenderTarget();
      if (renderTarget) {
        texture2.type = renderTarget.texture.type;
      } else {
        texture2.type = UnsignedByteType;
      }
    }
    const { width, height, depth: depth2 } = this.getSize(texture2);
    options.width = width;
    options.height = height;
    options.depth = depth2;
    options.needsMipmaps = this.needsMipmaps(texture2);
    options.levels = options.needsMipmaps
      ? this.getMipLevels(texture2, width, height)
      : 1;
    if (isRenderTarget || texture2.isStorageTexture === true) {
      backend.createSampler(texture2);
      backend.createTexture(texture2, options);
      textureData.generation = texture2.version;
    } else {
      const needsCreate = textureData.initialized !== true;
      if (needsCreate) backend.createSampler(texture2);
      if (texture2.version > 0) {
        const image = texture2.image;
        if (image === void 0) {
          console.warn(
            "THREE.Renderer: Texture marked for update but image is undefined."
          );
        } else if (image.complete === false) {
          console.warn(
            "THREE.Renderer: Texture marked for update but image is incomplete."
          );
        } else {
          if (texture2.images) {
            const images = [];
            for (const image2 of texture2.images) {
              images.push(image2);
            }
            options.images = images;
          } else {
            options.image = image;
          }
          if (
            textureData.isDefaultTexture === void 0 ||
            textureData.isDefaultTexture === true
          ) {
            backend.createTexture(texture2, options);
            textureData.isDefaultTexture = false;
            textureData.generation = texture2.version;
          }
          if (texture2.source.dataReady === true)
            backend.updateTexture(texture2, options);
          if (options.needsMipmaps && texture2.mipmaps.length === 0)
            backend.generateMipmaps(texture2);
        }
      } else {
        backend.createDefaultTexture(texture2);
        textureData.isDefaultTexture = true;
        textureData.generation = texture2.version;
      }
    }
    if (textureData.initialized !== true) {
      textureData.initialized = true;
      textureData.generation = texture2.version;
      this.info.memory.textures++;
      const onDispose = () => {
        texture2.removeEventListener("dispose", onDispose);
        this._destroyTexture(texture2);
      };
      texture2.addEventListener("dispose", onDispose);
    }
    textureData.version = texture2.version;
  }
  /**
   * Computes the size of the given texture and writes the result
   * into the target vector. This vector is also returned by the
   * method.
   *
   * If no texture data are available for the compute yet, the method
   * returns default size values.
   *
   * @param {Texture} texture - The texture to compute the size for.
   * @param {Vector3} target - The target vector.
   * @return {Vector3} The target vector.
   */
  getSize(texture2, target = _size$3) {
    let image = texture2.images ? texture2.images[0] : texture2.image;
    if (image) {
      if (image.image !== void 0) image = image.image;
      if (image instanceof HTMLVideoElement) {
        target.width = image.videoWidth || 1;
        target.height = image.videoHeight || 1;
        target.depth = 1;
      } else if (image instanceof VideoFrame) {
        target.width = image.displayWidth || 1;
        target.height = image.displayHeight || 1;
        target.depth = 1;
      } else {
        target.width = image.width || 1;
        target.height = image.height || 1;
        target.depth = texture2.isCubeTexture ? 6 : image.depth || 1;
      }
    } else {
      target.width = target.height = target.depth = 1;
    }
    return target;
  }
  /**
   * Computes the number of mipmap levels for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {number} width - The texture's width.
   * @param {number} height - The texture's height.
   * @return {number} The number of mipmap levels.
   */
  getMipLevels(texture2, width, height) {
    let mipLevelCount;
    if (texture2.isCompressedTexture) {
      if (texture2.mipmaps) {
        mipLevelCount = texture2.mipmaps.length;
      } else {
        mipLevelCount = 1;
      }
    } else {
      mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;
    }
    return mipLevelCount;
  }
  /**
   * Returns `true` if the given texture requires mipmaps.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether mipmaps are required or not.
   */
  needsMipmaps(texture2) {
    return texture2.isCompressedTexture === true || texture2.generateMipmaps;
  }
  /**
   * Frees internal resource when the given texture isn't
   * required anymore.
   *
   * @param {Texture} texture - The texture to destroy.
   */
  _destroyTexture(texture2) {
    if (this.has(texture2) === true) {
      this.backend.destroySampler(texture2);
      this.backend.destroyTexture(texture2);
      this.delete(texture2);
      this.info.memory.textures--;
    }
  }
}
class Color4 extends Color {
  /**
   * Constructs a new four-component color.
   * You can also pass a single THREE.Color, hex or
   * string argument to this constructor.
   *
   * @param {number|string} [r=1] - The red value.
   * @param {number} [g=1] - The green value.
   * @param {number} [b=1] - The blue value.
   * @param {number} [a=1] - The alpha value.
   */
  constructor(r2, g2, b, a2 = 1) {
    super(r2, g2, b);
    this.a = a2;
  }
  /**
   * Overwrites the default to honor alpha.
   * You can also pass a single THREE.Color, hex or
   * string argument to this method.
   *
   * @param {number|string|Color} r - The red value.
   * @param {number} [g] - The green value.
   * @param {number} [b] - The blue value.
   * @param {number} [a=1] - The alpha value.
   * @return {Color4} A reference to this object.
   */
  set(r2, g2, b, a2 = 1) {
    this.a = a2;
    return super.set(r2, g2, b);
  }
  /**
   * Overwrites the default to honor alpha.
   *
   * @param {Color4} color - The color to copy.
   * @return {Color4} A reference to this object.
   */
  copy(color2) {
    if (color2.a !== void 0) this.a = color2.a;
    return super.copy(color2);
  }
  /**
   * Overwrites the default to honor alpha.
   *
   * @return {Color4} The cloned color.
   */
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
}
class ParameterNode extends PropertyNode {
  static get type() {
    return "ParameterNode";
  }
  /**
   * Constructs a new parameter node.
   *
   * @param {string} nodeType - The type of the node.
   * @param {?string} [name=null] - The name of the parameter in the shader.
   */
  constructor(nodeType, name = null) {
    super(nodeType, name);
    this.isParameterNode = true;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
}
const parameter = (type, name) => nodeObject(new ParameterNode(type, name));
class StackNode extends Node {
  static get type() {
    return "StackNode";
  }
  /**
   * Constructs a new stack node.
   *
   * @param {?StackNode} [parent=null] - The parent stack node.
   */
  constructor(parent = null) {
    super();
    this.nodes = [];
    this.outputNode = null;
    this.parent = parent;
    this._currentCond = null;
    this._expressionNode = null;
    this.isStackNode = true;
  }
  getNodeType(builder) {
    return this.outputNode ? this.outputNode.getNodeType(builder) : "void";
  }
  getMemberType(builder, name) {
    return this.outputNode
      ? this.outputNode.getMemberType(builder, name)
      : "void";
  }
  /**
   * Adds a node to this stack.
   *
   * @param {Node} node - The node to add.
   * @return {StackNode} A reference to this stack node.
   */
  add(node) {
    this.nodes.push(node);
    return this;
  }
  /**
   * Represent an `if` statement in TSL.
   *
   * @param {Node} boolNode - Represents the condition.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  If(boolNode, method) {
    const methodNode = new ShaderNode(method);
    this._currentCond = select(boolNode, methodNode);
    return this.add(this._currentCond);
  }
  /**
   * Represent an `elseif` statement in TSL.
   *
   * @param {Node} boolNode - Represents the condition.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  ElseIf(boolNode, method) {
    const methodNode = new ShaderNode(method);
    const ifNode = select(boolNode, methodNode);
    this._currentCond.elseNode = ifNode;
    this._currentCond = ifNode;
    return this;
  }
  /**
   * Represent an `else` statement in TSL.
   *
   * @param {Function} method - TSL code which is executed in the `else` case.
   * @return {StackNode} A reference to this stack node.
   */
  Else(method) {
    this._currentCond.elseNode = new ShaderNode(method);
    return this;
  }
  /**
   * Represents a `switch` statement in TSL.
   *
   * @param {any} expression - Represents the expression.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  Switch(expression2) {
    this._expressionNode = nodeObject(expression2);
    return this;
  }
  /**
   * Represents a `case` statement in TSL. The TSL version accepts an arbitrary numbers of values.
   * The last parameter must be the callback method that should be executed in the `true` case.
   *
   * @param {...any} params - The values of the `Case()` statement as well as the callback method.
   * @return {StackNode} A reference to this stack node.
   */
  Case(...params) {
    const caseNodes = [];
    if (params.length >= 2) {
      for (let i2 = 0; i2 < params.length - 1; i2++) {
        caseNodes.push(this._expressionNode.equal(nodeObject(params[i2])));
      }
    } else {
      throw new Error(
        "TSL: Invalid parameter length. Case() requires at least two parameters."
      );
    }
    const method = params[params.length - 1];
    const methodNode = new ShaderNode(method);
    let caseNode = caseNodes[0];
    for (let i2 = 1; i2 < caseNodes.length; i2++) {
      caseNode = caseNode.or(caseNodes[i2]);
    }
    const condNode = select(caseNode, methodNode);
    if (this._currentCond === null) {
      this._currentCond = condNode;
      return this.add(this._currentCond);
    } else {
      this._currentCond.elseNode = condNode;
      this._currentCond = condNode;
      return this;
    }
  }
  /**
   * Represents the default code block of a Switch/Case statement.
   *
   * @param {Function} method - TSL code which is executed in the `else` case.
   * @return {StackNode} A reference to this stack node.
   */
  Default(method) {
    this.Else(method);
    return this;
  }
  setup(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    let index = 0;
    for (const childNode of this.getChildren()) {
      if (childNode.isVarNode && childNode.intent === true) {
        const properties = builder.getNodeProperties(childNode);
        if (properties.assign !== true) {
          continue;
        }
      }
      nodeProperties["node" + index++] = childNode;
    }
    return nodeProperties.outputNode || null;
  }
  build(builder, ...params) {
    const previousBuildStack = builder.currentStack;
    const previousStack = getCurrentStack();
    setCurrentStack(this);
    builder.currentStack = this;
    const buildStage = builder.buildStage;
    for (const node of this.nodes) {
      if (node.isVarNode && node.intent === true) {
        const properties = builder.getNodeProperties(node);
        if (properties.assign !== true) {
          continue;
        }
      }
      if (buildStage === "setup") {
        node.build(builder);
      } else if (buildStage === "analyze") {
        node.build(builder, this);
      } else if (buildStage === "generate") {
        const stages = builder.getDataFromNode(node, "any").stages;
        const parents = stages && stages[builder.shaderStage];
        if (
          node.isVarNode &&
          parents &&
          parents.length === 1 &&
          parents[0] &&
          parents[0].isStackNode
        ) {
          continue;
        }
        node.build(builder, "void");
      }
    }
    const result = this.outputNode
      ? this.outputNode.build(builder, ...params)
      : super.build(builder, ...params);
    setCurrentStack(previousStack);
    builder.currentStack = previousBuildStack;
    return result;
  }
}
const stack = /* @__PURE__ */ nodeProxy(StackNode).setParameterLength(0, 1);
function getMembersLayout(members) {
  return Object.entries(members).map(([name, value]) => {
    if (typeof value === "string") {
      return { name, type: value, atomic: false };
    }
    return { name, type: value.type, atomic: value.atomic || false };
  });
}
class StructTypeNode extends Node {
  static get type() {
    return "StructTypeNode";
  }
  /**
   * Creates an instance of StructTypeNode.
   *
   * @param {Object} membersLayout - The layout of the members for the struct.
   * @param {?string} [name=null] - The optional name of the struct.
   */
  constructor(membersLayout, name = null) {
    super("struct");
    this.membersLayout = getMembersLayout(membersLayout);
    this.name = name;
    this.isStructLayoutNode = true;
  }
  /**
   * Returns the length of the struct.
   * The length is calculated by summing the lengths of the struct's members.
   *
   * @returns {number} The length of the struct.
   */
  getLength() {
    const GPU_CHUNK_BYTES2 = 8;
    const BYTES_PER_ELEMENT = Float32Array.BYTES_PER_ELEMENT;
    let offset = 0;
    for (const member of this.membersLayout) {
      const type = member.type;
      const itemSize = getMemoryLengthFromType(type) * BYTES_PER_ELEMENT;
      const boundary = getByteBoundaryFromType(type);
      const chunkOffset = offset % GPU_CHUNK_BYTES2;
      const chunkPadding = chunkOffset % boundary;
      const chunkStart = chunkOffset + chunkPadding;
      offset += chunkPadding;
      if (chunkStart !== 0 && GPU_CHUNK_BYTES2 - chunkStart < itemSize) {
        offset += GPU_CHUNK_BYTES2 - chunkStart;
      }
      offset += itemSize;
    }
    return (
      (Math.ceil(offset / GPU_CHUNK_BYTES2) * GPU_CHUNK_BYTES2) /
      BYTES_PER_ELEMENT
    );
  }
  getMemberType(builder, name) {
    const member = this.membersLayout.find((m) => m.name === name);
    return member ? member.type : "void";
  }
  getNodeType(builder) {
    const structType = builder.getStructTypeFromNode(
      this,
      this.membersLayout,
      this.name
    );
    return structType.name;
  }
  setup(builder) {
    builder.addInclude(this);
  }
  generate(builder) {
    return this.getNodeType(builder);
  }
}
class StructNode extends Node {
  static get type() {
    return "StructNode";
  }
  constructor(structLayoutNode, values) {
    super("vec3");
    this.structLayoutNode = structLayoutNode;
    this.values = values;
    this.isStructNode = true;
  }
  getNodeType(builder) {
    return this.structLayoutNode.getNodeType(builder);
  }
  getMemberType(builder, name) {
    return this.structLayoutNode.getMemberType(builder, name);
  }
  generate(builder) {
    const nodeVar = builder.getVarFromNode(this);
    const structType = nodeVar.type;
    const propertyName = builder.getPropertyName(nodeVar);
    builder.addLineFlowCode(
      `${propertyName} = ${builder.generateStruct(
        structType,
        this.structLayoutNode.membersLayout,
        this.values
      )}`,
      this
    );
    return nodeVar.name;
  }
}
const struct = (membersLayout, name = null) => {
  const structLayout = new StructTypeNode(membersLayout, name);
  const struct2 = (...params) => {
    let values = null;
    if (params.length > 0) {
      if (params[0].isNode) {
        values = {};
        const names = Object.keys(membersLayout);
        for (let i2 = 0; i2 < params.length; i2++) {
          values[names[i2]] = params[i2];
        }
      } else {
        values = params[0];
      }
    }
    return nodeObject(new StructNode(structLayout, values));
  };
  struct2.layout = structLayout;
  struct2.isStruct = true;
  return struct2;
};
class OutputStructNode extends Node {
  static get type() {
    return "OutputStructNode";
  }
  /**
   * Constructs a new output struct node. The constructor can be invoked with an
   * arbitrary number of nodes representing the members.
   *
   * @param {...Node} members - A parameter list of nodes.
   */
  constructor(...members) {
    super();
    this.members = members;
    this.isOutputStructNode = true;
  }
  getNodeType(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.membersLayout === void 0) {
      const members = this.members;
      const membersLayout = [];
      for (let i2 = 0; i2 < members.length; i2++) {
        const name = "m" + i2;
        const type = members[i2].getNodeType(builder);
        membersLayout.push({ name, type, index: i2 });
      }
      properties.membersLayout = membersLayout;
      properties.structType = builder.getOutputStructTypeFromNode(
        this,
        properties.membersLayout
      );
    }
    return properties.structType.name;
  }
  generate(builder) {
    const propertyName = builder.getOutputStructName();
    const members = this.members;
    const structPrefix = propertyName !== "" ? propertyName + "." : "";
    for (let i2 = 0; i2 < members.length; i2++) {
      const snippet = members[i2].build(builder);
      builder.addLineFlowCode(`${structPrefix}m${i2} = ${snippet}`, this);
    }
    return propertyName;
  }
}
const outputStruct = /* @__PURE__ */ nodeProxy(OutputStructNode);
function getTextureIndex(textures, name) {
  for (let i2 = 0; i2 < textures.length; i2++) {
    if (textures[i2].name === name) {
      return i2;
    }
  }
  return -1;
}
class MRTNode extends OutputStructNode {
  static get type() {
    return "MRTNode";
  }
  /**
   * Constructs a new output struct node.
   *
   * @param {Object<string, Node>} outputNodes - The MRT outputs.
   */
  constructor(outputNodes) {
    super();
    this.outputNodes = outputNodes;
    this.isMRTNode = true;
  }
  /**
   * Returns `true` if the MRT node has an output with the given name.
   *
   * @param {string} name - The name of the output.
   * @return {NodeBuilder} Whether the MRT node has an output for the given name or not.
   */
  has(name) {
    return this.outputNodes[name] !== void 0;
  }
  /**
   * Returns the output node for the given name.
   *
   * @param {string} name - The name of the output.
   * @return {Node} The output node.
   */
  get(name) {
    return this.outputNodes[name];
  }
  /**
   * Merges the outputs of the given MRT node with the outputs of this node.
   *
   * @param {MRTNode} mrtNode - The MRT to merge.
   * @return {MRTNode} A new MRT node with merged outputs..
   */
  merge(mrtNode) {
    const outputs = { ...this.outputNodes, ...mrtNode.outputNodes };
    return mrt(outputs);
  }
  setup(builder) {
    const outputNodes = this.outputNodes;
    const mrt2 = builder.renderer.getRenderTarget();
    const members = [];
    const textures = mrt2.textures;
    for (const name in outputNodes) {
      const index = getTextureIndex(textures, name);
      members[index] = vec4(outputNodes[name]);
    }
    this.members = members;
    return super.setup(builder);
  }
}
const mrt = /* @__PURE__ */ nodeProxy(MRTNode);
const hash = /* @__PURE__ */ Fn(([seed]) => {
  const state = seed.toUint().mul(747796405).add(2891336453);
  const word = state
    .shiftRight(state.shiftRight(28).add(4))
    .bitXor(state)
    .mul(277803737);
  const result = word.shiftRight(22).bitXor(word);
  return result.toFloat().mul(1 / 2 ** 32);
});
const parabola = (x, k) => pow(mul(4, x.mul(sub(1, x))), k);
const gain = (x, k) =>
  x.lessThan(0.5)
    ? parabola(x.mul(2), k).div(2)
    : sub(1, parabola(mul(sub(1, x), 2), k).div(2));
const pcurve = (x, a2, b) =>
  pow(div(pow(x, a2), add(pow(x, a2), pow(sub(1, x), b))), 1 / a2);
const sinc = (x, k) =>
  sin(PI.mul(k.mul(x).sub(1))).div(PI.mul(k.mul(x).sub(1)));
const tri = /* @__PURE__ */ Fn(([x]) => {
  return x.fract().sub(0.5).abs();
}).setLayout({
  name: "tri",
  type: "float",
  inputs: [{ name: "x", type: "float" }],
});
const tri3 = /* @__PURE__ */ Fn(([p2]) => {
  return vec3(
    tri(p2.z.add(tri(p2.y.mul(1)))),
    tri(p2.z.add(tri(p2.x.mul(1)))),
    tri(p2.y.add(tri(p2.x.mul(1))))
  );
}).setLayout({
  name: "tri3",
  type: "vec3",
  inputs: [{ name: "p", type: "vec3" }],
});
const triNoise3D = /* @__PURE__ */ Fn(([position, speed, time2]) => {
  const p2 = vec3(position).toVar();
  const z = float(1.4).toVar();
  const rz = float(0).toVar();
  const bp = vec3(p2).toVar();
  Loop(
    { start: float(0), end: float(3), type: "float", condition: "<=" },
    () => {
      const dg = vec3(tri3(bp.mul(2))).toVar();
      p2.addAssign(dg.add(time2.mul(float(0.1).mul(speed))));
      bp.mulAssign(1.8);
      z.mulAssign(1.5);
      p2.mulAssign(1.2);
      const t2 = float(tri(p2.z.add(tri(p2.x.add(tri(p2.y)))))).toVar();
      rz.addAssign(t2.div(z));
      bp.addAssign(0.14);
    }
  );
  return rz;
}).setLayout({
  name: "triNoise3D",
  type: "float",
  inputs: [
    { name: "position", type: "vec3" },
    { name: "speed", type: "float" },
    { name: "time", type: "float" },
  ],
});
class FunctionOverloadingNode extends Node {
  static get type() {
    return "FunctionOverloadingNode";
  }
  /**
   * Constructs a new function overloading node.
   *
   * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.
   * @param {...Node} parametersNodes - A list of parameter nodes.
   */
  constructor(functionNodes = [], ...parametersNodes) {
    super();
    this.functionNodes = functionNodes;
    this.parametersNodes = parametersNodes;
    this._candidateFnCall = null;
    this.global = true;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the function's return type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.functionNodes[0].shaderNode.layout.type;
  }
  setup(builder) {
    const params = this.parametersNodes;
    let candidateFnCall = this._candidateFnCall;
    if (candidateFnCall === null) {
      let candidateFn = null;
      let candidateScore = -1;
      for (const functionNode of this.functionNodes) {
        const shaderNode = functionNode.shaderNode;
        const layout = shaderNode.layout;
        if (layout === null) {
          throw new Error(
            "FunctionOverloadingNode: FunctionNode must be a layout."
          );
        }
        const inputs = layout.inputs;
        if (params.length === inputs.length) {
          let score = 0;
          for (let i2 = 0; i2 < params.length; i2++) {
            const param = params[i2];
            const input = inputs[i2];
            if (param.getNodeType(builder) === input.type) {
              score++;
            } else {
              score = 0;
            }
          }
          if (score > candidateScore) {
            candidateFn = functionNode;
            candidateScore = score;
          }
        }
      }
      this._candidateFnCall = candidateFnCall = candidateFn(...params);
    }
    return candidateFnCall;
  }
}
const overloadingBaseFn = /* @__PURE__ */ nodeProxy(FunctionOverloadingNode);
const overloadingFn =
  (functionNodes) =>
  (...params) =>
    overloadingBaseFn(functionNodes, ...params);
const time$1 = /* @__PURE__ */ uniform$1(0)
  .setGroup(renderGroup)
  .onRenderUpdate((frame) => frame.time);
const deltaTime = /* @__PURE__ */ uniform$1(0)
  .setGroup(renderGroup)
  .onRenderUpdate((frame) => frame.deltaTime);
const frameId = /* @__PURE__ */ uniform$1(0, "uint")
  .setGroup(renderGroup)
  .onRenderUpdate((frame) => frame.frameId);
const timerLocal = (timeScale = 1) => {
  console.warn('TSL: timerLocal() is deprecated. Use "time" instead.');
  return time$1.mul(timeScale);
};
const timerGlobal = (timeScale = 1) => {
  console.warn('TSL: timerGlobal() is deprecated. Use "time" instead.');
  return time$1.mul(timeScale);
};
const timerDelta = (timeScale = 1) => {
  console.warn('TSL: timerDelta() is deprecated. Use "deltaTime" instead.');
  return deltaTime.mul(timeScale);
};
const oscSine = (t2 = time$1) =>
  t2
    .add(0.75)
    .mul(Math.PI * 2)
    .sin()
    .mul(0.5)
    .add(0.5);
const oscSquare = (t2 = time$1) => t2.fract().round();
const oscTriangle = (t2 = time$1) => t2.add(0.5).fract().mul(2).sub(1).abs();
const oscSawtooth = (t2 = time$1) => t2.fract();
const rotateUV$1 = /* @__PURE__ */ Fn(([uv2, rotation, center = vec2(0.5)]) => {
  return rotate(uv2.sub(center), rotation).add(center);
});
const spherizeUV = /* @__PURE__ */ Fn(([uv2, strength, center = vec2(0.5)]) => {
  const delta = uv2.sub(center);
  const delta2 = delta.dot(delta);
  const delta4 = delta2.mul(delta2);
  const deltaOffset = delta4.mul(strength);
  return uv2.add(delta.mul(deltaOffset));
});
const billboarding = /* @__PURE__ */ Fn(
  ({ position = null, horizontal = true, vertical = false }) => {
    let worldMatrix;
    if (position !== null) {
      worldMatrix = modelWorldMatrix.toVar();
      worldMatrix[3][0] = position.x;
      worldMatrix[3][1] = position.y;
      worldMatrix[3][2] = position.z;
    } else {
      worldMatrix = modelWorldMatrix;
    }
    const modelViewMatrix2 = cameraViewMatrix.mul(worldMatrix);
    if (defined(horizontal)) {
      modelViewMatrix2[0][0] = modelWorldMatrix[0].length();
      modelViewMatrix2[0][1] = 0;
      modelViewMatrix2[0][2] = 0;
    }
    if (defined(vertical)) {
      modelViewMatrix2[1][0] = 0;
      modelViewMatrix2[1][1] = modelWorldMatrix[1].length();
      modelViewMatrix2[1][2] = 0;
    }
    modelViewMatrix2[2][0] = 0;
    modelViewMatrix2[2][1] = 0;
    modelViewMatrix2[2][2] = 1;
    return cameraProjectionMatrix.mul(modelViewMatrix2).mul(positionLocal$1);
  }
);
const viewportSafeUV = /* @__PURE__ */ Fn(([uv2 = null]) => {
  const depth2 = linearDepth();
  const depthDiff = linearDepth(viewportDepthTexture(uv2)).sub(depth2);
  const finalUV = depthDiff.lessThan(0).select(screenUV, uv2);
  return finalUV;
});
class SpriteSheetUVNode extends Node {
  static get type() {
    return "SpriteSheetUVNode";
  }
  /**
   * Constructs a new sprite sheet uv node.
   *
   * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).
   * @param {Node<vec2>} [uvNode=uv()] - The uv node.
   * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.
   */
  constructor(countNode, uvNode = uv$1(), frameNode = float(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  setup() {
    const { frameNode, uvNode, countNode } = this;
    const { width, height } = countNode;
    const frameNum = frameNode.mod(width.mul(height)).floor();
    const column = frameNum.mod(width);
    const row = height.sub(frameNum.add(1).div(width).ceil());
    const scale2 = countNode.reciprocal();
    const uvFrameOffset = vec2(column, row);
    return uvNode.add(uvFrameOffset).mul(scale2);
  }
}
const spritesheetUV =
  /* @__PURE__ */ nodeProxy(SpriteSheetUVNode).setParameterLength(3);
const triplanarTextures = /* @__PURE__ */ Fn(
  ([
    textureXNode,
    textureYNode = null,
    textureZNode = null,
    scaleNode = float(1),
    positionNode = positionLocal$1,
    normalNode = normalLocal,
  ]) => {
    let bf = normalNode.abs().normalize();
    bf = bf.div(bf.dot(vec3(1)));
    const tx = positionNode.yz.mul(scaleNode);
    const ty = positionNode.zx.mul(scaleNode);
    const tz = positionNode.xy.mul(scaleNode);
    const textureX = textureXNode.value;
    const textureY = textureYNode !== null ? textureYNode.value : textureX;
    const textureZ = textureZNode !== null ? textureZNode.value : textureX;
    const cx = texture$1(textureX, tx).mul(bf.x);
    const cy = texture$1(textureY, ty).mul(bf.y);
    const cz = texture$1(textureZ, tz).mul(bf.z);
    return add(cx, cy, cz);
  }
);
const triplanarTexture = (...params) => triplanarTextures(...params);
const _reflectorPlane = new Plane();
const _normal = new Vector3();
const _reflectorWorldPosition = new Vector3();
const _cameraWorldPosition = new Vector3();
const _rotationMatrix = new Matrix4();
const _lookAtPosition = new Vector3(0, 0, -1);
const clipPlane = new Vector4();
const _view = new Vector3();
const _target = new Vector3();
const _q = new Vector4();
const _size$2 = new Vector2();
const _defaultRT = new RenderTarget();
const _defaultUV = screenUV.flipX();
_defaultRT.depthTexture = new DepthTexture(1, 1);
let _inReflector = false;
class ReflectorNode extends TextureNode {
  static get type() {
    return "ReflectorNode";
  }
  /**
   * Constructs a new reflector node.
   *
   * @param {Object} [parameters={}] - An object holding configuration parameters.
   * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
   * @param {number} [parameters.resolution=1] - The resolution scale.
   * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
   * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
   * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.
   * @param {TextureNode} [parameters.defaultTexture] - The default texture node.
   * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.
   */
  constructor(parameters = {}) {
    super(parameters.defaultTexture || _defaultRT.texture, _defaultUV);
    this._reflectorBaseNode =
      parameters.reflector || new ReflectorBaseNode(this, parameters);
    this._depthNode = null;
    this.setUpdateMatrix(false);
  }
  /**
   * A reference to the internal reflector node.
   *
   * @type {ReflectorBaseNode}
   */
  get reflector() {
    return this._reflectorBaseNode;
  }
  /**
   * A reference to 3D object the reflector is linked to.
   *
   * @type {Object3D}
   */
  get target() {
    return this._reflectorBaseNode.target;
  }
  /**
   * Returns a node representing the mirror's depth. That can be used
   * to implement more advanced reflection effects like distance attenuation.
   *
   * @return {Node} The depth node.
   */
  getDepthNode() {
    if (this._depthNode === null) {
      if (this._reflectorBaseNode.depth !== true) {
        throw new Error(
          "THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. "
        );
      }
      this._depthNode = nodeObject(
        new ReflectorNode({
          defaultTexture: _defaultRT.depthTexture,
          reflector: this._reflectorBaseNode,
        })
      );
    }
    return this._depthNode;
  }
  setup(builder) {
    if (!builder.object.isQuadMesh) this._reflectorBaseNode.build(builder);
    return super.setup(builder);
  }
  clone() {
    const newNode = new this.constructor(this.reflectorNode);
    newNode.uvNode = this.uvNode;
    newNode.levelNode = this.levelNode;
    newNode.biasNode = this.biasNode;
    newNode.sampler = this.sampler;
    newNode.depthNode = this.depthNode;
    newNode.compareNode = this.compareNode;
    newNode.gradNode = this.gradNode;
    newNode._reflectorBaseNode = this._reflectorBaseNode;
    return newNode;
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    super.dispose();
    this._reflectorBaseNode.dispose();
  }
}
class ReflectorBaseNode extends Node {
  static get type() {
    return "ReflectorBaseNode";
  }
  /**
   * Constructs a new reflector base node.
   *
   * @param {TextureNode} textureNode - Represents the rendered reflections as a texture node.
   * @param {Object} [parameters={}] - An object holding configuration parameters.
   * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
   * @param {number} [parameters.resolution=1] - The resolution scale.
   * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
   * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
   * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.
   */
  constructor(textureNode, parameters = {}) {
    super();
    const {
      target = new Object3D(),
      resolution = 1,
      generateMipmaps = false,
      bounces = true,
      depth: depth2 = false,
    } = parameters;
    this.textureNode = textureNode;
    this.target = target;
    this.resolution = resolution;
    this.generateMipmaps = generateMipmaps;
    this.bounces = bounces;
    this.depth = depth2;
    this.updateBeforeType = bounces
      ? NodeUpdateType.RENDER
      : NodeUpdateType.FRAME;
    this.virtualCameras = /* @__PURE__ */ new WeakMap();
    this.renderTargets = /* @__PURE__ */ new Map();
    this.forceUpdate = false;
    this.hasOutput = false;
  }
  /**
   * Updates the resolution of the internal render target.
   *
   * @private
   * @param {RenderTarget} renderTarget - The render target to resize.
   * @param {Renderer} renderer - The renderer that is used to determine the new size.
   */
  _updateResolution(renderTarget, renderer2) {
    const resolution = this.resolution;
    renderer2.getDrawingBufferSize(_size$2);
    renderTarget.setSize(
      Math.round(_size$2.width * resolution),
      Math.round(_size$2.height * resolution)
    );
  }
  setup(builder) {
    this._updateResolution(_defaultRT, builder.renderer);
    return super.setup(builder);
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    super.dispose();
    for (const renderTarget of this.renderTargets.values()) {
      renderTarget.dispose();
    }
  }
  /**
   * Returns a virtual camera for the given camera. The virtual camera is used to
   * render the scene from the reflector's view so correct reflections can be produced.
   *
   * @param {Camera} camera - The scene's camera.
   * @return {Camera} The corresponding virtual camera.
   */
  getVirtualCamera(camera2) {
    let virtualCamera = this.virtualCameras.get(camera2);
    if (virtualCamera === void 0) {
      virtualCamera = camera2.clone();
      this.virtualCameras.set(camera2, virtualCamera);
    }
    return virtualCamera;
  }
  /**
   * Returns a render target for the given camera. The reflections are rendered
   * into this render target.
   *
   * @param {Camera} camera - The scene's camera.
   * @return {RenderTarget} The render target.
   */
  getRenderTarget(camera2) {
    let renderTarget = this.renderTargets.get(camera2);
    if (renderTarget === void 0) {
      renderTarget = new RenderTarget(0, 0, { type: HalfFloatType });
      if (this.generateMipmaps === true) {
        renderTarget.texture.minFilter = LinearMipMapLinearFilter;
        renderTarget.texture.generateMipmaps = true;
      }
      if (this.depth === true) {
        renderTarget.depthTexture = new DepthTexture();
      }
      this.renderTargets.set(camera2, renderTarget);
    }
    return renderTarget;
  }
  updateBefore(frame) {
    if (this.bounces === false && _inReflector) return false;
    _inReflector = true;
    const {
      scene: scene2,
      camera: camera2,
      renderer: renderer2,
      material,
    } = frame;
    const { target } = this;
    const virtualCamera = this.getVirtualCamera(camera2);
    const renderTarget = this.getRenderTarget(virtualCamera);
    renderer2.getDrawingBufferSize(_size$2);
    this._updateResolution(renderTarget, renderer2);
    _reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);
    _cameraWorldPosition.setFromMatrixPosition(camera2.matrixWorld);
    _rotationMatrix.extractRotation(target.matrixWorld);
    _normal.set(0, 0, 1);
    _normal.applyMatrix4(_rotationMatrix);
    _view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);
    const isFacingAway = _view.dot(_normal) > 0;
    let needsClear = false;
    if (isFacingAway === true && this.forceUpdate === false) {
      if (this.hasOutput === false) {
        _inReflector = false;
        return;
      }
      needsClear = true;
    }
    _view.reflect(_normal).negate();
    _view.add(_reflectorWorldPosition);
    _rotationMatrix.extractRotation(camera2.matrixWorld);
    _lookAtPosition.set(0, 0, -1);
    _lookAtPosition.applyMatrix4(_rotationMatrix);
    _lookAtPosition.add(_cameraWorldPosition);
    _target.subVectors(_reflectorWorldPosition, _lookAtPosition);
    _target.reflect(_normal).negate();
    _target.add(_reflectorWorldPosition);
    virtualCamera.coordinateSystem = camera2.coordinateSystem;
    virtualCamera.position.copy(_view);
    virtualCamera.up.set(0, 1, 0);
    virtualCamera.up.applyMatrix4(_rotationMatrix);
    virtualCamera.up.reflect(_normal);
    virtualCamera.lookAt(_target);
    virtualCamera.near = camera2.near;
    virtualCamera.far = camera2.far;
    virtualCamera.updateMatrixWorld();
    virtualCamera.projectionMatrix.copy(camera2.projectionMatrix);
    _reflectorPlane.setFromNormalAndCoplanarPoint(
      _normal,
      _reflectorWorldPosition
    );
    _reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
    clipPlane.set(
      _reflectorPlane.normal.x,
      _reflectorPlane.normal.y,
      _reflectorPlane.normal.z,
      _reflectorPlane.constant
    );
    const projectionMatrix = virtualCamera.projectionMatrix;
    _q.x =
      (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) /
      projectionMatrix.elements[0];
    _q.y =
      (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) /
      projectionMatrix.elements[5];
    _q.z = -1;
    _q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
    clipPlane.multiplyScalar(1 / clipPlane.dot(_q));
    const clipBias = 0;
    projectionMatrix.elements[2] = clipPlane.x;
    projectionMatrix.elements[6] = clipPlane.y;
    projectionMatrix.elements[10] =
      renderer2.coordinateSystem === WebGPUCoordinateSystem
        ? clipPlane.z - clipBias
        : clipPlane.z + 1 - clipBias;
    projectionMatrix.elements[14] = clipPlane.w;
    this.textureNode.value = renderTarget.texture;
    if (this.depth === true) {
      this.textureNode.getDepthNode().value = renderTarget.depthTexture;
    }
    material.visible = false;
    const currentRenderTarget = renderer2.getRenderTarget();
    const currentMRT = renderer2.getMRT();
    const currentAutoClear = renderer2.autoClear;
    renderer2.setMRT(null);
    renderer2.setRenderTarget(renderTarget);
    renderer2.autoClear = true;
    if (needsClear) {
      renderer2.clear();
      this.hasOutput = false;
    } else {
      renderer2.render(scene2, virtualCamera);
      this.hasOutput = true;
    }
    renderer2.setMRT(currentMRT);
    renderer2.setRenderTarget(currentRenderTarget);
    renderer2.autoClear = currentAutoClear;
    material.visible = true;
    _inReflector = false;
    this.forceUpdate = false;
  }
}
const reflector = (parameters) => nodeObject(new ReflectorNode(parameters));
const _camera = /* @__PURE__ */ new OrthographicCamera(-1, 1, 1, -1, 0, 1);
class QuadGeometry extends BufferGeometry {
  /**
   * Constructs a new quad geometry.
   *
   * @param {boolean} [flipY=false] - Whether the uv coordinates should be flipped along the vertical axis or not.
   */
  constructor(flipY = false) {
    super();
    const uv2 = flipY === false ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
    this.setAttribute(
      "position",
      new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)
    );
    this.setAttribute("uv", new Float32BufferAttribute(uv2, 2));
  }
}
const _geometry = /* @__PURE__ */ new QuadGeometry();
class QuadMesh extends Mesh {
  /**
   * Constructs a new quad mesh.
   *
   * @param {?Material} [material=null] - The material to render the quad mesh with.
   */
  constructor(material = null) {
    super(_geometry, material);
    this.camera = _camera;
    this.isQuadMesh = true;
  }
  /**
   * Async version of `render()`.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the render has been finished.
   */
  async renderAsync(renderer2) {
    return renderer2.renderAsync(this, _camera);
  }
  /**
   * Renders the quad mesh
   *
   * @param {Renderer} renderer - The renderer.
   */
  render(renderer2) {
    renderer2.render(this, _camera);
  }
}
const _size$1 = /* @__PURE__ */ new Vector2();
class RTTNode extends TextureNode {
  static get type() {
    return "RTTNode";
  }
  /**
   * Constructs a new RTT node.
   *
   * @param {Node} node - The node to render a texture with.
   * @param {?number} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.
   * @param {?number} [height=null] - The height of the internal render target.
   * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.
   */
  constructor(
    node,
    width = null,
    height = null,
    options = { type: HalfFloatType }
  ) {
    const renderTarget = new RenderTarget(width, height, options);
    super(renderTarget.texture, uv$1());
    this.isRTTNode = true;
    this.node = node;
    this.width = width;
    this.height = height;
    this.pixelRatio = 1;
    this.renderTarget = renderTarget;
    this.textureNeedsUpdate = true;
    this.autoUpdate = true;
    this._rttNode = null;
    this._quadMesh = new QuadMesh(new NodeMaterial());
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  /**
   * Whether the internal render target should automatically be resized or not.
   *
   * @type {boolean}
   * @readonly
   * @default true
   */
  get autoResize() {
    return this.width === null;
  }
  setup(builder) {
    this._rttNode = this.node.context(builder.getSharedContext());
    this._quadMesh.material.name = "RTT";
    this._quadMesh.material.needsUpdate = true;
    return super.setup(builder);
  }
  /**
   * Sets the size of the internal render target
   *
   * @param {number} width - The width to set.
   * @param {number} height - The width to set.
   */
  setSize(width, height) {
    this.width = width;
    this.height = height;
    const effectiveWidth = width * this.pixelRatio;
    const effectiveHeight = height * this.pixelRatio;
    this.renderTarget.setSize(effectiveWidth, effectiveHeight);
    this.textureNeedsUpdate = true;
  }
  /**
   * Sets the pixel ratio. This will also resize the render target.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(pixelRatio) {
    this.pixelRatio = pixelRatio;
    this.setSize(this.width, this.height);
  }
  updateBefore({ renderer: renderer2 }) {
    if (this.textureNeedsUpdate === false && this.autoUpdate === false) return;
    this.textureNeedsUpdate = false;
    if (this.autoResize === true) {
      const pixelRatio = renderer2.getPixelRatio();
      const size = renderer2.getSize(_size$1);
      const effectiveWidth = size.width * pixelRatio;
      const effectiveHeight = size.height * pixelRatio;
      if (
        effectiveWidth !== this.renderTarget.width ||
        effectiveHeight !== this.renderTarget.height
      ) {
        this.renderTarget.setSize(effectiveWidth, effectiveHeight);
        this.textureNeedsUpdate = true;
      }
    }
    this._quadMesh.material.fragmentNode = this._rttNode;
    const currentRenderTarget = renderer2.getRenderTarget();
    renderer2.setRenderTarget(this.renderTarget);
    this._quadMesh.render(renderer2);
    renderer2.setRenderTarget(currentRenderTarget);
  }
  clone() {
    const newNode = new TextureNode(this.value, this.uvNode, this.levelNode);
    newNode.sampler = this.sampler;
    newNode.referenceNode = this;
    return newNode;
  }
}
const rtt = (node, ...params) =>
  nodeObject(new RTTNode(nodeObject(node), ...params));
const convertToTexture = (node, ...params) => {
  if (node.isTextureNode) return node;
  if (node.isPassNode) return node.getTextureNode();
  return rtt(node, ...params);
};
const getViewPosition = /* @__PURE__ */ Fn(
  ([screenPosition, depth2, projectionMatrixInverse], builder) => {
    let clipSpacePosition;
    if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {
      screenPosition = vec2(screenPosition.x, screenPosition.y.oneMinus())
        .mul(2)
        .sub(1);
      clipSpacePosition = vec4(vec3(screenPosition, depth2), 1);
    } else {
      clipSpacePosition = vec4(
        vec3(screenPosition.x, screenPosition.y.oneMinus(), depth2)
          .mul(2)
          .sub(1),
        1
      );
    }
    const viewSpacePosition = vec4(
      projectionMatrixInverse.mul(clipSpacePosition)
    );
    return viewSpacePosition.xyz.div(viewSpacePosition.w);
  }
);
const getScreenPosition = /* @__PURE__ */ Fn(
  ([viewPosition, projectionMatrix]) => {
    const sampleClipPos = projectionMatrix.mul(vec4(viewPosition, 1));
    const sampleUv = sampleClipPos.xy
      .div(sampleClipPos.w)
      .mul(0.5)
      .add(0.5)
      .toVar();
    return vec2(sampleUv.x, sampleUv.y.oneMinus());
  }
);
const getNormalFromDepth = /* @__PURE__ */ Fn(
  ([uv2, depthTexture, projectionMatrixInverse]) => {
    const size = textureSize(textureLoad(depthTexture));
    const p2 = ivec2(uv2.mul(size)).toVar();
    const c0 = textureLoad(depthTexture, p2).toVar();
    const l2 = textureLoad(depthTexture, p2.sub(ivec2(2, 0))).toVar();
    const l1 = textureLoad(depthTexture, p2.sub(ivec2(1, 0))).toVar();
    const r1 = textureLoad(depthTexture, p2.add(ivec2(1, 0))).toVar();
    const r2 = textureLoad(depthTexture, p2.add(ivec2(2, 0))).toVar();
    const b2 = textureLoad(depthTexture, p2.add(ivec2(0, 2))).toVar();
    const b1 = textureLoad(depthTexture, p2.add(ivec2(0, 1))).toVar();
    const t1 = textureLoad(depthTexture, p2.sub(ivec2(0, 1))).toVar();
    const t2 = textureLoad(depthTexture, p2.sub(ivec2(0, 2))).toVar();
    const dl = abs(sub(float(2).mul(l1).sub(l2), c0)).toVar();
    const dr = abs(sub(float(2).mul(r1).sub(r2), c0)).toVar();
    const db = abs(sub(float(2).mul(b1).sub(b2), c0)).toVar();
    const dt = abs(sub(float(2).mul(t1).sub(t2), c0)).toVar();
    const ce = getViewPosition(uv2, c0, projectionMatrixInverse).toVar();
    const dpdx = dl
      .lessThan(dr)
      .select(
        ce.sub(
          getViewPosition(
            uv2.sub(vec2(float(1).div(size.x), 0)),
            l1,
            projectionMatrixInverse
          )
        ),
        ce
          .negate()
          .add(
            getViewPosition(
              uv2.add(vec2(float(1).div(size.x), 0)),
              r1,
              projectionMatrixInverse
            )
          )
      );
    const dpdy = db
      .lessThan(dt)
      .select(
        ce.sub(
          getViewPosition(
            uv2.add(vec2(0, float(1).div(size.y))),
            b1,
            projectionMatrixInverse
          )
        ),
        ce
          .negate()
          .add(
            getViewPosition(
              uv2.sub(vec2(0, float(1).div(size.y))),
              t1,
              projectionMatrixInverse
            )
          )
      );
    return normalize(cross(dpdx, dpdy));
  }
);
class SampleNode extends Node {
  /**
   * Returns the type of the node.
   *
   * @type {string}
   * @readonly
   * @static
   */
  static get type() {
    return "SampleNode";
  }
  /**
   * Creates an instance of SampleNode.
   *
   * @param {Function} callback - The function to be called when sampling. Should accept a UV node and return a value.
   */
  constructor(callback) {
    super();
    this.callback = callback;
    this.isSampleNode = true;
  }
  /**
   * Sets up the node by sampling with the default UV accessor.
   *
   * @returns {Node} The result of the callback function when called with the UV node.
   */
  setup() {
    return this.sample(uv$1());
  }
  /**
   * Calls the callback function with the provided UV node.
   *
   * @param {Node<vec2>} uv - The UV node or value to be passed to the callback.
   * @returns {Node} The result of the callback function.
   */
  sample(uv2) {
    return this.callback(uv2);
  }
}
const sample = (callback) => nodeObject(new SampleNode(callback));
class EventNode extends Node {
  static get type() {
    return "EventNode";
  }
  /**
   * Creates an EventNode.
   *
   * @param {string} eventType - The type of event
   * @param {Function} callback - The callback to execute on update.
   */
  constructor(eventType, callback) {
    super("void");
    this.eventType = eventType;
    this.callback = callback;
    if (eventType === EventNode.OBJECT) {
      this.updateType = NodeUpdateType.OBJECT;
    } else if (eventType === EventNode.MATERIAL) {
      this.updateType = NodeUpdateType.RENDER;
    }
  }
  update(frame) {
    this.callback(frame);
  }
}
EventNode.OBJECT = "object";
EventNode.MATERIAL = "material";
const createEvent = (type, callback) =>
  nodeObject(new EventNode(type, callback)).toStack();
const OnObjectUpdate = (callback) => createEvent(EventNode.OBJECT, callback);
const OnMaterialUpdate = (callback) =>
  createEvent(EventNode.MATERIAL, callback);
class StorageInstancedBufferAttribute extends InstancedBufferAttribute {
  /**
   * Constructs a new storage instanced buffer attribute.
   *
   * @param {number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.
   * The subsequent parameters are then obsolete.
   * @param {number} itemSize - The item size.
   * @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.
   */
  constructor(count, itemSize, typeClass = Float32Array) {
    const array2 = ArrayBuffer.isView(count)
      ? count
      : new typeClass(count * itemSize);
    super(array2, itemSize);
    this.isStorageInstancedBufferAttribute = true;
  }
}
class StorageBufferAttribute extends BufferAttribute {
  /**
   * Constructs a new storage buffer attribute.
   *
   * @param {number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.
   * The subsequent parameters are then obsolete.
   * @param {number} itemSize - The item size.
   * @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.
   */
  constructor(count, itemSize, typeClass = Float32Array) {
    const array2 = ArrayBuffer.isView(count)
      ? count
      : new typeClass(count * itemSize);
    super(array2, itemSize);
    this.isStorageBufferAttribute = true;
  }
}
const attributeArray = (count, type = "float") => {
  let itemSize, typedArray;
  if (type.isStruct === true) {
    itemSize = type.layout.getLength();
    typedArray = getTypedArrayFromType("float");
  } else {
    itemSize = getLengthFromType(type);
    typedArray = getTypedArrayFromType(type);
  }
  const buffer2 = new StorageBufferAttribute(count, itemSize, typedArray);
  const node = storage(buffer2, type, count);
  return node;
};
const instancedArray = (count, type = "float") => {
  let itemSize, typedArray;
  if (type.isStruct === true) {
    itemSize = type.layout.getLength();
    typedArray = getTypedArrayFromType("float");
  } else {
    itemSize = getLengthFromType(type);
    typedArray = getTypedArrayFromType(type);
  }
  const buffer2 = new StorageInstancedBufferAttribute(
    count,
    itemSize,
    typedArray
  );
  const node = storage(buffer2, type, count);
  return node;
};
class PointUVNode extends Node {
  static get type() {
    return "PointUVNode";
  }
  /**
   * Constructs a new point uv node.
   */
  constructor() {
    super("vec2");
    this.isPointUVNode = true;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
}
const pointUV = /* @__PURE__ */ nodeImmutable(PointUVNode);
const _e1 = /* @__PURE__ */ new Euler();
const _m1 = /* @__PURE__ */ new Matrix4();
class SceneNode extends Node {
  static get type() {
    return "SceneNode";
  }
  /**
   * Constructs a new scene node.
   *
   * @param {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')} scope - The scope defines the type of scene property that is accessed.
   * @param {?Scene} [scene=null] - A reference to the scene.
   */
  constructor(scope = SceneNode.BACKGROUND_BLURRINESS, scene2 = null) {
    super();
    this.scope = scope;
    this.scene = scene2;
  }
  /**
   * Depending on the scope, the method returns a different type of node that represents
   * the respective scene property.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The output node.
   */
  setup(builder) {
    const scope = this.scope;
    const scene2 = this.scene !== null ? this.scene : builder.scene;
    let output2;
    if (scope === SceneNode.BACKGROUND_BLURRINESS) {
      output2 = reference("backgroundBlurriness", "float", scene2);
    } else if (scope === SceneNode.BACKGROUND_INTENSITY) {
      output2 = reference("backgroundIntensity", "float", scene2);
    } else if (scope === SceneNode.BACKGROUND_ROTATION) {
      output2 = uniform$1("mat4")
        .setName("backgroundRotation")
        .setGroup(renderGroup)
        .onRenderUpdate(() => {
          const background = scene2.background;
          if (
            background !== null &&
            background.isTexture &&
            background.mapping !== UVMapping
          ) {
            _e1.copy(scene2.backgroundRotation);
            _e1.x *= -1;
            _e1.y *= -1;
            _e1.z *= -1;
            _m1.makeRotationFromEuler(_e1);
          } else {
            _m1.identity();
          }
          return _m1;
        });
    } else {
      console.error("THREE.SceneNode: Unknown scope:", scope);
    }
    return output2;
  }
}
SceneNode.BACKGROUND_BLURRINESS = "backgroundBlurriness";
SceneNode.BACKGROUND_INTENSITY = "backgroundIntensity";
SceneNode.BACKGROUND_ROTATION = "backgroundRotation";
const backgroundBlurriness = /* @__PURE__ */ nodeImmutable(
  SceneNode,
  SceneNode.BACKGROUND_BLURRINESS
);
const backgroundIntensity = /* @__PURE__ */ nodeImmutable(
  SceneNode,
  SceneNode.BACKGROUND_INTENSITY
);
const backgroundRotation = /* @__PURE__ */ nodeImmutable(
  SceneNode,
  SceneNode.BACKGROUND_ROTATION
);
class StorageTextureNode extends TextureNode {
  static get type() {
    return "StorageTextureNode";
  }
  /**
   * Constructs a new storage texture node.
   *
   * @param {StorageTexture} value - The storage texture.
   * @param {Node<vec2|vec3>} uvNode - The uv node.
   * @param {?Node} [storeNode=null] - The value node that should be stored in the texture.
   */
  constructor(value, uvNode, storeNode = null) {
    super(value, uvNode);
    this.storeNode = storeNode;
    this.isStorageTextureNode = true;
    this.access = NodeAccess.WRITE_ONLY;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'storageTexture'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "storageTexture";
  }
  setup(builder) {
    super.setup(builder);
    const properties = builder.getNodeProperties(this);
    properties.storeNode = this.storeNode;
    return properties;
  }
  /**
   * Defines the node access.
   *
   * @param {string} value - The node access.
   * @return {StorageTextureNode} A reference to this node.
   */
  setAccess(value) {
    this.access = value;
    return this;
  }
  /**
   * Generates the code snippet of the storage node. If no `storeNode`
   * is defined, the texture node is generated as normal texture.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(builder, output2) {
    let snippet;
    if (this.storeNode !== null) {
      snippet = this.generateStore(builder);
    } else {
      snippet = super.generate(builder, output2);
    }
    return snippet;
  }
  /**
   * Convenience method for configuring a read/write node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toReadWrite() {
    return this.setAccess(NodeAccess.READ_WRITE);
  }
  /**
   * Convenience method for configuring a read-only node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toReadOnly() {
    return this.setAccess(NodeAccess.READ_ONLY);
  }
  /**
   * Convenience method for configuring a write-only node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toWriteOnly() {
    return this.setAccess(NodeAccess.WRITE_ONLY);
  }
  /**
   * Generates the code snippet of the storage texture node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  generateStore(builder) {
    const properties = builder.getNodeProperties(this);
    const { uvNode, storeNode, depthNode } = properties;
    const textureProperty = super.generate(builder, "property");
    const uvSnippet = uvNode.build(
      builder,
      this.value.is3DTexture === true ? "uvec3" : "uvec2"
    );
    const storeSnippet = storeNode.build(builder, "vec4");
    const depthSnippet = depthNode ? depthNode.build(builder, "int") : null;
    const snippet = builder.generateTextureStore(
      builder,
      textureProperty,
      uvSnippet,
      depthSnippet,
      storeSnippet
    );
    builder.addLineFlowCode(snippet, this);
  }
  clone() {
    const newNode = super.clone();
    newNode.storeNode = this.storeNode;
    return newNode;
  }
}
const storageTexture = /* @__PURE__ */ nodeProxy(
  StorageTextureNode
).setParameterLength(1, 3);
const textureStore = (value, uvNode, storeNode) => {
  const node = storageTexture(value, uvNode, storeNode);
  if (storeNode !== null) node.toStack();
  return node;
};
const normal = Fn(({ texture: texture2, uv: uv2 }) => {
  const epsilon = 1e-4;
  const ret = vec3().toVar();
  If(uv2.x.lessThan(epsilon), () => {
    ret.assign(vec3(1, 0, 0));
  })
    .ElseIf(uv2.y.lessThan(epsilon), () => {
      ret.assign(vec3(0, 1, 0));
    })
    .ElseIf(uv2.z.lessThan(epsilon), () => {
      ret.assign(vec3(0, 0, 1));
    })
    .ElseIf(uv2.x.greaterThan(1 - epsilon), () => {
      ret.assign(vec3(-1, 0, 0));
    })
    .ElseIf(uv2.y.greaterThan(1 - epsilon), () => {
      ret.assign(vec3(0, -1, 0));
    })
    .ElseIf(uv2.z.greaterThan(1 - epsilon), () => {
      ret.assign(vec3(0, 0, -1));
    })
    .Else(() => {
      const step2 = 0.01;
      const x = texture2
        .sample(uv2.add(vec3(-step2, 0, 0)))
        .r.sub(texture2.sample(uv2.add(vec3(step2, 0, 0))).r);
      const y = texture2
        .sample(uv2.add(vec3(0, -step2, 0)))
        .r.sub(texture2.sample(uv2.add(vec3(0, step2, 0))).r);
      const z = texture2
        .sample(uv2.add(vec3(0, 0, -step2)))
        .r.sub(texture2.sample(uv2.add(vec3(0, 0, step2))).r);
      ret.assign(vec3(x, y, z));
    });
  return ret.normalize();
});
class Texture3DNode extends TextureNode {
  static get type() {
    return "Texture3DNode";
  }
  /**
   * Constructs a new 3D texture node.
   *
   * @param {Data3DTexture} value - The 3D texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   */
  constructor(value, uvNode = null, levelNode = null) {
    super(value, uvNode, levelNode);
    this.isTexture3DNode = true;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'texture3D'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "texture3D";
  }
  /**
   * Returns a default uv node which is in context of 3D textures a three-dimensional
   * uv node.
   *
   * @return {Node<vec3>} The default uv node.
   */
  getDefaultUV() {
    return vec3(0.5, 0.5, 0.5);
  }
  /**
   * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
   * for 3D textures. The uv transformation matrix is not applied to 3D textures.
   *
   * @param {boolean} value - The update toggle.
   */
  setUpdateMatrix() {}
  // Ignore .updateMatrix for 3d TextureNode
  /**
   * Overwrites the default implementation to return the unmodified uv node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The unmodified uv node.
   */
  setupUV(builder, uvNode) {
    const texture2 = this.value;
    if (
      builder.isFlipY() &&
      (texture2.isRenderTargetTexture === true ||
        texture2.isFramebufferTexture === true)
    ) {
      if (this.sampler) {
        uvNode = uvNode.flipY();
      } else {
        uvNode = uvNode.setY(
          int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1)
        );
      }
    }
    return uvNode;
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(builder, uvNode) {
    return uvNode.build(builder, "vec3");
  }
  /**
   * TODO.
   *
   * @param {Node<vec3>} uvNode - The uv node .
   * @return {Node<vec3>} TODO.
   */
  normal(uvNode) {
    return normal({ texture: this, uv: uvNode });
  }
}
const texture3D = /* @__PURE__ */ nodeProxy(Texture3DNode).setParameterLength(
  1,
  3
);
class UserDataNode extends ReferenceNode {
  static get type() {
    return "UserDataNode";
  }
  /**
   * Constructs a new user data node.
   *
   * @param {string} property - The property name that should be referenced by the node.
   * @param {string} inputType - The node data type of the reference.
   * @param {?Object} [userData=null] - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.
   */
  constructor(property2, inputType, userData2 = null) {
    super(property2, inputType, userData2);
    this.userData = userData2;
  }
  /**
   * Overwritten to make sure {@link ReferenceNode#reference} points to the correct
   * `userData` field.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state to evaluate.
   * @return {Object} A reference to the `userData` field.
   */
  updateReference(state) {
    this.reference =
      this.userData !== null ? this.userData : state.object.userData;
    return this.reference;
  }
}
const userData = (name, inputType, userData2) =>
  nodeObject(new UserDataNode(name, inputType, userData2));
const _objectData = /* @__PURE__ */ new WeakMap();
class VelocityNode extends TempNode {
  static get type() {
    return "VelocityNode";
  }
  /**
   * Constructs a new vertex color node.
   */
  constructor() {
    super("vec2");
    this.projectionMatrix = null;
    this.updateType = NodeUpdateType.OBJECT;
    this.updateAfterType = NodeUpdateType.OBJECT;
    this.previousModelWorldMatrix = uniform$1(new Matrix4());
    this.previousProjectionMatrix = uniform$1(new Matrix4()).setGroup(
      renderGroup
    );
    this.previousCameraViewMatrix = uniform$1(new Matrix4());
  }
  /**
   * Sets the given projection matrix.
   *
   * @param {Matrix4} projectionMatrix - The projection matrix to set.
   */
  setProjectionMatrix(projectionMatrix) {
    this.projectionMatrix = projectionMatrix;
  }
  /**
   * Updates velocity specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update({ frameId: frameId2, camera: camera2, object }) {
    const previousModelMatrix = getPreviousMatrix(object);
    this.previousModelWorldMatrix.value.copy(previousModelMatrix);
    const cameraData = getData(camera2);
    if (cameraData.frameId !== frameId2) {
      cameraData.frameId = frameId2;
      if (cameraData.previousProjectionMatrix === void 0) {
        cameraData.previousProjectionMatrix = new Matrix4();
        cameraData.previousCameraViewMatrix = new Matrix4();
        cameraData.currentProjectionMatrix = new Matrix4();
        cameraData.currentCameraViewMatrix = new Matrix4();
        cameraData.previousProjectionMatrix.copy(
          this.projectionMatrix || camera2.projectionMatrix
        );
        cameraData.previousCameraViewMatrix.copy(camera2.matrixWorldInverse);
      } else {
        cameraData.previousProjectionMatrix.copy(
          cameraData.currentProjectionMatrix
        );
        cameraData.previousCameraViewMatrix.copy(
          cameraData.currentCameraViewMatrix
        );
      }
      cameraData.currentProjectionMatrix.copy(
        this.projectionMatrix || camera2.projectionMatrix
      );
      cameraData.currentCameraViewMatrix.copy(camera2.matrixWorldInverse);
      this.previousProjectionMatrix.value.copy(
        cameraData.previousProjectionMatrix
      );
      this.previousCameraViewMatrix.value.copy(
        cameraData.previousCameraViewMatrix
      );
    }
  }
  /**
   * Overwritten to updated velocity specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateAfter({ object }) {
    getPreviousMatrix(object).copy(object.matrixWorld);
  }
  /**
   * Implements the velocity computation based on the previous and current vertex data.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec2>} The motion vector.
   */
  setup() {
    const projectionMatrix =
      this.projectionMatrix === null
        ? cameraProjectionMatrix
        : uniform$1(this.projectionMatrix);
    const previousModelViewMatrix = this.previousCameraViewMatrix.mul(
      this.previousModelWorldMatrix
    );
    const clipPositionCurrent = projectionMatrix
      .mul(modelViewMatrix)
      .mul(positionLocal$1);
    const clipPositionPrevious = this.previousProjectionMatrix
      .mul(previousModelViewMatrix)
      .mul(positionPrevious);
    const ndcPositionCurrent = clipPositionCurrent.xy.div(
      clipPositionCurrent.w
    );
    const ndcPositionPrevious = clipPositionPrevious.xy.div(
      clipPositionPrevious.w
    );
    const velocity2 = sub(ndcPositionCurrent, ndcPositionPrevious);
    return velocity2;
  }
}
function getData(object) {
  let objectData = _objectData.get(object);
  if (objectData === void 0) {
    objectData = {};
    _objectData.set(object, objectData);
  }
  return objectData;
}
function getPreviousMatrix(object, index = 0) {
  const objectData = getData(object);
  let matrix = objectData[index];
  if (matrix === void 0) {
    objectData[index] = matrix = new Matrix4();
    objectData[index].copy(object.matrixWorld);
  }
  return matrix;
}
const velocity = /* @__PURE__ */ nodeImmutable(VelocityNode);
const grayscale = /* @__PURE__ */ Fn(([color2]) => {
  return luminance(color2.rgb);
});
const saturation = /* @__PURE__ */ Fn(([color2, adjustment = float(1)]) => {
  return adjustment.mix(luminance(color2.rgb), color2.rgb);
});
const vibrance = /* @__PURE__ */ Fn(([color2, adjustment = float(1)]) => {
  const average = add(color2.r, color2.g, color2.b).div(3);
  const mx = color2.r.max(color2.g.max(color2.b));
  const amt = mx.sub(average).mul(adjustment).mul(-3);
  return mix$1(color2.rgb, mx, amt);
});
const hue = /* @__PURE__ */ Fn(([color2, adjustment = float(1)]) => {
  const k = vec3(0.57735, 0.57735, 0.57735);
  const cosAngle = adjustment.cos();
  return vec3(
    color2.rgb.mul(cosAngle).add(
      k
        .cross(color2.rgb)
        .mul(adjustment.sin())
        .add(k.mul(dot(k, color2.rgb).mul(cosAngle.oneMinus())))
    )
  );
});
const luminance = (
  color2,
  luminanceCoefficients = vec3(
    ColorManagement.getLuminanceCoefficients(new Vector3())
  )
) => dot(color2, luminanceCoefficients);
const cdl = /* @__PURE__ */ Fn(
  ([
    color2,
    slope = vec3(1),
    offset = vec3(0),
    power = vec3(1),
    saturation2 = float(1),
    // ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.
    luminanceCoefficients = vec3(
      ColorManagement.getLuminanceCoefficients(
        new Vector3(),
        LinearSRGBColorSpace
      )
    ),
  ]) => {
    const luma = color2.rgb.dot(vec3(luminanceCoefficients));
    const v = max$1(color2.rgb.mul(slope).add(offset), 0).toVar();
    const pv = v.pow(power).toVar();
    If(v.r.greaterThan(0), () => {
      v.r.assign(pv.r);
    });
    If(v.g.greaterThan(0), () => {
      v.g.assign(pv.g);
    });
    If(v.b.greaterThan(0), () => {
      v.b.assign(pv.b);
    });
    v.assign(luma.add(v.sub(luma).mul(saturation2)));
    return vec4(v.rgb, color2.a);
  }
);
class PosterizeNode extends TempNode {
  static get type() {
    return "PosterizeNode";
  }
  /**
   * Constructs a new posterize node.
   *
   * @param {Node} sourceNode - The input color.
   * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.
   */
  constructor(sourceNode, stepsNode) {
    super();
    this.sourceNode = sourceNode;
    this.stepsNode = stepsNode;
  }
  setup() {
    const { sourceNode, stepsNode } = this;
    return sourceNode.mul(stepsNode).floor().div(stepsNode);
  }
}
const posterize =
  /* @__PURE__ */ nodeProxy(PosterizeNode).setParameterLength(2);
const _size = /* @__PURE__ */ new Vector2();
class PassTextureNode extends TextureNode {
  static get type() {
    return "PassTextureNode";
  }
  /**
   * Constructs a new pass texture node.
   *
   * @param {PassNode} passNode - The pass node.
   * @param {Texture} texture - The output texture.
   */
  constructor(passNode, texture2) {
    super(texture2);
    this.passNode = passNode;
    this.setUpdateMatrix(false);
  }
  setup(builder) {
    this.passNode.build(builder);
    return super.setup(builder);
  }
  clone() {
    return new this.constructor(this.passNode, this.value);
  }
}
class PassMultipleTextureNode extends PassTextureNode {
  static get type() {
    return "PassMultipleTextureNode";
  }
  /**
   * Constructs a new pass texture node.
   *
   * @param {PassNode} passNode - The pass node.
   * @param {string} textureName - The output texture name.
   * @param {boolean} [previousTexture=false] - Whether previous frame data should be used or not.
   */
  constructor(passNode, textureName, previousTexture = false) {
    super(passNode, null);
    this.textureName = textureName;
    this.previousTexture = previousTexture;
  }
  /**
   * Updates the texture reference of this node.
   */
  updateTexture() {
    this.value = this.previousTexture
      ? this.passNode.getPreviousTexture(this.textureName)
      : this.passNode.getTexture(this.textureName);
  }
  setup(builder) {
    this.updateTexture();
    return super.setup(builder);
  }
  clone() {
    const newNode = new this.constructor(
      this.passNode,
      this.textureName,
      this.previousTexture
    );
    newNode.uvNode = this.uvNode;
    newNode.levelNode = this.levelNode;
    newNode.biasNode = this.biasNode;
    newNode.sampler = this.sampler;
    newNode.depthNode = this.depthNode;
    newNode.compareNode = this.compareNode;
    newNode.gradNode = this.gradNode;
    return newNode;
  }
}
class PassNode extends TempNode {
  static get type() {
    return "PassNode";
  }
  /**
   * Constructs a new pass node.
   *
   * @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - A reference to the camera.
   * @param {Object} options - Options for the internal render target.
   */
  constructor(scope, scene2, camera2, options = {}) {
    super("vec4");
    this.scope = scope;
    this.scene = scene2;
    this.camera = camera2;
    this.options = options;
    this._pixelRatio = 1;
    this._width = 1;
    this._height = 1;
    const depthTexture = new DepthTexture();
    depthTexture.isRenderTargetTexture = true;
    depthTexture.name = "depth";
    const renderTarget = new RenderTarget(
      this._width * this._pixelRatio,
      this._height * this._pixelRatio,
      { type: HalfFloatType, ...options }
    );
    renderTarget.texture.name = "output";
    renderTarget.depthTexture = depthTexture;
    this.renderTarget = renderTarget;
    this._textures = {
      output: renderTarget.texture,
      depth: depthTexture,
    };
    this._textureNodes = {};
    this._linearDepthNodes = {};
    this._viewZNodes = {};
    this._previousTextures = {};
    this._previousTextureNodes = {};
    this._cameraNear = uniform$1(0);
    this._cameraFar = uniform$1(0);
    this._mrt = null;
    this._layers = null;
    this._resolution = 1;
    this._viewport = null;
    this._scissor = null;
    this.isPassNode = true;
    this.updateBeforeType = NodeUpdateType.FRAME;
    this.global = true;
  }
  /**
   * Sets the resolution for the pass.
   * The resolution is a factor that is multiplied with the renderer's width and height.
   *
   * @param {number} resolution - The resolution to set. A value of `1` means full resolution.
   * @return {PassNode} A reference to this pass.
   */
  setResolution(resolution) {
    this._resolution = resolution;
    return this;
  }
  /**
   * Gets the current resolution of the pass.
   *
   * @return {number} The current resolution. A value of `1` means full resolution.
   */
  getResolution() {
    return this._resolution;
  }
  /**
   * Sets the layer configuration that should be used when rendering the pass.
   *
   * @param {Layers} layers - The layers object to set.
   * @return {PassNode} A reference to this pass.
   */
  setLayers(layers) {
    this._layers = layers;
    return this;
  }
  /**
   * Gets the current layer configuration of the pass.
   *
   * @return {?Layers} .
   */
  getLayers() {
    return this._layers;
  }
  /**
   * Sets the given MRT node to setup MRT for this pass.
   *
   * @param {MRTNode} mrt - The MRT object.
   * @return {PassNode} A reference to this pass.
   */
  setMRT(mrt2) {
    this._mrt = mrt2;
    return this;
  }
  /**
   * Returns the current MRT node.
   *
   * @return {MRTNode} The current MRT node.
   */
  getMRT() {
    return this._mrt;
  }
  /**
   * Returns the texture for the given output name.
   *
   * @param {string} name - The output name to get the texture for.
   * @return {Texture} The texture.
   */
  getTexture(name) {
    let texture2 = this._textures[name];
    if (texture2 === void 0) {
      const refTexture = this.renderTarget.texture;
      texture2 = refTexture.clone();
      texture2.name = name;
      this._textures[name] = texture2;
      this.renderTarget.textures.push(texture2);
    }
    return texture2;
  }
  /**
   * Returns the texture holding the data of the previous frame for the given output name.
   *
   * @param {string} name - The output name to get the texture for.
   * @return {Texture} The texture holding the data of the previous frame.
   */
  getPreviousTexture(name) {
    let texture2 = this._previousTextures[name];
    if (texture2 === void 0) {
      texture2 = this.getTexture(name).clone();
      this._previousTextures[name] = texture2;
    }
    return texture2;
  }
  /**
   * Switches current and previous textures for the given output name.
   *
   * @param {string} name - The output name.
   */
  toggleTexture(name) {
    const prevTexture = this._previousTextures[name];
    if (prevTexture !== void 0) {
      const texture2 = this._textures[name];
      const index = this.renderTarget.textures.indexOf(texture2);
      this.renderTarget.textures[index] = prevTexture;
      this._textures[name] = prevTexture;
      this._previousTextures[name] = texture2;
      this._textureNodes[name].updateTexture();
      this._previousTextureNodes[name].updateTexture();
    }
  }
  /**
   * Returns the texture node for the given output name.
   *
   * @param {string} [name='output'] - The output name to get the texture node for.
   * @return {TextureNode} The texture node.
   */
  getTextureNode(name = "output") {
    let textureNode = this._textureNodes[name];
    if (textureNode === void 0) {
      textureNode = nodeObject(new PassMultipleTextureNode(this, name));
      textureNode.updateTexture();
      this._textureNodes[name] = textureNode;
    }
    return textureNode;
  }
  /**
   * Returns the previous texture node for the given output name.
   *
   * @param {string} [name='output'] - The output name to get the previous texture node for.
   * @return {TextureNode} The previous texture node.
   */
  getPreviousTextureNode(name = "output") {
    let textureNode = this._previousTextureNodes[name];
    if (textureNode === void 0) {
      if (this._textureNodes[name] === void 0) this.getTextureNode(name);
      textureNode = nodeObject(new PassMultipleTextureNode(this, name, true));
      textureNode.updateTexture();
      this._previousTextureNodes[name] = textureNode;
    }
    return textureNode;
  }
  /**
   * Returns a viewZ node of this pass.
   *
   * @param {string} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
   * @return {Node} The viewZ node.
   */
  getViewZNode(name = "depth") {
    let viewZNode = this._viewZNodes[name];
    if (viewZNode === void 0) {
      const cameraNear2 = this._cameraNear;
      const cameraFar2 = this._cameraFar;
      this._viewZNodes[name] = viewZNode = perspectiveDepthToViewZ(
        this.getTextureNode(name),
        cameraNear2,
        cameraFar2
      );
    }
    return viewZNode;
  }
  /**
   * Returns a linear depth node of this pass.
   *
   * @param {string} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
   * @return {Node} The linear depth node.
   */
  getLinearDepthNode(name = "depth") {
    let linearDepthNode = this._linearDepthNodes[name];
    if (linearDepthNode === void 0) {
      const cameraNear2 = this._cameraNear;
      const cameraFar2 = this._cameraFar;
      const viewZNode = this.getViewZNode(name);
      this._linearDepthNodes[name] = linearDepthNode = viewZToOrthographicDepth(
        viewZNode,
        cameraNear2,
        cameraFar2
      );
    }
    return linearDepthNode;
  }
  /**
   * Precompiles the pass.
   *
   * Note that this method must be called after the pass configuartion is complete.
   * So calls like `setMRT()` and `getTextureNode()` must proceed the precompilation.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the compile has been finished.
   * @see {@link Renderer#compileAsync}
   */
  async compileAsync(renderer2) {
    const currentRenderTarget = renderer2.getRenderTarget();
    const currentMRT = renderer2.getMRT();
    renderer2.setRenderTarget(this.renderTarget);
    renderer2.setMRT(this._mrt);
    await renderer2.compileAsync(this.scene, this.camera);
    renderer2.setRenderTarget(currentRenderTarget);
    renderer2.setMRT(currentMRT);
  }
  setup({ renderer: renderer2 }) {
    this.renderTarget.samples =
      this.options.samples === void 0
        ? renderer2.samples
        : this.options.samples;
    this.renderTarget.texture.type = renderer2.getColorBufferType();
    return this.scope === PassNode.COLOR
      ? this.getTextureNode()
      : this.getLinearDepthNode();
  }
  updateBefore(frame) {
    const { renderer: renderer2 } = frame;
    const { scene: scene2 } = this;
    let camera2;
    let pixelRatio;
    const outputRenderTarget = renderer2.getOutputRenderTarget();
    if (outputRenderTarget && outputRenderTarget.isXRRenderTarget === true) {
      pixelRatio = 1;
      camera2 = renderer2.xr.getCamera();
      renderer2.xr.updateCamera(camera2);
      _size.set(outputRenderTarget.width, outputRenderTarget.height);
    } else {
      camera2 = this.camera;
      pixelRatio = renderer2.getPixelRatio();
      renderer2.getSize(_size);
    }
    this._pixelRatio = pixelRatio;
    this.setSize(_size.width, _size.height);
    const currentRenderTarget = renderer2.getRenderTarget();
    const currentMRT = renderer2.getMRT();
    const currentMask = camera2.layers.mask;
    this._cameraNear.value = camera2.near;
    this._cameraFar.value = camera2.far;
    if (this._layers !== null) {
      camera2.layers.mask = this._layers.mask;
    }
    for (const name in this._previousTextures) {
      this.toggleTexture(name);
    }
    renderer2.setRenderTarget(this.renderTarget);
    renderer2.setMRT(this._mrt);
    renderer2.render(scene2, camera2);
    renderer2.setRenderTarget(currentRenderTarget);
    renderer2.setMRT(currentMRT);
    camera2.layers.mask = currentMask;
  }
  /**
   * Sets the size of the pass's render target. Honors the pixel ratio.
   *
   * @param {number} width - The width to set.
   * @param {number} height - The height to set.
   */
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = this._width * this._pixelRatio * this._resolution;
    const effectiveHeight = this._height * this._pixelRatio * this._resolution;
    this.renderTarget.setSize(effectiveWidth, effectiveHeight);
    if (this._scissor !== null) this.renderTarget.scissor.copy(this._scissor);
    if (this._viewport !== null)
      this.renderTarget.viewport.copy(this._viewport);
  }
  /**
   * This method allows to define the pass's scissor rectangle. By default, the scissor rectangle is kept
   * in sync with the pass's dimensions. To reverse the process and use auto-sizing again, call the method
   * with `null` as the single argument.
   *
   * @param {?(number | Vector4)} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
   * Instead of passing four arguments, the method also works with a single four-dimensional vector.
   * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
   * @param {number} width - The width of the scissor box in logical pixel unit.
   * @param {number} height - The height of the scissor box in logical pixel unit.
   */
  setScissor(x, y, width, height) {
    if (x === null) {
      this._scissor = null;
    } else {
      if (this._scissor === null) this._scissor = new Vector4();
      if (x.isVector4) {
        this._scissor.copy(x);
      } else {
        this._scissor.set(x, y, width, height);
      }
      this._scissor.multiplyScalar(this._pixelRatio * this._resolution).floor();
    }
  }
  /**
   * This method allows to define the pass's viewport. By default, the viewport is kept in sync
   * with the pass's dimensions. To reverse the process and use auto-sizing again, call the method
   * with `null` as the single argument.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
   * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
   * @param {number} width - The width of the viewport in logical pixel unit.
   * @param {number} height - The height of the viewport in logical pixel unit.
   */
  setViewport(x, y, width, height) {
    if (x === null) {
      this._viewport = null;
    } else {
      if (this._viewport === null) this._viewport = new Vector4();
      if (x.isVector4) {
        this._viewport.copy(x);
      } else {
        this._viewport.set(x, y, width, height);
      }
      this._viewport
        .multiplyScalar(this._pixelRatio * this._resolution)
        .floor();
    }
  }
  /**
   * Sets the pixel ratio the pass's render target and updates the size.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    this.renderTarget.dispose();
  }
}
PassNode.COLOR = "color";
PassNode.DEPTH = "depth";
const pass = (scene2, camera2, options) =>
  nodeObject(new PassNode(PassNode.COLOR, scene2, camera2, options));
const passTexture = (pass2, texture2) =>
  nodeObject(new PassTextureNode(pass2, texture2));
const depthPass = (scene2, camera2, options) =>
  nodeObject(new PassNode(PassNode.DEPTH, scene2, camera2, options));
class ToonOutlinePassNode extends PassNode {
  static get type() {
    return "ToonOutlinePassNode";
  }
  /**
   * Constructs a new outline pass node.
   *
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - A reference to the camera.
   * @param {Node} colorNode - Defines the outline's color.
   * @param {Node} thicknessNode - Defines the outline's thickness.
   * @param {Node} alphaNode - Defines the outline's alpha.
   */
  constructor(scene2, camera2, colorNode, thicknessNode, alphaNode) {
    super(PassNode.COLOR, scene2, camera2);
    this.colorNode = colorNode;
    this.thicknessNode = thicknessNode;
    this.alphaNode = alphaNode;
    this._materialCache = /* @__PURE__ */ new WeakMap();
  }
  updateBefore(frame) {
    const { renderer: renderer2 } = frame;
    const currentRenderObjectFunction = renderer2.getRenderObjectFunction();
    renderer2.setRenderObjectFunction(
      (
        object,
        scene2,
        camera2,
        geometry,
        material,
        group,
        lightsNode,
        clippingContext
      ) => {
        if (material.isMeshToonMaterial || material.isMeshToonNodeMaterial) {
          if (material.wireframe === false) {
            const outlineMaterial = this._getOutlineMaterial(material);
            renderer2.renderObject(
              object,
              scene2,
              camera2,
              geometry,
              outlineMaterial,
              group,
              lightsNode,
              clippingContext
            );
          }
        }
        renderer2.renderObject(
          object,
          scene2,
          camera2,
          geometry,
          material,
          group,
          lightsNode,
          clippingContext
        );
      }
    );
    super.updateBefore(frame);
    renderer2.setRenderObjectFunction(currentRenderObjectFunction);
  }
  /**
   * Creates the material used for outline rendering.
   *
   * @private
   * @return {NodeMaterial} The outline material.
   */
  _createMaterial() {
    const material = new NodeMaterial();
    material.isMeshToonOutlineMaterial = true;
    material.name = "Toon_Outline";
    material.side = BackSide;
    const outlineNormal = normalLocal.negate();
    const mvp = cameraProjectionMatrix.mul(modelViewMatrix);
    const ratio = float(1);
    const pos = mvp.mul(vec4(positionLocal$1, 1));
    const pos2 = mvp.mul(vec4(positionLocal$1.add(outlineNormal), 1));
    const norm = normalize(pos.sub(pos2));
    material.vertexNode = pos.add(
      norm.mul(this.thicknessNode).mul(pos.w).mul(ratio)
    );
    material.colorNode = vec4(this.colorNode, this.alphaNode);
    return material;
  }
  /**
   * For the given toon material, this method returns a corresponding
   * outline material.
   *
   * @private
   * @param {(MeshToonMaterial|MeshToonNodeMaterial)} originalMaterial - The toon material.
   * @return {NodeMaterial} The outline material.
   */
  _getOutlineMaterial(originalMaterial) {
    let outlineMaterial = this._materialCache.get(originalMaterial);
    if (outlineMaterial === void 0) {
      outlineMaterial = this._createMaterial();
      this._materialCache.set(originalMaterial, outlineMaterial);
    }
    return outlineMaterial;
  }
}
const toonOutlinePass = (
  scene2,
  camera2,
  color2 = new Color(0, 0, 0),
  thickness2 = 3e-3,
  alpha = 1
) =>
  nodeObject(
    new ToonOutlinePassNode(
      scene2,
      camera2,
      nodeObject(color2),
      nodeObject(thickness2),
      nodeObject(alpha)
    )
  );
const linearToneMapping = /* @__PURE__ */ Fn(([color2, exposure]) => {
  return color2.mul(exposure).clamp();
}).setLayout({
  name: "linearToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" },
  ],
});
const reinhardToneMapping = /* @__PURE__ */ Fn(([color2, exposure]) => {
  color2 = color2.mul(exposure);
  return color2.div(color2.add(1)).clamp();
}).setLayout({
  name: "reinhardToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" },
  ],
});
const cineonToneMapping = /* @__PURE__ */ Fn(([color2, exposure]) => {
  color2 = color2.mul(exposure);
  color2 = color2.sub(4e-3).max(0);
  const a2 = color2.mul(color2.mul(6.2).add(0.5));
  const b = color2.mul(color2.mul(6.2).add(1.7)).add(0.06);
  return a2.div(b).pow(2.2);
}).setLayout({
  name: "cineonToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" },
  ],
});
const RRTAndODTFit = /* @__PURE__ */ Fn(([color2]) => {
  const a2 = color2.mul(color2.add(0.0245786)).sub(90537e-9);
  const b = color2.mul(color2.add(0.432951).mul(0.983729)).add(0.238081);
  return a2.div(b);
});
const acesFilmicToneMapping = /* @__PURE__ */ Fn(([color2, exposure]) => {
  const ACESInputMat = mat3(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  );
  const ACESOutputMat = mat3(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  color2 = color2.mul(exposure).div(0.6);
  color2 = ACESInputMat.mul(color2);
  color2 = RRTAndODTFit(color2);
  color2 = ACESOutputMat.mul(color2);
  return color2.clamp();
}).setLayout({
  name: "acesFilmicToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" },
  ],
});
const LINEAR_REC2020_TO_LINEAR_SRGB = /* @__PURE__ */ mat3(
  vec3(1.6605, -0.1246, -0.0182),
  vec3(-0.5876, 1.1329, -0.1006),
  vec3(-0.0728, -83e-4, 1.1187)
);
const LINEAR_SRGB_TO_LINEAR_REC2020 = /* @__PURE__ */ mat3(
  vec3(0.6274, 0.0691, 0.0164),
  vec3(0.3293, 0.9195, 0.088),
  vec3(0.0433, 0.0113, 0.8956)
);
const agxDefaultContrastApprox = /* @__PURE__ */ Fn(([x_immutable]) => {
  const x = vec3(x_immutable).toVar();
  const x2 = vec3(x.mul(x)).toVar();
  const x4 = vec3(x2.mul(x2)).toVar();
  return float(15.5)
    .mul(x4.mul(x2))
    .sub(mul(40.14, x4.mul(x)))
    .add(
      mul(31.96, x4)
        .sub(mul(6.868, x2.mul(x)))
        .add(mul(0.4298, x2).add(mul(0.1191, x).sub(232e-5)))
    );
});
const agxToneMapping = /* @__PURE__ */ Fn(([color2, exposure]) => {
  const colortone = vec3(color2).toVar();
  const AgXInsetMatrix = mat3(
    vec3(0.856627153315983, 0.137318972929847, 0.11189821299995),
    vec3(0.0951212405381588, 0.761241990602591, 0.0767994186031903),
    vec3(0.0482516061458583, 0.101439036467562, 0.811302368396859)
  );
  const AgXOutsetMatrix = mat3(
    vec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826),
    vec3(-0.11060664309660323, 1.157823702216272, -0.11060664309660294),
    vec3(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405)
  );
  const AgxMinEv = float(-12.47393);
  const AgxMaxEv = float(4.026069);
  colortone.mulAssign(exposure);
  colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone));
  colortone.assign(AgXInsetMatrix.mul(colortone));
  colortone.assign(max$1(colortone, 1e-10));
  colortone.assign(log2(colortone));
  colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv)));
  colortone.assign(clamp(colortone, 0, 1));
  colortone.assign(agxDefaultContrastApprox(colortone));
  colortone.assign(AgXOutsetMatrix.mul(colortone));
  colortone.assign(pow(max$1(vec3(0), colortone), vec3(2.2)));
  colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone));
  colortone.assign(clamp(colortone, 0, 1));
  return colortone;
}).setLayout({
  name: "agxToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" },
  ],
});
const neutralToneMapping = /* @__PURE__ */ Fn(([color2, exposure]) => {
  const StartCompression = float(0.8 - 0.04);
  const Desaturation = float(0.15);
  color2 = color2.mul(exposure);
  const x = min$1(color2.r, min$1(color2.g, color2.b));
  const offset = select(x.lessThan(0.08), x.sub(mul(6.25, x.mul(x))), 0.04);
  color2.subAssign(offset);
  const peak = max$1(color2.r, max$1(color2.g, color2.b));
  If(peak.lessThan(StartCompression), () => {
    return color2;
  });
  const d2 = sub(1, StartCompression);
  const newPeak = sub(1, d2.mul(d2).div(peak.add(d2.sub(StartCompression))));
  color2.mulAssign(newPeak.div(peak));
  const g2 = sub(1, div(1, Desaturation.mul(peak.sub(newPeak)).add(1)));
  return mix$1(color2, vec3(newPeak), g2);
}).setLayout({
  name: "neutralToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" },
  ],
});
class CodeNode extends Node {
  static get type() {
    return "CodeNode";
  }
  /**
   * Constructs a new code node.
   *
   * @param {string} [code=''] - The native code.
   * @param {Array<Node>} [includes=[]] - An array of includes.
   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
   */
  constructor(code2 = "", includes = [], language = "") {
    super("code");
    this.isCodeNode = true;
    this.global = true;
    this.code = code2;
    this.includes = includes;
    this.language = language;
  }
  /**
   * Sets the includes of this code node.
   *
   * @param {Array<Node>} includes - The includes to set.
   * @return {CodeNode} A reference to this node.
   */
  setIncludes(includes) {
    this.includes = includes;
    return this;
  }
  /**
   * Returns the includes of this code node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Array<Node>} The includes.
   */
  getIncludes() {
    return this.includes;
  }
  generate(builder) {
    const includes = this.getIncludes(builder);
    for (const include of includes) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
  serialize(data) {
    super.serialize(data);
    data.code = this.code;
    data.language = this.language;
  }
  deserialize(data) {
    super.deserialize(data);
    this.code = data.code;
    this.language = data.language;
  }
}
const code = /* @__PURE__ */ nodeProxy(CodeNode).setParameterLength(1, 3);
const js = (src, includes) => code(src, includes, "js");
const wgsl = (src, includes) => code(src, includes, "wgsl");
const glsl = (src, includes) => code(src, includes, "glsl");
class FunctionNode extends CodeNode {
  static get type() {
    return "FunctionNode";
  }
  /**
   * Constructs a new function node.
   *
   * @param {string} [code=''] - The native code.
   * @param {Array<Node>} [includes=[]] - An array of includes.
   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
   */
  constructor(code2 = "", includes = [], language = "") {
    super(code2, includes, language);
  }
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  /**
   * Returns the inputs of this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Array<NodeFunctionInput>} The inputs.
   */
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  /**
   * Returns the node function for this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeFunction} The node function.
   */
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  generate(builder, output2) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    const code2 = this.getNodeFunction(builder).getCode(propertyName);
    nodeCode.code = code2 + "\n";
    if (output2 === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output2);
    }
  }
}
const nativeFn = (code2, includes = [], language = "") => {
  for (let i2 = 0; i2 < includes.length; i2++) {
    const include = includes[i2];
    if (typeof include === "function") {
      includes[i2] = include.functionNode;
    }
  }
  const functionNode = nodeObject(new FunctionNode(code2, includes, language));
  const fn = (...params) => functionNode.call(...params);
  fn.functionNode = functionNode;
  return fn;
};
const glslFn = (code2, includes) => nativeFn(code2, includes, "glsl");
const wgslFn = (code2, includes) => nativeFn(code2, includes, "wgsl");
class ScriptableValueNode extends Node {
  static get type() {
    return "ScriptableValueNode";
  }
  /**
   * Constructs a new scriptable node.
   *
   * @param {any} [value=null] - The value.
   */
  constructor(value = null) {
    super();
    this._value = value;
    this._cache = null;
    this.inputType = null;
    this.outputType = null;
    this.events = new EventDispatcher();
    this.isScriptableValueNode = true;
  }
  /**
   * Whether this node represents an output or not.
   *
   * @type {boolean}
   * @readonly
   * @default true
   */
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(val) {
    if (this._value === val) return;
    if (
      this._cache &&
      this.inputType === "URL" &&
      this.value.value instanceof ArrayBuffer
    ) {
      URL.revokeObjectURL(this._cache);
      this._cache = null;
    }
    this._value = val;
    this.events.dispatchEvent({ type: "change" });
    this.refresh();
  }
  /**
   * The node's value.
   *
   * @type {any}
   */
  get value() {
    return this._value;
  }
  /**
   * Dispatches the `refresh` event.
   */
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  /**
   * The `value` property usually represents a node or even binary data in form of array buffers.
   * In this case, this method tries to return the actual value behind the complex type.
   *
   * @return {any} The value.
   */
  getValue() {
    const value = this.value;
    if (
      value &&
      this._cache === null &&
      this.inputType === "URL" &&
      value.value instanceof ArrayBuffer
    ) {
      this._cache = URL.createObjectURL(new Blob([value.value]));
    } else if (
      value &&
      value.value !== null &&
      value.value !== void 0 &&
      (((this.inputType === "URL" || this.inputType === "String") &&
        typeof value.value === "string") ||
        (this.inputType === "Number" && typeof value.value === "number") ||
        (this.inputType === "Vector2" && value.value.isVector2) ||
        (this.inputType === "Vector3" && value.value.isVector3) ||
        (this.inputType === "Vector4" && value.value.isVector4) ||
        (this.inputType === "Color" && value.value.isColor) ||
        (this.inputType === "Matrix3" && value.value.isMatrix3) ||
        (this.inputType === "Matrix4" && value.value.isMatrix4))
    ) {
      return value.value;
    }
    return this._cache || value;
  }
  /**
   * Overwritten since the node type is inferred from the value.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.value && this.value.isNode
      ? this.value.getNodeType(builder)
      : "float";
  }
  setup() {
    return this.value && this.value.isNode ? this.value : float();
  }
  serialize(data) {
    super.serialize(data);
    if (this.value !== null) {
      if (this.inputType === "ArrayBuffer") {
        data.value = arrayBufferToBase64(this.value);
      } else {
        data.value = this.value ? this.value.toJSON(data.meta).uuid : null;
      }
    } else {
      data.value = null;
    }
    data.inputType = this.inputType;
    data.outputType = this.outputType;
  }
  deserialize(data) {
    super.deserialize(data);
    let value = null;
    if (data.value !== null) {
      if (data.inputType === "ArrayBuffer") {
        value = base64ToArrayBuffer(data.value);
      } else if (data.inputType === "Texture") {
        value = data.meta.textures[data.value];
      } else {
        value = data.meta.nodes[data.value] || null;
      }
    }
    this.value = value;
    this.inputType = data.inputType;
    this.outputType = data.outputType;
  }
}
const scriptableValue =
  /* @__PURE__ */ nodeProxy(ScriptableValueNode).setParameterLength(1);
class Resources extends Map {
  get(key, callback = null, ...params) {
    if (this.has(key)) return super.get(key);
    if (callback !== null) {
      const value = callback(...params);
      this.set(key, value);
      return value;
    }
  }
}
class Parameters {
  constructor(scriptableNode) {
    this.scriptableNode = scriptableNode;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(id) {
    return this.scriptableNode.getInputLayout(id);
  }
  get(name) {
    const param = this.parameters[name];
    const value = param ? param.getValue() : null;
    return value;
  }
}
const ScriptableNodeResources = new Resources();
class ScriptableNode extends Node {
  static get type() {
    return "ScriptableNode";
  }
  /**
   * Constructs a new scriptable node.
   *
   * @param {?CodeNode} [codeNode=null] - The code node.
   * @param {Object} [parameters={}] - The parameters definition.
   */
  constructor(codeNode = null, parameters = {}) {
    super();
    this.codeNode = codeNode;
    this.parameters = parameters;
    this._local = new Resources();
    this._output = scriptableValue(null);
    this._outputs = {};
    this._source = this.source;
    this._method = null;
    this._object = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this.onRefresh = this.onRefresh.bind(this);
    this.isScriptableNode = true;
  }
  /**
   * The source code of the scriptable node.
   *
   * @type {string}
   */
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  /**
   * Sets the reference of a local script variable.
   *
   * @param {string} name - The variable name.
   * @param {Object} value - The reference to set.
   * @return {Resources} The resource map
   */
  setLocal(name, value) {
    return this._local.set(name, value);
  }
  /**
   * Gets the value of a local script variable.
   *
   * @param {string} name - The variable name.
   * @return {Object} The value.
   */
  getLocal(name) {
    return this._local.get(name);
  }
  /**
   * Event listener for the `refresh` event.
   */
  onRefresh() {
    this._refresh();
  }
  /**
   * Returns an input from the layout with the given id/name.
   *
   * @param {string} id - The id/name of the input.
   * @return {Object} The element entry.
   */
  getInputLayout(id) {
    for (const element2 of this.getLayout()) {
      if (element2.inputType && (element2.id === id || element2.name === id)) {
        return element2;
      }
    }
  }
  /**
   * Returns an output from the layout with the given id/name.
   *
   * @param {string} id - The id/name of the output.
   * @return {Object} The element entry.
   */
  getOutputLayout(id) {
    for (const element2 of this.getLayout()) {
      if (element2.outputType && (element2.id === id || element2.name === id)) {
        return element2;
      }
    }
  }
  /**
   * Defines a script output for the given name and value.
   *
   * @param {string} name - The name of the output.
   * @param {Node} value - The node value.
   * @return {ScriptableNode} A reference to this node.
   */
  setOutput(name, value) {
    const outputs = this._outputs;
    if (outputs[name] === void 0) {
      outputs[name] = scriptableValue(value);
    } else {
      outputs[name].value = value;
    }
    return this;
  }
  /**
   * Returns a script output for the given name.
   *
   * @param {string} name - The name of the output.
   * @return {ScriptableValueNode} The node value.
   */
  getOutput(name) {
    return this._outputs[name];
  }
  /**
   * Returns a parameter for the given name
   *
   * @param {string} name - The name of the parameter.
   * @return {ScriptableValueNode} The node value.
   */
  getParameter(name) {
    return this.parameters[name];
  }
  /**
   * Sets a value for the given parameter name.
   *
   * @param {string} name - The parameter name.
   * @param {any} value - The parameter value.
   * @return {ScriptableNode} A reference to this node.
   */
  setParameter(name, value) {
    const parameters = this.parameters;
    if (value && value.isScriptableNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name]
        .getDefaultOutput()
        .events.addEventListener("refresh", this.onRefresh);
    } else if (value && value.isScriptableValueNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else if (parameters[name] === void 0) {
      parameters[name] = scriptableValue(value);
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else {
      parameters[name].value = value;
    }
    return this;
  }
  /**
   * Returns the value of this node which is the value of
   * the default output.
   *
   * @return {Node} The value.
   */
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  /**
   * Deletes a parameter from the script.
   *
   * @param {string} name - The parameter to remove.
   * @return {ScriptableNode} A reference to this node.
   */
  deleteParameter(name) {
    let valueNode = this.parameters[name];
    if (valueNode) {
      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
      valueNode.events.removeEventListener("refresh", this.onRefresh);
    }
    return this;
  }
  /**
   * Deletes all parameters from the script.
   *
   * @return {ScriptableNode} A reference to this node.
   */
  clearParameters() {
    for (const name of Object.keys(this.parameters)) {
      this.deleteParameter(name);
    }
    this.needsUpdate = true;
    return this;
  }
  /**
   * Calls a function from the script.
   *
   * @param {string} name - The function name.
   * @param {...any} params - A list of parameters.
   * @return {any} The result of the function call.
   */
  call(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method(...params);
    }
  }
  /**
   * Asynchronously calls a function from the script.
   *
   * @param {string} name - The function name.
   * @param {...any} params - A list of parameters.
   * @return {Promise<any>} The result of the function call.
   */
  async callAsync(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method.constructor.name === "AsyncFunction"
        ? await method(...params)
        : method(...params);
    }
  }
  /**
   * Overwritten since the node types is inferred from the script's output.
   *
   * @param {NodeBuilder} builder - The current node builder
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.getDefaultOutputNode().getNodeType(builder);
  }
  /**
   * Refreshes the script node.
   *
   * @param {?string} [output=null] - An optional output.
   */
  refresh(output2 = null) {
    if (output2 !== null) {
      this.getOutput(output2).refresh();
    } else {
      this._refresh();
    }
  }
  /**
   * Returns an object representation of the script.
   *
   * @return {Object} The result object.
   */
  getObject() {
    if (this.needsUpdate) this.dispose();
    if (this._object !== null) return this._object;
    const refresh = () => this.refresh();
    const setOutput = (id, value) => this.setOutput(id, value);
    const parameters = new Parameters(this);
    const THREE = ScriptableNodeResources.get("THREE");
    const TSL2 = ScriptableNodeResources.get("TSL");
    const method = this.getMethod();
    const params = [
      parameters,
      this._local,
      ScriptableNodeResources,
      refresh,
      setOutput,
      THREE,
      TSL2,
    ];
    this._object = method(...params);
    const layout = this._object.layout;
    if (layout) {
      if (layout.cache === false) {
        this._local.clear();
      }
      this._output.outputType = layout.outputType || null;
      if (Array.isArray(layout.elements)) {
        for (const element2 of layout.elements) {
          const id = element2.id || element2.name;
          if (element2.inputType) {
            if (this.getParameter(id) === void 0) this.setParameter(id, null);
            this.getParameter(id).inputType = element2.inputType;
          }
          if (element2.outputType) {
            if (this.getOutput(id) === void 0) this.setOutput(id, null);
            this.getOutput(id).outputType = element2.outputType;
          }
        }
      }
    }
    return this._object;
  }
  deserialize(data) {
    super.deserialize(data);
    for (const name in this.parameters) {
      let valueNode = this.parameters[name];
      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
      valueNode.events.addEventListener("refresh", this.onRefresh);
    }
  }
  /**
   * Returns the layout of the script.
   *
   * @return {Object} The script's layout.
   */
  getLayout() {
    return this.getObject().layout;
  }
  /**
   * Returns default node output of the script.
   *
   * @return {Node} The default node output.
   */
  getDefaultOutputNode() {
    const output2 = this.getDefaultOutput().value;
    if (output2 && output2.isNode) {
      return output2;
    }
    return float();
  }
  /**
   * Returns default output of the script.
   *
   * @return {ScriptableValueNode} The default output.
   */
  getDefaultOutput() {
    return this._exec()._output;
  }
  /**
   * Returns a function created from the node's script.
   *
   * @return {Function} The function representing the node's code.
   */
  getMethod() {
    if (this.needsUpdate) this.dispose();
    if (this._method !== null) return this._method;
    const parametersProps = [
      "parameters",
      "local",
      "global",
      "refresh",
      "setOutput",
      "THREE",
      "TSL",
    ];
    const interfaceProps = ["layout", "init", "main", "dispose"];
    const properties = interfaceProps.join(", ");
    const declarations = "var " + properties + "; var output = {};\n";
    const returns = "\nreturn { ...output, " + properties + " };";
    const code2 = declarations + this.codeNode.code + returns;
    this._method = new Function(...parametersProps, code2);
    return this._method;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    if (this._method === null) return;
    if (this._object && typeof this._object.dispose === "function") {
      this._object.dispose();
    }
    this._method = null;
    this._object = null;
    this._source = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this._output.value = null;
    this._outputs = {};
  }
  setup() {
    return this.getDefaultOutputNode();
  }
  getCacheKey(force) {
    const values = [
      hashString(this.source),
      this.getDefaultOutputNode().getCacheKey(force),
    ];
    for (const param in this.parameters) {
      values.push(this.parameters[param].getCacheKey(force));
    }
    return hashArray(values);
  }
  set needsUpdate(value) {
    if (value === true) this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  /**
   * Executes the `main` function of the script.
   *
   * @private
   * @return {ScriptableNode} A reference to this node.
   */
  _exec() {
    if (this.codeNode === null) return this;
    if (this._needsOutputUpdate === true) {
      this._value = this.call("main");
      this._needsOutputUpdate = false;
    }
    this._output.value = this._value;
    return this;
  }
  /**
   * Executes the refresh.
   *
   * @private
   */
  _refresh() {
    this.needsUpdate = true;
    this._exec();
    this._output.refresh();
  }
}
const scriptable = /* @__PURE__ */ nodeProxy(ScriptableNode).setParameterLength(
  1,
  2
);
function getViewZNode(builder) {
  let viewZ;
  const getViewZ = builder.context.getViewZ;
  if (getViewZ !== void 0) {
    viewZ = getViewZ(this);
  }
  return (viewZ || positionView.z).negate();
}
const rangeFogFactor = Fn(([near, far], builder) => {
  const viewZ = getViewZNode(builder);
  return smoothstep(near, far, viewZ);
});
const densityFogFactor = Fn(([density], builder) => {
  const viewZ = getViewZNode(builder);
  return density.mul(density, viewZ, viewZ).negate().exp().oneMinus();
});
const fog = Fn(([color2, factor]) => {
  return vec4(factor.toFloat().mix(output.rgb, color2.toVec3()), output.a);
});
function rangeFog(color2, near, far) {
  console.warn(
    'THREE.TSL: "rangeFog( color, near, far )" is deprecated. Use "fog( color, rangeFogFactor( near, far ) )" instead.'
  );
  return fog(color2, rangeFogFactor(near, far));
}
function densityFog(color2, density) {
  console.warn(
    'THREE.TSL: "densityFog( color, density )" is deprecated. Use "fog( color, densityFogFactor( density ) )" instead.'
  );
  return fog(color2, densityFogFactor(density));
}
let min = null;
let max = null;
class RangeNode extends Node {
  static get type() {
    return "RangeNode";
  }
  /**
   * Constructs a new range node.
   *
   * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.
   * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.
   */
  constructor(minNode = float(), maxNode = float()) {
    super();
    this.minNode = minNode;
    this.maxNode = maxNode;
  }
  /**
   * Returns the vector length which is computed based on the range definition.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {number} The vector length.
   */
  getVectorLength(builder) {
    const minLength = builder.getTypeLength(getValueType(this.minNode.value));
    const maxLength = builder.getTypeLength(getValueType(this.maxNode.value));
    return minLength > maxLength ? minLength : maxLength;
  }
  /**
   * This method is overwritten since the node type is inferred from range definition.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return builder.object.count > 1
      ? builder.getTypeFromLength(this.getVectorLength(builder))
      : "float";
  }
  setup(builder) {
    const object = builder.object;
    let output2 = null;
    if (object.count > 1) {
      const minValue = this.minNode.value;
      const maxValue = this.maxNode.value;
      const minLength = builder.getTypeLength(getValueType(minValue));
      const maxLength = builder.getTypeLength(getValueType(maxValue));
      min = min || new Vector4();
      max = max || new Vector4();
      min.setScalar(0);
      max.setScalar(0);
      if (minLength === 1) min.setScalar(minValue);
      else if (minValue.isColor) min.set(minValue.r, minValue.g, minValue.b, 1);
      else min.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);
      if (maxLength === 1) max.setScalar(maxValue);
      else if (maxValue.isColor) max.set(maxValue.r, maxValue.g, maxValue.b, 1);
      else max.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);
      const stride = 4;
      const length2 = stride * object.count;
      const array2 = new Float32Array(length2);
      for (let i2 = 0; i2 < length2; i2++) {
        const index = i2 % stride;
        const minElementValue = min.getComponent(index);
        const maxElementValue = max.getComponent(index);
        array2[i2] = MathUtils.lerp(
          minElementValue,
          maxElementValue,
          Math.random()
        );
      }
      const nodeType = this.getNodeType(builder);
      if (object.count <= 4096) {
        output2 = buffer(array2, "vec4", object.count)
          .element(instanceIndex)
          .convert(nodeType);
      } else {
        const bufferAttribute2 = new InstancedBufferAttribute(array2, 4);
        builder.geometry.setAttribute("__range" + this.id, bufferAttribute2);
        output2 = instancedBufferAttribute(bufferAttribute2).convert(nodeType);
      }
    } else {
      output2 = float(0);
    }
    return output2;
  }
}
const range$1 = /* @__PURE__ */ nodeProxy(RangeNode).setParameterLength(2);
class ComputeBuiltinNode extends Node {
  static get type() {
    return "ComputeBuiltinNode";
  }
  /**
   * Constructs a new compute builtin node.
   *
   * @param {string} builtinName - The built-in name.
   * @param {string} nodeType - The node type.
   */
  constructor(builtinName, nodeType) {
    super(nodeType);
    this._builtinName = builtinName;
  }
  /**
   * This method is overwritten since hash is derived from the built-in name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(builder) {
    return this.getBuiltinName(builder);
  }
  /**
   * This method is overwritten since the node type is simply derived from `nodeType`..
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.nodeType;
  }
  /**
   * Sets the builtin name.
   *
   * @param {string} builtinName - The built-in name.
   * @return {ComputeBuiltinNode} A reference to this node.
   */
  setBuiltinName(builtinName) {
    this._builtinName = builtinName;
    return this;
  }
  /**
   * Returns the builtin name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The builtin name.
   */
  getBuiltinName() {
    return this._builtinName;
  }
  /**
   * Whether the current node builder has the builtin or not.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether the builder has the builtin or not.
   */
  hasBuiltin(builder) {
    return builder.hasBuiltin(this._builtinName);
  }
  generate(builder, output2) {
    const builtinName = this.getBuiltinName(builder);
    const nodeType = this.getNodeType(builder);
    if (builder.shaderStage === "compute") {
      return builder.format(builtinName, nodeType, output2);
    } else {
      console.warn(
        `ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage`
      );
      return builder.generateConst(nodeType);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.global = this.global;
    data._builtinName = this._builtinName;
  }
  deserialize(data) {
    super.deserialize(data);
    this.global = data.global;
    this._builtinName = data._builtinName;
  }
}
const computeBuiltin = (name, nodeType) =>
  nodeObject(new ComputeBuiltinNode(name, nodeType));
const numWorkgroups = /* @__PURE__ */ computeBuiltin("numWorkgroups", "uvec3");
const workgroupId = /* @__PURE__ */ computeBuiltin("workgroupId", "uvec3");
const globalId = /* @__PURE__ */ computeBuiltin("globalId", "uvec3");
const localId = /* @__PURE__ */ computeBuiltin("localId", "uvec3");
const subgroupSize = /* @__PURE__ */ computeBuiltin("subgroupSize", "uint");
class BarrierNode extends Node {
  /**
   * Constructs a new barrier node.
   *
   * @param {string} scope - The scope defines the behavior of the node.
   */
  constructor(scope) {
    super();
    this.scope = scope;
  }
  generate(builder) {
    const { scope } = this;
    const { renderer: renderer2 } = builder;
    if (renderer2.backend.isWebGLBackend === true) {
      builder.addFlowCode(`	// ${scope}Barrier 
`);
    } else {
      builder.addLineFlowCode(`${scope}Barrier()`, this);
    }
  }
}
const barrier = nodeProxy(BarrierNode);
const workgroupBarrier = () => barrier("workgroup").toStack();
const storageBarrier = () => barrier("storage").toStack();
const textureBarrier = () => barrier("texture").toStack();
class WorkgroupInfoElementNode extends ArrayElementNode {
  /**
   * Constructs a new workgroup info element node.
   *
   * @param {Node} workgroupInfoNode - The workgroup info node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(workgroupInfoNode, indexNode) {
    super(workgroupInfoNode, indexNode);
    this.isWorkgroupInfoElementNode = true;
  }
  generate(builder, output2) {
    let snippet;
    const isAssignContext = builder.context.assign;
    snippet = super.generate(builder);
    if (isAssignContext !== true) {
      const type = this.getNodeType(builder);
      snippet = builder.format(snippet, type, output2);
    }
    return snippet;
  }
}
class WorkgroupInfoNode extends Node {
  /**
   * Constructs a new buffer scoped to type scope.
   *
   * @param {string} scope - TODO.
   * @param {string} bufferType - The data type of a 'workgroup' scoped buffer element.
   * @param {number} [bufferCount=0] - The number of elements in the buffer.
   */
  constructor(scope, bufferType, bufferCount = 0) {
    super(bufferType);
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
    this.isWorkgroupInfoNode = true;
    this.elementType = bufferType;
    this.scope = scope;
    this.name = "";
  }
  /**
   * Sets the name of this node.
   *
   * @param {string} name - The name to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the name/label of this node.
   *
   * @deprecated
   * @param {string} name - The name to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  label(name) {
    console.warn(
      'THREE.TSL: "label()" has been deprecated. Use "setName()" instead.'
    );
    return this.setName(name);
  }
  /**
   * Sets the scope of this node.
   *
   * @param {string} scope - The scope to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  setScope(scope) {
    this.scope = scope;
    return this;
  }
  /**
   * The data type of the array buffer.
   *
   * @return {string} The element type.
   */
  getElementType() {
    return this.elementType;
  }
  /**
   * Overwrites the default implementation since the input type
   * is inferred from the scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return `${this.scope}Array`;
  }
  /**
   * This method can be used to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {WorkgroupInfoElementNode} A reference to an element.
   */
  element(indexNode) {
    return nodeObject(new WorkgroupInfoElementNode(this, indexNode));
  }
  generate(builder) {
    const name = this.name !== "" ? this.name : `${this.scope}Array_${this.id}`;
    return builder.getScopedArray(
      name,
      this.scope.toLowerCase(),
      this.bufferType,
      this.bufferCount
    );
  }
}
const workgroupArray = (type, count) =>
  nodeObject(new WorkgroupInfoNode("Workgroup", type, count));
class AtomicFunctionNode extends Node {
  static get type() {
    return "AtomicFunctionNode";
  }
  /**
   * Constructs a new atomic function node.
   *
   * @param {string} method - The signature of the atomic function to construct.
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   */
  constructor(method, pointerNode, valueNode) {
    super("uint");
    this.method = method;
    this.pointerNode = pointerNode;
    this.valueNode = valueNode;
    this.parents = true;
  }
  /**
   * Overwrites the default implementation to return the type of
   * the pointer node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(builder) {
    return this.pointerNode.getNodeType(builder);
  }
  /**
   * Overwritten since the node type is inferred from the input type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.getInputType(builder);
  }
  generate(builder) {
    const properties = builder.getNodeProperties(this);
    const parents = properties.parents;
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a2 = this.pointerNode;
    const b = this.valueNode;
    const params = [];
    params.push(`&${a2.build(builder, inputType)}`);
    if (b !== null) {
      params.push(b.build(builder, inputType));
    }
    const methodSnippet = `${builder.getMethod(method, type)}( ${params.join(
      ", "
    )} )`;
    const isVoid = parents
      ? parents.length === 1 && parents[0].isStackNode === true
      : false;
    if (isVoid) {
      builder.addLineFlowCode(methodSnippet, this);
    } else {
      if (properties.constNode === void 0) {
        properties.constNode = expression(methodSnippet, type).toConst();
      }
      return properties.constNode.build(builder);
    }
  }
}
AtomicFunctionNode.ATOMIC_LOAD = "atomicLoad";
AtomicFunctionNode.ATOMIC_STORE = "atomicStore";
AtomicFunctionNode.ATOMIC_ADD = "atomicAdd";
AtomicFunctionNode.ATOMIC_SUB = "atomicSub";
AtomicFunctionNode.ATOMIC_MAX = "atomicMax";
AtomicFunctionNode.ATOMIC_MIN = "atomicMin";
AtomicFunctionNode.ATOMIC_AND = "atomicAnd";
AtomicFunctionNode.ATOMIC_OR = "atomicOr";
AtomicFunctionNode.ATOMIC_XOR = "atomicXor";
const atomicNode = nodeProxy(AtomicFunctionNode);
const atomicFunc = (method, pointerNode, valueNode) => {
  return atomicNode(method, pointerNode, valueNode).toStack();
};
const atomicLoad = (pointerNode) =>
  atomicFunc(AtomicFunctionNode.ATOMIC_LOAD, pointerNode, null);
const atomicStore = (pointerNode, valueNode) =>
  atomicFunc(AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode);
const atomicAdd = (pointerNode, valueNode) =>
  atomicFunc(AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode);
const atomicSub = (pointerNode, valueNode) =>
  atomicFunc(AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode);
const atomicMax = (pointerNode, valueNode) =>
  atomicFunc(AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode);
const atomicMin = (pointerNode, valueNode) =>
  atomicFunc(AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode);
const atomicAnd = (pointerNode, valueNode) =>
  atomicFunc(AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode);
const atomicOr = (pointerNode, valueNode) =>
  atomicFunc(AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode);
const atomicXor = (pointerNode, valueNode) =>
  atomicFunc(AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode);
let uniformsLib;
function getLightData(light) {
  uniformsLib = uniformsLib || /* @__PURE__ */ new WeakMap();
  let uniforms = uniformsLib.get(light);
  if (uniforms === void 0) uniformsLib.set(light, (uniforms = {}));
  return uniforms;
}
function lightShadowMatrix(light) {
  const data = getLightData(light);
  return (
    data.shadowMatrix ||
    (data.shadowMatrix = uniform$1("mat4")
      .setGroup(renderGroup)
      .onRenderUpdate((frame) => {
        if (
          light.castShadow !== true ||
          frame.renderer.shadowMap.enabled === false
        ) {
          light.shadow.updateMatrices(light);
        }
        return light.shadow.matrix;
      }))
  );
}
function lightProjectionUV(light, position = positionWorld) {
  const spotLightCoord = lightShadowMatrix(light).mul(position);
  const projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);
  return projectionUV;
}
function lightPosition(light) {
  const data = getLightData(light);
  return (
    data.position ||
    (data.position = uniform$1(new Vector3())
      .setGroup(renderGroup)
      .onRenderUpdate((_, self2) =>
        self2.value.setFromMatrixPosition(light.matrixWorld)
      ))
  );
}
function lightTargetPosition(light) {
  const data = getLightData(light);
  return (
    data.targetPosition ||
    (data.targetPosition = uniform$1(new Vector3())
      .setGroup(renderGroup)
      .onRenderUpdate((_, self2) =>
        self2.value.setFromMatrixPosition(light.target.matrixWorld)
      ))
  );
}
function lightViewPosition(light) {
  const data = getLightData(light);
  return (
    data.viewPosition ||
    (data.viewPosition = uniform$1(new Vector3())
      .setGroup(renderGroup)
      .onRenderUpdate(({ camera: camera2 }, self2) => {
        self2.value = self2.value || new Vector3();
        self2.value.setFromMatrixPosition(light.matrixWorld);
        self2.value.applyMatrix4(camera2.matrixWorldInverse);
      }))
  );
}
const lightTargetDirection = (light) =>
  cameraViewMatrix.transformDirection(
    lightPosition(light).sub(lightTargetPosition(light))
  );
const sortLights = (lights2) => {
  return lights2.sort((a2, b) => a2.id - b.id);
};
const getLightNodeById = (id, lightNodes) => {
  for (const lightNode of lightNodes) {
    if (lightNode.isAnalyticLightNode && lightNode.light.id === id) {
      return lightNode;
    }
  }
  return null;
};
const _lightsNodeRef = /* @__PURE__ */ new WeakMap();
const _hashData = [];
class LightsNode extends Node {
  static get type() {
    return "LightsNode";
  }
  /**
   * Constructs a new lights node.
   */
  constructor() {
    super("vec3");
    this.totalDiffuseNode = property("vec3", "totalDiffuse");
    this.totalSpecularNode = property("vec3", "totalSpecular");
    this.outgoingLightNode = property("vec3", "outgoingLight");
    this._lights = [];
    this._lightNodes = null;
    this._lightNodesHash = null;
    this.global = true;
  }
  /**
   * Overwrites the default {@link Node#customCacheKey} implementation by including
   * light data into the cache key.
   *
   * @return {number} The custom cache key.
   */
  customCacheKey() {
    const lights2 = this._lights;
    for (let i2 = 0; i2 < lights2.length; i2++) {
      const light = lights2[i2];
      _hashData.push(light.id);
      _hashData.push(light.castShadow ? 1 : 0);
      if (light.isSpotLight === true) {
        const hashMap = light.map !== null ? light.map.id : -1;
        const hashColorNode = light.colorNode
          ? light.colorNode.getCacheKey()
          : -1;
        _hashData.push(hashMap, hashColorNode);
      }
    }
    const cacheKey = hashArray(_hashData);
    _hashData.length = 0;
    return cacheKey;
  }
  /**
   * Computes a hash value for identifying the current light nodes setup.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {string} The computed hash.
   */
  getHash(builder) {
    if (this._lightNodesHash === null) {
      if (this._lightNodes === null) this.setupLightsNode(builder);
      const hash2 = [];
      for (const lightNode of this._lightNodes) {
        hash2.push(lightNode.getSelf().getHash());
      }
      this._lightNodesHash = "lights-" + hash2.join(",");
    }
    return this._lightNodesHash;
  }
  analyze(builder) {
    const properties = builder.getNodeProperties(this);
    for (const node of properties.nodes) {
      node.build(builder);
    }
    properties.outputNode.build(builder);
  }
  /**
   * Creates lighting nodes for each scene light. This makes it possible to further
   * process lights in the node system.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   */
  setupLightsNode(builder) {
    const lightNodes = [];
    const previousLightNodes = this._lightNodes;
    const lights2 = sortLights(this._lights);
    const nodeLibrary = builder.renderer.library;
    for (const light of lights2) {
      if (light.isNode) {
        lightNodes.push(nodeObject(light));
      } else {
        let lightNode = null;
        if (previousLightNodes !== null) {
          lightNode = getLightNodeById(light.id, previousLightNodes);
        }
        if (lightNode === null) {
          const lightNodeClass = nodeLibrary.getLightNodeClass(
            light.constructor
          );
          if (lightNodeClass === null) {
            console.warn(
              `LightsNode.setupNodeLights: Light node not found for ${light.constructor.name}`
            );
            continue;
          }
          let lightNode2 = null;
          if (!_lightsNodeRef.has(light)) {
            lightNode2 = nodeObject(new lightNodeClass(light));
            _lightsNodeRef.set(light, lightNode2);
          } else {
            lightNode2 = _lightsNodeRef.get(light);
          }
          lightNodes.push(lightNode2);
        }
      }
    }
    this._lightNodes = lightNodes;
  }
  /**
   * Sets up a direct light in the lighting model.
   *
   * @param {Object} builder - The builder object containing the context and stack.
   * @param {Object} lightNode - The light node.
   * @param {Object} lightData - The light object containing color and direction properties.
   */
  setupDirectLight(builder, lightNode, lightData) {
    const { lightingModel, reflectedLight } = builder.context;
    lightingModel.direct(
      {
        ...lightData,
        lightNode,
        reflectedLight,
      },
      builder
    );
  }
  setupDirectRectAreaLight(builder, lightNode, lightData) {
    const { lightingModel, reflectedLight } = builder.context;
    lightingModel.directRectArea(
      {
        ...lightData,
        lightNode,
        reflectedLight,
      },
      builder
    );
  }
  /**
   * Setups the internal lights by building all respective
   * light nodes.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Array<LightingNode>} lightNodes - An array of lighting nodes.
   */
  setupLights(builder, lightNodes) {
    for (const lightNode of lightNodes) {
      lightNode.build(builder);
    }
  }
  getLightNodes(builder) {
    if (this._lightNodes === null) this.setupLightsNode(builder);
    return this._lightNodes;
  }
  /**
   * The implementation makes sure that for each light in the scene
   * there is a corresponding light node. By building the light nodes
   * and evaluating the lighting model the outgoing light is computed.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec3>} A node representing the outgoing light.
   */
  setup(builder) {
    const currentLightsNode = builder.lightsNode;
    builder.lightsNode = this;
    let outgoingLightNode = this.outgoingLightNode;
    const context2 = builder.context;
    const lightingModel = context2.lightingModel;
    const properties = builder.getNodeProperties(this);
    if (lightingModel) {
      const { totalDiffuseNode, totalSpecularNode } = this;
      context2.outgoingLight = outgoingLightNode;
      const stack2 = builder.addStack();
      properties.nodes = stack2.nodes;
      lightingModel.start(builder);
      const { backdrop, backdropAlpha } = context2;
      const {
        directDiffuse,
        directSpecular,
        indirectDiffuse,
        indirectSpecular,
      } = context2.reflectedLight;
      let totalDiffuse = directDiffuse.add(indirectDiffuse);
      if (backdrop !== null) {
        if (backdropAlpha !== null) {
          totalDiffuse = vec3(backdropAlpha.mix(totalDiffuse, backdrop));
        } else {
          totalDiffuse = vec3(backdrop);
        }
        context2.material.transparent = true;
      }
      totalDiffuseNode.assign(totalDiffuse);
      totalSpecularNode.assign(directSpecular.add(indirectSpecular));
      outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));
      lightingModel.finish(builder);
      outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());
    } else {
      properties.nodes = [];
    }
    builder.lightsNode = currentLightsNode;
    return outgoingLightNode;
  }
  /**
   * Configures this node with an array of lights.
   *
   * @param {Array<Light>} lights - An array of lights.
   * @return {LightsNode} A reference to this node.
   */
  setLights(lights2) {
    this._lights = lights2;
    this._lightNodes = null;
    this._lightNodesHash = null;
    return this;
  }
  /**
   * Returns an array of the scene's lights.
   *
   * @return {Array<Light>} The scene's lights.
   */
  getLights() {
    return this._lights;
  }
  /**
   * Whether the scene has lights or not.
   *
   * @type {boolean}
   */
  get hasLights() {
    return this._lights.length > 0;
  }
}
const lights = (lights2 = []) =>
  nodeObject(new LightsNode()).setLights(lights2);
class ShadowBaseNode extends Node {
  static get type() {
    return "ShadowBaseNode";
  }
  /**
   * Constructs a new shadow base node.
   *
   * @param {Light} light - The shadow casting light.
   */
  constructor(light) {
    super();
    this.light = light;
    this.updateBeforeType = NodeUpdateType.RENDER;
    this.isShadowBaseNode = true;
  }
  /**
   * Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.
   *
   * @param {NodeBuilder} object - A configuration object that must at least hold a material reference.
   */
  setupShadowPosition({ context: context2, material }) {
    shadowPositionWorld.assign(
      material.receivedShadowPositionNode ||
        context2.shadowPositionWorld ||
        positionWorld
    );
  }
}
const shadowPositionWorld = /* @__PURE__ */ property(
  "vec3",
  "shadowPositionWorld"
);
function saveRendererState(renderer2, state = {}) {
  state.toneMapping = renderer2.toneMapping;
  state.toneMappingExposure = renderer2.toneMappingExposure;
  state.outputColorSpace = renderer2.outputColorSpace;
  state.renderTarget = renderer2.getRenderTarget();
  state.activeCubeFace = renderer2.getActiveCubeFace();
  state.activeMipmapLevel = renderer2.getActiveMipmapLevel();
  state.renderObjectFunction = renderer2.getRenderObjectFunction();
  state.pixelRatio = renderer2.getPixelRatio();
  state.mrt = renderer2.getMRT();
  state.clearColor = renderer2.getClearColor(state.clearColor || new Color());
  state.clearAlpha = renderer2.getClearAlpha();
  state.autoClear = renderer2.autoClear;
  state.scissorTest = renderer2.getScissorTest();
  return state;
}
function resetRendererState(renderer2, state) {
  state = saveRendererState(renderer2, state);
  renderer2.setMRT(null);
  renderer2.setRenderObjectFunction(null);
  renderer2.setClearColor(0, 1);
  renderer2.autoClear = true;
  return state;
}
function restoreRendererState(renderer2, state) {
  renderer2.toneMapping = state.toneMapping;
  renderer2.toneMappingExposure = state.toneMappingExposure;
  renderer2.outputColorSpace = state.outputColorSpace;
  renderer2.setRenderTarget(
    state.renderTarget,
    state.activeCubeFace,
    state.activeMipmapLevel
  );
  renderer2.setRenderObjectFunction(state.renderObjectFunction);
  renderer2.setPixelRatio(state.pixelRatio);
  renderer2.setMRT(state.mrt);
  renderer2.setClearColor(state.clearColor, state.clearAlpha);
  renderer2.autoClear = state.autoClear;
  renderer2.setScissorTest(state.scissorTest);
}
function saveSceneState(scene2, state = {}) {
  state.background = scene2.background;
  state.backgroundNode = scene2.backgroundNode;
  state.overrideMaterial = scene2.overrideMaterial;
  return state;
}
function resetSceneState(scene2, state) {
  state = saveSceneState(scene2, state);
  scene2.background = null;
  scene2.backgroundNode = null;
  scene2.overrideMaterial = null;
  return state;
}
function restoreSceneState(scene2, state) {
  scene2.background = state.background;
  scene2.backgroundNode = state.backgroundNode;
  scene2.overrideMaterial = state.overrideMaterial;
}
function resetRendererAndSceneState(renderer2, scene2, state) {
  state = resetRendererState(renderer2, state);
  state = resetSceneState(scene2, state);
  return state;
}
function restoreRendererAndSceneState(renderer2, scene2, state) {
  restoreRendererState(renderer2, state);
  restoreSceneState(scene2, state);
}
const shadowMaterialLib = /* @__PURE__ */ new WeakMap();
const BasicShadowFilter = /* @__PURE__ */ Fn(
  ({ depthTexture, shadowCoord, depthLayer }) => {
    let basic = texture$1(depthTexture, shadowCoord.xy).setName("t_basic");
    if (depthTexture.isArrayTexture) {
      basic = basic.depth(depthLayer);
    }
    return basic.compare(shadowCoord.z);
  }
);
const PCFShadowFilter = /* @__PURE__ */ Fn(
  ({ depthTexture, shadowCoord, shadow: shadow2, depthLayer }) => {
    const depthCompare = (uv2, compare) => {
      let depth2 = texture$1(depthTexture, uv2);
      if (depthTexture.isArrayTexture) {
        depth2 = depth2.depth(depthLayer);
      }
      return depth2.compare(compare);
    };
    const mapSize = reference("mapSize", "vec2", shadow2).setGroup(renderGroup);
    const radius = reference("radius", "float", shadow2).setGroup(renderGroup);
    const texelSize = vec2(1).div(mapSize);
    const dx0 = texelSize.x.negate().mul(radius);
    const dy0 = texelSize.y.negate().mul(radius);
    const dx1 = texelSize.x.mul(radius);
    const dy1 = texelSize.y.mul(radius);
    const dx2 = dx0.div(2);
    const dy2 = dy0.div(2);
    const dx3 = dx1.div(2);
    const dy3 = dy1.div(2);
    return add(
      depthCompare(shadowCoord.xy.add(vec2(dx0, dy0)), shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(0, dy0)), shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(dx1, dy0)), shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(dx2, dy2)), shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(0, dy2)), shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(dx3, dy2)), shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(dx0, 0)), shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(dx2, 0)), shadowCoord.z),
      depthCompare(shadowCoord.xy, shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(dx3, 0)), shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(dx1, 0)), shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(dx2, dy3)), shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(0, dy3)), shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(dx3, dy3)), shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(dx0, dy1)), shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(0, dy1)), shadowCoord.z),
      depthCompare(shadowCoord.xy.add(vec2(dx1, dy1)), shadowCoord.z)
    ).mul(1 / 17);
  }
);
const PCFSoftShadowFilter = /* @__PURE__ */ Fn(
  ({ depthTexture, shadowCoord, shadow: shadow2, depthLayer }) => {
    const depthCompare = (uv3, compare) => {
      let depth2 = texture$1(depthTexture, uv3);
      if (depthTexture.isArrayTexture) {
        depth2 = depth2.depth(depthLayer);
      }
      return depth2.compare(compare);
    };
    const mapSize = reference("mapSize", "vec2", shadow2).setGroup(renderGroup);
    const texelSize = vec2(1).div(mapSize);
    const dx = texelSize.x;
    const dy = texelSize.y;
    const uv2 = shadowCoord.xy;
    const f = fract(uv2.mul(mapSize).add(0.5));
    uv2.subAssign(f.mul(texelSize));
    return add(
      depthCompare(uv2, shadowCoord.z),
      depthCompare(uv2.add(vec2(dx, 0)), shadowCoord.z),
      depthCompare(uv2.add(vec2(0, dy)), shadowCoord.z),
      depthCompare(uv2.add(texelSize), shadowCoord.z),
      mix$1(
        depthCompare(uv2.add(vec2(dx.negate(), 0)), shadowCoord.z),
        depthCompare(uv2.add(vec2(dx.mul(2), 0)), shadowCoord.z),
        f.x
      ),
      mix$1(
        depthCompare(uv2.add(vec2(dx.negate(), dy)), shadowCoord.z),
        depthCompare(uv2.add(vec2(dx.mul(2), dy)), shadowCoord.z),
        f.x
      ),
      mix$1(
        depthCompare(uv2.add(vec2(0, dy.negate())), shadowCoord.z),
        depthCompare(uv2.add(vec2(0, dy.mul(2))), shadowCoord.z),
        f.y
      ),
      mix$1(
        depthCompare(uv2.add(vec2(dx, dy.negate())), shadowCoord.z),
        depthCompare(uv2.add(vec2(dx, dy.mul(2))), shadowCoord.z),
        f.y
      ),
      mix$1(
        mix$1(
          depthCompare(uv2.add(vec2(dx.negate(), dy.negate())), shadowCoord.z),
          depthCompare(uv2.add(vec2(dx.mul(2), dy.negate())), shadowCoord.z),
          f.x
        ),
        mix$1(
          depthCompare(uv2.add(vec2(dx.negate(), dy.mul(2))), shadowCoord.z),
          depthCompare(uv2.add(vec2(dx.mul(2), dy.mul(2))), shadowCoord.z),
          f.x
        ),
        f.y
      )
    ).mul(1 / 9);
  }
);
const VSMShadowFilter = /* @__PURE__ */ Fn(
  ({ depthTexture, shadowCoord, depthLayer }) => {
    const occlusion = float(1).toVar();
    let distribution = texture$1(depthTexture).sample(shadowCoord.xy);
    if (depthTexture.isArrayTexture) {
      distribution = distribution.depth(depthLayer);
    }
    distribution = distribution.rg;
    const hardShadow = step(shadowCoord.z, distribution.x);
    If(hardShadow.notEqual(float(1)), () => {
      const distance2 = shadowCoord.z.sub(distribution.x);
      const variance = max$1(0, distribution.y.mul(distribution.y));
      let softnessProbability = variance.div(
        variance.add(distance2.mul(distance2))
      );
      softnessProbability = clamp(
        sub(softnessProbability, 0.3).div(0.95 - 0.3)
      );
      occlusion.assign(clamp(max$1(hardShadow, softnessProbability)));
    });
    return occlusion;
  }
);
const linearDistance = /* @__PURE__ */ Fn(
  ([position, cameraNear2, cameraFar2]) => {
    let dist = positionWorld.sub(position).length();
    dist = dist.sub(cameraNear2).div(cameraFar2.sub(cameraNear2));
    dist = dist.saturate();
    return dist;
  }
);
const linearShadowDistance = (light) => {
  const camera2 = light.shadow.camera;
  const nearDistance = reference("near", "float", camera2).setGroup(
    renderGroup
  );
  const farDistance = reference("far", "float", camera2).setGroup(renderGroup);
  const referencePosition = objectPosition(light);
  return linearDistance(referencePosition, nearDistance, farDistance);
};
const getShadowMaterial = (light) => {
  let material = shadowMaterialLib.get(light);
  if (material === void 0) {
    const depthNode = light.isPointLight ? linearShadowDistance(light) : null;
    material = new NodeMaterial();
    material.colorNode = vec4(0, 0, 0, 1);
    material.depthNode = depthNode;
    material.isShadowPassMaterial = true;
    material.name = "ShadowMaterial";
    material.fog = false;
    shadowMaterialLib.set(light, material);
  }
  return material;
};
const _shadowRenderObjectLibrary = /* @__PURE__ */ new ChainMap();
const _shadowRenderObjectKeys = [];
const getShadowRenderObjectFunction = (
  renderer2,
  shadow2,
  shadowType,
  useVelocity
) => {
  _shadowRenderObjectKeys[0] = renderer2;
  _shadowRenderObjectKeys[1] = shadow2;
  let renderObjectFunction = _shadowRenderObjectLibrary.get(
    _shadowRenderObjectKeys
  );
  if (
    renderObjectFunction === void 0 ||
    renderObjectFunction.shadowType !== shadowType ||
    renderObjectFunction.useVelocity !== useVelocity
  ) {
    renderObjectFunction = (
      object,
      scene2,
      _camera2,
      geometry,
      material,
      group,
      ...params
    ) => {
      if (
        object.castShadow === true ||
        (object.receiveShadow && shadowType === VSMShadowMap)
      ) {
        if (useVelocity) {
          getDataFromObject(object).useVelocity = true;
        }
        object.onBeforeShadow(
          renderer2,
          object,
          _camera2,
          shadow2.camera,
          geometry,
          scene2.overrideMaterial,
          group
        );
        renderer2.renderObject(
          object,
          scene2,
          _camera2,
          geometry,
          material,
          group,
          ...params
        );
        object.onAfterShadow(
          renderer2,
          object,
          _camera2,
          shadow2.camera,
          geometry,
          scene2.overrideMaterial,
          group
        );
      }
    };
    renderObjectFunction.shadowType = shadowType;
    renderObjectFunction.useVelocity = useVelocity;
    _shadowRenderObjectLibrary.set(
      _shadowRenderObjectKeys,
      renderObjectFunction
    );
  }
  _shadowRenderObjectKeys[0] = null;
  _shadowRenderObjectKeys[1] = null;
  return renderObjectFunction;
};
const VSMPassVertical = /* @__PURE__ */ Fn(
  ({ samples, radius, size, shadowPass, depthLayer }) => {
    const mean = float(0).toVar("meanVertical");
    const squaredMean = float(0).toVar("squareMeanVertical");
    const uvStride = samples
      .lessThanEqual(float(1))
      .select(float(0), float(2).div(samples.sub(1)));
    const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));
    Loop(
      { start: int(0), end: int(samples), type: "int", condition: "<" },
      ({ i: i2 }) => {
        const uvOffset = uvStart.add(float(i2).mul(uvStride));
        let depth2 = shadowPass.sample(
          add(screenCoordinate.xy, vec2(0, uvOffset).mul(radius)).div(size)
        );
        if (shadowPass.value.isArrayTexture) {
          depth2 = depth2.depth(depthLayer);
        }
        depth2 = depth2.x;
        mean.addAssign(depth2);
        squaredMean.addAssign(depth2.mul(depth2));
      }
    );
    mean.divAssign(samples);
    squaredMean.divAssign(samples);
    const std_dev = sqrt(squaredMean.sub(mean.mul(mean)));
    return vec2(mean, std_dev);
  }
);
const VSMPassHorizontal = /* @__PURE__ */ Fn(
  ({ samples, radius, size, shadowPass, depthLayer }) => {
    const mean = float(0).toVar("meanHorizontal");
    const squaredMean = float(0).toVar("squareMeanHorizontal");
    const uvStride = samples
      .lessThanEqual(float(1))
      .select(float(0), float(2).div(samples.sub(1)));
    const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));
    Loop(
      { start: int(0), end: int(samples), type: "int", condition: "<" },
      ({ i: i2 }) => {
        const uvOffset = uvStart.add(float(i2).mul(uvStride));
        let distribution = shadowPass.sample(
          add(screenCoordinate.xy, vec2(uvOffset, 0).mul(radius)).div(size)
        );
        if (shadowPass.value.isArrayTexture) {
          distribution = distribution.depth(depthLayer);
        }
        mean.addAssign(distribution.x);
        squaredMean.addAssign(
          add(
            distribution.y.mul(distribution.y),
            distribution.x.mul(distribution.x)
          )
        );
      }
    );
    mean.divAssign(samples);
    squaredMean.divAssign(samples);
    const std_dev = sqrt(squaredMean.sub(mean.mul(mean)));
    return vec2(mean, std_dev);
  }
);
const _shadowFilterLib = [
  BasicShadowFilter,
  PCFShadowFilter,
  PCFSoftShadowFilter,
  VSMShadowFilter,
];
let _rendererState;
const _quadMesh = /* @__PURE__ */ new QuadMesh();
class ShadowNode extends ShadowBaseNode {
  static get type() {
    return "ShadowNode";
  }
  /**
   * Constructs a new shadow node.
   *
   * @param {Light} light - The shadow casting light.
   * @param {?LightShadow} [shadow=null] - An optional light shadow.
   */
  constructor(light, shadow2 = null) {
    super(light);
    this.shadow = shadow2 || light.shadow;
    this.shadowMap = null;
    this.vsmShadowMapVertical = null;
    this.vsmShadowMapHorizontal = null;
    this.vsmMaterialVertical = null;
    this.vsmMaterialHorizontal = null;
    this._node = null;
    this._cameraFrameId = /* @__PURE__ */ new WeakMap();
    this.isShadowNode = true;
    this.depthLayer = 0;
  }
  /**
   * Setups the shadow filtering.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Object} inputs - A configuration object that defines the shadow filtering.
   * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The result node of the shadow filtering.
   */
  setupShadowFilter(
    builder,
    { filterFn, depthTexture, shadowCoord, shadow: shadow2, depthLayer }
  ) {
    const frustumTest = shadowCoord.x
      .greaterThanEqual(0)
      .and(shadowCoord.x.lessThanEqual(1))
      .and(shadowCoord.y.greaterThanEqual(0))
      .and(shadowCoord.y.lessThanEqual(1))
      .and(shadowCoord.z.lessThanEqual(1));
    const shadowNode = filterFn({
      depthTexture,
      shadowCoord,
      shadow: shadow2,
      depthLayer,
    });
    return frustumTest.select(shadowNode, float(1));
  }
  /**
   * Setups the shadow coordinates.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
   * @return {Node<vec3>} The shadow coordinates.
   */
  setupShadowCoord(builder, shadowPosition) {
    const { shadow: shadow2 } = this;
    const { renderer: renderer2 } = builder;
    const bias = reference("bias", "float", shadow2).setGroup(renderGroup);
    let shadowCoord = shadowPosition;
    let coordZ;
    if (
      shadow2.camera.isOrthographicCamera ||
      renderer2.logarithmicDepthBuffer !== true
    ) {
      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);
      coordZ = shadowCoord.z;
      if (renderer2.coordinateSystem === WebGPUCoordinateSystem) {
        coordZ = coordZ.mul(2).sub(1);
      }
    } else {
      const w = shadowCoord.w;
      shadowCoord = shadowCoord.xy.div(w);
      const cameraNearLocal = reference(
        "near",
        "float",
        shadow2.camera
      ).setGroup(renderGroup);
      const cameraFarLocal = reference("far", "float", shadow2.camera).setGroup(
        renderGroup
      );
      coordZ = viewZToLogarithmicDepth(
        w.negate(),
        cameraNearLocal,
        cameraFarLocal
      );
    }
    shadowCoord = vec3(
      shadowCoord.x,
      shadowCoord.y.oneMinus(),
      // follow webgpu standards
      coordZ.add(bias)
    );
    return shadowCoord;
  }
  /**
   * Returns the shadow filtering function for the given shadow type.
   *
   * @param {number} type - The shadow type.
   * @return {Function} The filtering function.
   */
  getShadowFilterFn(type) {
    return _shadowFilterLib[type];
  }
  setupRenderTarget(shadow2, builder) {
    const depthTexture = new DepthTexture(
      shadow2.mapSize.width,
      shadow2.mapSize.height
    );
    depthTexture.name = "ShadowDepthTexture";
    depthTexture.compareFunction = LessCompare;
    const shadowMap = builder.createRenderTarget(
      shadow2.mapSize.width,
      shadow2.mapSize.height
    );
    shadowMap.texture.name = "ShadowMap";
    shadowMap.texture.type = shadow2.mapType;
    shadowMap.depthTexture = depthTexture;
    return { shadowMap, depthTexture };
  }
  /**
   * Setups the shadow output node.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec3>} The shadow output node.
   */
  setupShadow(builder) {
    const { renderer: renderer2 } = builder;
    const { light, shadow: shadow2 } = this;
    const shadowMapType = renderer2.shadowMap.type;
    const { depthTexture, shadowMap } = this.setupRenderTarget(
      shadow2,
      builder
    );
    shadow2.camera.updateProjectionMatrix();
    if (shadowMapType === VSMShadowMap && shadow2.isPointLightShadow !== true) {
      depthTexture.compareFunction = null;
      if (shadowMap.depth > 1) {
        if (!shadowMap._vsmShadowMapVertical) {
          shadowMap._vsmShadowMapVertical = builder.createRenderTarget(
            shadow2.mapSize.width,
            shadow2.mapSize.height,
            {
              format: RGFormat,
              type: HalfFloatType,
              depth: shadowMap.depth,
              depthBuffer: false,
            }
          );
          shadowMap._vsmShadowMapVertical.texture.name = "VSMVertical";
        }
        this.vsmShadowMapVertical = shadowMap._vsmShadowMapVertical;
        if (!shadowMap._vsmShadowMapHorizontal) {
          shadowMap._vsmShadowMapHorizontal = builder.createRenderTarget(
            shadow2.mapSize.width,
            shadow2.mapSize.height,
            {
              format: RGFormat,
              type: HalfFloatType,
              depth: shadowMap.depth,
              depthBuffer: false,
            }
          );
          shadowMap._vsmShadowMapHorizontal.texture.name = "VSMHorizontal";
        }
        this.vsmShadowMapHorizontal = shadowMap._vsmShadowMapHorizontal;
      } else {
        this.vsmShadowMapVertical = builder.createRenderTarget(
          shadow2.mapSize.width,
          shadow2.mapSize.height,
          { format: RGFormat, type: HalfFloatType, depthBuffer: false }
        );
        this.vsmShadowMapHorizontal = builder.createRenderTarget(
          shadow2.mapSize.width,
          shadow2.mapSize.height,
          { format: RGFormat, type: HalfFloatType, depthBuffer: false }
        );
      }
      let shadowPassVertical = texture$1(depthTexture);
      if (depthTexture.isArrayTexture) {
        shadowPassVertical = shadowPassVertical.depth(this.depthLayer);
      }
      let shadowPassHorizontal = texture$1(this.vsmShadowMapVertical.texture);
      if (depthTexture.isArrayTexture) {
        shadowPassHorizontal = shadowPassHorizontal.depth(this.depthLayer);
      }
      const samples = reference("blurSamples", "float", shadow2).setGroup(
        renderGroup
      );
      const radius = reference("radius", "float", shadow2).setGroup(
        renderGroup
      );
      const size = reference("mapSize", "vec2", shadow2).setGroup(renderGroup);
      let material =
        this.vsmMaterialVertical ||
        (this.vsmMaterialVertical = new NodeMaterial());
      material.fragmentNode = VSMPassVertical({
        samples,
        radius,
        size,
        shadowPass: shadowPassVertical,
        depthLayer: this.depthLayer,
      }).context(builder.getSharedContext());
      material.name = "VSMVertical";
      material =
        this.vsmMaterialHorizontal ||
        (this.vsmMaterialHorizontal = new NodeMaterial());
      material.fragmentNode = VSMPassHorizontal({
        samples,
        radius,
        size,
        shadowPass: shadowPassHorizontal,
        depthLayer: this.depthLayer,
      }).context(builder.getSharedContext());
      material.name = "VSMHorizontal";
    }
    const shadowIntensity = reference("intensity", "float", shadow2).setGroup(
      renderGroup
    );
    const normalBias = reference("normalBias", "float", shadow2).setGroup(
      renderGroup
    );
    const shadowPosition = lightShadowMatrix(light).mul(
      shadowPositionWorld.add(normalWorld.mul(normalBias))
    );
    const shadowCoord = this.setupShadowCoord(builder, shadowPosition);
    const filterFn =
      shadow2.filterNode ||
      this.getShadowFilterFn(renderer2.shadowMap.type) ||
      null;
    if (filterFn === null) {
      throw new Error(
        "THREE.WebGPURenderer: Shadow map type not supported yet."
      );
    }
    const shadowDepthTexture =
      shadowMapType === VSMShadowMap && shadow2.isPointLightShadow !== true
        ? this.vsmShadowMapHorizontal.texture
        : depthTexture;
    const shadowNode = this.setupShadowFilter(builder, {
      filterFn,
      shadowTexture: shadowMap.texture,
      depthTexture: shadowDepthTexture,
      shadowCoord,
      shadow: shadow2,
      depthLayer: this.depthLayer,
    });
    let shadowColor = texture$1(shadowMap.texture, shadowCoord);
    if (depthTexture.isArrayTexture) {
      shadowColor = shadowColor.depth(this.depthLayer);
    }
    const shadowOutput = mix$1(
      1,
      shadowNode.rgb.mix(shadowColor, 1),
      shadowIntensity.mul(shadowColor.a)
    ).toVar();
    this.shadowMap = shadowMap;
    this.shadow.map = shadowMap;
    return shadowOutput;
  }
  /**
   * The implementation performs the setup of the output node. An output is only
   * produces if shadow mapping is globally enabled in the renderer.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {ShaderCallNodeInternal} The output node.
   */
  setup(builder) {
    if (builder.renderer.shadowMap.enabled === false) return;
    return Fn(() => {
      let node = this._node;
      this.setupShadowPosition(builder);
      if (node === null) {
        this._node = node = this.setupShadow(builder);
      }
      if (builder.material.shadowNode) {
        console.warn(
          'THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.'
        );
      }
      if (builder.material.receivedShadowNode) {
        node = builder.material.receivedShadowNode(node);
      }
      return node;
    })();
  }
  /**
   * Renders the shadow. The logic of this function could be included
   * into {@link ShadowNode#updateShadow} however more specialized shadow
   * nodes might require a custom shadow map rendering. By having a
   * dedicated method, it's easier to overwrite the default behavior.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  renderShadow(frame) {
    const { shadow: shadow2, shadowMap, light } = this;
    const { renderer: renderer2, scene: scene2 } = frame;
    shadow2.updateMatrices(light);
    shadowMap.setSize(
      shadow2.mapSize.width,
      shadow2.mapSize.height,
      shadowMap.depth
    );
    renderer2.render(scene2, shadow2.camera);
  }
  /**
   * Updates the shadow.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateShadow(frame) {
    const { shadowMap, light, shadow: shadow2 } = this;
    const { renderer: renderer2, scene: scene2, camera: camera2 } = frame;
    const shadowType = renderer2.shadowMap.type;
    const depthVersion = shadowMap.depthTexture.version;
    this._depthVersionCached = depthVersion;
    const _shadowCameraLayer = shadow2.camera.layers.mask;
    if ((shadow2.camera.layers.mask & 4294967294) === 0) {
      shadow2.camera.layers.mask = camera2.layers.mask;
    }
    const currentRenderObjectFunction = renderer2.getRenderObjectFunction();
    const currentMRT = renderer2.getMRT();
    const useVelocity = currentMRT ? currentMRT.has("velocity") : false;
    _rendererState = resetRendererAndSceneState(
      renderer2,
      scene2,
      _rendererState
    );
    scene2.overrideMaterial = getShadowMaterial(light);
    renderer2.setRenderObjectFunction(
      getShadowRenderObjectFunction(renderer2, shadow2, shadowType, useVelocity)
    );
    renderer2.setClearColor(0, 0);
    renderer2.setRenderTarget(shadowMap);
    this.renderShadow(frame);
    renderer2.setRenderObjectFunction(currentRenderObjectFunction);
    if (shadowType === VSMShadowMap && shadow2.isPointLightShadow !== true) {
      this.vsmPass(renderer2);
    }
    shadow2.camera.layers.mask = _shadowCameraLayer;
    restoreRendererAndSceneState(renderer2, scene2, _rendererState);
  }
  /**
   * For VSM additional render passes are required.
   *
   * @param {Renderer} renderer - A reference to the current renderer.
   */
  vsmPass(renderer2) {
    const { shadow: shadow2 } = this;
    const depth2 = this.shadowMap.depth;
    this.vsmShadowMapVertical.setSize(
      shadow2.mapSize.width,
      shadow2.mapSize.height,
      depth2
    );
    this.vsmShadowMapHorizontal.setSize(
      shadow2.mapSize.width,
      shadow2.mapSize.height,
      depth2
    );
    renderer2.setRenderTarget(this.vsmShadowMapVertical);
    _quadMesh.material = this.vsmMaterialVertical;
    _quadMesh.render(renderer2);
    renderer2.setRenderTarget(this.vsmShadowMapHorizontal);
    _quadMesh.material = this.vsmMaterialHorizontal;
    _quadMesh.render(renderer2);
  }
  /**
   * Frees the internal resources of this shadow node.
   */
  dispose() {
    this.shadowMap.dispose();
    this.shadowMap = null;
    if (this.vsmShadowMapVertical !== null) {
      this.vsmShadowMapVertical.dispose();
      this.vsmShadowMapVertical = null;
      this.vsmMaterialVertical.dispose();
      this.vsmMaterialVertical = null;
    }
    if (this.vsmShadowMapHorizontal !== null) {
      this.vsmShadowMapHorizontal.dispose();
      this.vsmShadowMapHorizontal = null;
      this.vsmMaterialHorizontal.dispose();
      this.vsmMaterialHorizontal = null;
    }
    super.dispose();
  }
  /**
   * The implementation performs the update of the shadow map if necessary.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateBefore(frame) {
    const { shadow: shadow2 } = this;
    let needsUpdate = shadow2.needsUpdate || shadow2.autoUpdate;
    if (needsUpdate) {
      if (this._cameraFrameId[frame.camera] === frame.frameId) {
        needsUpdate = false;
      }
      this._cameraFrameId[frame.camera] = frame.frameId;
    }
    if (needsUpdate) {
      this.updateShadow(frame);
      if (this.shadowMap.depthTexture.version === this._depthVersionCached) {
        shadow2.needsUpdate = false;
      }
    }
  }
}
const shadow = (light, shadow2) => nodeObject(new ShadowNode(light, shadow2));
const _clearColor$1 = /* @__PURE__ */ new Color();
const cubeToUV = /* @__PURE__ */ Fn(([pos, texelSizeY]) => {
  const v = pos.toVar();
  const absV = abs(v);
  const scaleToCube = div(1, max$1(absV.x, max$1(absV.y, absV.z)));
  absV.mulAssign(scaleToCube);
  v.mulAssign(scaleToCube.mul(texelSizeY.mul(2).oneMinus()));
  const planar = vec2(v.xy).toVar();
  const almostATexel = texelSizeY.mul(1.5);
  const almostOne = almostATexel.oneMinus();
  If(absV.z.greaterThanEqual(almostOne), () => {
    If(v.z.greaterThan(0), () => {
      planar.x.assign(sub(4, v.x));
    });
  })
    .ElseIf(absV.x.greaterThanEqual(almostOne), () => {
      const signX = sign(v.x);
      planar.x.assign(v.z.mul(signX).add(signX.mul(2)));
    })
    .ElseIf(absV.y.greaterThanEqual(almostOne), () => {
      const signY = sign(v.y);
      planar.x.assign(v.x.add(signY.mul(2)).add(2));
      planar.y.assign(v.z.mul(signY).sub(2));
    });
  return vec2(0.125, 0.25).mul(planar).add(vec2(0.375, 0.75)).flipY();
}).setLayout({
  name: "cubeToUV",
  type: "vec2",
  inputs: [
    { name: "pos", type: "vec3" },
    { name: "texelSizeY", type: "float" },
  ],
});
const BasicPointShadowFilter = /* @__PURE__ */ Fn(
  ({ depthTexture, bd3D, dp, texelSize }) => {
    return texture$1(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp);
  }
);
const PointShadowFilter = /* @__PURE__ */ Fn(
  ({ depthTexture, bd3D, dp, texelSize, shadow: shadow2 }) => {
    const radius = reference("radius", "float", shadow2).setGroup(renderGroup);
    const offset = vec2(-1, 1).mul(radius).mul(texelSize.y);
    return texture$1(depthTexture, cubeToUV(bd3D.add(offset.xyy), texelSize.y))
      .compare(dp)
      .add(
        texture$1(
          depthTexture,
          cubeToUV(bd3D.add(offset.yyy), texelSize.y)
        ).compare(dp)
      )
      .add(
        texture$1(
          depthTexture,
          cubeToUV(bd3D.add(offset.xyx), texelSize.y)
        ).compare(dp)
      )
      .add(
        texture$1(
          depthTexture,
          cubeToUV(bd3D.add(offset.yyx), texelSize.y)
        ).compare(dp)
      )
      .add(texture$1(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp))
      .add(
        texture$1(
          depthTexture,
          cubeToUV(bd3D.add(offset.xxy), texelSize.y)
        ).compare(dp)
      )
      .add(
        texture$1(
          depthTexture,
          cubeToUV(bd3D.add(offset.yxy), texelSize.y)
        ).compare(dp)
      )
      .add(
        texture$1(
          depthTexture,
          cubeToUV(bd3D.add(offset.xxx), texelSize.y)
        ).compare(dp)
      )
      .add(
        texture$1(
          depthTexture,
          cubeToUV(bd3D.add(offset.yxx), texelSize.y)
        ).compare(dp)
      )
      .mul(1 / 9);
  }
);
const pointShadowFilter = /* @__PURE__ */ Fn(
  ({ filterFn, depthTexture, shadowCoord, shadow: shadow2 }) => {
    const lightToPosition = shadowCoord.xyz.toVar();
    const lightToPositionLength = lightToPosition.length();
    const cameraNearLocal = uniform$1("float")
      .setGroup(renderGroup)
      .onRenderUpdate(() => shadow2.camera.near);
    const cameraFarLocal = uniform$1("float")
      .setGroup(renderGroup)
      .onRenderUpdate(() => shadow2.camera.far);
    const bias = reference("bias", "float", shadow2).setGroup(renderGroup);
    const mapSize = uniform$1(shadow2.mapSize).setGroup(renderGroup);
    const result = float(1).toVar();
    If(
      lightToPositionLength
        .sub(cameraFarLocal)
        .lessThanEqual(0)
        .and(lightToPositionLength.sub(cameraNearLocal).greaterThanEqual(0)),
      () => {
        const dp = lightToPositionLength
          .sub(cameraNearLocal)
          .div(cameraFarLocal.sub(cameraNearLocal))
          .toVar();
        dp.addAssign(bias);
        const bd3D = lightToPosition.normalize();
        const texelSize = vec2(1).div(mapSize.mul(vec2(4, 2)));
        result.assign(
          filterFn({ depthTexture, bd3D, dp, texelSize, shadow: shadow2 })
        );
      }
    );
    return result;
  }
);
const _viewport = /* @__PURE__ */ new Vector4();
const _viewportSize = /* @__PURE__ */ new Vector2();
const _shadowMapSize = /* @__PURE__ */ new Vector2();
class PointShadowNode extends ShadowNode {
  static get type() {
    return "PointShadowNode";
  }
  /**
   * Constructs a new point shadow node.
   *
   * @param {PointLight} light - The shadow casting point light.
   * @param {?PointLightShadow} [shadow=null] - An optional point light shadow.
   */
  constructor(light, shadow2 = null) {
    super(light, shadow2);
  }
  /**
   * Overwrites the default implementation to return point light shadow specific
   * filtering functions.
   *
   * @param {number} type - The shadow type.
   * @return {Function} The filtering function.
   */
  getShadowFilterFn(type) {
    return type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;
  }
  /**
   * Overwrites the default implementation so the unaltered shadow position is used.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
   * @return {Node<vec3>} The shadow coordinates.
   */
  setupShadowCoord(builder, shadowPosition) {
    return shadowPosition;
  }
  /**
   * Overwrites the default implementation to only use point light specific
   * shadow filter functions.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Object} inputs - A configuration object that defines the shadow filtering.
   * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
   * @param {Texture} inputs.shadowTexture - A reference to the shadow map's texture.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The result node of the shadow filtering.
   */
  setupShadowFilter(
    builder,
    { filterFn, shadowTexture, depthTexture, shadowCoord, shadow: shadow2 }
  ) {
    return pointShadowFilter({
      filterFn,
      shadowTexture,
      depthTexture,
      shadowCoord,
      shadow: shadow2,
    });
  }
  /**
   * Overwrites the default implementation with point light specific
   * rendering code.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  renderShadow(frame) {
    const { shadow: shadow2, shadowMap, light } = this;
    const { renderer: renderer2, scene: scene2 } = frame;
    const shadowFrameExtents = shadow2.getFrameExtents();
    _shadowMapSize.copy(shadow2.mapSize);
    _shadowMapSize.multiply(shadowFrameExtents);
    shadowMap.setSize(_shadowMapSize.width, _shadowMapSize.height);
    _viewportSize.copy(shadow2.mapSize);
    const previousAutoClear = renderer2.autoClear;
    const previousClearColor = renderer2.getClearColor(_clearColor$1);
    const previousClearAlpha = renderer2.getClearAlpha();
    renderer2.autoClear = false;
    renderer2.setClearColor(shadow2.clearColor, shadow2.clearAlpha);
    renderer2.clear();
    const viewportCount = shadow2.getViewportCount();
    for (let vp = 0; vp < viewportCount; vp++) {
      const viewport2 = shadow2.getViewport(vp);
      const x = _viewportSize.x * viewport2.x;
      const y =
        _shadowMapSize.y - _viewportSize.y - _viewportSize.y * viewport2.y;
      _viewport.set(
        x,
        y,
        _viewportSize.x * viewport2.z,
        _viewportSize.y * viewport2.w
      );
      shadowMap.viewport.copy(_viewport);
      shadow2.updateMatrices(light, vp);
      renderer2.render(scene2, shadow2.camera);
    }
    renderer2.autoClear = previousAutoClear;
    renderer2.setClearColor(previousClearColor, previousClearAlpha);
  }
}
const pointShadow = (light, shadow2) =>
  nodeObject(new PointShadowNode(light, shadow2));
class AnalyticLightNode extends LightingNode {
  static get type() {
    return "AnalyticLightNode";
  }
  /**
   * Constructs a new analytic light node.
   *
   * @param {?Light} [light=null] - The light source.
   */
  constructor(light = null) {
    super();
    this.light = light;
    this.color = new Color();
    this.colorNode =
      (light && light.colorNode) || uniform$1(this.color).setGroup(renderGroup);
    this.baseColorNode = null;
    this.shadowNode = null;
    this.shadowColorNode = null;
    this.isAnalyticLightNode = true;
    this.updateType = NodeUpdateType.FRAME;
  }
  getHash() {
    return this.light.uuid;
  }
  /**
   * Returns a node representing a direction vector which points from the current
   * position in view space to the light's position in view space.
   *
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Node<vec3>} The light vector node.
   */
  getLightVector(builder) {
    return lightViewPosition(this.light).sub(
      builder.context.positionView || positionView
    );
  }
  /**
   * Sets up the direct lighting for the analytic light node.
   *
   * @abstract
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Object|undefined} The direct light data (color and direction).
   */
  setupDirect() {}
  /**
   * Sets up the direct rect area lighting for the analytic light node.
   *
   * @abstract
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Object|undefined} The direct rect area light data.
   */
  setupDirectRectArea() {}
  /**
   * Setups the shadow node for this light. The method exists so concrete light classes
   * can setup different types of shadow nodes.
   *
   * @return {ShadowNode} The created shadow node.
   */
  setupShadowNode() {
    return shadow(this.light);
  }
  /**
   * Setups the shadow for this light. This method is only executed if the light
   * cast shadows and the current build object receives shadows. It incorporates
   * shadows into the lighting computation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupShadow(builder) {
    const { renderer: renderer2 } = builder;
    if (renderer2.shadowMap.enabled === false) return;
    let shadowColorNode = this.shadowColorNode;
    if (shadowColorNode === null) {
      const customShadowNode = this.light.shadow.shadowNode;
      let shadowNode;
      if (customShadowNode !== void 0) {
        shadowNode = nodeObject(customShadowNode);
      } else {
        shadowNode = this.setupShadowNode();
      }
      this.shadowNode = shadowNode;
      this.shadowColorNode = shadowColorNode = this.colorNode.mul(shadowNode);
      this.baseColorNode = this.colorNode;
    }
    this.colorNode = shadowColorNode;
  }
  /**
   * Unlike most other nodes, lighting nodes do not return a output node in {@link Node#setup}.
   * The main purpose of lighting nodes is to configure the current {@link LightingModel} and/or
   * invocate the respective interface methods.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    this.colorNode = this.baseColorNode || this.colorNode;
    if (this.light.castShadow) {
      if (builder.object.receiveShadow) {
        this.setupShadow(builder);
      }
    } else if (this.shadowNode !== null) {
      this.shadowNode.dispose();
      this.shadowNode = null;
      this.shadowColorNode = null;
    }
    const directLightData = this.setupDirect(builder);
    const directRectAreaLightData = this.setupDirectRectArea(builder);
    if (directLightData) {
      builder.lightsNode.setupDirectLight(builder, this, directLightData);
    }
    if (directRectAreaLightData) {
      builder.lightsNode.setupDirectRectAreaLight(
        builder,
        this,
        directRectAreaLightData
      );
    }
  }
  /**
   * The update method is used to update light uniforms per frame.
   * Potentially overwritten in concrete light nodes to update light
   * specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    const { light } = this;
    this.color.copy(light.color).multiplyScalar(light.intensity);
  }
}
const getDistanceAttenuation = /* @__PURE__ */ Fn(
  ({ lightDistance, cutoffDistance, decayExponent }) => {
    const distanceFalloff = lightDistance
      .pow(decayExponent)
      .max(0.01)
      .reciprocal();
    return cutoffDistance
      .greaterThan(0)
      .select(
        distanceFalloff.mul(
          lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()
        ),
        distanceFalloff
      );
  }
);
const directPointLight = ({
  color: color2,
  lightVector,
  cutoffDistance,
  decayExponent,
}) => {
  const lightDirection = lightVector.normalize();
  const lightDistance = lightVector.length();
  const attenuation = getDistanceAttenuation({
    lightDistance,
    cutoffDistance,
    decayExponent,
  });
  const lightColor = color2.mul(attenuation);
  return { lightDirection, lightColor };
};
class PointLightNode extends AnalyticLightNode {
  static get type() {
    return "PointLightNode";
  }
  /**
   * Constructs a new point light node.
   *
   * @param {?PointLight} [light=null] - The point light source.
   */
  constructor(light = null) {
    super(light);
    this.cutoffDistanceNode = uniform$1(0).setGroup(renderGroup);
    this.decayExponentNode = uniform$1(2).setGroup(renderGroup);
  }
  /**
   * Overwritten to updated point light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  /**
   * Overwritten to setup point light specific shadow.
   *
   * @return {PointShadowNode}
   */
  setupShadowNode() {
    return pointShadow(this.light);
  }
  setupDirect(builder) {
    return directPointLight({
      color: this.colorNode,
      lightVector: this.getLightVector(builder),
      cutoffDistance: this.cutoffDistanceNode,
      decayExponent: this.decayExponentNode,
    });
  }
}
const checker = /* @__PURE__ */ Fn(([coord = uv$1()]) => {
  const uv2 = coord.mul(2);
  const cx = uv2.x.floor();
  const cy = uv2.y.floor();
  const result = cx.add(cy).mod(2);
  return result.sign();
});
const shapeCircle = Fn(
  ([coord = uv$1()], { renderer: renderer2, material }) => {
    const len2 = lengthSq(coord.mul(2).sub(1));
    let alpha;
    if (material.alphaToCoverage && renderer2.samples > 1) {
      const dlen = float(len2.fwidth()).toVar();
      alpha = smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus();
    } else {
      alpha = select(len2.greaterThan(1), 0, 1);
    }
    return alpha;
  }
);
const mx_select = /* @__PURE__ */ Fn(
  ([b_immutable, t_immutable, f_immutable]) => {
    const f = float(f_immutable).toVar();
    const t2 = float(t_immutable).toVar();
    const b = bool(b_immutable).toVar();
    return select(b, t2, f);
  }
).setLayout({
  name: "mx_select",
  type: "float",
  inputs: [
    { name: "b", type: "bool" },
    { name: "t", type: "float" },
    { name: "f", type: "float" },
  ],
});
const mx_negate_if = /* @__PURE__ */ Fn(([val_immutable, b_immutable]) => {
  const b = bool(b_immutable).toVar();
  const val = float(val_immutable).toVar();
  return select(b, val.negate(), val);
}).setLayout({
  name: "mx_negate_if",
  type: "float",
  inputs: [
    { name: "val", type: "float" },
    { name: "b", type: "bool" },
  ],
});
const mx_floor = /* @__PURE__ */ Fn(([x_immutable]) => {
  const x = float(x_immutable).toVar();
  return int(floor(x));
}).setLayout({
  name: "mx_floor",
  type: "int",
  inputs: [{ name: "x", type: "float" }],
});
const mx_floorfrac = /* @__PURE__ */ Fn(([x_immutable, i2]) => {
  const x = float(x_immutable).toVar();
  i2.assign(mx_floor(x));
  return x.sub(float(i2));
});
const mx_bilerp_0 = /* @__PURE__ */ Fn(
  ([
    v0_immutable,
    v1_immutable,
    v2_immutable,
    v3_immutable,
    s_immutable,
    t_immutable,
  ]) => {
    const t2 = float(t_immutable).toVar();
    const s2 = float(s_immutable).toVar();
    const v3 = float(v3_immutable).toVar();
    const v2 = float(v2_immutable).toVar();
    const v1 = float(v1_immutable).toVar();
    const v0 = float(v0_immutable).toVar();
    const s1 = float(sub(1, s2)).toVar();
    return sub(1, t2)
      .mul(v0.mul(s1).add(v1.mul(s2)))
      .add(t2.mul(v2.mul(s1).add(v3.mul(s2))));
  }
).setLayout({
  name: "mx_bilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
  ],
});
const mx_bilerp_1 = /* @__PURE__ */ Fn(
  ([
    v0_immutable,
    v1_immutable,
    v2_immutable,
    v3_immutable,
    s_immutable,
    t_immutable,
  ]) => {
    const t2 = float(t_immutable).toVar();
    const s2 = float(s_immutable).toVar();
    const v3 = vec3(v3_immutable).toVar();
    const v2 = vec3(v2_immutable).toVar();
    const v1 = vec3(v1_immutable).toVar();
    const v0 = vec3(v0_immutable).toVar();
    const s1 = float(sub(1, s2)).toVar();
    return sub(1, t2)
      .mul(v0.mul(s1).add(v1.mul(s2)))
      .add(t2.mul(v2.mul(s1).add(v3.mul(s2))));
  }
).setLayout({
  name: "mx_bilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
  ],
});
const mx_bilerp = /* @__PURE__ */ overloadingFn([mx_bilerp_0, mx_bilerp_1]);
const mx_trilerp_0 = /* @__PURE__ */ Fn(
  ([
    v0_immutable,
    v1_immutable,
    v2_immutable,
    v3_immutable,
    v4_immutable,
    v5_immutable,
    v6_immutable,
    v7_immutable,
    s_immutable,
    t_immutable,
    r_immutable,
  ]) => {
    const r2 = float(r_immutable).toVar();
    const t2 = float(t_immutable).toVar();
    const s2 = float(s_immutable).toVar();
    const v7 = float(v7_immutable).toVar();
    const v6 = float(v6_immutable).toVar();
    const v5 = float(v5_immutable).toVar();
    const v4 = float(v4_immutable).toVar();
    const v3 = float(v3_immutable).toVar();
    const v2 = float(v2_immutable).toVar();
    const v1 = float(v1_immutable).toVar();
    const v0 = float(v0_immutable).toVar();
    const s1 = float(sub(1, s2)).toVar();
    const t1 = float(sub(1, t2)).toVar();
    const r1 = float(sub(1, r2)).toVar();
    return r1
      .mul(
        t1
          .mul(v0.mul(s1).add(v1.mul(s2)))
          .add(t2.mul(v2.mul(s1).add(v3.mul(s2))))
      )
      .add(
        r2.mul(
          t1
            .mul(v4.mul(s1).add(v5.mul(s2)))
            .add(t2.mul(v6.mul(s1).add(v7.mul(s2))))
        )
      );
  }
).setLayout({
  name: "mx_trilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "v4", type: "float" },
    { name: "v5", type: "float" },
    { name: "v6", type: "float" },
    { name: "v7", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" },
  ],
});
const mx_trilerp_1 = /* @__PURE__ */ Fn(
  ([
    v0_immutable,
    v1_immutable,
    v2_immutable,
    v3_immutable,
    v4_immutable,
    v5_immutable,
    v6_immutable,
    v7_immutable,
    s_immutable,
    t_immutable,
    r_immutable,
  ]) => {
    const r2 = float(r_immutable).toVar();
    const t2 = float(t_immutable).toVar();
    const s2 = float(s_immutable).toVar();
    const v7 = vec3(v7_immutable).toVar();
    const v6 = vec3(v6_immutable).toVar();
    const v5 = vec3(v5_immutable).toVar();
    const v4 = vec3(v4_immutable).toVar();
    const v3 = vec3(v3_immutable).toVar();
    const v2 = vec3(v2_immutable).toVar();
    const v1 = vec3(v1_immutable).toVar();
    const v0 = vec3(v0_immutable).toVar();
    const s1 = float(sub(1, s2)).toVar();
    const t1 = float(sub(1, t2)).toVar();
    const r1 = float(sub(1, r2)).toVar();
    return r1
      .mul(
        t1
          .mul(v0.mul(s1).add(v1.mul(s2)))
          .add(t2.mul(v2.mul(s1).add(v3.mul(s2))))
      )
      .add(
        r2.mul(
          t1
            .mul(v4.mul(s1).add(v5.mul(s2)))
            .add(t2.mul(v6.mul(s1).add(v7.mul(s2))))
        )
      );
  }
).setLayout({
  name: "mx_trilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "v4", type: "vec3" },
    { name: "v5", type: "vec3" },
    { name: "v6", type: "vec3" },
    { name: "v7", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" },
  ],
});
const mx_trilerp = /* @__PURE__ */ overloadingFn([mx_trilerp_0, mx_trilerp_1]);
const mx_gradient_float_0 = /* @__PURE__ */ Fn(
  ([hash_immutable, x_immutable, y_immutable]) => {
    const y = float(y_immutable).toVar();
    const x = float(x_immutable).toVar();
    const hash2 = uint(hash_immutable).toVar();
    const h2 = uint(hash2.bitAnd(uint(7))).toVar();
    const u2 = float(mx_select(h2.lessThan(uint(4)), x, y)).toVar();
    const v = float(mul(2, mx_select(h2.lessThan(uint(4)), y, x))).toVar();
    return mx_negate_if(u2, bool(h2.bitAnd(uint(1)))).add(
      mx_negate_if(v, bool(h2.bitAnd(uint(2))))
    );
  }
).setLayout({
  name: "mx_gradient_float_0",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
  ],
});
const mx_gradient_float_1 = /* @__PURE__ */ Fn(
  ([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
    const z = float(z_immutable).toVar();
    const y = float(y_immutable).toVar();
    const x = float(x_immutable).toVar();
    const hash2 = uint(hash_immutable).toVar();
    const h2 = uint(hash2.bitAnd(uint(15))).toVar();
    const u2 = float(mx_select(h2.lessThan(uint(8)), x, y)).toVar();
    const v = float(
      mx_select(
        h2.lessThan(uint(4)),
        y,
        mx_select(h2.equal(uint(12)).or(h2.equal(uint(14))), x, z)
      )
    ).toVar();
    return mx_negate_if(u2, bool(h2.bitAnd(uint(1)))).add(
      mx_negate_if(v, bool(h2.bitAnd(uint(2))))
    );
  }
).setLayout({
  name: "mx_gradient_float_1",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" },
  ],
});
const mx_gradient_float = /* @__PURE__ */ overloadingFn([
  mx_gradient_float_0,
  mx_gradient_float_1,
]);
const mx_gradient_vec3_0 = /* @__PURE__ */ Fn(
  ([hash_immutable, x_immutable, y_immutable]) => {
    const y = float(y_immutable).toVar();
    const x = float(x_immutable).toVar();
    const hash2 = uvec3(hash_immutable).toVar();
    return vec3(
      mx_gradient_float(hash2.x, x, y),
      mx_gradient_float(hash2.y, x, y),
      mx_gradient_float(hash2.z, x, y)
    );
  }
).setLayout({
  name: "mx_gradient_vec3_0",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
  ],
});
const mx_gradient_vec3_1 = /* @__PURE__ */ Fn(
  ([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
    const z = float(z_immutable).toVar();
    const y = float(y_immutable).toVar();
    const x = float(x_immutable).toVar();
    const hash2 = uvec3(hash_immutable).toVar();
    return vec3(
      mx_gradient_float(hash2.x, x, y, z),
      mx_gradient_float(hash2.y, x, y, z),
      mx_gradient_float(hash2.z, x, y, z)
    );
  }
).setLayout({
  name: "mx_gradient_vec3_1",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" },
  ],
});
const mx_gradient_vec3 = /* @__PURE__ */ overloadingFn([
  mx_gradient_vec3_0,
  mx_gradient_vec3_1,
]);
const mx_gradient_scale2d_0 = /* @__PURE__ */ Fn(([v_immutable]) => {
  const v = float(v_immutable).toVar();
  return mul(0.6616, v);
}).setLayout({
  name: "mx_gradient_scale2d_0",
  type: "float",
  inputs: [{ name: "v", type: "float" }],
});
const mx_gradient_scale3d_0 = /* @__PURE__ */ Fn(([v_immutable]) => {
  const v = float(v_immutable).toVar();
  return mul(0.982, v);
}).setLayout({
  name: "mx_gradient_scale3d_0",
  type: "float",
  inputs: [{ name: "v", type: "float" }],
});
const mx_gradient_scale2d_1 = /* @__PURE__ */ Fn(([v_immutable]) => {
  const v = vec3(v_immutable).toVar();
  return mul(0.6616, v);
}).setLayout({
  name: "mx_gradient_scale2d_1",
  type: "vec3",
  inputs: [{ name: "v", type: "vec3" }],
});
const mx_gradient_scale2d = /* @__PURE__ */ overloadingFn([
  mx_gradient_scale2d_0,
  mx_gradient_scale2d_1,
]);
const mx_gradient_scale3d_1 = /* @__PURE__ */ Fn(([v_immutable]) => {
  const v = vec3(v_immutable).toVar();
  return mul(0.982, v);
}).setLayout({
  name: "mx_gradient_scale3d_1",
  type: "vec3",
  inputs: [{ name: "v", type: "vec3" }],
});
const mx_gradient_scale3d = /* @__PURE__ */ overloadingFn([
  mx_gradient_scale3d_0,
  mx_gradient_scale3d_1,
]);
const mx_rotl32 = /* @__PURE__ */ Fn(([x_immutable, k_immutable]) => {
  const k = int(k_immutable).toVar();
  const x = uint(x_immutable).toVar();
  return x.shiftLeft(k).bitOr(x.shiftRight(int(32).sub(k)));
}).setLayout({
  name: "mx_rotl32",
  type: "uint",
  inputs: [
    { name: "x", type: "uint" },
    { name: "k", type: "int" },
  ],
});
const mx_bjmix = /* @__PURE__ */ Fn(([a2, b, c2]) => {
  a2.subAssign(c2);
  a2.bitXorAssign(mx_rotl32(c2, int(4)));
  c2.addAssign(b);
  b.subAssign(a2);
  b.bitXorAssign(mx_rotl32(a2, int(6)));
  a2.addAssign(c2);
  c2.subAssign(b);
  c2.bitXorAssign(mx_rotl32(b, int(8)));
  b.addAssign(a2);
  a2.subAssign(c2);
  a2.bitXorAssign(mx_rotl32(c2, int(16)));
  c2.addAssign(b);
  b.subAssign(a2);
  b.bitXorAssign(mx_rotl32(a2, int(19)));
  a2.addAssign(c2);
  c2.subAssign(b);
  c2.bitXorAssign(mx_rotl32(b, int(4)));
  b.addAssign(a2);
});
const mx_bjfinal = /* @__PURE__ */ Fn(
  ([a_immutable, b_immutable, c_immutable]) => {
    const c2 = uint(c_immutable).toVar();
    const b = uint(b_immutable).toVar();
    const a2 = uint(a_immutable).toVar();
    c2.bitXorAssign(b);
    c2.subAssign(mx_rotl32(b, int(14)));
    a2.bitXorAssign(c2);
    a2.subAssign(mx_rotl32(c2, int(11)));
    b.bitXorAssign(a2);
    b.subAssign(mx_rotl32(a2, int(25)));
    c2.bitXorAssign(b);
    c2.subAssign(mx_rotl32(b, int(16)));
    a2.bitXorAssign(c2);
    a2.subAssign(mx_rotl32(c2, int(4)));
    b.bitXorAssign(a2);
    b.subAssign(mx_rotl32(a2, int(14)));
    c2.bitXorAssign(b);
    c2.subAssign(mx_rotl32(b, int(24)));
    return c2;
  }
).setLayout({
  name: "mx_bjfinal",
  type: "uint",
  inputs: [
    { name: "a", type: "uint" },
    { name: "b", type: "uint" },
    { name: "c", type: "uint" },
  ],
});
const mx_bits_to_01 = /* @__PURE__ */ Fn(([bits_immutable]) => {
  const bits = uint(bits_immutable).toVar();
  return float(bits).div(float(uint(int(4294967295))));
}).setLayout({
  name: "mx_bits_to_01",
  type: "float",
  inputs: [{ name: "bits", type: "uint" }],
});
const mx_fade = /* @__PURE__ */ Fn(([t_immutable]) => {
  const t2 = float(t_immutable).toVar();
  return t2
    .mul(t2)
    .mul(t2)
    .mul(t2.mul(t2.mul(6).sub(15)).add(10));
}).setLayout({
  name: "mx_fade",
  type: "float",
  inputs: [{ name: "t", type: "float" }],
});
const mx_hash_int_0 = /* @__PURE__ */ Fn(([x_immutable]) => {
  const x = int(x_immutable).toVar();
  const len = uint(uint(1)).toVar();
  const seed = uint(
    uint(int(3735928559))
      .add(len.shiftLeft(uint(2)))
      .add(uint(13))
  ).toVar();
  return mx_bjfinal(seed.add(uint(x)), seed, seed);
}).setLayout({
  name: "mx_hash_int_0",
  type: "uint",
  inputs: [{ name: "x", type: "int" }],
});
const mx_hash_int_1 = /* @__PURE__ */ Fn(([x_immutable, y_immutable]) => {
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(2)).toVar();
  const a2 = uint().toVar(),
    b = uint().toVar(),
    c2 = uint().toVar();
  a2.assign(
    b.assign(
      c2.assign(
        uint(int(3735928559))
          .add(len.shiftLeft(uint(2)))
          .add(uint(13))
      )
    )
  );
  a2.addAssign(uint(x));
  b.addAssign(uint(y));
  return mx_bjfinal(a2, b, c2);
}).setLayout({
  name: "mx_hash_int_1",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
  ],
});
const mx_hash_int_2 = /* @__PURE__ */ Fn(
  ([x_immutable, y_immutable, z_immutable]) => {
    const z = int(z_immutable).toVar();
    const y = int(y_immutable).toVar();
    const x = int(x_immutable).toVar();
    const len = uint(uint(3)).toVar();
    const a2 = uint().toVar(),
      b = uint().toVar(),
      c2 = uint().toVar();
    a2.assign(
      b.assign(
        c2.assign(
          uint(int(3735928559))
            .add(len.shiftLeft(uint(2)))
            .add(uint(13))
        )
      )
    );
    a2.addAssign(uint(x));
    b.addAssign(uint(y));
    c2.addAssign(uint(z));
    return mx_bjfinal(a2, b, c2);
  }
).setLayout({
  name: "mx_hash_int_2",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
  ],
});
const mx_hash_int_3 = /* @__PURE__ */ Fn(
  ([x_immutable, y_immutable, z_immutable, xx_immutable]) => {
    const xx = int(xx_immutable).toVar();
    const z = int(z_immutable).toVar();
    const y = int(y_immutable).toVar();
    const x = int(x_immutable).toVar();
    const len = uint(uint(4)).toVar();
    const a2 = uint().toVar(),
      b = uint().toVar(),
      c2 = uint().toVar();
    a2.assign(
      b.assign(
        c2.assign(
          uint(int(3735928559))
            .add(len.shiftLeft(uint(2)))
            .add(uint(13))
        )
      )
    );
    a2.addAssign(uint(x));
    b.addAssign(uint(y));
    c2.addAssign(uint(z));
    mx_bjmix(a2, b, c2);
    a2.addAssign(uint(xx));
    return mx_bjfinal(a2, b, c2);
  }
).setLayout({
  name: "mx_hash_int_3",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" },
  ],
});
const mx_hash_int_4 = /* @__PURE__ */ Fn(
  ([x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable]) => {
    const yy = int(yy_immutable).toVar();
    const xx = int(xx_immutable).toVar();
    const z = int(z_immutable).toVar();
    const y = int(y_immutable).toVar();
    const x = int(x_immutable).toVar();
    const len = uint(uint(5)).toVar();
    const a2 = uint().toVar(),
      b = uint().toVar(),
      c2 = uint().toVar();
    a2.assign(
      b.assign(
        c2.assign(
          uint(int(3735928559))
            .add(len.shiftLeft(uint(2)))
            .add(uint(13))
        )
      )
    );
    a2.addAssign(uint(x));
    b.addAssign(uint(y));
    c2.addAssign(uint(z));
    mx_bjmix(a2, b, c2);
    a2.addAssign(uint(xx));
    b.addAssign(uint(yy));
    return mx_bjfinal(a2, b, c2);
  }
).setLayout({
  name: "mx_hash_int_4",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" },
    { name: "yy", type: "int" },
  ],
});
const mx_hash_int = /* @__PURE__ */ overloadingFn([
  mx_hash_int_0,
  mx_hash_int_1,
  mx_hash_int_2,
  mx_hash_int_3,
  mx_hash_int_4,
]);
const mx_hash_vec3_0 = /* @__PURE__ */ Fn(([x_immutable, y_immutable]) => {
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const h2 = uint(mx_hash_int(x, y)).toVar();
  const result = uvec3().toVar();
  result.x.assign(h2.bitAnd(int(255)));
  result.y.assign(h2.shiftRight(int(8)).bitAnd(int(255)));
  result.z.assign(h2.shiftRight(int(16)).bitAnd(int(255)));
  return result;
}).setLayout({
  name: "mx_hash_vec3_0",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
  ],
});
const mx_hash_vec3_1 = /* @__PURE__ */ Fn(
  ([x_immutable, y_immutable, z_immutable]) => {
    const z = int(z_immutable).toVar();
    const y = int(y_immutable).toVar();
    const x = int(x_immutable).toVar();
    const h2 = uint(mx_hash_int(x, y, z)).toVar();
    const result = uvec3().toVar();
    result.x.assign(h2.bitAnd(int(255)));
    result.y.assign(h2.shiftRight(int(8)).bitAnd(int(255)));
    result.z.assign(h2.shiftRight(int(16)).bitAnd(int(255)));
    return result;
  }
).setLayout({
  name: "mx_hash_vec3_1",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
  ],
});
const mx_hash_vec3 = /* @__PURE__ */ overloadingFn([
  mx_hash_vec3_0,
  mx_hash_vec3_1,
]);
const mx_perlin_noise_float_0 = /* @__PURE__ */ Fn(([p_immutable]) => {
  const p2 = vec2(p_immutable).toVar();
  const X = int().toVar(),
    Y = int().toVar();
  const fx = float(mx_floorfrac(p2.x, X)).toVar();
  const fy = float(mx_floorfrac(p2.y, Y)).toVar();
  const u2 = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const result = float(
    mx_bilerp(
      mx_gradient_float(mx_hash_int(X, Y), fx, fy),
      mx_gradient_float(mx_hash_int(X.add(int(1)), Y), fx.sub(1), fy),
      mx_gradient_float(mx_hash_int(X, Y.add(int(1))), fx, fy.sub(1)),
      mx_gradient_float(
        mx_hash_int(X.add(int(1)), Y.add(int(1))),
        fx.sub(1),
        fy.sub(1)
      ),
      u2,
      v
    )
  ).toVar();
  return mx_gradient_scale2d(result);
}).setLayout({
  name: "mx_perlin_noise_float_0",
  type: "float",
  inputs: [{ name: "p", type: "vec2" }],
});
const mx_perlin_noise_float_1 = /* @__PURE__ */ Fn(([p_immutable]) => {
  const p2 = vec3(p_immutable).toVar();
  const X = int().toVar(),
    Y = int().toVar(),
    Z = int().toVar();
  const fx = float(mx_floorfrac(p2.x, X)).toVar();
  const fy = float(mx_floorfrac(p2.y, Y)).toVar();
  const fz = float(mx_floorfrac(p2.z, Z)).toVar();
  const u2 = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const w = float(mx_fade(fz)).toVar();
  const result = float(
    mx_trilerp(
      mx_gradient_float(mx_hash_int(X, Y, Z), fx, fy, fz),
      mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z), fx.sub(1), fy, fz),
      mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z), fx, fy.sub(1), fz),
      mx_gradient_float(
        mx_hash_int(X.add(int(1)), Y.add(int(1)), Z),
        fx.sub(1),
        fy.sub(1),
        fz
      ),
      mx_gradient_float(mx_hash_int(X, Y, Z.add(int(1))), fx, fy, fz.sub(1)),
      mx_gradient_float(
        mx_hash_int(X.add(int(1)), Y, Z.add(int(1))),
        fx.sub(1),
        fy,
        fz.sub(1)
      ),
      mx_gradient_float(
        mx_hash_int(X, Y.add(int(1)), Z.add(int(1))),
        fx,
        fy.sub(1),
        fz.sub(1)
      ),
      mx_gradient_float(
        mx_hash_int(X.add(int(1)), Y.add(int(1)), Z.add(int(1))),
        fx.sub(1),
        fy.sub(1),
        fz.sub(1)
      ),
      u2,
      v,
      w
    )
  ).toVar();
  return mx_gradient_scale3d(result);
}).setLayout({
  name: "mx_perlin_noise_float_1",
  type: "float",
  inputs: [{ name: "p", type: "vec3" }],
});
const mx_perlin_noise_float = /* @__PURE__ */ overloadingFn([
  mx_perlin_noise_float_0,
  mx_perlin_noise_float_1,
]);
const mx_perlin_noise_vec3_0 = /* @__PURE__ */ Fn(([p_immutable]) => {
  const p2 = vec2(p_immutable).toVar();
  const X = int().toVar(),
    Y = int().toVar();
  const fx = float(mx_floorfrac(p2.x, X)).toVar();
  const fy = float(mx_floorfrac(p2.y, Y)).toVar();
  const u2 = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const result = vec3(
    mx_bilerp(
      mx_gradient_vec3(mx_hash_vec3(X, Y), fx, fy),
      mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y), fx.sub(1), fy),
      mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1))), fx, fy.sub(1)),
      mx_gradient_vec3(
        mx_hash_vec3(X.add(int(1)), Y.add(int(1))),
        fx.sub(1),
        fy.sub(1)
      ),
      u2,
      v
    )
  ).toVar();
  return mx_gradient_scale2d(result);
}).setLayout({
  name: "mx_perlin_noise_vec3_0",
  type: "vec3",
  inputs: [{ name: "p", type: "vec2" }],
});
const mx_perlin_noise_vec3_1 = /* @__PURE__ */ Fn(([p_immutable]) => {
  const p2 = vec3(p_immutable).toVar();
  const X = int().toVar(),
    Y = int().toVar(),
    Z = int().toVar();
  const fx = float(mx_floorfrac(p2.x, X)).toVar();
  const fy = float(mx_floorfrac(p2.y, Y)).toVar();
  const fz = float(mx_floorfrac(p2.z, Z)).toVar();
  const u2 = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const w = float(mx_fade(fz)).toVar();
  const result = vec3(
    mx_trilerp(
      mx_gradient_vec3(mx_hash_vec3(X, Y, Z), fx, fy, fz),
      mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z), fx.sub(1), fy, fz),
      mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z), fx, fy.sub(1), fz),
      mx_gradient_vec3(
        mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z),
        fx.sub(1),
        fy.sub(1),
        fz
      ),
      mx_gradient_vec3(mx_hash_vec3(X, Y, Z.add(int(1))), fx, fy, fz.sub(1)),
      mx_gradient_vec3(
        mx_hash_vec3(X.add(int(1)), Y, Z.add(int(1))),
        fx.sub(1),
        fy,
        fz.sub(1)
      ),
      mx_gradient_vec3(
        mx_hash_vec3(X, Y.add(int(1)), Z.add(int(1))),
        fx,
        fy.sub(1),
        fz.sub(1)
      ),
      mx_gradient_vec3(
        mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z.add(int(1))),
        fx.sub(1),
        fy.sub(1),
        fz.sub(1)
      ),
      u2,
      v,
      w
    )
  ).toVar();
  return mx_gradient_scale3d(result);
}).setLayout({
  name: "mx_perlin_noise_vec3_1",
  type: "vec3",
  inputs: [{ name: "p", type: "vec3" }],
});
const mx_perlin_noise_vec3 = /* @__PURE__ */ overloadingFn([
  mx_perlin_noise_vec3_0,
  mx_perlin_noise_vec3_1,
]);
const mx_cell_noise_float_0 = /* @__PURE__ */ Fn(([p_immutable]) => {
  const p2 = float(p_immutable).toVar();
  const ix = int(mx_floor(p2)).toVar();
  return mx_bits_to_01(mx_hash_int(ix));
}).setLayout({
  name: "mx_cell_noise_float_0",
  type: "float",
  inputs: [{ name: "p", type: "float" }],
});
const mx_cell_noise_float_1 = /* @__PURE__ */ Fn(([p_immutable]) => {
  const p2 = vec2(p_immutable).toVar();
  const ix = int(mx_floor(p2.x)).toVar();
  const iy = int(mx_floor(p2.y)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy));
}).setLayout({
  name: "mx_cell_noise_float_1",
  type: "float",
  inputs: [{ name: "p", type: "vec2" }],
});
const mx_cell_noise_float_2 = /* @__PURE__ */ Fn(([p_immutable]) => {
  const p2 = vec3(p_immutable).toVar();
  const ix = int(mx_floor(p2.x)).toVar();
  const iy = int(mx_floor(p2.y)).toVar();
  const iz = int(mx_floor(p2.z)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}).setLayout({
  name: "mx_cell_noise_float_2",
  type: "float",
  inputs: [{ name: "p", type: "vec3" }],
});
const mx_cell_noise_float_3 = /* @__PURE__ */ Fn(([p_immutable]) => {
  const p2 = vec4(p_immutable).toVar();
  const ix = int(mx_floor(p2.x)).toVar();
  const iy = int(mx_floor(p2.y)).toVar();
  const iz = int(mx_floor(p2.z)).toVar();
  const iw = int(mx_floor(p2.w)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}).setLayout({
  name: "mx_cell_noise_float_3",
  type: "float",
  inputs: [{ name: "p", type: "vec4" }],
});
const mx_cell_noise_float$1 = /* @__PURE__ */ overloadingFn([
  mx_cell_noise_float_0,
  mx_cell_noise_float_1,
  mx_cell_noise_float_2,
  mx_cell_noise_float_3,
]);
const mx_cell_noise_vec3_0 = /* @__PURE__ */ Fn(([p_immutable]) => {
  const p2 = float(p_immutable).toVar();
  const ix = int(mx_floor(p2)).toVar();
  return vec3(
    mx_bits_to_01(mx_hash_int(ix, int(0))),
    mx_bits_to_01(mx_hash_int(ix, int(1))),
    mx_bits_to_01(mx_hash_int(ix, int(2)))
  );
}).setLayout({
  name: "mx_cell_noise_vec3_0",
  type: "vec3",
  inputs: [{ name: "p", type: "float" }],
});
const mx_cell_noise_vec3_1 = /* @__PURE__ */ Fn(([p_immutable]) => {
  const p2 = vec2(p_immutable).toVar();
  const ix = int(mx_floor(p2.x)).toVar();
  const iy = int(mx_floor(p2.y)).toVar();
  return vec3(
    mx_bits_to_01(mx_hash_int(ix, iy, int(0))),
    mx_bits_to_01(mx_hash_int(ix, iy, int(1))),
    mx_bits_to_01(mx_hash_int(ix, iy, int(2)))
  );
}).setLayout({
  name: "mx_cell_noise_vec3_1",
  type: "vec3",
  inputs: [{ name: "p", type: "vec2" }],
});
const mx_cell_noise_vec3_2 = /* @__PURE__ */ Fn(([p_immutable]) => {
  const p2 = vec3(p_immutable).toVar();
  const ix = int(mx_floor(p2.x)).toVar();
  const iy = int(mx_floor(p2.y)).toVar();
  const iz = int(mx_floor(p2.z)).toVar();
  return vec3(
    mx_bits_to_01(mx_hash_int(ix, iy, iz, int(0))),
    mx_bits_to_01(mx_hash_int(ix, iy, iz, int(1))),
    mx_bits_to_01(mx_hash_int(ix, iy, iz, int(2)))
  );
}).setLayout({
  name: "mx_cell_noise_vec3_2",
  type: "vec3",
  inputs: [{ name: "p", type: "vec3" }],
});
const mx_cell_noise_vec3_3 = /* @__PURE__ */ Fn(([p_immutable]) => {
  const p2 = vec4(p_immutable).toVar();
  const ix = int(mx_floor(p2.x)).toVar();
  const iy = int(mx_floor(p2.y)).toVar();
  const iz = int(mx_floor(p2.z)).toVar();
  const iw = int(mx_floor(p2.w)).toVar();
  return vec3(
    mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(0))),
    mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(1))),
    mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(2)))
  );
}).setLayout({
  name: "mx_cell_noise_vec3_3",
  type: "vec3",
  inputs: [{ name: "p", type: "vec4" }],
});
const mx_cell_noise_vec3 = /* @__PURE__ */ overloadingFn([
  mx_cell_noise_vec3_0,
  mx_cell_noise_vec3_1,
  mx_cell_noise_vec3_2,
  mx_cell_noise_vec3_3,
]);
const mx_fractal_noise_float$1 = /* @__PURE__ */ Fn(
  ([
    p_immutable,
    octaves_immutable,
    lacunarity_immutable,
    diminish_immutable,
  ]) => {
    const diminish = float(diminish_immutable).toVar();
    const lacunarity = float(lacunarity_immutable).toVar();
    const octaves = int(octaves_immutable).toVar();
    const p2 = vec3(p_immutable).toVar();
    const result = float(0).toVar();
    const amplitude = float(1).toVar();
    Loop(octaves, () => {
      result.addAssign(amplitude.mul(mx_perlin_noise_float(p2)));
      amplitude.mulAssign(diminish);
      p2.mulAssign(lacunarity);
    });
    return result;
  }
).setLayout({
  name: "mx_fractal_noise_float",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" },
  ],
});
const mx_fractal_noise_vec3$1 = /* @__PURE__ */ Fn(
  ([
    p_immutable,
    octaves_immutable,
    lacunarity_immutable,
    diminish_immutable,
  ]) => {
    const diminish = float(diminish_immutable).toVar();
    const lacunarity = float(lacunarity_immutable).toVar();
    const octaves = int(octaves_immutable).toVar();
    const p2 = vec3(p_immutable).toVar();
    const result = vec3(0).toVar();
    const amplitude = float(1).toVar();
    Loop(octaves, () => {
      result.addAssign(amplitude.mul(mx_perlin_noise_vec3(p2)));
      amplitude.mulAssign(diminish);
      p2.mulAssign(lacunarity);
    });
    return result;
  }
).setLayout({
  name: "mx_fractal_noise_vec3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" },
  ],
});
const mx_fractal_noise_vec2$1 = /* @__PURE__ */ Fn(
  ([
    p_immutable,
    octaves_immutable,
    lacunarity_immutable,
    diminish_immutable,
  ]) => {
    const diminish = float(diminish_immutable).toVar();
    const lacunarity = float(lacunarity_immutable).toVar();
    const octaves = int(octaves_immutable).toVar();
    const p2 = vec3(p_immutable).toVar();
    return vec2(
      mx_fractal_noise_float$1(p2, octaves, lacunarity, diminish),
      mx_fractal_noise_float$1(
        p2.add(vec3(int(19), int(193), int(17))),
        octaves,
        lacunarity,
        diminish
      )
    );
  }
).setLayout({
  name: "mx_fractal_noise_vec2",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" },
  ],
});
const mx_fractal_noise_vec4$1 = /* @__PURE__ */ Fn(
  ([
    p_immutable,
    octaves_immutable,
    lacunarity_immutable,
    diminish_immutable,
  ]) => {
    const diminish = float(diminish_immutable).toVar();
    const lacunarity = float(lacunarity_immutable).toVar();
    const octaves = int(octaves_immutable).toVar();
    const p2 = vec3(p_immutable).toVar();
    const c2 = vec3(
      mx_fractal_noise_vec3$1(p2, octaves, lacunarity, diminish)
    ).toVar();
    const f = float(
      mx_fractal_noise_float$1(
        p2.add(vec3(int(19), int(193), int(17))),
        octaves,
        lacunarity,
        diminish
      )
    ).toVar();
    return vec4(c2, f);
  }
).setLayout({
  name: "mx_fractal_noise_vec4",
  type: "vec4",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" },
  ],
});
const mx_worley_distance_0 = /* @__PURE__ */ Fn(
  ([
    p_immutable,
    x_immutable,
    y_immutable,
    xoff_immutable,
    yoff_immutable,
    jitter_immutable,
    metric_immutable,
  ]) => {
    const metric = int(metric_immutable).toVar();
    const jitter = float(jitter_immutable).toVar();
    const yoff = int(yoff_immutable).toVar();
    const xoff = int(xoff_immutable).toVar();
    const y = int(y_immutable).toVar();
    const x = int(x_immutable).toVar();
    const p2 = vec2(p_immutable).toVar();
    const tmp = vec3(
      mx_cell_noise_vec3(vec2(x.add(xoff), y.add(yoff)))
    ).toVar();
    const off = vec2(tmp.x, tmp.y).toVar();
    off.subAssign(0.5);
    off.mulAssign(jitter);
    off.addAssign(0.5);
    const cellpos = vec2(vec2(float(x), float(y)).add(off)).toVar();
    const diff = vec2(cellpos.sub(p2)).toVar();
    If(metric.equal(int(2)), () => {
      return abs(diff.x).add(abs(diff.y));
    });
    If(metric.equal(int(3)), () => {
      return max$1(abs(diff.x), abs(diff.y));
    });
    return dot(diff, diff);
  }
).setLayout({
  name: "mx_worley_distance_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
const mx_worley_distance_1 = /* @__PURE__ */ Fn(
  ([
    p_immutable,
    x_immutable,
    y_immutable,
    z_immutable,
    xoff_immutable,
    yoff_immutable,
    zoff_immutable,
    jitter_immutable,
    metric_immutable,
  ]) => {
    const metric = int(metric_immutable).toVar();
    const jitter = float(jitter_immutable).toVar();
    const zoff = int(zoff_immutable).toVar();
    const yoff = int(yoff_immutable).toVar();
    const xoff = int(xoff_immutable).toVar();
    const z = int(z_immutable).toVar();
    const y = int(y_immutable).toVar();
    const x = int(x_immutable).toVar();
    const p2 = vec3(p_immutable).toVar();
    const off = vec3(
      mx_cell_noise_vec3(vec3(x.add(xoff), y.add(yoff), z.add(zoff)))
    ).toVar();
    off.subAssign(0.5);
    off.mulAssign(jitter);
    off.addAssign(0.5);
    const cellpos = vec3(vec3(float(x), float(y), float(z)).add(off)).toVar();
    const diff = vec3(cellpos.sub(p2)).toVar();
    If(metric.equal(int(2)), () => {
      return abs(diff.x).add(abs(diff.y)).add(abs(diff.z));
    });
    If(metric.equal(int(3)), () => {
      return max$1(abs(diff.x), abs(diff.y), abs(diff.z));
    });
    return dot(diff, diff);
  }
).setLayout({
  name: "mx_worley_distance_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "zoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
const mx_worley_distance = /* @__PURE__ */ overloadingFn([
  mx_worley_distance_0,
  mx_worley_distance_1,
]);
const mx_worley_noise_float_0 = /* @__PURE__ */ Fn(
  ([p_immutable, jitter_immutable, metric_immutable]) => {
    const metric = int(metric_immutable).toVar();
    const jitter = float(jitter_immutable).toVar();
    const p2 = vec2(p_immutable).toVar();
    const X = int().toVar(),
      Y = int().toVar();
    const localpos = vec2(mx_floorfrac(p2.x, X), mx_floorfrac(p2.y, Y)).toVar();
    const sqdist = float(1e6).toVar();
    Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
      Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
        const dist = float(
          mx_worley_distance(localpos, x, y, X, Y, jitter, metric)
        ).toVar();
        sqdist.assign(min$1(sqdist, dist));
      });
    });
    If(metric.equal(int(0)), () => {
      sqdist.assign(sqrt(sqdist));
    });
    return sqdist;
  }
).setLayout({
  name: "mx_worley_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
const mx_worley_noise_vec2_0 = /* @__PURE__ */ Fn(
  ([p_immutable, jitter_immutable, metric_immutable]) => {
    const metric = int(metric_immutable).toVar();
    const jitter = float(jitter_immutable).toVar();
    const p2 = vec2(p_immutable).toVar();
    const X = int().toVar(),
      Y = int().toVar();
    const localpos = vec2(mx_floorfrac(p2.x, X), mx_floorfrac(p2.y, Y)).toVar();
    const sqdist = vec2(1e6, 1e6).toVar();
    Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
      Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
        const dist = float(
          mx_worley_distance(localpos, x, y, X, Y, jitter, metric)
        ).toVar();
        If(dist.lessThan(sqdist.x), () => {
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).ElseIf(dist.lessThan(sqdist.y), () => {
          sqdist.y.assign(dist);
        });
      });
    });
    If(metric.equal(int(0)), () => {
      sqdist.assign(sqrt(sqdist));
    });
    return sqdist;
  }
).setLayout({
  name: "mx_worley_noise_vec2_0",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
const mx_worley_noise_vec3_0 = /* @__PURE__ */ Fn(
  ([p_immutable, jitter_immutable, metric_immutable]) => {
    const metric = int(metric_immutable).toVar();
    const jitter = float(jitter_immutable).toVar();
    const p2 = vec2(p_immutable).toVar();
    const X = int().toVar(),
      Y = int().toVar();
    const localpos = vec2(mx_floorfrac(p2.x, X), mx_floorfrac(p2.y, Y)).toVar();
    const sqdist = vec3(1e6, 1e6, 1e6).toVar();
    Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
      Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
        const dist = float(
          mx_worley_distance(localpos, x, y, X, Y, jitter, metric)
        ).toVar();
        If(dist.lessThan(sqdist.x), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        })
          .ElseIf(dist.lessThan(sqdist.y), () => {
            sqdist.z.assign(sqdist.y);
            sqdist.y.assign(dist);
          })
          .ElseIf(dist.lessThan(sqdist.z), () => {
            sqdist.z.assign(dist);
          });
      });
    });
    If(metric.equal(int(0)), () => {
      sqdist.assign(sqrt(sqdist));
    });
    return sqdist;
  }
).setLayout({
  name: "mx_worley_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
const mx_worley_noise_float_1 = /* @__PURE__ */ Fn(
  ([p_immutable, jitter_immutable, metric_immutable]) => {
    const metric = int(metric_immutable).toVar();
    const jitter = float(jitter_immutable).toVar();
    const p2 = vec3(p_immutable).toVar();
    const X = int().toVar(),
      Y = int().toVar(),
      Z = int().toVar();
    const localpos = vec3(
      mx_floorfrac(p2.x, X),
      mx_floorfrac(p2.y, Y),
      mx_floorfrac(p2.z, Z)
    ).toVar();
    const sqdist = float(1e6).toVar();
    Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
      Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
        Loop(
          { start: -1, end: int(1), name: "z", condition: "<=" },
          ({ z }) => {
            const dist = float(
              mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)
            ).toVar();
            sqdist.assign(min$1(sqdist, dist));
          }
        );
      });
    });
    If(metric.equal(int(0)), () => {
      sqdist.assign(sqrt(sqdist));
    });
    return sqdist;
  }
).setLayout({
  name: "mx_worley_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
const mx_worley_noise_float$1 = /* @__PURE__ */ overloadingFn([
  mx_worley_noise_float_0,
  mx_worley_noise_float_1,
]);
const mx_worley_noise_vec2_1 = /* @__PURE__ */ Fn(
  ([p_immutable, jitter_immutable, metric_immutable]) => {
    const metric = int(metric_immutable).toVar();
    const jitter = float(jitter_immutable).toVar();
    const p2 = vec3(p_immutable).toVar();
    const X = int().toVar(),
      Y = int().toVar(),
      Z = int().toVar();
    const localpos = vec3(
      mx_floorfrac(p2.x, X),
      mx_floorfrac(p2.y, Y),
      mx_floorfrac(p2.z, Z)
    ).toVar();
    const sqdist = vec2(1e6, 1e6).toVar();
    Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
      Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
        Loop(
          { start: -1, end: int(1), name: "z", condition: "<=" },
          ({ z }) => {
            const dist = float(
              mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)
            ).toVar();
            If(dist.lessThan(sqdist.x), () => {
              sqdist.y.assign(sqdist.x);
              sqdist.x.assign(dist);
            }).ElseIf(dist.lessThan(sqdist.y), () => {
              sqdist.y.assign(dist);
            });
          }
        );
      });
    });
    If(metric.equal(int(0)), () => {
      sqdist.assign(sqrt(sqdist));
    });
    return sqdist;
  }
).setLayout({
  name: "mx_worley_noise_vec2_1",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
const mx_worley_noise_vec2$1 = /* @__PURE__ */ overloadingFn([
  mx_worley_noise_vec2_0,
  mx_worley_noise_vec2_1,
]);
const mx_worley_noise_vec3_1 = /* @__PURE__ */ Fn(
  ([p_immutable, jitter_immutable, metric_immutable]) => {
    const metric = int(metric_immutable).toVar();
    const jitter = float(jitter_immutable).toVar();
    const p2 = vec3(p_immutable).toVar();
    const X = int().toVar(),
      Y = int().toVar(),
      Z = int().toVar();
    const localpos = vec3(
      mx_floorfrac(p2.x, X),
      mx_floorfrac(p2.y, Y),
      mx_floorfrac(p2.z, Z)
    ).toVar();
    const sqdist = vec3(1e6, 1e6, 1e6).toVar();
    Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
      Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
        Loop(
          { start: -1, end: int(1), name: "z", condition: "<=" },
          ({ z }) => {
            const dist = float(
              mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)
            ).toVar();
            If(dist.lessThan(sqdist.x), () => {
              sqdist.z.assign(sqdist.y);
              sqdist.y.assign(sqdist.x);
              sqdist.x.assign(dist);
            })
              .ElseIf(dist.lessThan(sqdist.y), () => {
                sqdist.z.assign(sqdist.y);
                sqdist.y.assign(dist);
              })
              .ElseIf(dist.lessThan(sqdist.z), () => {
                sqdist.z.assign(dist);
              });
          }
        );
      });
    });
    If(metric.equal(int(0)), () => {
      sqdist.assign(sqrt(sqdist));
    });
    return sqdist;
  }
).setLayout({
  name: "mx_worley_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
const mx_worley_noise_vec3$1 = /* @__PURE__ */ overloadingFn([
  mx_worley_noise_vec3_0,
  mx_worley_noise_vec3_1,
]);
const mx_unifiednoise2d$1 = /* @__PURE__ */ Fn(
  ([
    noiseType_immutable,
    texcoord_immutable,
    freq_immutable,
    offset_immutable,
    jitter_immutable,
    outmin_immutable,
    outmax_immutable,
    clampoutput_immutable,
    octaves_immutable,
    lacunarity_immutable,
    diminish_immutable,
  ]) => {
    const noiseType = int(noiseType_immutable).toVar();
    const texcoord = vec2(texcoord_immutable).toVar();
    const freq = vec2(freq_immutable).toVar();
    const offset = vec2(offset_immutable).toVar();
    const jitter = float(jitter_immutable).toVar();
    const outmin = float(outmin_immutable).toVar();
    const outmax = float(outmax_immutable).toVar();
    const clampoutput = bool(clampoutput_immutable).toVar();
    const octaves = int(octaves_immutable).toVar();
    const lacunarity = float(lacunarity_immutable).toVar();
    const diminish = float(diminish_immutable).toVar();
    const p2 = texcoord.mul(freq).add(offset);
    const result = float(0).toVar();
    If(noiseType.equal(int(0)), () => {
      result.assign(mx_perlin_noise_vec3(p2));
    });
    If(noiseType.equal(int(1)), () => {
      result.assign(mx_cell_noise_vec3(p2));
    });
    If(noiseType.equal(int(2)), () => {
      result.assign(mx_worley_noise_vec3$1(p2, jitter, int(0)));
    });
    If(noiseType.equal(int(3)), () => {
      result.assign(
        mx_fractal_noise_vec3$1(vec3(p2, 0), octaves, lacunarity, diminish)
      );
    });
    result.assign(result.mul(outmax.sub(outmin)).add(outmin));
    If(clampoutput, () => {
      result.assign(clamp(result, outmin, outmax));
    });
    return result;
  }
).setLayout({
  name: "mx_unifiednoise2d",
  type: "float",
  inputs: [
    { name: "noiseType", type: "int" },
    { name: "texcoord", type: "vec2" },
    { name: "freq", type: "vec2" },
    { name: "offset", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "outmin", type: "float" },
    { name: "outmax", type: "float" },
    { name: "clampoutput", type: "bool" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" },
  ],
});
const mx_unifiednoise3d$1 = /* @__PURE__ */ Fn(
  ([
    noiseType_immutable,
    position_immutable,
    freq_immutable,
    offset_immutable,
    jitter_immutable,
    outmin_immutable,
    outmax_immutable,
    clampoutput_immutable,
    octaves_immutable,
    lacunarity_immutable,
    diminish_immutable,
  ]) => {
    const noiseType = int(noiseType_immutable).toVar();
    const position = vec3(position_immutable).toVar();
    const freq = vec3(freq_immutable).toVar();
    const offset = vec3(offset_immutable).toVar();
    const jitter = float(jitter_immutable).toVar();
    const outmin = float(outmin_immutable).toVar();
    const outmax = float(outmax_immutable).toVar();
    const clampoutput = bool(clampoutput_immutable).toVar();
    const octaves = int(octaves_immutable).toVar();
    const lacunarity = float(lacunarity_immutable).toVar();
    const diminish = float(diminish_immutable).toVar();
    const p2 = position.mul(freq).add(offset);
    const result = float(0).toVar();
    If(noiseType.equal(int(0)), () => {
      result.assign(mx_perlin_noise_vec3(p2));
    });
    If(noiseType.equal(int(1)), () => {
      result.assign(mx_cell_noise_vec3(p2));
    });
    If(noiseType.equal(int(2)), () => {
      result.assign(mx_worley_noise_vec3$1(p2, jitter, int(0)));
    });
    If(noiseType.equal(int(3)), () => {
      result.assign(mx_fractal_noise_vec3$1(p2, octaves, lacunarity, diminish));
    });
    result.assign(result.mul(outmax.sub(outmin)).add(outmin));
    If(clampoutput, () => {
      result.assign(clamp(result, outmin, outmax));
    });
    return result;
  }
).setLayout({
  name: "mx_unifiednoise3d",
  type: "float",
  inputs: [
    { name: "noiseType", type: "int" },
    { name: "position", type: "vec3" },
    { name: "freq", type: "vec3" },
    { name: "offset", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "outmin", type: "float" },
    { name: "outmax", type: "float" },
    { name: "clampoutput", type: "bool" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" },
  ],
});
const mx_hsvtorgb = /* @__PURE__ */ Fn(([hsv]) => {
  const s2 = hsv.y;
  const v = hsv.z;
  const result = vec3().toVar();
  If(s2.lessThan(1e-4), () => {
    result.assign(vec3(v, v, v));
  }).Else(() => {
    let h2 = hsv.x;
    h2 = h2.sub(floor(h2)).mul(6).toVar();
    const hi = int(trunc(h2));
    const f = h2.sub(float(hi));
    const p2 = v.mul(s2.oneMinus());
    const q = v.mul(s2.mul(f).oneMinus());
    const t2 = v.mul(s2.mul(f.oneMinus()).oneMinus());
    If(hi.equal(int(0)), () => {
      result.assign(vec3(v, t2, p2));
    })
      .ElseIf(hi.equal(int(1)), () => {
        result.assign(vec3(q, v, p2));
      })
      .ElseIf(hi.equal(int(2)), () => {
        result.assign(vec3(p2, v, t2));
      })
      .ElseIf(hi.equal(int(3)), () => {
        result.assign(vec3(p2, q, v));
      })
      .ElseIf(hi.equal(int(4)), () => {
        result.assign(vec3(t2, p2, v));
      })
      .Else(() => {
        result.assign(vec3(v, p2, q));
      });
  });
  return result;
}).setLayout({
  name: "mx_hsvtorgb",
  type: "vec3",
  inputs: [{ name: "hsv", type: "vec3" }],
});
const mx_rgbtohsv = /* @__PURE__ */ Fn(([c_immutable]) => {
  const c2 = vec3(c_immutable).toVar();
  const r2 = float(c2.x).toVar();
  const g2 = float(c2.y).toVar();
  const b = float(c2.z).toVar();
  const mincomp = float(min$1(r2, min$1(g2, b))).toVar();
  const maxcomp = float(max$1(r2, max$1(g2, b))).toVar();
  const delta = float(maxcomp.sub(mincomp)).toVar();
  const h2 = float().toVar(),
    s2 = float().toVar(),
    v = float().toVar();
  v.assign(maxcomp);
  If(maxcomp.greaterThan(0), () => {
    s2.assign(delta.div(maxcomp));
  }).Else(() => {
    s2.assign(0);
  });
  If(s2.lessThanEqual(0), () => {
    h2.assign(0);
  }).Else(() => {
    If(r2.greaterThanEqual(maxcomp), () => {
      h2.assign(g2.sub(b).div(delta));
    })
      .ElseIf(g2.greaterThanEqual(maxcomp), () => {
        h2.assign(add(2, b.sub(r2).div(delta)));
      })
      .Else(() => {
        h2.assign(add(4, r2.sub(g2).div(delta)));
      });
    h2.mulAssign(1 / 6);
    If(h2.lessThan(0), () => {
      h2.addAssign(1);
    });
  });
  return vec3(h2, s2, v);
}).setLayout({
  name: "mx_rgbtohsv",
  type: "vec3",
  inputs: [{ name: "c", type: "vec3" }],
});
const mx_srgb_texture_to_lin_rec709 = /* @__PURE__ */ Fn(
  ([color_immutable]) => {
    const color2 = vec3(color_immutable).toVar();
    const isAbove = bvec3(greaterThan(color2, vec3(0.04045))).toVar();
    const linSeg = vec3(color2.div(12.92)).toVar();
    const powSeg = vec3(
      pow(max$1(color2.add(vec3(0.055)), vec3(0)).div(1.055), vec3(2.4))
    ).toVar();
    return mix$1(linSeg, powSeg, isAbove);
  }
).setLayout({
  name: "mx_srgb_texture_to_lin_rec709",
  type: "vec3",
  inputs: [{ name: "color", type: "vec3" }],
});
const mx_aastep = (threshold, value) => {
  threshold = float(threshold);
  value = float(value);
  const afwidth = vec2(value.dFdx(), value.dFdy())
    .length()
    .mul(0.7071067811865476);
  return smoothstep(threshold.sub(afwidth), threshold.add(afwidth), value);
};
const _ramp = (a2, b, uv2, p2) => mix$1(a2, b, uv2[p2].clamp());
const mx_ramplr = (valuel, valuer, texcoord = uv$1()) =>
  _ramp(valuel, valuer, texcoord, "x");
const mx_ramptb = (valuet, valueb, texcoord = uv$1()) =>
  _ramp(valuet, valueb, texcoord, "y");
const mx_ramp4 = (valuetl, valuetr, valuebl, valuebr, texcoord = uv$1()) => {
  const u2 = texcoord.x.clamp();
  const v = texcoord.y.clamp();
  const top = mix$1(valuetl, valuetr, u2);
  const bottom = mix$1(valuebl, valuebr, u2);
  return mix$1(top, bottom, v);
};
const _split = (a2, b, center, uv2, p2) =>
  mix$1(a2, b, mx_aastep(center, uv2[p2]));
const mx_splitlr = (valuel, valuer, center, texcoord = uv$1()) =>
  _split(valuel, valuer, center, texcoord, "x");
const mx_splittb = (valuet, valueb, center, texcoord = uv$1()) =>
  _split(valuet, valueb, center, texcoord, "y");
const mx_transform_uv = (uv_scale = 1, uv_offset = 0, uv_geo = uv$1()) =>
  uv_geo.mul(uv_scale).add(uv_offset);
const mx_safepower = (in1, in2 = 1) => {
  in1 = float(in1);
  return in1.abs().pow(in2).mul(in1.sign());
};
const mx_contrast = (input, amount = 1, pivot = 0.5) =>
  float(input).sub(pivot).mul(amount).add(pivot);
const mx_noise_float = (texcoord = uv$1(), amplitude = 1, pivot = 0) =>
  mx_perlin_noise_float(texcoord.convert("vec2|vec3"))
    .mul(amplitude)
    .add(pivot);
const mx_noise_vec3 = (texcoord = uv$1(), amplitude = 1, pivot = 0) =>
  mx_perlin_noise_vec3(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
const mx_noise_vec4 = (texcoord = uv$1(), amplitude = 1, pivot = 0) => {
  texcoord = texcoord.convert("vec2|vec3");
  const noise_vec4 = vec4(
    mx_perlin_noise_vec3(texcoord),
    mx_perlin_noise_float(texcoord.add(vec2(19, 73)))
  );
  return noise_vec4.mul(amplitude).add(pivot);
};
const mx_unifiednoise2d = (
  noiseType,
  texcoord = uv$1(),
  freq = vec2(1, 1),
  offset = vec2(0, 0),
  jitter = 1,
  outmin = 0,
  outmax = 1,
  clampoutput = false,
  octaves = 1,
  lacunarity = 2,
  diminish = 0.5
) =>
  mx_unifiednoise2d$1(
    noiseType,
    texcoord.convert("vec2|vec3"),
    freq,
    offset,
    jitter,
    outmin,
    outmax,
    clampoutput,
    octaves,
    lacunarity,
    diminish
  );
const mx_unifiednoise3d = (
  noiseType,
  texcoord = uv$1(),
  freq = vec2(1, 1),
  offset = vec2(0, 0),
  jitter = 1,
  outmin = 0,
  outmax = 1,
  clampoutput = false,
  octaves = 1,
  lacunarity = 2,
  diminish = 0.5
) =>
  mx_unifiednoise3d$1(
    noiseType,
    texcoord.convert("vec2|vec3"),
    freq,
    offset,
    jitter,
    outmin,
    outmax,
    clampoutput,
    octaves,
    lacunarity,
    diminish
  );
const mx_worley_noise_float = (texcoord = uv$1(), jitter = 1) =>
  mx_worley_noise_float$1(texcoord.convert("vec2|vec3"), jitter, int(1));
const mx_worley_noise_vec2 = (texcoord = uv$1(), jitter = 1) =>
  mx_worley_noise_vec2$1(texcoord.convert("vec2|vec3"), jitter, int(1));
const mx_worley_noise_vec3 = (texcoord = uv$1(), jitter = 1) =>
  mx_worley_noise_vec3$1(texcoord.convert("vec2|vec3"), jitter, int(1));
const mx_cell_noise_float = (texcoord = uv$1()) =>
  mx_cell_noise_float$1(texcoord.convert("vec2|vec3"));
const mx_fractal_noise_float = (
  position = uv$1(),
  octaves = 3,
  lacunarity = 2,
  diminish = 0.5,
  amplitude = 1
) =>
  mx_fractal_noise_float$1(position, int(octaves), lacunarity, diminish).mul(
    amplitude
  );
const mx_fractal_noise_vec2 = (
  position = uv$1(),
  octaves = 3,
  lacunarity = 2,
  diminish = 0.5,
  amplitude = 1
) =>
  mx_fractal_noise_vec2$1(position, int(octaves), lacunarity, diminish).mul(
    amplitude
  );
const mx_fractal_noise_vec3 = (
  position = uv$1(),
  octaves = 3,
  lacunarity = 2,
  diminish = 0.5,
  amplitude = 1
) =>
  mx_fractal_noise_vec3$1(position, int(octaves), lacunarity, diminish).mul(
    amplitude
  );
const mx_fractal_noise_vec4 = (
  position = uv$1(),
  octaves = 3,
  lacunarity = 2,
  diminish = 0.5,
  amplitude = 1
) =>
  mx_fractal_noise_vec4$1(position, int(octaves), lacunarity, diminish).mul(
    amplitude
  );
const mx_add = (in1, in2 = float(0)) => add(in1, in2);
const mx_subtract = (in1, in2 = float(0)) => sub(in1, in2);
const mx_multiply = (in1, in2 = float(1)) => mul(in1, in2);
const mx_divide = (in1, in2 = float(1)) => div(in1, in2);
const mx_modulo = (in1, in2 = float(1)) => mod(in1, in2);
const mx_power = (in1, in2 = float(1)) => pow(in1, in2);
const mx_atan2 = (in1 = float(0), in2 = float(1)) => atan(in1, in2);
const mx_timer = () => time$1;
const mx_frame = () => frameId;
const mx_invert = (in1, amount = float(1)) => sub(amount, in1);
const mx_ifgreater = (value1, value2, in1, in2) =>
  value1.greaterThan(value2).mix(in1, in2);
const mx_ifgreatereq = (value1, value2, in1, in2) =>
  value1.greaterThanEqual(value2).mix(in1, in2);
const mx_ifequal = (value1, value2, in1, in2) =>
  value1.equal(value2).mix(in1, in2);
const mx_separate = (in1, channelOrOut = null) => {
  if (typeof channelOrOut === "string") {
    const map = { x: 0, r: 0, y: 1, g: 1, z: 2, b: 2, w: 3, a: 3 };
    const c2 = channelOrOut.replace(/^out/, "").toLowerCase();
    if (map[c2] !== void 0) return in1.element(map[c2]);
  }
  if (typeof channelOrOut === "number") {
    return in1.element(channelOrOut);
  }
  if (typeof channelOrOut === "string" && channelOrOut.length === 1) {
    const map = { x: 0, r: 0, y: 1, g: 1, z: 2, b: 2, w: 3, a: 3 };
    if (map[channelOrOut] !== void 0) return in1.element(map[channelOrOut]);
  }
  return in1;
};
const mx_place2d = (
  texcoord,
  pivot = vec2(0.5, 0.5),
  scale2 = vec2(1, 1),
  rotate2 = float(0),
  offset = vec2(0, 0)
) => {
  let uv2 = texcoord;
  if (pivot) uv2 = uv2.sub(pivot);
  if (scale2) uv2 = uv2.mul(scale2);
  if (rotate2) {
    const rad = rotate2.mul(Math.PI / 180);
    const cosR = rad.cos();
    const sinR = rad.sin();
    uv2 = vec2(
      uv2.x.mul(cosR).sub(uv2.y.mul(sinR)),
      uv2.x.mul(sinR).add(uv2.y.mul(cosR))
    );
  }
  if (pivot) uv2 = uv2.add(pivot);
  if (offset) uv2 = uv2.add(offset);
  return uv2;
};
const mx_rotate2d = (input, amount) => {
  input = vec2(input);
  amount = float(amount);
  const radians2 = amount.mul(Math.PI / 180);
  return rotate(input, radians2);
};
const mx_rotate3d = (input, amount, axis) => {
  input = vec3(input);
  amount = float(amount);
  axis = vec3(axis);
  const radians2 = amount.mul(Math.PI / 180);
  const nAxis = axis.normalize();
  const cosA = radians2.cos();
  const sinA = radians2.sin();
  const oneMinusCosA = float(1).sub(cosA);
  const rot = input
    .mul(cosA)
    .add(nAxis.cross(input).mul(sinA))
    .add(nAxis.mul(nAxis.dot(input)).mul(oneMinusCosA));
  return rot;
};
const mx_heighttonormal = (input, scale2) => {
  input = vec3(input);
  scale2 = float(scale2);
  return bumpMap(input, scale2);
};
const getParallaxCorrectNormal = /* @__PURE__ */ Fn(
  ([normal2, cubeSize, cubePos]) => {
    const nDir = normalize(normal2).toVar();
    const rbmax = sub(float(0.5).mul(cubeSize.sub(cubePos)), positionWorld)
      .div(nDir)
      .toVar();
    const rbmin = sub(float(-0.5).mul(cubeSize.sub(cubePos)), positionWorld)
      .div(nDir)
      .toVar();
    const rbminmax = vec3().toVar();
    rbminmax.x = nDir.x.greaterThan(float(0)).select(rbmax.x, rbmin.x);
    rbminmax.y = nDir.y.greaterThan(float(0)).select(rbmax.y, rbmin.y);
    rbminmax.z = nDir.z.greaterThan(float(0)).select(rbmax.z, rbmin.z);
    const correction = min$1(rbminmax.x, rbminmax.y, rbminmax.z).toVar();
    const boxIntersection = positionWorld.add(nDir.mul(correction)).toVar();
    return boxIntersection.sub(cubePos);
  }
);
const getShIrradianceAt = /* @__PURE__ */ Fn(([normal2, shCoefficients]) => {
  const x = normal2.x,
    y = normal2.y,
    z = normal2.z;
  let result = shCoefficients.element(0).mul(0.886227);
  result = result.add(
    shCoefficients
      .element(1)
      .mul(2 * 0.511664)
      .mul(y)
  );
  result = result.add(
    shCoefficients
      .element(2)
      .mul(2 * 0.511664)
      .mul(z)
  );
  result = result.add(
    shCoefficients
      .element(3)
      .mul(2 * 0.511664)
      .mul(x)
  );
  result = result.add(
    shCoefficients
      .element(4)
      .mul(2 * 0.429043)
      .mul(x)
      .mul(y)
  );
  result = result.add(
    shCoefficients
      .element(5)
      .mul(2 * 0.429043)
      .mul(y)
      .mul(z)
  );
  result = result.add(
    shCoefficients.element(6).mul(z.mul(z).mul(0.743125).sub(0.247708))
  );
  result = result.add(
    shCoefficients
      .element(7)
      .mul(2 * 0.429043)
      .mul(x)
      .mul(z)
  );
  result = result.add(
    shCoefficients
      .element(8)
      .mul(0.429043)
      .mul(mul(x, x).sub(mul(y, y)))
  );
  return result;
});
var TSL = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BRDF_GGX,
  BRDF_Lambert,
  BasicPointShadowFilter,
  BasicShadowFilter,
  Break,
  Const,
  Continue,
  DFGApprox,
  D_GGX,
  Discard,
  EPSILON,
  F_Schlick,
  Fn,
  INFINITY,
  If,
  Loop,
  NodeAccess,
  NodeShaderStage,
  NodeType,
  NodeUpdateType,
  OnMaterialUpdate,
  OnObjectUpdate,
  PCFShadowFilter,
  PCFSoftShadowFilter,
  PI,
  PI2,
  PointShadowFilter,
  Return,
  Schlick_to_F0,
  ScriptableNodeResources,
  ShaderNode,
  Stack,
  Switch,
  TBNViewMatrix,
  VSMShadowFilter,
  V_GGX_SmithCorrelated,
  Var,
  VarIntent,
  abs,
  acesFilmicToneMapping,
  acos,
  add,
  addMethodChaining,
  addNodeElement,
  agxToneMapping,
  all,
  alphaT,
  and,
  anisotropy,
  anisotropyB,
  anisotropyT,
  any,
  append,
  array,
  arrayBuffer,
  asin,
  assign,
  atan,
  atan2,
  atomicAdd,
  atomicAnd,
  atomicFunc,
  atomicLoad,
  atomicMax,
  atomicMin,
  atomicOr,
  atomicStore,
  atomicSub,
  atomicXor,
  attenuationColor,
  attenuationDistance,
  attribute,
  attributeArray,
  backgroundBlurriness,
  backgroundIntensity,
  backgroundRotation,
  batch,
  bentNormalView,
  billboarding,
  bitAnd,
  bitNot,
  bitOr,
  bitXor,
  bitangentGeometry,
  bitangentLocal,
  bitangentView,
  bitangentWorld,
  bitcast,
  blendBurn,
  blendColor,
  blendDodge,
  blendOverlay,
  blendScreen,
  blur,
  bool,
  buffer,
  bufferAttribute,
  bumpMap,
  burn,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  cache,
  call,
  cameraFar,
  cameraIndex,
  cameraNear,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraProjectionMatrixInverse,
  cameraViewMatrix,
  cameraWorldMatrix,
  cbrt,
  cdl,
  ceil,
  checker,
  cineonToneMapping,
  clamp,
  clearcoat,
  clearcoatNormalView,
  clearcoatRoughness,
  code,
  color: color$1,
  colorSpaceToWorking,
  colorToDirection,
  compute,
  computeKernel,
  computeSkinning,
  context,
  convert,
  convertColorSpace,
  convertToTexture,
  cos,
  cross,
  cubeTexture,
  cubeTextureBase,
  cubeToUV,
  dFdx,
  dFdy,
  dashSize,
  debug,
  decrement,
  decrementBefore,
  defaultBuildStages,
  defaultShaderStages,
  defined,
  degrees,
  deltaTime,
  densityFog,
  densityFogFactor,
  depth,
  depthPass,
  determinant,
  difference,
  diffuseColor,
  directPointLight,
  directionToColor,
  directionToFaceDirection,
  dispersion,
  distance,
  div,
  dodge,
  dot,
  drawIndex,
  dynamicBufferAttribute,
  element,
  emissive,
  equal,
  equals,
  equirectUV,
  exp,
  exp2,
  expression,
  faceDirection,
  faceForward,
  faceforward,
  float,
  floor,
  fog,
  fract,
  frameGroup,
  frameId,
  frontFacing,
  fwidth,
  gain,
  gapSize,
  getConstNodeType,
  getCurrentStack,
  getDirection,
  getDistanceAttenuation,
  getGeometryRoughness,
  getNormalFromDepth,
  getParallaxCorrectNormal,
  getRoughness,
  getScreenPosition,
  getShIrradianceAt,
  getShadowMaterial,
  getShadowRenderObjectFunction,
  getTextureIndex,
  getViewPosition,
  globalId,
  glsl,
  glslFn,
  grayscale,
  greaterThan,
  greaterThanEqual,
  hash,
  highpModelNormalViewMatrix,
  highpModelViewMatrix,
  hue,
  increment,
  incrementBefore,
  instance,
  instanceIndex,
  instancedArray,
  instancedBufferAttribute,
  instancedDynamicBufferAttribute,
  instancedMesh,
  int,
  inverse,
  inverseSqrt,
  inversesqrt,
  invocationLocalIndex,
  invocationSubgroupIndex,
  ior,
  iridescence,
  iridescenceIOR,
  iridescenceThickness,
  ivec2,
  ivec3,
  ivec4,
  js,
  label,
  length,
  lengthSq,
  lessThan,
  lessThanEqual,
  lightPosition,
  lightProjectionUV,
  lightShadowMatrix,
  lightTargetDirection,
  lightTargetPosition,
  lightViewPosition,
  lightingContext,
  lights,
  linearDepth,
  linearToneMapping,
  localId,
  log,
  log2,
  logarithmicDepthToViewZ,
  luminance,
  mat2,
  mat3,
  mat4,
  matcapUV,
  materialAO,
  materialAlphaTest,
  materialAnisotropy,
  materialAnisotropyVector,
  materialAttenuationColor,
  materialAttenuationDistance,
  materialClearcoat,
  materialClearcoatNormal,
  materialClearcoatRoughness,
  materialColor,
  materialDispersion,
  materialEmissive,
  materialEnvIntensity,
  materialEnvRotation,
  materialIOR,
  materialIridescence,
  materialIridescenceIOR,
  materialIridescenceThickness,
  materialLightMap,
  materialLineDashOffset,
  materialLineDashSize,
  materialLineGapSize,
  materialLineScale,
  materialLineWidth,
  materialMetalness,
  materialNormal,
  materialOpacity,
  materialPointSize,
  materialReference,
  materialReflectivity,
  materialRefractionRatio,
  materialRotation,
  materialRoughness,
  materialSheen,
  materialSheenRoughness,
  materialShininess,
  materialSpecular,
  materialSpecularColor,
  materialSpecularIntensity,
  materialSpecularStrength,
  materialThickness,
  materialTransmission,
  max: max$1,
  maxMipLevel,
  mediumpModelViewMatrix,
  metalness,
  min: min$1,
  mix: mix$1,
  mixElement,
  mod,
  modInt,
  modelDirection,
  modelNormalMatrix,
  modelPosition,
  modelRadius,
  modelScale,
  modelViewMatrix,
  modelViewPosition,
  modelViewProjection,
  modelWorldMatrix,
  modelWorldMatrixInverse,
  morphReference,
  mrt,
  mul,
  mx_aastep,
  mx_add,
  mx_atan2,
  mx_cell_noise_float,
  mx_contrast,
  mx_divide,
  mx_fractal_noise_float,
  mx_fractal_noise_vec2,
  mx_fractal_noise_vec3,
  mx_fractal_noise_vec4,
  mx_frame,
  mx_heighttonormal,
  mx_hsvtorgb,
  mx_ifequal,
  mx_ifgreater,
  mx_ifgreatereq,
  mx_invert,
  mx_modulo,
  mx_multiply,
  mx_noise_float,
  mx_noise_vec3,
  mx_noise_vec4,
  mx_place2d,
  mx_power,
  mx_ramp4,
  mx_ramplr,
  mx_ramptb,
  mx_rgbtohsv,
  mx_rotate2d,
  mx_rotate3d,
  mx_safepower,
  mx_separate,
  mx_splitlr,
  mx_splittb,
  mx_srgb_texture_to_lin_rec709,
  mx_subtract,
  mx_timer,
  mx_transform_uv,
  mx_unifiednoise2d,
  mx_unifiednoise3d,
  mx_worley_noise_float,
  mx_worley_noise_vec2,
  mx_worley_noise_vec3,
  negate,
  neutralToneMapping,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjectIntent,
  nodeObjects,
  nodeProxy,
  nodeProxyIntent,
  normalFlat,
  normalGeometry,
  normalLocal,
  normalMap,
  normalView,
  normalViewGeometry,
  normalWorld,
  normalWorldGeometry,
  normalize,
  not,
  notEqual,
  numWorkgroups,
  objectDirection,
  objectGroup,
  objectPosition,
  objectRadius,
  objectScale,
  objectViewPosition,
  objectWorldMatrix,
  oneMinus,
  or,
  orthographicDepthToViewZ,
  oscSawtooth,
  oscSine,
  oscSquare,
  oscTriangle,
  output,
  outputStruct,
  overlay,
  overloadingFn,
  parabola,
  parallaxDirection,
  parallaxUV,
  parameter,
  pass,
  passTexture,
  pcurve,
  perspectiveDepthToViewZ,
  pmremTexture,
  pointShadow,
  pointUV,
  pointWidth,
  positionGeometry,
  positionLocal: positionLocal$1,
  positionPrevious,
  positionView,
  positionViewDirection,
  positionWorld,
  positionWorldDirection,
  posterize,
  pow,
  pow2,
  pow3,
  pow4,
  premultiplyAlpha,
  property,
  radians,
  rand,
  range: range$1,
  rangeFog,
  rangeFogFactor,
  reciprocal,
  reference,
  referenceBuffer,
  reflect,
  reflectVector,
  reflectView,
  reflector,
  refract,
  refractVector,
  refractView,
  reinhardToneMapping,
  remap,
  remapClamp,
  renderGroup,
  renderOutput,
  rendererReference,
  rotate,
  rotateUV: rotateUV$1,
  roughness,
  round,
  rtt,
  sRGBTransferEOTF,
  sRGBTransferOETF,
  sample,
  sampler,
  samplerComparison,
  saturate,
  saturation,
  screen,
  screenCoordinate,
  screenSize,
  screenUV,
  scriptable,
  scriptableValue,
  select,
  setCurrentStack,
  setName,
  shaderStages,
  shadow,
  shadowPositionWorld,
  shapeCircle,
  sharedUniformGroup,
  sheen,
  sheenRoughness,
  shiftLeft,
  shiftRight,
  shininess,
  sign,
  sin,
  sinc,
  skinning,
  smoothstep,
  smoothstepElement,
  specularColor,
  specularF90,
  spherizeUV,
  split,
  spritesheetUV,
  sqrt,
  stack,
  step,
  stepElement,
  storage,
  storageBarrier,
  storageObject,
  storageTexture,
  string,
  struct,
  sub,
  subBuild,
  subgroupIndex,
  subgroupSize,
  tan,
  tangentGeometry,
  tangentLocal,
  tangentView,
  tangentWorld,
  temp,
  texture: texture$1,
  texture3D,
  textureBarrier,
  textureBicubic,
  textureBicubicLevel,
  textureCubeUV,
  textureLoad,
  textureSize,
  textureStore,
  thickness,
  time: time$1,
  timerDelta,
  timerGlobal,
  timerLocal,
  toneMapping,
  toneMappingExposure,
  toonOutlinePass,
  transformDirection,
  transformNormal,
  transformNormalToView,
  transformedClearcoatNormalView,
  transformedNormalView,
  transformedNormalWorld,
  transmission,
  transpose,
  triNoise3D,
  triplanarTexture,
  triplanarTextures,
  trunc,
  uint,
  uniform: uniform$1,
  uniformArray,
  uniformCubeTexture,
  uniformGroup,
  uniformTexture,
  unpremultiplyAlpha,
  userData,
  uv: uv$1,
  uvec2,
  uvec3,
  uvec4,
  varying,
  varyingProperty,
  vec2,
  vec3,
  vec4,
  vectorComponents,
  velocity,
  vertexColor,
  vertexIndex,
  vertexStage,
  vibrance,
  viewZToLogarithmicDepth,
  viewZToOrthographicDepth,
  viewZToPerspectiveDepth,
  viewport,
  viewportCoordinate,
  viewportDepthTexture,
  viewportLinearDepth,
  viewportMipTexture,
  viewportResolution,
  viewportSafeUV,
  viewportSharedTexture,
  viewportSize,
  viewportTexture,
  viewportUV,
  wgsl,
  wgslFn,
  workgroupArray,
  workgroupBarrier,
  workgroupId,
  workingToColorSpace,
  xor,
});
const _clearColor = /* @__PURE__ */ new Color4();
class Background extends DataMap {
  /**
   * Constructs a new background management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   */
  constructor(renderer2, nodes) {
    super();
    this.renderer = renderer2;
    this.nodes = nodes;
  }
  /**
   * Updates the background for the given scene. Depending on how `Scene.background`
   * or `Scene.backgroundNode` are configured, this method might configure a simple clear
   * or add a mesh to the render list for rendering the background as a textured plane
   * or skybox.
   *
   * @param {Scene} scene - The scene.
   * @param {RenderList} renderList - The current render list.
   * @param {RenderContext} renderContext - The current render context.
   */
  update(scene2, renderList, renderContext) {
    const renderer2 = this.renderer;
    const background =
      this.nodes.getBackgroundNode(scene2) || scene2.background;
    let forceClear = false;
    if (background === null) {
      renderer2._clearColor.getRGB(_clearColor);
      _clearColor.a = renderer2._clearColor.a;
    } else if (background.isColor === true) {
      background.getRGB(_clearColor);
      _clearColor.a = 1;
      forceClear = true;
    } else if (background.isNode === true) {
      const sceneData = this.get(scene2);
      const backgroundNode = background;
      _clearColor.copy(renderer2._clearColor);
      let backgroundMesh = sceneData.backgroundMesh;
      if (backgroundMesh === void 0) {
        let onBackgroundDispose = function () {
          background.removeEventListener("dispose", onBackgroundDispose);
          backgroundMesh.material.dispose();
          backgroundMesh.geometry.dispose();
        };
        const backgroundMeshNode = context(
          vec4(backgroundNode).mul(backgroundIntensity),
          {
            // @TODO: Add Texture2D support using node context
            getUV: () => backgroundRotation.mul(normalWorldGeometry),
            getTextureLevel: () => backgroundBlurriness,
          }
        );
        let viewProj = modelViewProjection;
        viewProj = viewProj.setZ(viewProj.w);
        const nodeMaterial = new NodeMaterial();
        nodeMaterial.name = "Background.material";
        nodeMaterial.side = BackSide;
        nodeMaterial.depthTest = false;
        nodeMaterial.depthWrite = false;
        nodeMaterial.allowOverride = false;
        nodeMaterial.fog = false;
        nodeMaterial.lights = false;
        nodeMaterial.vertexNode = viewProj;
        nodeMaterial.colorNode = backgroundMeshNode;
        sceneData.backgroundMeshNode = backgroundMeshNode;
        sceneData.backgroundMesh = backgroundMesh = new Mesh(
          new SphereGeometry(1, 32, 32),
          nodeMaterial
        );
        backgroundMesh.frustumCulled = false;
        backgroundMesh.name = "Background.mesh";
        backgroundMesh.onBeforeRender = function (renderer3, scene3, camera2) {
          this.matrixWorld.copyPosition(camera2.matrixWorld);
        };
        background.addEventListener("dispose", onBackgroundDispose);
      }
      const backgroundCacheKey = backgroundNode.getCacheKey();
      if (sceneData.backgroundCacheKey !== backgroundCacheKey) {
        sceneData.backgroundMeshNode.node =
          vec4(backgroundNode).mul(backgroundIntensity);
        sceneData.backgroundMeshNode.needsUpdate = true;
        backgroundMesh.material.needsUpdate = true;
        sceneData.backgroundCacheKey = backgroundCacheKey;
      }
      renderList.unshift(
        backgroundMesh,
        backgroundMesh.geometry,
        backgroundMesh.material,
        0,
        0,
        null,
        null
      );
    } else {
      console.error(
        "THREE.Renderer: Unsupported background configuration.",
        background
      );
    }
    const environmentBlendMode = renderer2.xr.getEnvironmentBlendMode();
    if (environmentBlendMode === "additive") {
      _clearColor.set(0, 0, 0, 1);
    } else if (environmentBlendMode === "alpha-blend") {
      _clearColor.set(0, 0, 0, 0);
    }
    if (renderer2.autoClear === true || forceClear === true) {
      const clearColorValue = renderContext.clearColorValue;
      clearColorValue.r = _clearColor.r;
      clearColorValue.g = _clearColor.g;
      clearColorValue.b = _clearColor.b;
      clearColorValue.a = _clearColor.a;
      if (
        renderer2.backend.isWebGLBackend === true ||
        renderer2.alpha === true
      ) {
        clearColorValue.r *= clearColorValue.a;
        clearColorValue.g *= clearColorValue.a;
        clearColorValue.b *= clearColorValue.a;
      }
      renderContext.depthClearValue = renderer2._clearDepth;
      renderContext.stencilClearValue = renderer2._clearStencil;
      renderContext.clearColor = renderer2.autoClearColor === true;
      renderContext.clearDepth = renderer2.autoClearDepth === true;
      renderContext.clearStencil = renderer2.autoClearStencil === true;
    } else {
      renderContext.clearColor = false;
      renderContext.clearDepth = false;
      renderContext.clearStencil = false;
    }
  }
}
let _id$6 = 0;
class BindGroup {
  /**
   * Constructs a new bind group.
   *
   * @param {string} name - The bind group's name.
   * @param {Array<Binding>} bindings - An array of bindings.
   * @param {number} index - The group index.
   * @param {Array<Binding>} bindingsReference - An array of reference bindings.
   */
  constructor(name = "", bindings = [], index = 0, bindingsReference = []) {
    this.name = name;
    this.bindings = bindings;
    this.index = index;
    this.bindingsReference = bindingsReference;
    this.id = _id$6++;
  }
}
class NodeBuilderState {
  /**
   * Constructs a new node builder state.
   *
   * @param {string} vertexShader - The native vertex shader code.
   * @param {string} fragmentShader - The native fragment shader code.
   * @param {string} computeShader - The native compute shader code.
   * @param {Array<NodeAttribute>} nodeAttributes - An array of node attributes.
   * @param {Array<BindGroup>} bindings - An array of bind groups.
   * @param {Array<Node>} updateNodes - An array of nodes that implement their `update()` method.
   * @param {Array<Node>} updateBeforeNodes - An array of nodes that implement their `updateBefore()` method.
   * @param {Array<Node>} updateAfterNodes - An array of nodes that implement their `updateAfter()` method.
   * @param {NodeMaterialObserver} observer - A node material observer.
   * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.
   */
  constructor(
    vertexShader,
    fragmentShader,
    computeShader,
    nodeAttributes,
    bindings,
    updateNodes,
    updateBeforeNodes,
    updateAfterNodes,
    observer,
    transforms = []
  ) {
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    this.computeShader = computeShader;
    this.transforms = transforms;
    this.nodeAttributes = nodeAttributes;
    this.bindings = bindings;
    this.updateNodes = updateNodes;
    this.updateBeforeNodes = updateBeforeNodes;
    this.updateAfterNodes = updateAfterNodes;
    this.observer = observer;
    this.usedTimes = 0;
  }
  /**
   * This method is used to create a array of bind groups based
   * on the existing bind groups of this state. Shared groups are
   * not cloned.
   *
   * @return {Array<BindGroup>} A array of bind groups.
   */
  createBindings() {
    const bindings = [];
    for (const instanceGroup of this.bindings) {
      const shared = instanceGroup.bindings[0].groupNode.shared;
      if (shared !== true) {
        const bindingsGroup = new BindGroup(
          instanceGroup.name,
          [],
          instanceGroup.index,
          instanceGroup
        );
        bindings.push(bindingsGroup);
        for (const instanceBinding of instanceGroup.bindings) {
          bindingsGroup.bindings.push(instanceBinding.clone());
        }
      } else {
        bindings.push(instanceGroup);
      }
    }
    return bindings;
  }
}
class NodeAttribute {
  /**
   * Constructs a new node attribute.
   *
   * @param {string} name - The name of the attribute.
   * @param {string} type - The type of the attribute.
   * @param {?Node} node - An optional reference to the node.
   */
  constructor(name, type, node = null) {
    this.isNodeAttribute = true;
    this.name = name;
    this.type = type;
    this.node = node;
  }
}
class NodeUniform {
  /**
   * Constructs a new node uniform.
   *
   * @param {string} name - The name of the uniform.
   * @param {string} type - The type of the uniform.
   * @param {UniformNode} node - An reference to the node.
   */
  constructor(name, type, node) {
    this.isNodeUniform = true;
    this.name = name;
    this.type = type;
    this.node = node.getSelf();
  }
  /**
   * The value of the uniform node.
   *
   * @type {any}
   */
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
  /**
   * The id of the uniform node.
   *
   * @type {number}
   */
  get id() {
    return this.node.id;
  }
  /**
   * The uniform node's group.
   *
   * @type {UniformGroupNode}
   */
  get groupNode() {
    return this.node.groupNode;
  }
}
class NodeVar {
  /**
   * Constructs a new node variable.
   *
   * @param {string} name - The name of the variable.
   * @param {string} type - The type of the variable.
   * @param {boolean} [readOnly=false] - The read-only flag.
   * @param {?number} [count=null] - The size.
   */
  constructor(name, type, readOnly = false, count = null) {
    this.isNodeVar = true;
    this.name = name;
    this.type = type;
    this.readOnly = readOnly;
    this.count = count;
  }
}
class NodeVarying extends NodeVar {
  /**
   * Constructs a new node varying.
   *
   * @param {string} name - The name of the varying.
   * @param {string} type - The type of the varying.
   * @param {?string} interpolationType - The interpolation type of the varying.
   * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
   */
  constructor(
    name,
    type,
    interpolationType = null,
    interpolationSampling = null
  ) {
    super(name, type);
    this.needsInterpolation = false;
    this.isNodeVarying = true;
    this.interpolationType = interpolationType;
    this.interpolationSampling = interpolationSampling;
  }
}
class NodeCode {
  /**
   * Constructs a new code node.
   *
   * @param {string} name - The name of the code.
   * @param {string} type - The node type.
   * @param {string} [code=''] - The native shader code.
   */
  constructor(name, type, code2 = "") {
    this.name = name;
    this.type = type;
    this.code = code2;
    Object.defineProperty(this, "isNodeCode", { value: true });
  }
}
let _id$5 = 0;
class NodeCache {
  /**
   * Constructs a new node cache.
   *
   * @param {?NodeCache} parent - A reference to a parent cache.
   */
  constructor(parent = null) {
    this.id = _id$5++;
    this.nodesData = /* @__PURE__ */ new WeakMap();
    this.parent = parent;
  }
  /**
   * Returns the data for the given node.
   *
   * @param {Node} node - The node.
   * @return {?Object} The data for the node.
   */
  getData(node) {
    let data = this.nodesData.get(node);
    if (data === void 0 && this.parent !== null) {
      data = this.parent.getData(node);
    }
    return data;
  }
  /**
   * Sets the data for a given node.
   *
   * @param {Node} node - The node.
   * @param {Object} data - The data that should be cached.
   */
  setData(node, data) {
    this.nodesData.set(node, data);
  }
}
class StructType {
  constructor(name, members) {
    this.name = name;
    this.members = members;
    this.output = false;
  }
}
class Uniform {
  /**
   * Constructs a new uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {any} value - The uniform's value.
   */
  constructor(name, value) {
    this.name = name;
    this.value = value;
    this.boundary = 0;
    this.itemSize = 0;
    this.offset = 0;
  }
  /**
   * Sets the uniform's value.
   *
   * @param {any} value - The value to set.
   */
  setValue(value) {
    this.value = value;
  }
  /**
   * Returns the uniform's value.
   *
   * @return {any} The value.
   */
  getValue() {
    return this.value;
  }
}
class NumberUniform extends Uniform {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {number} value - The uniform's value.
   */
  constructor(name, value = 0) {
    super(name, value);
    this.isNumberUniform = true;
    this.boundary = 4;
    this.itemSize = 1;
  }
}
class Vector2Uniform extends Uniform {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector2} value - The uniform's value.
   */
  constructor(name, value = new Vector2()) {
    super(name, value);
    this.isVector2Uniform = true;
    this.boundary = 8;
    this.itemSize = 2;
  }
}
class Vector3Uniform extends Uniform {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector3} value - The uniform's value.
   */
  constructor(name, value = new Vector3()) {
    super(name, value);
    this.isVector3Uniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
}
class Vector4Uniform extends Uniform {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector4} value - The uniform's value.
   */
  constructor(name, value = new Vector4()) {
    super(name, value);
    this.isVector4Uniform = true;
    this.boundary = 16;
    this.itemSize = 4;
  }
}
class ColorUniform extends Uniform {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Color} value - The uniform's value.
   */
  constructor(name, value = new Color()) {
    super(name, value);
    this.isColorUniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
}
class Matrix2Uniform extends Uniform {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix2} value - The uniform's value.
   */
  constructor(name, value = new Matrix2()) {
    super(name, value);
    this.isMatrix2Uniform = true;
    this.boundary = 8;
    this.itemSize = 4;
  }
}
class Matrix3Uniform extends Uniform {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix3} value - The uniform's value.
   */
  constructor(name, value = new Matrix3()) {
    super(name, value);
    this.isMatrix3Uniform = true;
    this.boundary = 48;
    this.itemSize = 12;
  }
}
class Matrix4Uniform extends Uniform {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix4} value - The uniform's value.
   */
  constructor(name, value = new Matrix4()) {
    super(name, value);
    this.isMatrix4Uniform = true;
    this.boundary = 64;
    this.itemSize = 16;
  }
}
class NumberNodeUniform extends NumberUniform {
  /**
   * Constructs a new node-based Number uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {number} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class Vector2NodeUniform extends Vector2Uniform {
  /**
   * Constructs a new node-based Vector2 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector2} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class Vector3NodeUniform extends Vector3Uniform {
  /**
   * Constructs a new node-based Vector3 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector3} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class Vector4NodeUniform extends Vector4Uniform {
  /**
   * Constructs a new node-based Vector4 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector4} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class ColorNodeUniform extends ColorUniform {
  /**
   * Constructs a new node-based Color uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Color} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class Matrix2NodeUniform extends Matrix2Uniform {
  /**
   * Constructs a new node-based Matrix2 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix2} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class Matrix3NodeUniform extends Matrix3Uniform {
  /**
   * Constructs a new node-based Matrix3 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix3} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class Matrix4NodeUniform extends Matrix4Uniform {
  /**
   * Constructs a new node-based Matrix4 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix4} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
const rendererCache = /* @__PURE__ */ new WeakMap();
const typeFromArray = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"],
]);
const toFloat = (value) => {
  if (/e/g.test(value)) {
    return String(value).replace(/\+/g, "");
  } else {
    value = Number(value);
    return value + (value % 1 ? "" : ".0");
  }
};
class NodeBuilder {
  /**
   * Constructs a new node builder.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The current renderer.
   * @param {NodeParser} parser - A reference to a node parser.
   */
  constructor(object, renderer2, parser) {
    this.object = object;
    this.material = (object && object.material) || null;
    this.geometry = (object && object.geometry) || null;
    this.renderer = renderer2;
    this.parser = parser;
    this.scene = null;
    this.camera = null;
    this.nodes = [];
    this.sequentialNodes = [];
    this.updateNodes = [];
    this.updateBeforeNodes = [];
    this.updateAfterNodes = [];
    this.hashNodes = {};
    this.observer = null;
    this.lightsNode = null;
    this.environmentNode = null;
    this.fogNode = null;
    this.clippingContext = null;
    this.vertexShader = null;
    this.fragmentShader = null;
    this.computeShader = null;
    this.flowNodes = { vertex: [], fragment: [], compute: [] };
    this.flowCode = { vertex: "", fragment: "", compute: "" };
    this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
    this.structs = { vertex: [], fragment: [], compute: [], index: 0 };
    this.bindings = { vertex: {}, fragment: {}, compute: {} };
    this.bindingsIndexes = {};
    this.bindGroups = null;
    this.attributes = [];
    this.bufferAttributes = [];
    this.varyings = [];
    this.codes = {};
    this.vars = {};
    this.declarations = {};
    this.flow = { code: "" };
    this.chaining = [];
    this.stack = stack();
    this.stacks = [];
    this.tab = "	";
    this.currentFunctionNode = null;
    this.context = {
      material: this.material,
    };
    this.cache = new NodeCache();
    this.globalCache = this.cache;
    this.flowsData = /* @__PURE__ */ new WeakMap();
    this.shaderStage = null;
    this.buildStage = null;
    this.subBuildLayers = [];
    this.currentStack = null;
    this.subBuildFn = null;
  }
  /**
   * Returns the bind groups of the current renderer.
   *
   * @return {ChainMap} The cache.
   */
  getBindGroupsCache() {
    let bindGroupsCache = rendererCache.get(this.renderer);
    if (bindGroupsCache === void 0) {
      bindGroupsCache = new ChainMap();
      rendererCache.set(this.renderer, bindGroupsCache);
    }
    return bindGroupsCache;
  }
  /**
   * Factory method for creating an instance of {@link RenderTarget} with the given
   * dimensions and options.
   *
   * @param {number} width - The width of the render target.
   * @param {number} height - The height of the render target.
   * @param {Object} options - The options of the render target.
   * @return {RenderTarget} The render target.
   */
  createRenderTarget(width, height, options) {
    return new RenderTarget(width, height, options);
  }
  /**
   * Factory method for creating an instance of {@link CubeRenderTarget} with the given
   * dimensions and options.
   *
   * @param {number} size - The size of the cube render target.
   * @param {Object} options - The options of the cube render target.
   * @return {CubeRenderTarget} The cube render target.
   */
  createCubeRenderTarget(size, options) {
    return new CubeRenderTarget(size, options);
  }
  /**
   * Whether the given node is included in the internal array of nodes or not.
   *
   * @param {Node} node - The node to test.
   * @return {boolean} Whether the given node is included in the internal array of nodes or not.
   */
  includes(node) {
    return this.nodes.includes(node);
  }
  /**
   * Returns the output struct name which is required by
   * {@link OutputStructNode}.
   *
   * @abstract
   * @return {string} The name of the output struct.
   */
  getOutputStructName() {}
  /**
   * Returns a bind group for the given group name and binding.
   *
   * @private
   * @param {string} groupName - The group name.
   * @param {Array<NodeUniformsGroup>} bindings - List of bindings.
   * @return {BindGroup} The bind group
   */
  _getBindGroup(groupName, bindings) {
    const bindGroupsCache = this.getBindGroupsCache();
    const bindingsArray = [];
    let sharedGroup = true;
    for (const binding of bindings) {
      bindingsArray.push(binding);
      sharedGroup = sharedGroup && binding.groupNode.shared !== true;
    }
    let bindGroup;
    if (sharedGroup) {
      bindGroup = bindGroupsCache.get(bindingsArray);
      if (bindGroup === void 0) {
        bindGroup = new BindGroup(
          groupName,
          bindingsArray,
          this.bindingsIndexes[groupName].group,
          bindingsArray
        );
        bindGroupsCache.set(bindingsArray, bindGroup);
      }
    } else {
      bindGroup = new BindGroup(
        groupName,
        bindingsArray,
        this.bindingsIndexes[groupName].group,
        bindingsArray
      );
    }
    return bindGroup;
  }
  /**
   * Returns an array of node uniform groups for the given group name and shader stage.
   *
   * @param {string} groupName - The group name.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {Array<NodeUniformsGroup>} The array of node uniform groups.
   */
  getBindGroupArray(groupName, shaderStage) {
    const bindings = this.bindings[shaderStage];
    let bindGroup = bindings[groupName];
    if (bindGroup === void 0) {
      if (this.bindingsIndexes[groupName] === void 0) {
        this.bindingsIndexes[groupName] = {
          binding: 0,
          group: Object.keys(this.bindingsIndexes).length,
        };
      }
      bindings[groupName] = bindGroup = [];
    }
    return bindGroup;
  }
  /**
   * Returns a list bindings of all shader stages separated by groups.
   *
   * @return {Array<BindGroup>} The list of bindings.
   */
  getBindings() {
    let bindingsGroups = this.bindGroups;
    if (bindingsGroups === null) {
      const groups = {};
      const bindings = this.bindings;
      for (const shaderStage of shaderStages) {
        for (const groupName in bindings[shaderStage]) {
          const uniforms = bindings[shaderStage][groupName];
          const groupUniforms = groups[groupName] || (groups[groupName] = []);
          groupUniforms.push(...uniforms);
        }
      }
      bindingsGroups = [];
      for (const groupName in groups) {
        const group = groups[groupName];
        const bindingsGroup = this._getBindGroup(groupName, group);
        bindingsGroups.push(bindingsGroup);
      }
      this.bindGroups = bindingsGroups;
    }
    return bindingsGroups;
  }
  /**
   * Sorts the bind groups and updates {@link NodeBuilder#bindingsIndexes}.
   */
  sortBindingGroups() {
    const bindingsGroups = this.getBindings();
    bindingsGroups.sort(
      (a2, b) => a2.bindings[0].groupNode.order - b.bindings[0].groupNode.order
    );
    for (let i2 = 0; i2 < bindingsGroups.length; i2++) {
      const bindingGroup = bindingsGroups[i2];
      this.bindingsIndexes[bindingGroup.name].group = i2;
      bindingGroup.index = i2;
    }
  }
  /**
   * The builder maintains each node in a hash-based dictionary.
   * This method sets the given node (value) with the given hash (key) into this dictionary.
   *
   * @param {Node} node - The node to add.
   * @param {number} hash - The hash of the node.
   */
  setHashNode(node, hash2) {
    this.hashNodes[hash2] = node;
  }
  /**
   * Adds a node to this builder.
   *
   * @param {Node} node - The node to add.
   */
  addNode(node) {
    if (this.nodes.includes(node) === false) {
      this.nodes.push(node);
      this.setHashNode(node, node.getHash(this));
    }
  }
  /**
   * It is used to add Nodes that will be used as FRAME and RENDER events,
   * and need to follow a certain sequence in the calls to work correctly.
   * This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.
   *
   * @param {Node} node - The node to add.
   */
  addSequentialNode(node) {
    if (this.sequentialNodes.includes(node) === false) {
      this.sequentialNodes.push(node);
    }
  }
  /**
   * Checks the update types of nodes
   */
  buildUpdateNodes() {
    for (const node of this.nodes) {
      const updateType = node.getUpdateType();
      if (updateType !== NodeUpdateType.NONE) {
        this.updateNodes.push(node.getSelf());
      }
    }
    for (const node of this.sequentialNodes) {
      const updateBeforeType = node.getUpdateBeforeType();
      const updateAfterType = node.getUpdateAfterType();
      if (updateBeforeType !== NodeUpdateType.NONE) {
        this.updateBeforeNodes.push(node.getSelf());
      }
      if (updateAfterType !== NodeUpdateType.NONE) {
        this.updateAfterNodes.push(node.getSelf());
      }
    }
  }
  /**
   * A reference the current node which is the
   * last node in the chain of nodes.
   *
   * @type {Node}
   */
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  /**
   * Whether the given texture is filtered or not.
   *
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture is filtered or not.
   */
  isFilteredTexture(texture2) {
    return (
      texture2.magFilter === LinearFilter ||
      texture2.magFilter === LinearMipmapNearestFilter ||
      texture2.magFilter === NearestMipmapLinearFilter ||
      texture2.magFilter === LinearMipmapLinearFilter ||
      texture2.minFilter === LinearFilter ||
      texture2.minFilter === LinearMipmapNearestFilter ||
      texture2.minFilter === NearestMipmapLinearFilter ||
      texture2.minFilter === LinearMipmapLinearFilter
    );
  }
  /**
   * Adds the given node to the internal node chain.
   * This is used to check recursive calls in node-graph.
   *
   * @param {Node} node - The node to add.
   */
  addChain(node) {
    this.chaining.push(node);
  }
  /**
   * Removes the given node from the internal node chain.
   *
   * @param {Node} node - The node to remove.
   */
  removeChain(node) {
    const lastChain = this.chaining.pop();
    if (lastChain !== node) {
      throw new Error("NodeBuilder: Invalid node chaining!");
    }
  }
  /**
   * Returns the native shader method name for a given generic name. E.g.
   * the method name `textureDimensions` matches the WGSL name but must be
   * resolved to `textureSize` in GLSL.
   *
   * @abstract
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved method name.
   */
  getMethod(method) {
    return method;
  }
  /**
   * Returns a node for the given hash, see {@link NodeBuilder#setHashNode}.
   *
   * @param {number} hash - The hash of the node.
   * @return {Node} The found node.
   */
  getNodeFromHash(hash2) {
    return this.hashNodes[hash2];
  }
  /**
   * Adds the Node to a target flow so that it can generate code in the 'generate' process.
   *
   * @param {('vertex'|'fragment'|'compute')} shaderStage - The shader stage.
   * @param {Node} node - The node to add.
   * @return {Node} The node.
   */
  addFlow(shaderStage, node) {
    this.flowNodes[shaderStage].push(node);
    return node;
  }
  /**
   * Sets builder's context.
   *
   * @param {Object} context - The context to set.
   */
  setContext(context2) {
    this.context = context2;
  }
  /**
   * Returns the builder's current context.
   *
   * @return {Object} The builder's current context.
   */
  getContext() {
    return this.context;
  }
  /**
   * Gets a context used in shader construction that can be shared across different materials.
   * This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.
   *
   * @return {Object} The builder's current context without material.
   */
  getSharedContext() {
    ({ ...this.context });
    return this.context;
  }
  /**
   * Sets builder's cache.
   *
   * @param {NodeCache} cache - The cache to set.
   */
  setCache(cache2) {
    this.cache = cache2;
  }
  /**
   * Returns the builder's current cache.
   *
   * @return {NodeCache} The builder's current cache.
   */
  getCache() {
    return this.cache;
  }
  /**
   * Returns a cache for the given node.
   *
   * @param {Node} node - The node.
   * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
   * @return {NodeCache} The cache.
   */
  getCacheFromNode(node, parent = true) {
    const data = this.getDataFromNode(node);
    if (data.cache === void 0)
      data.cache = new NodeCache(parent ? this.getCache() : null);
    return data.cache;
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @abstract
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable() {
    return false;
  }
  /**
   * Returns the vertexIndex input variable as a native shader string.
   *
   * @abstract
   * @return {string} The instanceIndex shader string.
   */
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the instanceIndex input variable as a native shader string.
   *
   * @abstract
   * @return {string} The instanceIndex shader string.
   */
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the drawIndex input variable as a native shader string.
   * Only relevant for WebGL and its `WEBGL_multi_draw` extension.
   *
   * @abstract
   * @return {?string} The drawIndex shader string.
   */
  getDrawIndex() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the frontFacing input variable as a native shader string.
   *
   * @abstract
   * @return {string} The frontFacing shader string.
   */
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the fragCoord input variable as a native shader string.
   *
   * @abstract
   * @return {string} The fragCoord shader string.
   */
  getFragCoord() {
    console.warn("Abstract function.");
  }
  /**
   * Whether to flip texture data along its vertical axis or not. WebGL needs
   * this method evaluate to `true`, WebGPU to `false`.
   *
   * @abstract
   * @return {boolean} Whether to flip texture data along its vertical axis or not.
   */
  isFlipY() {
    return false;
  }
  /**
   * Calling this method increases the usage count for the given node by one.
   *
   * @param {Node} node - The node to increase the usage count for.
   * @return {number} The updated usage count.
   */
  increaseUsage(node) {
    const nodeData = this.getDataFromNode(node);
    nodeData.usageCount =
      nodeData.usageCount === void 0 ? 1 : nodeData.usageCount + 1;
    return nodeData.usageCount;
  }
  /**
   * Generates a texture sample shader string for the given texture data.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The texture property name.
   * @param {string} uvSnippet - Snippet defining the texture coordinates.
   * @return {string} The generated shader string.
   */
  generateTexture() {
    console.warn("Abstract function.");
  }
  /**
   * Generates a texture LOD shader string for the given texture data.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The texture property name.
   * @param {string} uvSnippet - Snippet defining the texture coordinates.
   * @param {?string} depthSnippet - Snippet defining the 0-based texture array index to sample.
   * @param {string} levelSnippet - Snippet defining the mip level.
   * @return {string} The generated shader string.
   */
  generateTextureLod() {
    console.warn("Abstract function.");
  }
  /**
   * Generates the array declaration string.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @return {string} The generated value as a shader string.
   */
  generateArrayDeclaration(type, count) {
    return this.getType(type) + "[ " + count + " ]";
  }
  /**
   * Generates the array shader string for the given type and value.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @param {?Array<Node>} [values=null] - The default values.
   * @return {string} The generated value as a shader string.
   */
  generateArray(type, count, values = null) {
    let snippet = this.generateArrayDeclaration(type, count) + "( ";
    for (let i2 = 0; i2 < count; i2++) {
      const value = values ? values[i2] : null;
      if (value !== null) {
        snippet += value.build(this, type);
      } else {
        snippet += this.generateConst(type);
      }
      if (i2 < count - 1) snippet += ", ";
    }
    snippet += " )";
    return snippet;
  }
  /**
   * Generates the struct shader string.
   *
   * @param {string} type - The type.
   * @param {Array<Object>} [membersLayout] - The count.
   * @param {?Array<Node>} [values=null] - The default values.
   * @return {string} The generated value as a shader string.
   */
  generateStruct(type, membersLayout, values = null) {
    const snippets = [];
    for (const member of membersLayout) {
      const { name, type: type2 } = member;
      if (values && values[name] && values[name].isNode) {
        snippets.push(values[name].build(this, type2));
      } else {
        snippets.push(this.generateConst(type2));
      }
    }
    return type + "( " + snippets.join(", ") + " )";
  }
  /**
   * Generates the shader string for the given type and value.
   *
   * @param {string} type - The type.
   * @param {?any} [value=null] - The value.
   * @return {string} The generated value as a shader string.
   */
  generateConst(type, value = null) {
    if (value === null) {
      if (type === "float" || type === "int" || type === "uint") value = 0;
      else if (type === "bool") value = false;
      else if (type === "color") value = new Color();
      else if (type === "vec2") value = new Vector2();
      else if (type === "vec3") value = new Vector3();
      else if (type === "vec4") value = new Vector4();
    }
    if (type === "float") return toFloat(value);
    if (type === "int") return `${Math.round(value)}`;
    if (type === "uint") return value >= 0 ? `${Math.round(value)}u` : "0u";
    if (type === "bool") return value ? "true" : "false";
    if (type === "color")
      return `${this.getType("vec3")}( ${toFloat(value.r)}, ${toFloat(
        value.g
      )}, ${toFloat(value.b)} )`;
    const typeLength = this.getTypeLength(type);
    const componentType = this.getComponentType(type);
    const generateConst = (value2) => this.generateConst(componentType, value2);
    if (typeLength === 2) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(
        value.y
      )} )`;
    } else if (typeLength === 3) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(
        value.y
      )}, ${generateConst(value.z)} )`;
    } else if (typeLength === 4 && type !== "mat2") {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(
        value.y
      )}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;
    } else if (
      typeLength >= 4 &&
      value &&
      (value.isMatrix2 || value.isMatrix3 || value.isMatrix4)
    ) {
      return `${this.getType(type)}( ${value.elements
        .map(generateConst)
        .join(", ")} )`;
    } else if (typeLength > 4) {
      return `${this.getType(type)}()`;
    }
    throw new Error(
      `NodeBuilder: Type '${type}' not found in generate constant attempt.`
    );
  }
  /**
   * It might be necessary to convert certain data types to different ones
   * so this method can be used to hide the conversion.
   *
   * @param {string} type - The type.
   * @return {string} The updated type.
   */
  getType(type) {
    if (type === "color") return "vec3";
    return type;
  }
  /**
   * Whether the given attribute name is defined in the geometry or not.
   *
   * @param {string} name - The attribute name.
   * @return {boolean} Whether the given attribute name is defined in the geometry.
   */
  hasGeometryAttribute(name) {
    return this.geometry && this.geometry.getAttribute(name) !== void 0;
  }
  /**
   * Returns a node attribute for the given name and type.
   *
   * @param {string} name - The attribute's name.
   * @param {string} type - The attribute's type.
   * @return {NodeAttribute} The node attribute.
   */
  getAttribute(name, type) {
    const attributes = this.attributes;
    for (const attribute3 of attributes) {
      if (attribute3.name === name) {
        return attribute3;
      }
    }
    const attribute2 = new NodeAttribute(name, type);
    this.registerDeclaration(attribute2);
    attributes.push(attribute2);
    return attribute2;
  }
  /**
   * Returns for the given node and shader stage the property name for the shader.
   *
   * @param {Node} node - The node.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The property name.
   */
  getPropertyName(node) {
    return node.name;
  }
  /**
   * Whether the given type is a vector type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a vector type or not.
   */
  isVector(type) {
    return /vec\d/.test(type);
  }
  /**
   * Whether the given type is a matrix type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a matrix type or not.
   */
  isMatrix(type) {
    return /mat\d/.test(type);
  }
  /**
   * Whether the given type is a reference type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a reference type or not.
   */
  isReference(type) {
    return (
      type === "void" ||
      type === "property" ||
      type === "sampler" ||
      type === "samplerComparison" ||
      type === "texture" ||
      type === "cubeTexture" ||
      type === "storageTexture" ||
      type === "depthTexture" ||
      type === "texture3D"
    );
  }
  /**
   * Checks if the given texture requires a manual conversion to the working color space.
   *
   * @abstract
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture requires a conversion to working color space or not.
   */
  needsToWorkingColorSpace() {
    return false;
  }
  /**
   * Returns the component type of a given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {string} The component type.
   */
  getComponentTypeFromTexture(texture2) {
    const type = texture2.type;
    if (texture2.isDataTexture) {
      if (type === IntType) return "int";
      if (type === UnsignedIntType) return "uint";
    }
    return "float";
  }
  /**
   * Returns the element type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The element type.
   */
  getElementType(type) {
    if (type === "mat2") return "vec2";
    if (type === "mat3") return "vec3";
    if (type === "mat4") return "vec4";
    return this.getComponentType(type);
  }
  /**
   * Returns the component type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The component type.
   */
  getComponentType(type) {
    type = this.getVectorType(type);
    if (
      type === "float" ||
      type === "bool" ||
      type === "int" ||
      type === "uint"
    )
      return type;
    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);
    if (componentType === null) return null;
    if (componentType[1] === "b") return "bool";
    if (componentType[1] === "i") return "int";
    if (componentType[1] === "u") return "uint";
    return "float";
  }
  /**
   * Returns the vector type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The vector type.
   */
  getVectorType(type) {
    if (type === "color") return "vec3";
    if (
      type === "texture" ||
      type === "cubeTexture" ||
      type === "storageTexture" ||
      type === "texture3D"
    )
      return "vec4";
    return type;
  }
  /**
   * Returns the data type for the given the length and component type.
   *
   * @param {number} length - The length.
   * @param {string} [componentType='float'] - The component type.
   * @return {string} The type.
   */
  getTypeFromLength(length2, componentType = "float") {
    if (length2 === 1) return componentType;
    let baseType = getTypeFromLength(length2);
    const prefix = componentType === "float" ? "" : componentType[0];
    if (/mat2/.test(componentType) === true) {
      baseType = baseType.replace("vec", "mat");
    }
    return prefix + baseType;
  }
  /**
   * Returns the type for a given typed array.
   *
   * @param {TypedArray} array - The typed array.
   * @return {string} The type.
   */
  getTypeFromArray(array2) {
    return typeFromArray.get(array2.constructor);
  }
  /**
   * Returns the type is an integer type.
   *
   * @param {string} type - The type.
   * @return {boolean} Whether the type is an integer type or not.
   */
  isInteger(type) {
    return /int|uint|(i|u)vec/.test(type);
  }
  /**
   * Returns the type for a given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @return {string} The type.
   */
  getTypeFromAttribute(attribute2) {
    let dataAttribute = attribute2;
    if (attribute2.isInterleavedBufferAttribute)
      dataAttribute = attribute2.data;
    const array2 = dataAttribute.array;
    const itemSize = attribute2.itemSize;
    const normalized = attribute2.normalized;
    let arrayType;
    if (
      !(attribute2 instanceof Float16BufferAttribute) &&
      normalized !== true
    ) {
      arrayType = this.getTypeFromArray(array2);
    }
    return this.getTypeFromLength(itemSize, arrayType);
  }
  /**
   * Returns the length for the given data type.
   *
   * @param {string} type - The data type.
   * @return {number} The length.
   */
  getTypeLength(type) {
    const vecType = this.getVectorType(type);
    const vecNum = /vec([2-4])/.exec(vecType);
    if (vecNum !== null) return Number(vecNum[1]);
    if (
      vecType === "float" ||
      vecType === "bool" ||
      vecType === "int" ||
      vecType === "uint"
    )
      return 1;
    if (/mat2/.test(type) === true) return 4;
    if (/mat3/.test(type) === true) return 9;
    if (/mat4/.test(type) === true) return 16;
    return 0;
  }
  /**
   * Returns the vector type for a given matrix type.
   *
   * @param {string} type - The matrix type.
   * @return {string} The vector type.
   */
  getVectorFromMatrix(type) {
    return type.replace("mat", "vec");
  }
  /**
   * For a given type this method changes the component type to the
   * given value. E.g. `vec4` should be changed to the new component type
   * `uint` which results in `uvec4`.
   *
   * @param {string} type - The type.
   * @param {string} newComponentType - The new component type.
   * @return {string} The new type.
   */
  changeComponentType(type, newComponentType) {
    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
  }
  /**
   * Returns the integer type pendant for the given type.
   *
   * @param {string} type - The type.
   * @return {string} The integer type.
   */
  getIntegerType(type) {
    const componentType = this.getComponentType(type);
    if (componentType === "int" || componentType === "uint") return type;
    return this.changeComponentType(type, "int");
  }
  /**
   * Adds a stack node to the internal stack.
   *
   * @return {StackNode} The added stack node.
   */
  addStack() {
    this.stack = stack(this.stack);
    this.stacks.push(getCurrentStack() || this.stack);
    setCurrentStack(this.stack);
    return this.stack;
  }
  /**
   * Removes the last stack node from the internal stack.
   *
   * @return {StackNode} The removed stack node.
   */
  removeStack() {
    const lastStack = this.stack;
    this.stack = lastStack.parent;
    setCurrentStack(this.stacks.pop());
    return lastStack;
  }
  /**
   * The builder maintains (cached) data for each node during the building process. This method
   * can be used to get these data for a specific shader stage and cache.
   *
   * @param {Node} node - The node to get the data for.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {?NodeCache} cache - An optional cache.
   * @return {Object} The node data.
   */
  getDataFromNode(node, shaderStage = this.shaderStage, cache2 = null) {
    cache2 =
      cache2 === null
        ? node.isGlobal(this)
          ? this.globalCache
          : this.cache
        : cache2;
    let nodeData = cache2.getData(node);
    if (nodeData === void 0) {
      nodeData = {};
      cache2.setData(node, nodeData);
    }
    if (nodeData[shaderStage] === void 0) nodeData[shaderStage] = {};
    let data = nodeData[shaderStage];
    const subBuilds = nodeData.any ? nodeData.any.subBuilds : null;
    const subBuild2 = this.getClosestSubBuild(subBuilds);
    if (subBuild2) {
      if (data.subBuildsCache === void 0) data.subBuildsCache = {};
      data =
        data.subBuildsCache[subBuild2] || (data.subBuildsCache[subBuild2] = {});
      data.subBuilds = subBuilds;
    }
    return data;
  }
  /**
   * Returns the properties for the given node and shader stage.
   *
   * @param {Node} node - The node to get the properties for.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.
   * @return {Object} The node properties.
   */
  getNodeProperties(node, shaderStage = "any") {
    const nodeData = this.getDataFromNode(node, shaderStage);
    return nodeData.properties || (nodeData.properties = { outputNode: null });
  }
  /**
   * Returns an instance of {@link NodeAttribute} for the given buffer attribute node.
   *
   * @param {BufferAttributeNode} node - The buffer attribute node.
   * @param {string} type - The node type.
   * @return {NodeAttribute} The node attribute.
   */
  getBufferAttributeFromNode(node, type) {
    const nodeData = this.getDataFromNode(node);
    let bufferAttribute2 = nodeData.bufferAttribute;
    if (bufferAttribute2 === void 0) {
      const index = this.uniforms.index++;
      bufferAttribute2 = new NodeAttribute("nodeAttribute" + index, type, node);
      this.bufferAttributes.push(bufferAttribute2);
      nodeData.bufferAttribute = bufferAttribute2;
    }
    return bufferAttribute2;
  }
  /**
   * Returns an instance of {@link StructType} for the given output struct node.
   *
   * @param {OutputStructNode} node - The output struct node.
   * @param {Array<Object>} membersLayout - The output struct types.
   * @param {?string} [name=null] - The name of the struct.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @return {StructType} The struct type attribute.
   */
  getStructTypeFromNode(
    node,
    membersLayout,
    name = null,
    shaderStage = this.shaderStage
  ) {
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    let structType = nodeData.structType;
    if (structType === void 0) {
      const index = this.structs.index++;
      if (name === null) name = "StructType" + index;
      structType = new StructType(name, membersLayout);
      this.structs[shaderStage].push(structType);
      nodeData.structType = structType;
    }
    return structType;
  }
  /**
   * Returns an instance of {@link StructType} for the given output struct node.
   *
   * @param {OutputStructNode} node - The output struct node.
   * @param {Array<Object>} membersLayout - The output struct types.
   * @return {StructType} The struct type attribute.
   */
  getOutputStructTypeFromNode(node, membersLayout) {
    const structType = this.getStructTypeFromNode(
      node,
      membersLayout,
      "OutputType",
      "fragment"
    );
    structType.output = true;
    return structType;
  }
  /**
   * Returns an instance of {@link NodeUniform} for the given uniform node.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The uniform type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {?string} name - The name of the uniform.
   * @return {NodeUniform} The node uniform.
   */
  getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    let nodeUniform = nodeData.uniform;
    if (nodeUniform === void 0) {
      const index = this.uniforms.index++;
      nodeUniform = new NodeUniform(name || "nodeUniform" + index, type, node);
      this.uniforms[shaderStage].push(nodeUniform);
      this.registerDeclaration(nodeUniform);
      nodeData.uniform = nodeUniform;
    }
    return nodeUniform;
  }
  /**
   * Returns an instance of {@link NodeVar} for the given variable node.
   *
   * @param {VarNode} node - The variable node.
   * @param {?string} name - The variable's name.
   * @param {string} [type=node.getNodeType( this )] - The variable's type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {boolean} [readOnly=false] - Whether the variable is read-only or not.
   *
   * @return {NodeVar} The node variable.
   */
  getVarFromNode(
    node,
    name = null,
    type = node.getNodeType(this),
    shaderStage = this.shaderStage,
    readOnly = false
  ) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    const subBuildVariable = this.getSubBuildProperty(
      "variable",
      nodeData.subBuilds
    );
    let nodeVar = nodeData[subBuildVariable];
    if (nodeVar === void 0) {
      const idNS = readOnly ? "_const" : "_var";
      const vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);
      const id = this.vars[idNS] || (this.vars[idNS] = 0);
      if (name === null) {
        name = (readOnly ? "nodeConst" : "nodeVar") + id;
        this.vars[idNS]++;
      }
      if (subBuildVariable !== "variable") {
        name = this.getSubBuildProperty(name, nodeData.subBuilds);
      }
      const count = node.getArrayCount(this);
      nodeVar = new NodeVar(name, type, readOnly, count);
      if (!readOnly) {
        vars.push(nodeVar);
      }
      this.registerDeclaration(nodeVar);
      nodeData[subBuildVariable] = nodeVar;
    }
    return nodeVar;
  }
  /**
   * Returns whether a Node or its flow is deterministic, useful for use in `const`.
   *
   * @param {Node} node - The varying node.
   * @return {boolean} Returns true if deterministic.
   */
  isDeterministic(node) {
    if (node.isMathNode) {
      return (
        this.isDeterministic(node.aNode) &&
        (node.bNode ? this.isDeterministic(node.bNode) : true) &&
        (node.cNode ? this.isDeterministic(node.cNode) : true)
      );
    } else if (node.isOperatorNode) {
      return (
        this.isDeterministic(node.aNode) &&
        (node.bNode ? this.isDeterministic(node.bNode) : true)
      );
    } else if (node.isArrayNode) {
      if (node.values !== null) {
        for (const n2 of node.values) {
          if (!this.isDeterministic(n2)) {
            return false;
          }
        }
      }
      return true;
    } else if (node.isConstNode) {
      return true;
    }
    return false;
  }
  /**
   * Returns an instance of {@link NodeVarying} for the given varying node.
   *
   * @param {(VaryingNode|PropertyNode)} node - The varying node.
   * @param {?string} name - The varying's name.
   * @param {string} [type=node.getNodeType( this )] - The varying's type.
   * @param {?string} interpolationType - The interpolation type of the varying.
   * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
   * @return {NodeVar} The node varying.
   */
  getVaryingFromNode(
    node,
    name = null,
    type = node.getNodeType(this),
    interpolationType = null,
    interpolationSampling = null
  ) {
    const nodeData = this.getDataFromNode(node, "any");
    const subBuildVarying = this.getSubBuildProperty(
      "varying",
      nodeData.subBuilds
    );
    let nodeVarying = nodeData[subBuildVarying];
    if (nodeVarying === void 0) {
      const varyings = this.varyings;
      const index = varyings.length;
      if (name === null) name = "nodeVarying" + index;
      if (subBuildVarying !== "varying") {
        name = this.getSubBuildProperty(name, nodeData.subBuilds);
      }
      nodeVarying = new NodeVarying(
        name,
        type,
        interpolationType,
        interpolationSampling
      );
      varyings.push(nodeVarying);
      this.registerDeclaration(nodeVarying);
      nodeData[subBuildVarying] = nodeVarying;
    }
    return nodeVarying;
  }
  /**
   * Registers a node declaration in the current shader stage.
   *
   * @param {Object} node - The node to be registered.
   */
  registerDeclaration(node) {
    const shaderStage = this.shaderStage;
    const declarations =
      this.declarations[shaderStage] || (this.declarations[shaderStage] = {});
    const property2 = this.getPropertyName(node);
    let index = 1;
    let name = property2;
    while (declarations[name] !== void 0) {
      name = property2 + "_" + index++;
    }
    if (index > 1) {
      node.name = name;
      console.warn(
        `THREE.TSL: Declaration name '${property2}' of '${node.type}' already in use. Renamed to '${name}'.`
      );
    }
    declarations[name] = node;
  }
  /**
   * Returns an instance of {@link NodeCode} for the given code node.
   *
   * @param {CodeNode} node - The code node.
   * @param {string} type - The node type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @return {NodeCode} The node code.
   */
  getCodeFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node);
    let nodeCode = nodeData.code;
    if (nodeCode === void 0) {
      const codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);
      const index = codes.length;
      nodeCode = new NodeCode("nodeCode" + index, type);
      codes.push(nodeCode);
      nodeData.code = nodeCode;
    }
    return nodeCode;
  }
  /**
  	 * Adds a code flow based on the code-block hierarchy.
  
  	 * This is used so that code-blocks like If,Else create their variables locally if the Node
  	 * is only used inside one of these conditionals in the current shader stage.
  	 *
  	 * @param {Node} node - The node to add.
  	 * @param {Node} nodeBlock - Node-based code-block. Usually 'ConditionalNode'.
  	 */
  addFlowCodeHierarchy(node, nodeBlock) {
    const { flowCodes, flowCodeBlock } = this.getDataFromNode(node);
    let needsFlowCode = true;
    let nodeBlockHierarchy = nodeBlock;
    while (nodeBlockHierarchy) {
      if (flowCodeBlock.get(nodeBlockHierarchy) === true) {
        needsFlowCode = false;
        break;
      }
      nodeBlockHierarchy =
        this.getDataFromNode(nodeBlockHierarchy).parentNodeBlock;
    }
    if (needsFlowCode) {
      for (const flowCode of flowCodes) {
        this.addLineFlowCode(flowCode);
      }
    }
  }
  /**
   * Add a inline-code to the current flow code-block.
   *
   * @param {Node} node - The node to add.
   * @param {string} code - The code to add.
   * @param {Node} nodeBlock - Current ConditionalNode
   */
  addLineFlowCodeBlock(node, code2, nodeBlock) {
    const nodeData = this.getDataFromNode(node);
    const flowCodes = nodeData.flowCodes || (nodeData.flowCodes = []);
    const codeBlock =
      nodeData.flowCodeBlock ||
      (nodeData.flowCodeBlock = /* @__PURE__ */ new WeakMap());
    flowCodes.push(code2);
    codeBlock.set(nodeBlock, true);
  }
  /**
   * Add a inline-code to the current flow.
   *
   * @param {string} code - The code to add.
   * @param {?Node} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.
   * @return {NodeBuilder} A reference to this node builder.
   */
  addLineFlowCode(code2, node = null) {
    if (code2 === "") return this;
    if (node !== null && this.context.nodeBlock) {
      this.addLineFlowCodeBlock(node, code2, this.context.nodeBlock);
    }
    code2 = this.tab + code2;
    if (!/;\s*$/.test(code2)) {
      code2 = code2 + ";\n";
    }
    this.flow.code += code2;
    return this;
  }
  /**
   * Adds a code to the current code flow.
   *
   * @param {string} code - Shader code.
   * @return {NodeBuilder} A reference to this node builder.
   */
  addFlowCode(code2) {
    this.flow.code += code2;
    return this;
  }
  /**
   * Add tab in the code that will be generated so that other snippets respect the current tabulation.
   * Typically used in codes with If,Else.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  addFlowTab() {
    this.tab += "	";
    return this;
  }
  /**
   * Removes a tab.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  removeFlowTab() {
    this.tab = this.tab.slice(0, -1);
    return this;
  }
  /**
   * Gets the current flow data based on a Node.
   *
   * @param {Node} node - Node that the flow was started.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {Object} The flow data.
   */
  getFlowData(node) {
    return this.flowsData.get(node);
  }
  /**
   * Executes the node flow based on a root node to generate the final shader code.
   *
   * @param {Node} node - The node to execute.
   * @return {Object} The code flow.
   */
  flowNode(node) {
    const output2 = node.getNodeType(this);
    const flowData = this.flowChildNode(node, output2);
    this.flowsData.set(node, flowData);
    return flowData;
  }
  /**
   * Includes a node in the current function node.
   *
   * @param {Node} node - The node to include.
   * @returns {void}
   */
  addInclude(node) {
    if (this.currentFunctionNode !== null) {
      this.currentFunctionNode.includes.push(node);
    }
  }
  /**
   * Returns the native shader operator name for a given generic name.
   * It is a similar type of method like {@link NodeBuilder#getMethod}.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.
   * @return {FunctionNode} The build function node.
   */
  buildFunctionNode(shaderNode) {
    const fn = new FunctionNode();
    const previous = this.currentFunctionNode;
    this.currentFunctionNode = fn;
    fn.code = this.buildFunctionCode(shaderNode);
    this.currentFunctionNode = previous;
    return fn;
  }
  /**
   * Generates a code flow based on a TSL function: Fn().
   *
   * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.
   * @return {Object}
   */
  flowShaderNode(shaderNode) {
    const layout = shaderNode.layout;
    const inputs = {
      [Symbol.iterator]() {
        let index = 0;
        const values = Object.values(this);
        return {
          next: () => ({
            value: values[index],
            done: index++ >= values.length,
          }),
        };
      },
    };
    for (const input of layout.inputs) {
      inputs[input.name] = new ParameterNode(input.type, input.name);
    }
    shaderNode.layout = null;
    const callNode = shaderNode.call(inputs);
    const flowData = this.flowStagesNode(callNode, layout.type);
    shaderNode.layout = layout;
    return flowData;
  }
  /**
   * Executes the node in a specific build stage.
   *
   * @param {Node} node - The node to execute.
   * @param {string} buildStage - The build stage to execute the node in.
   * @param {Node|string|null} output - Expected output type. For example 'vec3'.
   * @return {Node|string|null} The result of the node build.
   */
  flowBuildStage(node, buildStage, output2 = null) {
    const previousBuildStage = this.getBuildStage();
    this.setBuildStage(buildStage);
    const result = node.build(this, output2);
    this.setBuildStage(previousBuildStage);
    return result;
  }
  /**
   * Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.
   *
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @return {Object}
   */
  flowStagesNode(node, output2 = null) {
    const previousFlow = this.flow;
    const previousVars = this.vars;
    const previousDeclarations = this.declarations;
    const previousCache = this.cache;
    const previousBuildStage = this.buildStage;
    const previousStack = this.stack;
    const flow = {
      code: "",
    };
    this.flow = flow;
    this.vars = {};
    this.declarations = {};
    this.cache = new NodeCache();
    this.stack = stack();
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      flow.result = node.build(this, output2);
    }
    flow.vars = this.getVars(this.shaderStage);
    this.flow = previousFlow;
    this.vars = previousVars;
    this.declarations = previousDeclarations;
    this.cache = previousCache;
    this.stack = previousStack;
    this.setBuildStage(previousBuildStage);
    return flow;
  }
  /**
   * Returns the native shader operator name for a given generic name.
   * It is a similar type of method like {@link NodeBuilder#getMethod}.
   *
   * @abstract
   * @param {string} op - The operator name to resolve.
   * @return {?string} The resolved operator name.
   */
  getFunctionOperator() {
    return null;
  }
  /**
   * Builds the given shader node.
   *
   * @abstract
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The function code.
   */
  buildFunctionCode() {
    console.warn("Abstract function.");
  }
  /**
   * Generates a code flow based on a child Node.
   *
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @return {Object} The code flow.
   */
  flowChildNode(node, output2 = null) {
    const previousFlow = this.flow;
    const flow = {
      code: "",
    };
    this.flow = flow;
    flow.result = node.build(this, output2);
    this.flow = previousFlow;
    return flow;
  }
  /**
   * Executes a flow of code in a different stage.
   *
   * Some nodes like `varying()` have the ability to compute code in vertex-stage and
   * return the value in fragment-stage even if it is being executed in an input fragment.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @param {?string} propertyName - The property name to assign the result.
   * @return {Object|Node|null} The code flow or node.build() result.
   */
  flowNodeFromShaderStage(
    shaderStage,
    node,
    output2 = null,
    propertyName = null
  ) {
    const previousTab = this.tab;
    const previousCache = this.cache;
    const previousShaderStage = this.shaderStage;
    const previousContext = this.context;
    this.setShaderStage(shaderStage);
    const context2 = { ...this.context };
    delete context2.nodeBlock;
    this.cache = this.globalCache;
    this.tab = "	";
    this.context = context2;
    let result = null;
    if (this.buildStage === "generate") {
      const flowData = this.flowChildNode(node, output2);
      if (propertyName !== null) {
        flowData.code += `${this.tab + propertyName} = ${flowData.result};
`;
      }
      this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;
      result = flowData;
    } else {
      result = node.build(this);
    }
    this.setShaderStage(previousShaderStage);
    this.cache = previousCache;
    this.tab = previousTab;
    this.context = previousContext;
    return result;
  }
  /**
   * Returns an array holding all node attributes of this node builder.
   *
   * @return {Array<NodeAttribute>} The node attributes of this builder.
   */
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  /**
   * Returns the attribute definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The attribute code section.
   */
  getAttributes() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the varying definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The varying code section.
   */
  getVaryings() {
    console.warn("Abstract function.");
  }
  /**
   * Returns a single variable definition as a shader string for the given variable type and name.
   *
   * @param {string} type - The variable's type.
   * @param {string} name - The variable's name.
   * @param {?number} [count=null] - The array length.
   * @return {string} The shader string.
   */
  getVar(type, name, count = null) {
    return `${
      count !== null
        ? this.generateArrayDeclaration(type, count)
        : this.getType(type)
    } ${name}`;
  }
  /**
   * Returns the variable definitions as a shader string for the given shader stage.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The variable code section.
   */
  getVars(shaderStage) {
    let snippet = "";
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippet += `${this.getVar(variable.type, variable.name)}; `;
      }
    }
    return snippet;
  }
  /**
   * Returns the uniform definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The uniform code section.
   */
  getUniforms() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the native code definitions as a shader string for the given shader stage.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The native code section.
   */
  getCodes(shaderStage) {
    const codes = this.codes[shaderStage];
    let code2 = "";
    if (codes !== void 0) {
      for (const nodeCode of codes) {
        code2 += nodeCode.code + "\n";
      }
    }
    return code2;
  }
  /**
   * Returns the hash of this node builder.
   *
   * @return {string} The hash.
   */
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  /**
   * Sets the current shader stage.
   *
   * @param {?('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage to set.
   */
  setShaderStage(shaderStage) {
    this.shaderStage = shaderStage;
  }
  /**
   * Returns the current shader stage.
   *
   * @return {?('vertex'|'fragment'|'compute'|'any')} The current shader stage.
   */
  getShaderStage() {
    return this.shaderStage;
  }
  /**
   * Sets the current build stage.
   *
   * @param {?('setup'|'analyze'|'generate')} buildStage - The build stage to set.
   */
  setBuildStage(buildStage) {
    this.buildStage = buildStage;
  }
  /**
   * Returns the current build stage.
   *
   * @return {?('setup'|'analyze'|'generate')} The current build stage.
   */
  getBuildStage() {
    return this.buildStage;
  }
  /**
   * Controls the code build of the shader stages.
   *
   * @abstract
   */
  buildCode() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the current sub-build layer.
   *
   * @return {SubBuildNode} The current sub-build layers.
   */
  get subBuild() {
    return this.subBuildLayers[this.subBuildLayers.length - 1] || null;
  }
  /**
   * Adds a sub-build layer to the node builder.
   *
   * @param {SubBuildNode} subBuild - The sub-build layer to add.
   */
  addSubBuild(subBuild2) {
    this.subBuildLayers.push(subBuild2);
  }
  /**
   * Removes the last sub-build layer from the node builder.
   *
   * @return {SubBuildNode} The removed sub-build layer.
   */
  removeSubBuild() {
    return this.subBuildLayers.pop();
  }
  /**
   * Returns the closest sub-build layer for the given data.
   *
   * @param {Node|Set|Array} data - The data to get the closest sub-build layer from.
   * @return {?string} The closest sub-build name or null if none found.
   */
  getClosestSubBuild(data) {
    let subBuilds;
    if (data && data.isNode) {
      if (data.isShaderCallNodeInternal) {
        subBuilds = data.shaderNode.subBuilds;
      } else if (data.isStackNode) {
        subBuilds = [data.subBuild];
      } else {
        subBuilds = this.getDataFromNode(data, "any").subBuilds;
      }
    } else if (data instanceof Set) {
      subBuilds = [...data];
    } else {
      subBuilds = data;
    }
    if (!subBuilds) return null;
    const subBuildLayers = this.subBuildLayers;
    for (let i2 = subBuilds.length - 1; i2 >= 0; i2--) {
      const subBuild2 = subBuilds[i2];
      if (subBuildLayers.includes(subBuild2)) {
        return subBuild2;
      }
    }
    return null;
  }
  /**
   * Returns the output node of a sub-build layer.
   *
   * @param {Node} node - The node to get the output from.
   * @return {string} The output node name.
   */
  getSubBuildOutput(node) {
    return this.getSubBuildProperty("outputNode", node);
  }
  /**
   * Returns the sub-build property name for the given property and node.
   *
   * @param {string} [property=''] - The property name.
   * @param {?Node} [node=null] - The node to get the sub-build from.
   * @return {string} The sub-build property name.
   */
  getSubBuildProperty(property2 = "", node = null) {
    let subBuild2;
    if (node !== null) {
      subBuild2 = this.getClosestSubBuild(node);
    } else {
      subBuild2 = this.subBuildFn;
    }
    let result;
    if (subBuild2) {
      result = property2 ? subBuild2 + "_" + property2 : subBuild2;
    } else {
      result = property2;
    }
    return result;
  }
  /**
   * Central build method which controls the build for the given object.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  build() {
    const { object, material, renderer: renderer2 } = this;
    if (material !== null) {
      let nodeMaterial = renderer2.library.fromMaterial(material);
      if (nodeMaterial === null) {
        console.error(
          `NodeMaterial: Material "${material.type}" is not compatible.`
        );
        nodeMaterial = new NodeMaterial();
      }
      nodeMaterial.build(this);
    } else {
      this.addFlow("compute", object);
    }
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      if (this.context.vertex && this.context.vertex.isNode) {
        this.flowNodeFromShaderStage("vertex", this.context.vertex);
      }
      for (const shaderStage of shaderStages) {
        this.setShaderStage(shaderStage);
        const flowNodes = this.flowNodes[shaderStage];
        for (const node of flowNodes) {
          if (buildStage === "generate") {
            this.flowNode(node);
          } else {
            node.build(this);
          }
        }
      }
    }
    this.setBuildStage(null);
    this.setShaderStage(null);
    this.buildCode();
    this.buildUpdateNodes();
    return this;
  }
  /**
   * Returns a uniform representation which is later used for UBO generation and rendering.
   *
   * @param {NodeUniform} uniformNode - The uniform node.
   * @param {string} type - The requested type.
   * @return {Uniform} The uniform.
   */
  getNodeUniform(uniformNode, type) {
    if (type === "float" || type === "int" || type === "uint")
      return new NumberNodeUniform(uniformNode);
    if (type === "vec2" || type === "ivec2" || type === "uvec2")
      return new Vector2NodeUniform(uniformNode);
    if (type === "vec3" || type === "ivec3" || type === "uvec3")
      return new Vector3NodeUniform(uniformNode);
    if (type === "vec4" || type === "ivec4" || type === "uvec4")
      return new Vector4NodeUniform(uniformNode);
    if (type === "color") return new ColorNodeUniform(uniformNode);
    if (type === "mat2") return new Matrix2NodeUniform(uniformNode);
    if (type === "mat3") return new Matrix3NodeUniform(uniformNode);
    if (type === "mat4") return new Matrix4NodeUniform(uniformNode);
    throw new Error(`Uniform "${type}" not declared.`);
  }
  /**
   * Formats the given shader snippet from a given type into another one. E.g.
   * this method might be used to convert a simple float string `"1.0"` into a
   * `vec3` representation: `"vec3<f32>( 1.0 )"`.
   *
   * @param {string} snippet - The shader snippet.
   * @param {string} fromType - The source type.
   * @param {string} toType - The target type.
   * @return {string} The updated shader string.
   */
  format(snippet, fromType, toType) {
    fromType = this.getVectorType(fromType);
    toType = this.getVectorType(toType);
    if (fromType === toType || toType === null || this.isReference(toType)) {
      return snippet;
    }
    const fromTypeLength = this.getTypeLength(fromType);
    const toTypeLength = this.getTypeLength(toType);
    if (fromTypeLength === 16 && toTypeLength === 9) {
      return `${this.getType(
        toType
      )}( ${snippet}[ 0 ].xyz, ${snippet}[ 1 ].xyz, ${snippet}[ 2 ].xyz )`;
    }
    if (fromTypeLength === 9 && toTypeLength === 4) {
      return `${this.getType(
        toType
      )}( ${snippet}[ 0 ].xy, ${snippet}[ 1 ].xy )`;
    }
    if (fromTypeLength > 4) {
      return snippet;
    }
    if (toTypeLength > 4 || toTypeLength === 0) {
      return snippet;
    }
    if (fromTypeLength === toTypeLength) {
      return `${this.getType(toType)}( ${snippet} )`;
    }
    if (fromTypeLength > toTypeLength) {
      snippet =
        toType === "bool"
          ? `all( ${snippet} )`
          : `${snippet}.${"xyz".slice(0, toTypeLength)}`;
      return this.format(
        snippet,
        this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)),
        toType
      );
    }
    if (toTypeLength === 4 && fromTypeLength > 1) {
      return `${this.getType(toType)}( ${this.format(
        snippet,
        fromType,
        "vec3"
      )}, 1.0 )`;
    }
    if (fromTypeLength === 2) {
      return `${this.getType(toType)}( ${this.format(
        snippet,
        fromType,
        "vec2"
      )}, 0.0 )`;
    }
    if (
      fromTypeLength === 1 &&
      toTypeLength > 1 &&
      fromType !== this.getComponentType(toType)
    ) {
      snippet = `${this.getType(this.getComponentType(toType))}( ${snippet} )`;
    }
    return `${this.getType(toType)}( ${snippet} )`;
  }
  /**
   * Returns a signature with the engine's current revision.
   *
   * @return {string} The signature.
   */
  getSignature() {
    return `// Three.js r${REVISION} - Node System
`;
  }
  /**
   * Prevents the node builder from being used as an iterable in TSL.Fn(), avoiding potential runtime errors.
   */
  *[Symbol.iterator]() {}
}
class NodeFrame {
  /**
   * Constructs a new node fame.
   */
  constructor() {
    this.time = 0;
    this.deltaTime = 0;
    this.frameId = 0;
    this.renderId = 0;
    this.updateMap = /* @__PURE__ */ new WeakMap();
    this.updateBeforeMap = /* @__PURE__ */ new WeakMap();
    this.updateAfterMap = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.material = null;
    this.camera = null;
    this.object = null;
    this.scene = null;
  }
  /**
   * Returns a dictionary for a given node and update map which
   * is used to correctly call node update methods per frame or render.
   *
   * @private
   * @param {WeakMap<Node, Object>} referenceMap - The reference weak map.
   * @param {Node} nodeRef - The reference to the current node.
   * @return {Object<string,WeakMap>} The dictionary.
   */
  _getMaps(referenceMap, nodeRef) {
    let maps = referenceMap.get(nodeRef);
    if (maps === void 0) {
      maps = {
        renderMap: /* @__PURE__ */ new WeakMap(),
        frameMap: /* @__PURE__ */ new WeakMap(),
      };
      referenceMap.set(nodeRef, maps);
    }
    return maps;
  }
  /**
   * This method executes the {@link Node#updateBefore} for the given node.
   * It makes sure {@link Node#updateBeforeType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateBeforeNode(node) {
    const updateType = node.getUpdateBeforeType();
    const reference2 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const { frameMap } = this._getMaps(this.updateBeforeMap, reference2);
      if (frameMap.get(reference2) !== this.frameId) {
        if (node.updateBefore(this) !== false) {
          frameMap.set(reference2, this.frameId);
        }
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const { renderMap } = this._getMaps(this.updateBeforeMap, reference2);
      if (renderMap.get(reference2) !== this.renderId) {
        if (node.updateBefore(this) !== false) {
          renderMap.set(reference2, this.renderId);
        }
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.updateBefore(this);
    }
  }
  /**
   * This method executes the {@link Node#updateAfter} for the given node.
   * It makes sure {@link Node#updateAfterType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateAfterNode(node) {
    const updateType = node.getUpdateAfterType();
    const reference2 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const { frameMap } = this._getMaps(this.updateAfterMap, reference2);
      if (frameMap.get(reference2) !== this.frameId) {
        if (node.updateAfter(this) !== false) {
          frameMap.set(reference2, this.frameId);
        }
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const { renderMap } = this._getMaps(this.updateAfterMap, reference2);
      if (renderMap.get(reference2) !== this.renderId) {
        if (node.updateAfter(this) !== false) {
          renderMap.set(reference2, this.renderId);
        }
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.updateAfter(this);
    }
  }
  /**
   * This method executes the {@link Node#update} for the given node.
   * It makes sure {@link Node#updateType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateNode(node) {
    const updateType = node.getUpdateType();
    const reference2 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const { frameMap } = this._getMaps(this.updateMap, reference2);
      if (frameMap.get(reference2) !== this.frameId) {
        if (node.update(this) !== false) {
          frameMap.set(reference2, this.frameId);
        }
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const { renderMap } = this._getMaps(this.updateMap, reference2);
      if (renderMap.get(reference2) !== this.renderId) {
        if (node.update(this) !== false) {
          renderMap.set(reference2, this.renderId);
        }
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.update(this);
    }
  }
  /**
   * Updates the internal state of the node frame. This method is
   * called by the renderer in its internal animation loop.
   */
  update() {
    this.frameId++;
    if (this.lastTime === void 0) this.lastTime = performance.now();
    this.deltaTime = (performance.now() - this.lastTime) / 1e3;
    this.lastTime = performance.now();
    this.time += this.deltaTime;
  }
}
class NodeFunctionInput {
  /**
   * Constructs a new node function input.
   *
   * @param {string} type - The input type.
   * @param {string} name - The input name.
   * @param {?number} [count=null] - If the input is an Array, count will be the length.
   * @param {('in'|'out'|'inout')} [qualifier=''] - The parameter qualifier (only relevant for GLSL).
   * @param {boolean} [isConst=false] - Whether the input uses a const qualifier or not (only relevant for GLSL).
   */
  constructor(type, name, count = null, qualifier = "", isConst = false) {
    this.type = type;
    this.name = name;
    this.count = count;
    this.qualifier = qualifier;
    this.isConst = isConst;
  }
}
NodeFunctionInput.isNodeFunctionInput = true;
class DirectionalLightNode extends AnalyticLightNode {
  static get type() {
    return "DirectionalLightNode";
  }
  /**
   * Constructs a new directional light node.
   *
   * @param {?DirectionalLight} [light=null] - The directional light source.
   */
  constructor(light = null) {
    super(light);
  }
  setupDirect() {
    const lightColor = this.colorNode;
    const lightDirection = lightTargetDirection(this.light);
    return { lightDirection, lightColor };
  }
}
const _matrix41 = /* @__PURE__ */ new Matrix4();
const _matrix42 = /* @__PURE__ */ new Matrix4();
let _ltcLib = null;
class RectAreaLightNode extends AnalyticLightNode {
  static get type() {
    return "RectAreaLightNode";
  }
  /**
   * Constructs a new rect area light node.
   *
   * @param {?RectAreaLight} [light=null] - The rect area light source.
   */
  constructor(light = null) {
    super(light);
    this.halfHeight = uniform$1(new Vector3()).setGroup(renderGroup);
    this.halfWidth = uniform$1(new Vector3()).setGroup(renderGroup);
    this.updateType = NodeUpdateType.RENDER;
  }
  /**
   * Overwritten to updated rect area light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame) {
    super.update(frame);
    const { light } = this;
    const viewMatrix = frame.camera.matrixWorldInverse;
    _matrix42.identity();
    _matrix41.copy(light.matrixWorld);
    _matrix41.premultiply(viewMatrix);
    _matrix42.extractRotation(_matrix41);
    this.halfWidth.value.set(light.width * 0.5, 0, 0);
    this.halfHeight.value.set(0, light.height * 0.5, 0);
    this.halfWidth.value.applyMatrix4(_matrix42);
    this.halfHeight.value.applyMatrix4(_matrix42);
  }
  setupDirectRectArea(builder) {
    let ltc_1, ltc_2;
    if (builder.isAvailable("float32Filterable")) {
      ltc_1 = texture$1(_ltcLib.LTC_FLOAT_1);
      ltc_2 = texture$1(_ltcLib.LTC_FLOAT_2);
    } else {
      ltc_1 = texture$1(_ltcLib.LTC_HALF_1);
      ltc_2 = texture$1(_ltcLib.LTC_HALF_2);
    }
    const { colorNode, light } = this;
    const lightPosition2 = lightViewPosition(light);
    return {
      lightColor: colorNode,
      lightPosition: lightPosition2,
      halfWidth: this.halfWidth,
      halfHeight: this.halfHeight,
      ltc_1,
      ltc_2,
    };
  }
  /**
   * Used to configure the internal BRDF approximation texture data.
   *
   * @param {RectAreaLightTexturesLib} ltc - The BRDF approximation texture data.
   */
  static setLTC(ltc) {
    _ltcLib = ltc;
  }
}
class SpotLightNode extends AnalyticLightNode {
  static get type() {
    return "SpotLightNode";
  }
  /**
   * Constructs a new spot light node.
   *
   * @param {?SpotLight} [light=null] - The spot light source.
   */
  constructor(light = null) {
    super(light);
    this.coneCosNode = uniform$1(0).setGroup(renderGroup);
    this.penumbraCosNode = uniform$1(0).setGroup(renderGroup);
    this.cutoffDistanceNode = uniform$1(0).setGroup(renderGroup);
    this.decayExponentNode = uniform$1(0).setGroup(renderGroup);
    this.colorNode = uniform$1(this.color).setGroup(renderGroup);
  }
  /**
   * Overwritten to updated spot light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame) {
    super.update(frame);
    const { light } = this;
    this.coneCosNode.value = Math.cos(light.angle);
    this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  /**
   * Computes the spot attenuation for the given angle.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(builder, angleCosine) {
    const { coneCosNode, penumbraCosNode } = this;
    return smoothstep(coneCosNode, penumbraCosNode, angleCosine);
  }
  getLightCoord(builder) {
    const properties = builder.getNodeProperties(this);
    let projectionUV = properties.projectionUV;
    if (projectionUV === void 0) {
      projectionUV = lightProjectionUV(
        this.light,
        builder.context.positionWorld
      );
      properties.projectionUV = projectionUV;
    }
    return projectionUV;
  }
  setupDirect(builder) {
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lightVector = this.getLightVector(builder);
    const lightDirection = lightVector.normalize();
    const angleCos = lightDirection.dot(lightTargetDirection(light));
    const spotAttenuation = this.getSpotAttenuation(builder, angleCos);
    const lightDistance = lightVector.length();
    const lightAttenuation = getDistanceAttenuation({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode,
    });
    let lightColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);
    let projected, lightCoord;
    if (light.colorNode) {
      lightCoord = this.getLightCoord(builder);
      projected = light.colorNode(lightCoord);
    } else if (light.map) {
      lightCoord = this.getLightCoord(builder);
      projected = texture$1(light.map, lightCoord.xy).onRenderUpdate(
        () => light.map
      );
    }
    if (projected) {
      const inSpotLightMap = lightCoord.mul(2).sub(1).abs().lessThan(1).all();
      lightColor = inSpotLightMap.select(lightColor.mul(projected), lightColor);
    }
    return { lightColor, lightDirection };
  }
}
class IESSpotLightNode extends SpotLightNode {
  static get type() {
    return "IESSpotLightNode";
  }
  /**
   * Overwrites the default implementation to compute an IES conform spot attenuation.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(builder, angleCosine) {
    const iesMap = this.light.iesMap;
    let spotAttenuation = null;
    if (iesMap && iesMap.isTexture === true) {
      const angle = angleCosine.acos().mul(1 / Math.PI);
      spotAttenuation = texture$1(iesMap, vec2(angle, 0), 0).r;
    } else {
      spotAttenuation = super.getSpotAttenuation(angleCosine);
    }
    return spotAttenuation;
  }
}
const sdBox = /* @__PURE__ */ Fn(([p2, b]) => {
  const d2 = p2.abs().sub(b);
  return length(max$1(d2, 0)).add(min$1(max$1(d2.x, d2.y), 0));
});
class ProjectorLightNode extends SpotLightNode {
  static get type() {
    return "ProjectorLightNode";
  }
  update(frame) {
    super.update(frame);
    const light = this.light;
    this.penumbraCosNode.value = Math.min(
      Math.cos(light.angle * (1 - light.penumbra)),
      0.99999
    );
    if (light.aspect === null) {
      let aspect2 = 1;
      if (light.map !== null) {
        aspect2 = light.map.width / light.map.height;
      }
      light.shadow.aspect = aspect2;
    } else {
      light.shadow.aspect = light.aspect;
    }
  }
  /**
   * Overwrites the default implementation to compute projection attenuation.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(builder) {
    const attenuation = float(0);
    const penumbraCos = this.penumbraCosNode;
    const spotLightCoord = lightShadowMatrix(this.light).mul(
      builder.context.positionWorld || positionWorld
    );
    If(spotLightCoord.w.greaterThan(0), () => {
      const projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);
      const boxDist = sdBox(projectionUV.xy.sub(vec2(0.5)), vec2(0.5));
      const angleFactor = div(-1, sub(1, acos(penumbraCos)).sub(1));
      attenuation.assign(saturate(boxDist.mul(-2).mul(angleFactor)));
    });
    return attenuation;
  }
}
class AmbientLightNode extends AnalyticLightNode {
  static get type() {
    return "AmbientLightNode";
  }
  /**
   * Constructs a new ambient light node.
   *
   * @param {?AmbientLight} [light=null] - The ambient light source.
   */
  constructor(light = null) {
    super(light);
  }
  setup({ context: context2 }) {
    context2.irradiance.addAssign(this.colorNode);
  }
}
class HemisphereLightNode extends AnalyticLightNode {
  static get type() {
    return "HemisphereLightNode";
  }
  /**
   * Constructs a new hemisphere light node.
   *
   * @param {?HemisphereLight} [light=null] - The hemisphere light source.
   */
  constructor(light = null) {
    super(light);
    this.lightPositionNode = lightPosition(light);
    this.lightDirectionNode = this.lightPositionNode.normalize();
    this.groundColorNode = uniform$1(new Color()).setGroup(renderGroup);
  }
  /**
   * Overwritten to updated hemisphere light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.lightPositionNode.object3d = light;
    this.groundColorNode.value
      .copy(light.groundColor)
      .multiplyScalar(light.intensity);
  }
  setup(builder) {
    const { colorNode, groundColorNode, lightDirectionNode } = this;
    const dotNL = normalWorld.dot(lightDirectionNode);
    const hemiDiffuseWeight = dotNL.mul(0.5).add(0.5);
    const irradiance = mix$1(groundColorNode, colorNode, hemiDiffuseWeight);
    builder.context.irradiance.addAssign(irradiance);
  }
}
class LightProbeNode extends AnalyticLightNode {
  static get type() {
    return "LightProbeNode";
  }
  /**
   * Constructs a new light probe node.
   *
   * @param {?LightProbe} [light=null] - The light probe.
   */
  constructor(light = null) {
    super(light);
    const array2 = [];
    for (let i2 = 0; i2 < 9; i2++) array2.push(new Vector3());
    this.lightProbe = uniformArray(array2);
  }
  /**
   * Overwritten to updated light probe specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame) {
    const { light } = this;
    super.update(frame);
    for (let i2 = 0; i2 < 9; i2++) {
      this.lightProbe.array[i2]
        .copy(light.sh.coefficients[i2])
        .multiplyScalar(light.intensity);
    }
  }
  setup(builder) {
    const irradiance = getShIrradianceAt(normalWorld, this.lightProbe);
    builder.context.irradiance.addAssign(irradiance);
  }
}
class NodeParser {
  /**
   * The method parses the given native code an returns a node function.
   *
   * @abstract
   * @param {string} source - The native shader code.
   * @return {NodeFunction} A node function.
   */
  parseFunction() {
    console.warn("Abstract function.");
  }
}
class NodeFunction {
  /**
   * Constructs a new node function.
   *
   * @param {string} type - The node type. This type is the return type of the node function.
   * @param {Array<NodeFunctionInput>} inputs - The function's inputs.
   * @param {string} [name=''] - The function's name.
   * @param {string} [precision=''] - The precision qualifier.
   */
  constructor(type, inputs, name = "", precision = "") {
    this.type = type;
    this.inputs = inputs;
    this.name = name;
    this.precision = precision;
  }
  /**
   * This method returns the native code of the node function.
   *
   * @abstract
   * @param {string} name - The function's name.
   * @return {string} A shader code.
   */
  getCode() {
    console.warn("Abstract function.");
  }
}
NodeFunction.isNodeFunction = true;
const declarationRegexp$1 =
  /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
const propertiesRegexp$1 = /[a-z_0-9]+/gi;
const pragmaMain = "#pragma main";
const parse$1 = (source) => {
  source = source.trim();
  const pragmaMainIndex = source.indexOf(pragmaMain);
  const mainCode =
    pragmaMainIndex !== -1
      ? source.slice(pragmaMainIndex + pragmaMain.length)
      : source;
  const declaration = mainCode.match(declarationRegexp$1);
  if (declaration !== null && declaration.length === 5) {
    const inputsCode = declaration[4];
    const propsMatches = [];
    let nameMatch = null;
    while ((nameMatch = propertiesRegexp$1.exec(inputsCode)) !== null) {
      propsMatches.push(nameMatch);
    }
    const inputs = [];
    let i2 = 0;
    while (i2 < propsMatches.length) {
      const isConst = propsMatches[i2][0] === "const";
      if (isConst === true) {
        i2++;
      }
      let qualifier = propsMatches[i2][0];
      if (qualifier === "in" || qualifier === "out" || qualifier === "inout") {
        i2++;
      } else {
        qualifier = "";
      }
      const type2 = propsMatches[i2++][0];
      let count = Number.parseInt(propsMatches[i2][0]);
      if (Number.isNaN(count) === false) i2++;
      else count = null;
      const name2 = propsMatches[i2++][0];
      inputs.push(
        new NodeFunctionInput(type2, name2, count, qualifier, isConst)
      );
    }
    const blockCode = mainCode.substring(declaration[0].length);
    const name = declaration[3] !== void 0 ? declaration[3] : "";
    const type = declaration[2];
    const precision = declaration[1] !== void 0 ? declaration[1] : "";
    const headerCode =
      pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : "";
    return {
      type,
      inputs,
      name,
      precision,
      inputsCode,
      blockCode,
      headerCode,
    };
  } else {
    throw new Error("FunctionNode: Function is not a GLSL code.");
  }
};
class GLSLNodeFunction extends NodeFunction {
  /**
   * Constructs a new GLSL node function.
   *
   * @param {string} source - The GLSL source.
   */
  constructor(source) {
    const { type, inputs, name, precision, inputsCode, blockCode, headerCode } =
      parse$1(source);
    super(type, inputs, name, precision);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
    this.headerCode = headerCode;
  }
  /**
   * This method returns the GLSL code of the node function.
   *
   * @param {string} [name=this.name] - The function's name.
   * @return {string} The shader code.
   */
  getCode(name = this.name) {
    let code2;
    const blockCode = this.blockCode;
    if (blockCode !== "") {
      const { type, inputsCode, headerCode, precision } = this;
      let declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;
      if (precision !== "") {
        declarationCode = `${precision} ${declarationCode}`;
      }
      code2 = headerCode + declarationCode + blockCode;
    } else {
      code2 = "";
    }
    return code2;
  }
}
class GLSLNodeParser extends NodeParser {
  /**
   * The method parses the given GLSL code an returns a node function.
   *
   * @param {string} source - The GLSL code.
   * @return {GLSLNodeFunction} A node function.
   */
  parseFunction(source) {
    return new GLSLNodeFunction(source);
  }
}
const _outputNodeMap = /* @__PURE__ */ new WeakMap();
const _chainKeys$2 = [];
const _cacheKeyValues = [];
class Nodes extends DataMap {
  /**
   * Constructs a new nodes management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Backend} backend - The renderer's backend.
   */
  constructor(renderer2, backend) {
    super();
    this.renderer = renderer2;
    this.backend = backend;
    this.nodeFrame = new NodeFrame();
    this.nodeBuilderCache = /* @__PURE__ */ new Map();
    this.callHashCache = new ChainMap();
    this.groupsData = new ChainMap();
    this.cacheLib = {};
  }
  /**
   * Returns `true` if the given node uniforms group must be updated or not.
   *
   * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.
   * @return {boolean} Whether the node uniforms group requires an update or not.
   */
  updateGroup(nodeUniformsGroup) {
    const groupNode = nodeUniformsGroup.groupNode;
    const name = groupNode.name;
    if (name === objectGroup.name) return true;
    if (name === renderGroup.name) {
      const uniformsGroupData = this.get(nodeUniformsGroup);
      const renderId = this.nodeFrame.renderId;
      if (uniformsGroupData.renderId !== renderId) {
        uniformsGroupData.renderId = renderId;
        return true;
      }
      return false;
    }
    if (name === frameGroup.name) {
      const uniformsGroupData = this.get(nodeUniformsGroup);
      const frameId2 = this.nodeFrame.frameId;
      if (uniformsGroupData.frameId !== frameId2) {
        uniformsGroupData.frameId = frameId2;
        return true;
      }
      return false;
    }
    _chainKeys$2[0] = groupNode;
    _chainKeys$2[1] = nodeUniformsGroup;
    let groupData = this.groupsData.get(_chainKeys$2);
    if (groupData === void 0)
      this.groupsData.set(_chainKeys$2, (groupData = {}));
    _chainKeys$2.length = 0;
    if (groupData.version !== groupNode.version) {
      groupData.version = groupNode.version;
      return true;
    }
    return false;
  }
  /**
   * Returns the cache key for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {number} The cache key.
   */
  getForRenderCacheKey(renderObject) {
    return renderObject.initialCacheKey;
  }
  /**
   * Returns a node builder state for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {NodeBuilderState} The node builder state.
   */
  getForRender(renderObject) {
    const renderObjectData = this.get(renderObject);
    let nodeBuilderState = renderObjectData.nodeBuilderState;
    if (nodeBuilderState === void 0) {
      const { nodeBuilderCache } = this;
      const cacheKey = this.getForRenderCacheKey(renderObject);
      nodeBuilderState = nodeBuilderCache.get(cacheKey);
      if (nodeBuilderState === void 0) {
        const nodeBuilder = this.backend.createNodeBuilder(
          renderObject.object,
          this.renderer
        );
        nodeBuilder.scene = renderObject.scene;
        nodeBuilder.material = renderObject.material;
        nodeBuilder.camera = renderObject.camera;
        nodeBuilder.context.material = renderObject.material;
        nodeBuilder.lightsNode = renderObject.lightsNode;
        nodeBuilder.environmentNode = this.getEnvironmentNode(
          renderObject.scene
        );
        nodeBuilder.fogNode = this.getFogNode(renderObject.scene);
        nodeBuilder.clippingContext = renderObject.clippingContext;
        if (
          this.renderer.getOutputRenderTarget()
            ? this.renderer.getOutputRenderTarget().multiview
            : false
        ) {
          nodeBuilder.enableMultiview();
        }
        nodeBuilder.build();
        nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
        nodeBuilderCache.set(cacheKey, nodeBuilderState);
      }
      nodeBuilderState.usedTimes++;
      renderObjectData.nodeBuilderState = nodeBuilderState;
    }
    return nodeBuilderState;
  }
  /**
   * Deletes the given object from the internal data map
   *
   * @param {any} object - The object to delete.
   * @return {?Object} The deleted dictionary.
   */
  delete(object) {
    if (object.isRenderObject) {
      const nodeBuilderState = this.get(object).nodeBuilderState;
      nodeBuilderState.usedTimes--;
      if (nodeBuilderState.usedTimes === 0) {
        this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));
      }
    }
    return super.delete(object);
  }
  /**
   * Returns a node builder state for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @return {NodeBuilderState} The node builder state.
   */
  getForCompute(computeNode) {
    const computeData = this.get(computeNode);
    let nodeBuilderState = computeData.nodeBuilderState;
    if (nodeBuilderState === void 0) {
      const nodeBuilder = this.backend.createNodeBuilder(
        computeNode,
        this.renderer
      );
      nodeBuilder.build();
      nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
      computeData.nodeBuilderState = nodeBuilderState;
    }
    return nodeBuilderState;
  }
  /**
   * Creates a node builder state for the given node builder.
   *
   * @private
   * @param {NodeBuilder} nodeBuilder - The node builder.
   * @return {NodeBuilderState} The node builder state.
   */
  _createNodeBuilderState(nodeBuilder) {
    return new NodeBuilderState(
      nodeBuilder.vertexShader,
      nodeBuilder.fragmentShader,
      nodeBuilder.computeShader,
      nodeBuilder.getAttributesArray(),
      nodeBuilder.getBindings(),
      nodeBuilder.updateNodes,
      nodeBuilder.updateBeforeNodes,
      nodeBuilder.updateAfterNodes,
      nodeBuilder.observer,
      nodeBuilder.transforms
    );
  }
  /**
   * Returns an environment node for the current configured
   * scene environment.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene environment.
   */
  getEnvironmentNode(scene2) {
    this.updateEnvironment(scene2);
    let environmentNode = null;
    if (scene2.environmentNode && scene2.environmentNode.isNode) {
      environmentNode = scene2.environmentNode;
    } else {
      const sceneData = this.get(scene2);
      if (sceneData.environmentNode) {
        environmentNode = sceneData.environmentNode;
      }
    }
    return environmentNode;
  }
  /**
   * Returns a background node for the current configured
   * scene background.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene background.
   */
  getBackgroundNode(scene2) {
    this.updateBackground(scene2);
    let backgroundNode = null;
    if (scene2.backgroundNode && scene2.backgroundNode.isNode) {
      backgroundNode = scene2.backgroundNode;
    } else {
      const sceneData = this.get(scene2);
      if (sceneData.backgroundNode) {
        backgroundNode = sceneData.backgroundNode;
      }
    }
    return backgroundNode;
  }
  /**
   * Returns a fog node for the current configured scene fog.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene fog.
   */
  getFogNode(scene2) {
    this.updateFog(scene2);
    return scene2.fogNode || this.get(scene2).fogNode || null;
  }
  /**
   * Returns a cache key for the given scene and lights node.
   * This key is used by `RenderObject` as a part of the dynamic
   * cache key (a key that must be checked every time the render
   * objects is drawn).
   *
   * @param {Scene} scene - The scene.
   * @param {LightsNode} lightsNode - The lights node.
   * @return {number} The cache key.
   */
  getCacheKey(scene2, lightsNode) {
    _chainKeys$2[0] = scene2;
    _chainKeys$2[1] = lightsNode;
    const callId = this.renderer.info.calls;
    const cacheKeyData = this.callHashCache.get(_chainKeys$2) || {};
    if (cacheKeyData.callId !== callId) {
      const environmentNode = this.getEnvironmentNode(scene2);
      const fogNode = this.getFogNode(scene2);
      if (lightsNode) _cacheKeyValues.push(lightsNode.getCacheKey(true));
      if (environmentNode) _cacheKeyValues.push(environmentNode.getCacheKey());
      if (fogNode) _cacheKeyValues.push(fogNode.getCacheKey());
      _cacheKeyValues.push(
        this.renderer.getOutputRenderTarget() &&
          this.renderer.getOutputRenderTarget().multiview
          ? 1
          : 0
      );
      _cacheKeyValues.push(this.renderer.shadowMap.enabled ? 1 : 0);
      cacheKeyData.callId = callId;
      cacheKeyData.cacheKey = hashArray(_cacheKeyValues);
      this.callHashCache.set(_chainKeys$2, cacheKeyData);
      _cacheKeyValues.length = 0;
    }
    _chainKeys$2.length = 0;
    return cacheKeyData.cacheKey;
  }
  /**
   * A boolean that indicates whether tone mapping should be enabled
   * or not.
   *
   * @type {boolean}
   */
  get isToneMappingState() {
    return this.renderer.getRenderTarget() ? false : true;
  }
  /**
   * If a scene background is configured, this method makes sure to
   * represent the background with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateBackground(scene2) {
    const sceneData = this.get(scene2);
    const background = scene2.background;
    if (background) {
      const forceUpdate =
        (scene2.backgroundBlurriness === 0 &&
          sceneData.backgroundBlurriness > 0) ||
        (scene2.backgroundBlurriness > 0 &&
          sceneData.backgroundBlurriness === 0);
      if (sceneData.background !== background || forceUpdate) {
        const backgroundNode = this.getCacheNode(
          "background",
          background,
          () => {
            if (
              background.isCubeTexture === true ||
              background.mapping === EquirectangularReflectionMapping ||
              background.mapping === EquirectangularRefractionMapping ||
              background.mapping === CubeUVReflectionMapping
            ) {
              if (
                scene2.backgroundBlurriness > 0 ||
                background.mapping === CubeUVReflectionMapping
              ) {
                return pmremTexture(background);
              } else {
                let envMap;
                if (background.isCubeTexture === true) {
                  envMap = cubeTexture(background);
                } else {
                  envMap = texture$1(background);
                }
                return cubeMapNode(envMap);
              }
            } else if (background.isTexture === true) {
              return texture$1(background, screenUV.flipY()).setUpdateMatrix(
                true
              );
            } else if (background.isColor !== true) {
              console.error(
                "WebGPUNodes: Unsupported background configuration.",
                background
              );
            }
          },
          forceUpdate
        );
        sceneData.backgroundNode = backgroundNode;
        sceneData.background = background;
        sceneData.backgroundBlurriness = scene2.backgroundBlurriness;
      }
    } else if (sceneData.backgroundNode) {
      delete sceneData.backgroundNode;
      delete sceneData.background;
    }
  }
  /**
   * This method is part of the caching of nodes which are used to represents the
   * scene's background, fog or environment.
   *
   * @param {string} type - The type of object to cache.
   * @param {Object} object - The object.
   * @param {Function} callback - A callback that produces a node representation for the given object.
   * @param {boolean} [forceUpdate=false] - Whether an update should be enforced or not.
   * @return {Node} The node representation.
   */
  getCacheNode(type, object, callback, forceUpdate = false) {
    const nodeCache =
      this.cacheLib[type] ||
      (this.cacheLib[type] = /* @__PURE__ */ new WeakMap());
    let node = nodeCache.get(object);
    if (node === void 0 || forceUpdate) {
      node = callback();
      nodeCache.set(object, node);
    }
    return node;
  }
  /**
   * If a scene fog is configured, this method makes sure to
   * represent the fog with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateFog(scene2) {
    const sceneData = this.get(scene2);
    const sceneFog = scene2.fog;
    if (sceneFog) {
      if (sceneData.fog !== sceneFog) {
        const fogNode = this.getCacheNode("fog", sceneFog, () => {
          if (sceneFog.isFogExp2) {
            const color2 = reference("color", "color", sceneFog).setGroup(
              renderGroup
            );
            const density = reference("density", "float", sceneFog).setGroup(
              renderGroup
            );
            return fog(color2, densityFogFactor(density));
          } else if (sceneFog.isFog) {
            const color2 = reference("color", "color", sceneFog).setGroup(
              renderGroup
            );
            const near = reference("near", "float", sceneFog).setGroup(
              renderGroup
            );
            const far = reference("far", "float", sceneFog).setGroup(
              renderGroup
            );
            return fog(color2, rangeFogFactor(near, far));
          } else {
            console.error(
              "THREE.Renderer: Unsupported fog configuration.",
              sceneFog
            );
          }
        });
        sceneData.fogNode = fogNode;
        sceneData.fog = sceneFog;
      }
    } else {
      delete sceneData.fogNode;
      delete sceneData.fog;
    }
  }
  /**
   * If a scene environment is configured, this method makes sure to
   * represent the environment with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateEnvironment(scene2) {
    const sceneData = this.get(scene2);
    const environment = scene2.environment;
    if (environment) {
      if (sceneData.environment !== environment) {
        const environmentNode = this.getCacheNode(
          "environment",
          environment,
          () => {
            if (environment.isCubeTexture === true) {
              return cubeTexture(environment);
            } else if (environment.isTexture === true) {
              return texture$1(environment);
            } else {
              console.error(
                "Nodes: Unsupported environment configuration.",
                environment
              );
            }
          }
        );
        sceneData.environmentNode = environmentNode;
        sceneData.environment = environment;
      }
    } else if (sceneData.environmentNode) {
      delete sceneData.environmentNode;
      delete sceneData.environment;
    }
  }
  getNodeFrame(
    renderer2 = this.renderer,
    scene2 = null,
    object = null,
    camera2 = null,
    material = null
  ) {
    const nodeFrame = this.nodeFrame;
    nodeFrame.renderer = renderer2;
    nodeFrame.scene = scene2;
    nodeFrame.object = object;
    nodeFrame.camera = camera2;
    nodeFrame.material = material;
    return nodeFrame;
  }
  getNodeFrameForRender(renderObject) {
    return this.getNodeFrame(
      renderObject.renderer,
      renderObject.scene,
      renderObject.object,
      renderObject.camera,
      renderObject.material
    );
  }
  /**
   * Returns the current output cache key.
   *
   * @return {string} The output cache key.
   */
  getOutputCacheKey() {
    const renderer2 = this.renderer;
    return (
      renderer2.toneMapping +
      "," +
      renderer2.currentColorSpace +
      "," +
      renderer2.xr.isPresenting
    );
  }
  /**
   * Checks if the output configuration (tone mapping and color space) for
   * the given target has changed.
   *
   * @param {Texture} outputTarget - The output target.
   * @return {boolean} Whether the output configuration has changed or not.
   */
  hasOutputChange(outputTarget) {
    const cacheKey = _outputNodeMap.get(outputTarget);
    return cacheKey !== this.getOutputCacheKey();
  }
  /**
   * Returns a node that represents the output configuration (tone mapping and
   * color space) for the current target.
   *
   * @param {Texture} outputTarget - The output target.
   * @return {Node} The output node.
   */
  getOutputNode(outputTarget) {
    const renderer2 = this.renderer;
    const cacheKey = this.getOutputCacheKey();
    const output2 = outputTarget.isArrayTexture
      ? texture3D(
          outputTarget,
          vec3(screenUV, builtin("gl_ViewID_OVR"))
        ).renderOutput(renderer2.toneMapping, renderer2.currentColorSpace)
      : texture$1(outputTarget, screenUV).renderOutput(
          renderer2.toneMapping,
          renderer2.currentColorSpace
        );
    _outputNodeMap.set(outputTarget, cacheKey);
    return output2;
  }
  /**
   * Triggers the call of `updateBefore()` methods
   * for all nodes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateBefore(renderObject) {
    const nodeBuilder = renderObject.getNodeBuilderState();
    for (const node of nodeBuilder.updateBeforeNodes) {
      this.getNodeFrameForRender(renderObject).updateBeforeNode(node);
    }
  }
  /**
   * Triggers the call of `updateAfter()` methods
   * for all nodes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateAfter(renderObject) {
    const nodeBuilder = renderObject.getNodeBuilderState();
    for (const node of nodeBuilder.updateAfterNodes) {
      this.getNodeFrameForRender(renderObject).updateAfterNode(node);
    }
  }
  /**
   * Triggers the call of `update()` methods
   * for all nodes of the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   */
  updateForCompute(computeNode) {
    const nodeFrame = this.getNodeFrame();
    const nodeBuilder = this.getForCompute(computeNode);
    for (const node of nodeBuilder.updateNodes) {
      nodeFrame.updateNode(node);
    }
  }
  /**
   * Triggers the call of `update()` methods
   * for all nodes of the given compute node.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(renderObject) {
    const nodeFrame = this.getNodeFrameForRender(renderObject);
    const nodeBuilder = renderObject.getNodeBuilderState();
    for (const node of nodeBuilder.updateNodes) {
      nodeFrame.updateNode(node);
    }
  }
  /**
   * Returns `true` if the given render object requires a refresh.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the given render object requires a refresh or not.
   */
  needsRefresh(renderObject) {
    const nodeFrame = this.getNodeFrameForRender(renderObject);
    const monitor = renderObject.getMonitor();
    return monitor.needsRefresh(renderObject, nodeFrame);
  }
  /**
   * Frees the internal resources.
   */
  dispose() {
    super.dispose();
    this.nodeFrame = new NodeFrame();
    this.nodeBuilderCache = /* @__PURE__ */ new Map();
    this.cacheLib = {};
  }
}
const _plane$1 = /* @__PURE__ */ new Plane();
class ClippingContext {
  /**
   * Constructs a new clipping context.
   *
   * @param {?ClippingContext} [parentContext=null] - A reference to the parent clipping context.
   */
  constructor(parentContext = null) {
    this.version = 0;
    this.clipIntersection = null;
    this.cacheKey = "";
    this.shadowPass = false;
    this.viewNormalMatrix = new Matrix3();
    this.clippingGroupContexts = /* @__PURE__ */ new WeakMap();
    this.intersectionPlanes = [];
    this.unionPlanes = [];
    this.parentVersion = null;
    if (parentContext !== null) {
      this.viewNormalMatrix = parentContext.viewNormalMatrix;
      this.clippingGroupContexts = parentContext.clippingGroupContexts;
      this.shadowPass = parentContext.shadowPass;
      this.viewMatrix = parentContext.viewMatrix;
    }
  }
  /**
   * Projects the given source clipping planes and writes the result into the
   * destination array.
   *
   * @param {Array<Plane>} source - The source clipping planes.
   * @param {Array<Vector4>} destination - The destination.
   * @param {number} offset - The offset.
   */
  projectPlanes(source, destination, offset) {
    const l2 = source.length;
    for (let i2 = 0; i2 < l2; i2++) {
      _plane$1
        .copy(source[i2])
        .applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
      const v = destination[offset + i2];
      const normal2 = _plane$1.normal;
      v.x = -normal2.x;
      v.y = -normal2.y;
      v.z = -normal2.z;
      v.w = _plane$1.constant;
    }
  }
  /**
   * Updates the root clipping context of a scene.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   */
  updateGlobal(scene2, camera2) {
    this.shadowPass =
      scene2.overrideMaterial !== null &&
      scene2.overrideMaterial.isShadowPassMaterial;
    this.viewMatrix = camera2.matrixWorldInverse;
    this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
  }
  /**
   * Updates the clipping context.
   *
   * @param {ClippingContext} parentContext - The parent context.
   * @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.
   */
  update(parentContext, clippingGroup) {
    let update = false;
    if (parentContext.version !== this.parentVersion) {
      this.intersectionPlanes = Array.from(parentContext.intersectionPlanes);
      this.unionPlanes = Array.from(parentContext.unionPlanes);
      this.parentVersion = parentContext.version;
    }
    if (this.clipIntersection !== clippingGroup.clipIntersection) {
      this.clipIntersection = clippingGroup.clipIntersection;
      if (this.clipIntersection) {
        this.unionPlanes.length = parentContext.unionPlanes.length;
      } else {
        this.intersectionPlanes.length =
          parentContext.intersectionPlanes.length;
      }
    }
    const srcClippingPlanes = clippingGroup.clippingPlanes;
    const l2 = srcClippingPlanes.length;
    let dstClippingPlanes;
    let offset;
    if (this.clipIntersection) {
      dstClippingPlanes = this.intersectionPlanes;
      offset = parentContext.intersectionPlanes.length;
    } else {
      dstClippingPlanes = this.unionPlanes;
      offset = parentContext.unionPlanes.length;
    }
    if (dstClippingPlanes.length !== offset + l2) {
      dstClippingPlanes.length = offset + l2;
      for (let i2 = 0; i2 < l2; i2++) {
        dstClippingPlanes[offset + i2] = new Vector4();
      }
      update = true;
    }
    this.projectPlanes(srcClippingPlanes, dstClippingPlanes, offset);
    if (update) {
      this.version++;
      this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`;
    }
  }
  /**
   * Returns a clipping context for the given clipping group.
   *
   * @param {ClippingGroup} clippingGroup - The clipping group.
   * @return {ClippingContext} The clipping context.
   */
  getGroupContext(clippingGroup) {
    if (this.shadowPass && !clippingGroup.clipShadows) return this;
    let context2 = this.clippingGroupContexts.get(clippingGroup);
    if (context2 === void 0) {
      context2 = new ClippingContext(this);
      this.clippingGroupContexts.set(clippingGroup, context2);
    }
    context2.update(this, clippingGroup);
    return context2;
  }
  /**
   * The count of union clipping planes.
   *
   * @type {number}
   * @readonly
   */
  get unionClippingCount() {
    return this.unionPlanes.length;
  }
}
class RenderBundle {
  /**
   * Constructs a new bundle group.
   *
   * @param {BundleGroup} bundleGroup - The bundle group.
   * @param {Camera} camera - The camera the bundle group is rendered with.
   */
  constructor(bundleGroup, camera2) {
    this.bundleGroup = bundleGroup;
    this.camera = camera2;
  }
}
const _chainKeys$1 = [];
class RenderBundles {
  /**
   * Constructs a new render bundle management component.
   */
  constructor() {
    this.bundles = new ChainMap();
  }
  /**
   * Returns a render bundle for the given bundle group and camera.
   *
   * @param {BundleGroup} bundleGroup - The bundle group.
   * @param {Camera} camera - The camera the bundle group is rendered with.
   * @return {RenderBundle} The render bundle.
   */
  get(bundleGroup, camera2) {
    const bundles = this.bundles;
    _chainKeys$1[0] = bundleGroup;
    _chainKeys$1[1] = camera2;
    let bundle = bundles.get(_chainKeys$1);
    if (bundle === void 0) {
      bundle = new RenderBundle(bundleGroup, camera2);
      bundles.set(_chainKeys$1, bundle);
    }
    _chainKeys$1.length = 0;
    return bundle;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    this.bundles = new ChainMap();
  }
}
class NodeLibrary {
  /**
   * Constructs a new node library.
   */
  constructor() {
    this.lightNodes = /* @__PURE__ */ new WeakMap();
    this.materialNodes = /* @__PURE__ */ new Map();
    this.toneMappingNodes = /* @__PURE__ */ new Map();
  }
  /**
   * Returns a matching node material instance for the given material object.
   *
   * This method also assigns/copies the properties of the given material object
   * to the node material. This is done to make sure the current material
   * configuration carries over to the node version.
   *
   * @param {Material} material - A material.
   * @return {NodeMaterial} The corresponding node material.
   */
  fromMaterial(material) {
    if (material.isNodeMaterial) return material;
    let nodeMaterial = null;
    const nodeMaterialClass = this.getMaterialNodeClass(material.type);
    if (nodeMaterialClass !== null) {
      nodeMaterial = new nodeMaterialClass();
      for (const key in material) {
        nodeMaterial[key] = material[key];
      }
    }
    return nodeMaterial;
  }
  /**
   * Adds a tone mapping node function for a tone mapping technique (constant).
   *
   * @param {Function} toneMappingNode - The tone mapping node function.
   * @param {number} toneMapping - The tone mapping.
   */
  addToneMapping(toneMappingNode, toneMapping2) {
    this.addType(toneMappingNode, toneMapping2, this.toneMappingNodes);
  }
  /**
   * Returns a tone mapping node function for a tone mapping technique (constant).
   *
   * @param {number} toneMapping - The tone mapping.
   * @return {?Function} The tone mapping node function. Returns `null` if no node function is found.
   */
  getToneMappingFunction(toneMapping2) {
    return this.toneMappingNodes.get(toneMapping2) || null;
  }
  /**
   * Returns a node material class definition for a material type.
   *
   * @param {string} materialType - The material type.
   * @return {?NodeMaterial.constructor} The node material class definition. Returns `null` if no node material is found.
   */
  getMaterialNodeClass(materialType) {
    return this.materialNodes.get(materialType) || null;
  }
  /**
   * Adds a node material class definition for a given material type.
   *
   * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.
   * @param {string} materialClassType - The material type.
   */
  addMaterial(materialNodeClass, materialClassType) {
    this.addType(materialNodeClass, materialClassType, this.materialNodes);
  }
  /**
   * Returns a light node class definition for a light class definition.
   *
   * @param {Light.constructor} light - The light class definition.
   * @return {?AnalyticLightNode.constructor} The light node class definition. Returns `null` if no light node is found.
   */
  getLightNodeClass(light) {
    return this.lightNodes.get(light) || null;
  }
  /**
   * Adds a light node class definition for a given light class definition.
   *
   * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.
   * @param {Light.constructor} lightClass - The light class definition.
   */
  addLight(lightNodeClass, lightClass) {
    this.addClass(lightNodeClass, lightClass, this.lightNodes);
  }
  /**
   * Adds a node class definition for the given type to the provided type library.
   *
   * @param {any} nodeClass - The node class definition.
   * @param {number|string} type - The object type.
   * @param {Map} library - The type library.
   */
  addType(nodeClass, type, library) {
    if (library.has(type)) {
      console.warn(`Redefinition of node ${type}`);
      return;
    }
    if (typeof nodeClass !== "function")
      throw new Error(`Node class ${nodeClass.name} is not a class.`);
    if (typeof type === "function" || typeof type === "object")
      throw new Error(`Base class ${type} is not a class.`);
    library.set(type, nodeClass);
  }
  /**
   * Adds a node class definition for the given class definition to the provided type library.
   *
   * @param {any} nodeClass - The node class definition.
   * @param {any} baseClass - The class definition.
   * @param {WeakMap} library - The type library.
   */
  addClass(nodeClass, baseClass, library) {
    if (library.has(baseClass)) {
      console.warn(`Redefinition of node ${baseClass.name}`);
      return;
    }
    if (typeof nodeClass !== "function")
      throw new Error(`Node class ${nodeClass.name} is not a class.`);
    if (typeof baseClass !== "function")
      throw new Error(`Base class ${baseClass.name} is not a class.`);
    library.set(baseClass, nodeClass);
  }
}
const _defaultLights = /* @__PURE__ */ new LightsNode();
const _chainKeys = [];
class Lighting extends ChainMap {
  /**
   * Constructs a lighting management component.
   */
  constructor() {
    super();
  }
  /**
   * Creates a new lights node for the given array of lights.
   *
   * @param {Array<Light>} lights - The render object.
   * @return {LightsNode} The lights node.
   */
  createNode(lights2 = []) {
    return new LightsNode().setLights(lights2);
  }
  /**
   * Returns a lights node for the given scene and camera.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera.
   * @return {LightsNode} The lights node.
   */
  getNode(scene2, camera2) {
    if (scene2.isQuadMesh) return _defaultLights;
    _chainKeys[0] = scene2;
    _chainKeys[1] = camera2;
    let node = this.get(_chainKeys);
    if (node === void 0) {
      node = this.createNode();
      this.set(_chainKeys, node);
    }
    _chainKeys.length = 0;
    return node;
  }
}
class XRRenderTarget extends RenderTarget {
  /**
   * Constructs a new XR render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {Object} [options={}] - The configuration options.
   */
  constructor(width = 1, height = 1, options = {}) {
    super(width, height, options);
    this.isXRRenderTarget = true;
    this._hasExternalTextures = false;
    this._autoAllocateDepthBuffer = true;
    this._isOpaqueFramebuffer = false;
  }
  copy(source) {
    super.copy(source);
    this._hasExternalTextures = source._hasExternalTextures;
    this._autoAllocateDepthBuffer = source._autoAllocateDepthBuffer;
    this._isOpaqueFramebuffer = source._isOpaqueFramebuffer;
    return this;
  }
}
const _cameraLPos = /* @__PURE__ */ new Vector3();
const _cameraRPos = /* @__PURE__ */ new Vector3();
class XRManager extends EventDispatcher {
  /**
   * Constructs a new XR manager.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {boolean} [multiview=false] - Enables multiview if the device supports it.
   */
  constructor(renderer2, multiview = false) {
    super();
    this.enabled = false;
    this.isPresenting = false;
    this.cameraAutoUpdate = true;
    this._renderer = renderer2;
    this._cameraL = new PerspectiveCamera();
    this._cameraL.viewport = new Vector4();
    this._cameraR = new PerspectiveCamera();
    this._cameraR.viewport = new Vector4();
    this._cameras = [this._cameraL, this._cameraR];
    this._cameraXR = new ArrayCamera();
    this._currentDepthNear = null;
    this._currentDepthFar = null;
    this._controllers = [];
    this._controllerInputSources = [];
    this._xrRenderTarget = null;
    this._layers = [];
    this._supportsLayers = false;
    this._supportsGlBinding = typeof XRWebGLBinding !== "undefined";
    this._frameBufferTargets = null;
    this._createXRLayer = createXRLayer.bind(this);
    this._gl = null;
    this._currentAnimationContext = null;
    this._currentAnimationLoop = null;
    this._currentPixelRatio = null;
    this._currentSize = new Vector2();
    this._onSessionEvent = onSessionEvent.bind(this);
    this._onSessionEnd = onSessionEnd.bind(this);
    this._onInputSourcesChange = onInputSourcesChange.bind(this);
    this._onAnimationFrame = onAnimationFrame.bind(this);
    this._referenceSpace = null;
    this._referenceSpaceType = "local-floor";
    this._customReferenceSpace = null;
    this._framebufferScaleFactor = 1;
    this._foveation = 1;
    this._session = null;
    this._glBaseLayer = null;
    this._glBinding = null;
    this._glProjLayer = null;
    this._xrFrame = null;
    this._useLayers =
      this._supportsGlBinding &&
      "createProjectionLayer" in XRWebGLBinding.prototype;
    this._useMultiviewIfPossible = multiview;
    this._useMultiview = false;
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in target ray space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getController(index) {
    const controller = this._getController(index);
    return controller.getTargetRaySpace();
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in grip space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getControllerGrip(index) {
    const controller = this._getController(index);
    return controller.getGripSpace();
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in hand space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getHand(index) {
    const controller = this._getController(index);
    return controller.getHandSpace();
  }
  /**
   * Returns the foveation value.
   *
   * @return {number|undefined} The foveation value. Returns `undefined` if no base or projection layer is defined.
   */
  getFoveation() {
    if (this._glProjLayer === null && this._glBaseLayer === null) {
      return void 0;
    }
    return this._foveation;
  }
  /**
   * Sets the foveation value.
   *
   * @param {number} foveation - A number in the range `[0,1]` where `0` means no foveation (full resolution)
   * and `1` means maximum foveation (the edges render at lower resolution).
   */
  setFoveation(foveation) {
    this._foveation = foveation;
    if (this._glProjLayer !== null) {
      this._glProjLayer.fixedFoveation = foveation;
    }
    if (
      this._glBaseLayer !== null &&
      this._glBaseLayer.fixedFoveation !== void 0
    ) {
      this._glBaseLayer.fixedFoveation = foveation;
    }
  }
  /**
   * Returns the framebuffer scale factor.
   *
   * @return {number} The framebuffer scale factor.
   */
  getFramebufferScaleFactor() {
    return this._framebufferScaleFactor;
  }
  /**
   * Sets the framebuffer scale factor.
   *
   * This method can not be used during a XR session.
   *
   * @param {number} factor - The framebuffer scale factor.
   */
  setFramebufferScaleFactor(factor) {
    this._framebufferScaleFactor = factor;
    if (this.isPresenting === true) {
      console.warn(
        "THREE.XRManager: Cannot change framebuffer scale while presenting."
      );
    }
  }
  /**
   * Returns the reference space type.
   *
   * @return {XRReferenceSpaceType} The reference space type.
   */
  getReferenceSpaceType() {
    return this._referenceSpaceType;
  }
  /**
   * Sets the reference space type.
   *
   * This method can not be used during a XR session.
   *
   * @param {XRReferenceSpaceType} type - The reference space type.
   */
  setReferenceSpaceType(type) {
    this._referenceSpaceType = type;
    if (this.isPresenting === true) {
      console.warn(
        "THREE.XRManager: Cannot change reference space type while presenting."
      );
    }
  }
  /**
   * Returns the XR reference space.
   *
   * @return {XRReferenceSpace} The XR reference space.
   */
  getReferenceSpace() {
    return this._customReferenceSpace || this._referenceSpace;
  }
  /**
   * Sets a custom XR reference space.
   *
   * @param {XRReferenceSpace} space - The XR reference space.
   */
  setReferenceSpace(space) {
    this._customReferenceSpace = space;
  }
  /**
   * Returns the XR camera.
   *
   * @return {ArrayCamera} The XR camera.
   */
  getCamera() {
    return this._cameraXR;
  }
  /**
   * Returns the environment blend mode from the current XR session.
   *
   * @return {'opaque'|'additive'|'alpha-blend'|undefined} The environment blend mode. Returns `undefined` when used outside of a XR session.
   */
  getEnvironmentBlendMode() {
    if (this._session !== null) {
      return this._session.environmentBlendMode;
    }
  }
  /**
   * Returns the current XR frame.
   *
   * @return {?XRFrame} The XR frame. Returns `null` when used outside a XR session.
   */
  getFrame() {
    return this._xrFrame;
  }
  /**
   * Returns `true` if the engine renders to a multiview target.
   *
   * @return {boolean} Whether the engine renders to a multiview render target or not.
   */
  useMultiview() {
    return this._useMultiview;
  }
  /**
   * This method can be used in XR applications to create a quadratic layer that presents a separate
   * rendered scene.
   *
   * @param {number} width - The width of the layer plane in world units.
   * @param {number} height - The height of the layer plane in world units.
   * @param {Vector3} translation - The position/translation of the layer plane in world units.
   * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
   * @param {number} pixelwidth - The width of the layer's render target in pixels.
   * @param {number} pixelheight - The height of the layer's render target in pixels.
   * @param {Function} rendercall - A callback function that renders the layer. Similar to code in
   * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
   * @param {Object} [attributes={}] - Allows to configure the layer's render target.
   * @return {Mesh} A mesh representing the quadratic XR layer. This mesh should be added to the XR scene.
   */
  createQuadLayer(
    width,
    height,
    translation,
    quaternion,
    pixelwidth,
    pixelheight,
    rendercall,
    attributes = {}
  ) {
    const geometry = new PlaneGeometry(width, height);
    const renderTarget = new XRRenderTarget(pixelwidth, pixelheight, {
      format: RGBAFormat,
      type: UnsignedByteType,
      depthTexture: new DepthTexture(
        pixelwidth,
        pixelheight,
        attributes.stencil ? UnsignedInt248Type : UnsignedIntType,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        attributes.stencil ? DepthStencilFormat : DepthFormat
      ),
      stencilBuffer: attributes.stencil,
      resolveDepthBuffer: false,
      resolveStencilBuffer: false,
    });
    renderTarget._autoAllocateDepthBuffer = true;
    const material = new MeshBasicMaterial({
      color: 16777215,
      side: FrontSide,
    });
    material.map = renderTarget.texture;
    material.map.offset.y = 1;
    material.map.repeat.y = -1;
    const plane = new Mesh(geometry, material);
    plane.position.copy(translation);
    plane.quaternion.copy(quaternion);
    const layer = {
      type: "quad",
      width,
      height,
      translation,
      quaternion,
      pixelwidth,
      pixelheight,
      plane,
      material,
      rendercall,
      renderTarget,
    };
    this._layers.push(layer);
    if (this._session !== null) {
      layer.plane.material = new MeshBasicMaterial({
        color: 16777215,
        side: FrontSide,
      });
      layer.plane.material.blending = CustomBlending;
      layer.plane.material.blendEquation = AddEquation;
      layer.plane.material.blendSrc = ZeroFactor;
      layer.plane.material.blendDst = ZeroFactor;
      layer.xrlayer = this._createXRLayer(layer);
      const xrlayers = this._session.renderState.layers;
      xrlayers.unshift(layer.xrlayer);
      this._session.updateRenderState({ layers: xrlayers });
    } else {
      renderTarget.isXRRenderTarget = false;
    }
    return plane;
  }
  /**
   * This method can be used in XR applications to create a cylindrical layer that presents a separate
   * rendered scene.
   *
   * @param {number} radius - The radius of the cylinder in world units.
   * @param {number} centralAngle - The central angle of the cylinder in radians.
   * @param {number} aspectratio - The aspect ratio.
   * @param {Vector3} translation - The position/translation of the layer plane in world units.
   * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
   * @param {number} pixelwidth - The width of the layer's render target in pixels.
   * @param {number} pixelheight - The height of the layer's render target in pixels.
   * @param {Function} rendercall - A callback function that renders the layer. Similar to code in
   * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
   * @param {Object} [attributes={}] - Allows to configure the layer's render target.
   * @return {Mesh} A mesh representing the cylindrical XR layer. This mesh should be added to the XR scene.
   */
  createCylinderLayer(
    radius,
    centralAngle,
    aspectratio,
    translation,
    quaternion,
    pixelwidth,
    pixelheight,
    rendercall,
    attributes = {}
  ) {
    const geometry = new CylinderGeometry(
      radius,
      radius,
      (radius * centralAngle) / aspectratio,
      64,
      64,
      true,
      Math.PI - centralAngle / 2,
      centralAngle
    );
    const renderTarget = new XRRenderTarget(pixelwidth, pixelheight, {
      format: RGBAFormat,
      type: UnsignedByteType,
      depthTexture: new DepthTexture(
        pixelwidth,
        pixelheight,
        attributes.stencil ? UnsignedInt248Type : UnsignedIntType,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        attributes.stencil ? DepthStencilFormat : DepthFormat
      ),
      stencilBuffer: attributes.stencil,
      resolveDepthBuffer: false,
      resolveStencilBuffer: false,
    });
    renderTarget._autoAllocateDepthBuffer = true;
    const material = new MeshBasicMaterial({ color: 16777215, side: BackSide });
    material.map = renderTarget.texture;
    material.map.offset.y = 1;
    material.map.repeat.y = -1;
    const plane = new Mesh(geometry, material);
    plane.position.copy(translation);
    plane.quaternion.copy(quaternion);
    const layer = {
      type: "cylinder",
      radius,
      centralAngle,
      aspectratio,
      translation,
      quaternion,
      pixelwidth,
      pixelheight,
      plane,
      material,
      rendercall,
      renderTarget,
    };
    this._layers.push(layer);
    if (this._session !== null) {
      layer.plane.material = new MeshBasicMaterial({
        color: 16777215,
        side: BackSide,
      });
      layer.plane.material.blending = CustomBlending;
      layer.plane.material.blendEquation = AddEquation;
      layer.plane.material.blendSrc = ZeroFactor;
      layer.plane.material.blendDst = ZeroFactor;
      layer.xrlayer = this._createXRLayer(layer);
      const xrlayers = this._session.renderState.layers;
      xrlayers.unshift(layer.xrlayer);
      this._session.updateRenderState({ layers: xrlayers });
    } else {
      renderTarget.isXRRenderTarget = false;
    }
    return plane;
  }
  /**
   * Renders the XR layers that have been previously added to the scene.
   *
   * This method is usually called in your animation loop before rendering
   * the actual scene via `renderer.render( scene, camera );`.
   */
  renderLayers() {
    const translationObject = new Vector3();
    const quaternionObject = new Quaternion();
    const renderer2 = this._renderer;
    const wasPresenting = this.isPresenting;
    const rendererOutputTarget = renderer2.getOutputRenderTarget();
    const rendererFramebufferTarget = renderer2._frameBufferTarget;
    this.isPresenting = false;
    const rendererSize = new Vector2();
    renderer2.getSize(rendererSize);
    const rendererQuad = renderer2._quad;
    for (const layer of this._layers) {
      layer.renderTarget.isXRRenderTarget = this._session !== null;
      layer.renderTarget._hasExternalTextures =
        layer.renderTarget.isXRRenderTarget;
      if (layer.renderTarget.isXRRenderTarget && this._supportsLayers) {
        layer.xrlayer.transform = new XRRigidTransform(
          layer.plane.getWorldPosition(translationObject),
          layer.plane.getWorldQuaternion(quaternionObject)
        );
        const glSubImage = this._glBinding.getSubImage(
          layer.xrlayer,
          this._xrFrame
        );
        renderer2.backend.setXRRenderTargetTextures(
          layer.renderTarget,
          glSubImage.colorTexture,
          void 0
        );
        renderer2._setXRLayerSize(
          layer.renderTarget.width,
          layer.renderTarget.height
        );
        renderer2.setOutputRenderTarget(layer.renderTarget);
        renderer2.setRenderTarget(null);
        renderer2._frameBufferTarget = null;
        this._frameBufferTargets ||
          (this._frameBufferTargets = /* @__PURE__ */ new WeakMap());
        const { frameBufferTarget, quad } = this._frameBufferTargets.get(
          layer.renderTarget
        ) || { frameBufferTarget: null, quad: null };
        if (!frameBufferTarget) {
          renderer2._quad = new QuadMesh(new NodeMaterial());
          this._frameBufferTargets.set(layer.renderTarget, {
            frameBufferTarget: renderer2._getFrameBufferTarget(),
            quad: renderer2._quad,
          });
        } else {
          renderer2._frameBufferTarget = frameBufferTarget;
          renderer2._quad = quad;
        }
        layer.rendercall();
        renderer2._frameBufferTarget = null;
      } else {
        renderer2.setRenderTarget(layer.renderTarget);
        layer.rendercall();
      }
    }
    renderer2.setRenderTarget(null);
    renderer2.setOutputRenderTarget(rendererOutputTarget);
    renderer2._frameBufferTarget = rendererFramebufferTarget;
    renderer2._setXRLayerSize(rendererSize.x, rendererSize.y);
    renderer2._quad = rendererQuad;
    this.isPresenting = wasPresenting;
  }
  /**
   * Returns the current XR session.
   *
   * @return {?XRSession} The XR session. Returns `null` when used outside a XR session.
   */
  getSession() {
    return this._session;
  }
  /**
   * After a XR session has been requested usually with one of the `*Button` modules, it
   * is injected into the renderer with this method. This method triggers the start of
   * the actual XR rendering.
   *
   * @async
   * @param {XRSession} session - The XR session to set.
   * @return {Promise} A Promise that resolves when the session has been set.
   */
  async setSession(session) {
    const renderer2 = this._renderer;
    const backend = renderer2.backend;
    this._gl = renderer2.getContext();
    const gl = this._gl;
    const attributes = gl.getContextAttributes();
    this._session = session;
    if (session !== null) {
      if (backend.isWebGPUBackend === true)
        throw new Error(
          'THREE.XRManager: XR is currently not supported with a WebGPU backend. Use WebGL by passing "{ forceWebGL: true }" to the constructor of the renderer.'
        );
      session.addEventListener("select", this._onSessionEvent);
      session.addEventListener("selectstart", this._onSessionEvent);
      session.addEventListener("selectend", this._onSessionEvent);
      session.addEventListener("squeeze", this._onSessionEvent);
      session.addEventListener("squeezestart", this._onSessionEvent);
      session.addEventListener("squeezeend", this._onSessionEvent);
      session.addEventListener("end", this._onSessionEnd);
      session.addEventListener(
        "inputsourceschange",
        this._onInputSourcesChange
      );
      await backend.makeXRCompatible();
      this._currentPixelRatio = renderer2.getPixelRatio();
      renderer2.getSize(this._currentSize);
      this._currentAnimationContext = renderer2._animation.getContext();
      this._currentAnimationLoop = renderer2._animation.getAnimationLoop();
      renderer2._animation.stop();
      if (this._supportsGlBinding) {
        const glBinding = new XRWebGLBinding(session, gl);
        this._glBinding = glBinding;
      }
      if (this._useLayers === true) {
        let depthFormat = null;
        let depthType = null;
        let glDepthFormat = null;
        if (renderer2.depth) {
          glDepthFormat = renderer2.stencil
            ? gl.DEPTH24_STENCIL8
            : gl.DEPTH_COMPONENT24;
          depthFormat = renderer2.stencil ? DepthStencilFormat : DepthFormat;
          depthType = renderer2.stencil ? UnsignedInt248Type : UnsignedIntType;
        }
        const projectionlayerInit = {
          colorFormat: gl.RGBA8,
          depthFormat: glDepthFormat,
          scaleFactor: this._framebufferScaleFactor,
          clearOnAccess: false,
        };
        if (
          this._useMultiviewIfPossible &&
          renderer2.hasFeature("OVR_multiview2")
        ) {
          projectionlayerInit.textureType = "texture-array";
          this._useMultiview = true;
        }
        const glProjLayer =
          this._glBinding.createProjectionLayer(projectionlayerInit);
        const layersArray = [glProjLayer];
        this._glProjLayer = glProjLayer;
        renderer2.setPixelRatio(1);
        renderer2._setXRLayerSize(
          glProjLayer.textureWidth,
          glProjLayer.textureHeight
        );
        const depth2 = this._useMultiview ? 2 : 1;
        const depthTexture = new DepthTexture(
          glProjLayer.textureWidth,
          glProjLayer.textureHeight,
          depthType,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          depthFormat,
          depth2
        );
        this._xrRenderTarget = new XRRenderTarget(
          glProjLayer.textureWidth,
          glProjLayer.textureHeight,
          {
            format: RGBAFormat,
            type: UnsignedByteType,
            colorSpace: renderer2.outputColorSpace,
            depthTexture,
            stencilBuffer: renderer2.stencil,
            samples: attributes.antialias ? 4 : 0,
            resolveDepthBuffer: glProjLayer.ignoreDepthValues === false,
            resolveStencilBuffer: glProjLayer.ignoreDepthValues === false,
            depth: this._useMultiview ? 2 : 1,
            multiview: this._useMultiview,
          }
        );
        this._xrRenderTarget._hasExternalTextures = true;
        this._xrRenderTarget.depth = this._useMultiview ? 2 : 1;
        this._supportsLayers = session.enabledFeatures.includes("layers");
        this._referenceSpace = await session.requestReferenceSpace(
          this.getReferenceSpaceType()
        );
        if (this._supportsLayers) {
          for (const layer of this._layers) {
            layer.plane.material = new MeshBasicMaterial({
              color: 16777215,
              side: layer.type === "cylinder" ? BackSide : FrontSide,
            });
            layer.plane.material.blending = CustomBlending;
            layer.plane.material.blendEquation = AddEquation;
            layer.plane.material.blendSrc = ZeroFactor;
            layer.plane.material.blendDst = ZeroFactor;
            layer.xrlayer = this._createXRLayer(layer);
            layersArray.unshift(layer.xrlayer);
          }
        }
        session.updateRenderState({ layers: layersArray });
      } else {
        const layerInit = {
          antialias: renderer2.samples > 0,
          alpha: true,
          depth: renderer2.depth,
          stencil: renderer2.stencil,
          framebufferScaleFactor: this.getFramebufferScaleFactor(),
        };
        const glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
        this._glBaseLayer = glBaseLayer;
        session.updateRenderState({ baseLayer: glBaseLayer });
        renderer2.setPixelRatio(1);
        renderer2._setXRLayerSize(
          glBaseLayer.framebufferWidth,
          glBaseLayer.framebufferHeight
        );
        this._xrRenderTarget = new XRRenderTarget(
          glBaseLayer.framebufferWidth,
          glBaseLayer.framebufferHeight,
          {
            format: RGBAFormat,
            type: UnsignedByteType,
            colorSpace: renderer2.outputColorSpace,
            stencilBuffer: renderer2.stencil,
            resolveDepthBuffer: glBaseLayer.ignoreDepthValues === false,
            resolveStencilBuffer: glBaseLayer.ignoreDepthValues === false,
          }
        );
        this._xrRenderTarget._isOpaqueFramebuffer = true;
        this._referenceSpace = await session.requestReferenceSpace(
          this.getReferenceSpaceType()
        );
      }
      this.setFoveation(this.getFoveation());
      renderer2._animation.setAnimationLoop(this._onAnimationFrame);
      renderer2._animation.setContext(session);
      renderer2._animation.start();
      this.isPresenting = true;
      this.dispatchEvent({ type: "sessionstart" });
    }
  }
  /**
   * This method is called by the renderer per frame and updates the XR camera
   * and it sub cameras based on the given camera. The given camera is the "user"
   * camera created on application level and used for non-XR rendering.
   *
   * @param {PerspectiveCamera} camera - The camera.
   */
  updateCamera(camera2) {
    const session = this._session;
    if (session === null) return;
    const depthNear = camera2.near;
    const depthFar = camera2.far;
    const cameraXR = this._cameraXR;
    const cameraL = this._cameraL;
    const cameraR = this._cameraR;
    cameraXR.near = cameraR.near = cameraL.near = depthNear;
    cameraXR.far = cameraR.far = cameraL.far = depthFar;
    cameraXR.isMultiViewCamera = this._useMultiview;
    if (
      this._currentDepthNear !== cameraXR.near ||
      this._currentDepthFar !== cameraXR.far
    ) {
      session.updateRenderState({
        depthNear: cameraXR.near,
        depthFar: cameraXR.far,
      });
      this._currentDepthNear = cameraXR.near;
      this._currentDepthFar = cameraXR.far;
    }
    cameraXR.layers.mask = camera2.layers.mask | 6;
    cameraL.layers.mask = cameraXR.layers.mask & 3;
    cameraR.layers.mask = cameraXR.layers.mask & 5;
    const parent = camera2.parent;
    const cameras = cameraXR.cameras;
    updateCamera(cameraXR, parent);
    for (let i2 = 0; i2 < cameras.length; i2++) {
      updateCamera(cameras[i2], parent);
    }
    if (cameras.length === 2) {
      setProjectionFromUnion(cameraXR, cameraL, cameraR);
    } else {
      cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
    }
    updateUserCamera(camera2, cameraXR, parent);
  }
  /**
   * Returns a WebXR controller for the given controller index.
   *
   * @private
   * @param {number} index - The controller index.
   * @return {WebXRController} The XR controller.
   */
  _getController(index) {
    let controller = this._controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      this._controllers[index] = controller;
    }
    return controller;
  }
}
function setProjectionFromUnion(camera2, cameraL, cameraR) {
  _cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
  _cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
  const ipd = _cameraLPos.distanceTo(_cameraRPos);
  const projL = cameraL.projectionMatrix.elements;
  const projR = cameraR.projectionMatrix.elements;
  const near = projL[14] / (projL[10] - 1);
  const far = projL[14] / (projL[10] + 1);
  const topFov = (projL[9] + 1) / projL[5];
  const bottomFov = (projL[9] - 1) / projL[5];
  const leftFov = (projL[8] - 1) / projL[0];
  const rightFov = (projR[8] + 1) / projR[0];
  const left = near * leftFov;
  const right = near * rightFov;
  const zOffset = ipd / (-leftFov + rightFov);
  const xOffset = zOffset * -leftFov;
  cameraL.matrixWorld.decompose(
    camera2.position,
    camera2.quaternion,
    camera2.scale
  );
  camera2.translateX(xOffset);
  camera2.translateZ(zOffset);
  camera2.matrixWorld.compose(
    camera2.position,
    camera2.quaternion,
    camera2.scale
  );
  camera2.matrixWorldInverse.copy(camera2.matrixWorld).invert();
  if (projL[10] === -1) {
    camera2.projectionMatrix.copy(cameraL.projectionMatrix);
    camera2.projectionMatrixInverse.copy(cameraL.projectionMatrixInverse);
  } else {
    const near2 = near + zOffset;
    const far2 = far + zOffset;
    const left2 = left - xOffset;
    const right2 = right + (ipd - xOffset);
    const top2 = ((topFov * far) / far2) * near2;
    const bottom2 = ((bottomFov * far) / far2) * near2;
    camera2.projectionMatrix.makePerspective(
      left2,
      right2,
      top2,
      bottom2,
      near2,
      far2
    );
    camera2.projectionMatrixInverse.copy(camera2.projectionMatrix).invert();
  }
}
function updateCamera(camera2, parent) {
  if (parent === null) {
    camera2.matrixWorld.copy(camera2.matrix);
  } else {
    camera2.matrixWorld.multiplyMatrices(parent.matrixWorld, camera2.matrix);
  }
  camera2.matrixWorldInverse.copy(camera2.matrixWorld).invert();
}
function updateUserCamera(camera2, cameraXR, parent) {
  if (parent === null) {
    camera2.matrix.copy(cameraXR.matrixWorld);
  } else {
    camera2.matrix.copy(parent.matrixWorld);
    camera2.matrix.invert();
    camera2.matrix.multiply(cameraXR.matrixWorld);
  }
  camera2.matrix.decompose(camera2.position, camera2.quaternion, camera2.scale);
  camera2.updateMatrixWorld(true);
  camera2.projectionMatrix.copy(cameraXR.projectionMatrix);
  camera2.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse);
  if (camera2.isPerspectiveCamera) {
    camera2.fov =
      RAD2DEG * 2 * Math.atan(1 / camera2.projectionMatrix.elements[5]);
    camera2.zoom = 1;
  }
}
function onSessionEvent(event) {
  const controllerIndex = this._controllerInputSources.indexOf(
    event.inputSource
  );
  if (controllerIndex === -1) {
    return;
  }
  const controller = this._controllers[controllerIndex];
  if (controller !== void 0) {
    const referenceSpace = this.getReferenceSpace();
    controller.update(event.inputSource, event.frame, referenceSpace);
    controller.dispatchEvent({ type: event.type, data: event.inputSource });
  }
}
function onSessionEnd() {
  const session = this._session;
  const renderer2 = this._renderer;
  session.removeEventListener("select", this._onSessionEvent);
  session.removeEventListener("selectstart", this._onSessionEvent);
  session.removeEventListener("selectend", this._onSessionEvent);
  session.removeEventListener("squeeze", this._onSessionEvent);
  session.removeEventListener("squeezestart", this._onSessionEvent);
  session.removeEventListener("squeezeend", this._onSessionEvent);
  session.removeEventListener("end", this._onSessionEnd);
  session.removeEventListener("inputsourceschange", this._onInputSourcesChange);
  for (let i2 = 0; i2 < this._controllers.length; i2++) {
    const inputSource = this._controllerInputSources[i2];
    if (inputSource === null) continue;
    this._controllerInputSources[i2] = null;
    this._controllers[i2].disconnect(inputSource);
  }
  this._currentDepthNear = null;
  this._currentDepthFar = null;
  renderer2._resetXRState();
  this._session = null;
  this._xrRenderTarget = null;
  if (this._supportsLayers === true) {
    for (const layer of this._layers) {
      layer.renderTarget = new XRRenderTarget(
        layer.pixelwidth,
        layer.pixelheight,
        {
          format: RGBAFormat,
          type: UnsignedByteType,
          depthTexture: new DepthTexture(
            layer.pixelwidth,
            layer.pixelheight,
            layer.stencilBuffer ? UnsignedInt248Type : UnsignedIntType,
            void 0,
            void 0,
            void 0,
            void 0,
            void 0,
            void 0,
            layer.stencilBuffer ? DepthStencilFormat : DepthFormat
          ),
          stencilBuffer: layer.stencilBuffer,
          resolveDepthBuffer: false,
          resolveStencilBuffer: false,
        }
      );
      layer.renderTarget.isXRRenderTarget = false;
      layer.plane.material = layer.material;
      layer.material.map = layer.renderTarget.texture;
      layer.material.map.offset.y = 1;
      layer.material.map.repeat.y = -1;
      delete layer.xrlayer;
    }
  }
  this.isPresenting = false;
  this._useMultiview = false;
  renderer2._animation.stop();
  renderer2._animation.setAnimationLoop(this._currentAnimationLoop);
  renderer2._animation.setContext(this._currentAnimationContext);
  renderer2._animation.start();
  renderer2.setPixelRatio(this._currentPixelRatio);
  renderer2.setSize(this._currentSize.width, this._currentSize.height, false);
  this.dispatchEvent({ type: "sessionend" });
}
function onInputSourcesChange(event) {
  const controllers = this._controllers;
  const controllerInputSources = this._controllerInputSources;
  for (let i2 = 0; i2 < event.removed.length; i2++) {
    const inputSource = event.removed[i2];
    const index = controllerInputSources.indexOf(inputSource);
    if (index >= 0) {
      controllerInputSources[index] = null;
      controllers[index].disconnect(inputSource);
    }
  }
  for (let i2 = 0; i2 < event.added.length; i2++) {
    const inputSource = event.added[i2];
    let controllerIndex = controllerInputSources.indexOf(inputSource);
    if (controllerIndex === -1) {
      for (let i3 = 0; i3 < controllers.length; i3++) {
        if (i3 >= controllerInputSources.length) {
          controllerInputSources.push(inputSource);
          controllerIndex = i3;
          break;
        } else if (controllerInputSources[i3] === null) {
          controllerInputSources[i3] = inputSource;
          controllerIndex = i3;
          break;
        }
      }
      if (controllerIndex === -1) break;
    }
    const controller = controllers[controllerIndex];
    if (controller) {
      controller.connect(inputSource);
    }
  }
}
function createXRLayer(layer) {
  if (layer.type === "quad") {
    return this._glBinding.createQuadLayer({
      transform: new XRRigidTransform(layer.translation, layer.quaternion),
      width: layer.width / 2,
      height: layer.height / 2,
      space: this._referenceSpace,
      viewPixelWidth: layer.pixelwidth,
      viewPixelHeight: layer.pixelheight,
      clearOnAccess: false,
    });
  } else {
    return this._glBinding.createCylinderLayer({
      transform: new XRRigidTransform(layer.translation, layer.quaternion),
      radius: layer.radius,
      centralAngle: layer.centralAngle,
      aspectRatio: layer.aspectRatio,
      space: this._referenceSpace,
      viewPixelWidth: layer.pixelwidth,
      viewPixelHeight: layer.pixelheight,
      clearOnAccess: false,
    });
  }
}
function onAnimationFrame(time2, frame) {
  if (frame === void 0) return;
  const cameraXR = this._cameraXR;
  const renderer2 = this._renderer;
  const backend = renderer2.backend;
  const glBaseLayer = this._glBaseLayer;
  const referenceSpace = this.getReferenceSpace();
  const pose = frame.getViewerPose(referenceSpace);
  this._xrFrame = frame;
  if (pose !== null) {
    const views = pose.views;
    if (this._glBaseLayer !== null) {
      backend.setXRTarget(glBaseLayer.framebuffer);
    }
    let cameraXRNeedsUpdate = false;
    if (views.length !== cameraXR.cameras.length) {
      cameraXR.cameras.length = 0;
      cameraXRNeedsUpdate = true;
    }
    for (let i2 = 0; i2 < views.length; i2++) {
      const view = views[i2];
      let viewport2;
      if (this._useLayers === true) {
        const glSubImage = this._glBinding.getViewSubImage(
          this._glProjLayer,
          view
        );
        viewport2 = glSubImage.viewport;
        if (i2 === 0) {
          backend.setXRRenderTargetTextures(
            this._xrRenderTarget,
            glSubImage.colorTexture,
            this._glProjLayer.ignoreDepthValues && !this._useMultiview
              ? void 0
              : glSubImage.depthStencilTexture
          );
        }
      } else {
        viewport2 = glBaseLayer.getViewport(view);
      }
      let camera2 = this._cameras[i2];
      if (camera2 === void 0) {
        camera2 = new PerspectiveCamera();
        camera2.layers.enable(i2);
        camera2.viewport = new Vector4();
        this._cameras[i2] = camera2;
      }
      camera2.matrix.fromArray(view.transform.matrix);
      camera2.matrix.decompose(
        camera2.position,
        camera2.quaternion,
        camera2.scale
      );
      camera2.projectionMatrix.fromArray(view.projectionMatrix);
      camera2.projectionMatrixInverse.copy(camera2.projectionMatrix).invert();
      camera2.viewport.set(
        viewport2.x,
        viewport2.y,
        viewport2.width,
        viewport2.height
      );
      if (i2 === 0) {
        cameraXR.matrix.copy(camera2.matrix);
        cameraXR.matrix.decompose(
          cameraXR.position,
          cameraXR.quaternion,
          cameraXR.scale
        );
      }
      if (cameraXRNeedsUpdate === true) {
        cameraXR.cameras.push(camera2);
      }
    }
    renderer2.setOutputRenderTarget(this._xrRenderTarget);
  }
  for (let i2 = 0; i2 < this._controllers.length; i2++) {
    const inputSource = this._controllerInputSources[i2];
    const controller = this._controllers[i2];
    if (inputSource !== null && controller !== void 0) {
      controller.update(inputSource, frame, referenceSpace);
    }
  }
  if (this._currentAnimationLoop) this._currentAnimationLoop(time2, frame);
  if (frame.detectedPlanes) {
    this.dispatchEvent({ type: "planesdetected", data: frame });
  }
  this._xrFrame = null;
}
const _scene = /* @__PURE__ */ new Scene();
const _drawingBufferSize = /* @__PURE__ */ new Vector2();
const _screen = /* @__PURE__ */ new Vector4();
const _frustum = /* @__PURE__ */ new Frustum();
const _frustumArray = /* @__PURE__ */ new FrustumArray();
const _projScreenMatrix = /* @__PURE__ */ new Matrix4();
const _vector4 = /* @__PURE__ */ new Vector4();
class Renderer {
  /**
   * Renderer options.
   *
   * @typedef {Object} Renderer~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0
   * to overwrite the default.
   * @property {?Function} [getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.
   * @property {number} [colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best
   * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
   * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
   */
  /**
  	 * Constructs a new renderer.
  	 *
  	 * @param {Backend} backend - The backend the renderer is targeting (e.g. WebGPU or WebGL 2).
  	 * @param {Renderer~Options} [parameters] - The configuration parameter.
  
  	 */
  constructor(backend, parameters = {}) {
    this.isRenderer = true;
    const {
      logarithmicDepthBuffer = false,
      alpha = true,
      depth: depth2 = true,
      stencil = false,
      antialias = false,
      samples = 0,
      getFallback = null,
      colorBufferType = HalfFloatType,
      multiview = false,
    } = parameters;
    this.domElement = backend.getDomElement();
    this.backend = backend;
    this.samples = samples || antialias === true ? 4 : 0;
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.alpha = alpha;
    this.logarithmicDepthBuffer = logarithmicDepthBuffer;
    this.outputColorSpace = SRGBColorSpace;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    this.sortObjects = true;
    this.depth = depth2;
    this.stencil = stencil;
    this.info = new Info();
    this.overrideNodes = {
      modelViewMatrix: null,
      modelNormalViewMatrix: null,
    };
    this.library = new NodeLibrary();
    this.lighting = new Lighting();
    this._getFallback = getFallback;
    this._pixelRatio = 1;
    this._width = this.domElement.width;
    this._height = this.domElement.height;
    this._viewport = new Vector4(0, 0, this._width, this._height);
    this._scissor = new Vector4(0, 0, this._width, this._height);
    this._scissorTest = false;
    this._attributes = null;
    this._geometries = null;
    this._nodes = null;
    this._animation = null;
    this._bindings = null;
    this._objects = null;
    this._pipelines = null;
    this._bundles = null;
    this._renderLists = null;
    this._renderContexts = null;
    this._textures = null;
    this._background = null;
    this._quad = new QuadMesh(new NodeMaterial());
    this._quad.material.name = "Renderer_output";
    this._currentRenderContext = null;
    this._opaqueSort = null;
    this._transparentSort = null;
    this._frameBufferTarget = null;
    const alphaClear = this.alpha === true ? 0 : 1;
    this._clearColor = new Color4(0, 0, 0, alphaClear);
    this._clearDepth = 1;
    this._clearStencil = 0;
    this._renderTarget = null;
    this._activeCubeFace = 0;
    this._activeMipmapLevel = 0;
    this._outputRenderTarget = null;
    this._mrt = null;
    this._renderObjectFunction = null;
    this._currentRenderObjectFunction = null;
    this._currentRenderBundle = null;
    this._handleObjectFunction = this._renderObjectDirect;
    this._isDeviceLost = false;
    this.onDeviceLost = this._onDeviceLost;
    this._colorBufferType = colorBufferType;
    this._initialized = false;
    this._initPromise = null;
    this._compilationPromises = null;
    this.transparent = true;
    this.opaque = true;
    this.shadowMap = {
      enabled: false,
      type: PCFShadowMap,
    };
    this.xr = new XRManager(this, multiview);
    this.debug = {
      checkShaderErrors: true,
      onShaderError: null,
      getShaderAsync: async (scene2, camera2, object) => {
        await this.compileAsync(scene2, camera2);
        const renderList = this._renderLists.get(scene2, camera2);
        const renderContext = this._renderContexts.get(
          scene2,
          camera2,
          this._renderTarget
        );
        const material = scene2.overrideMaterial || object.material;
        const renderObject = this._objects.get(
          object,
          material,
          scene2,
          camera2,
          renderList.lightsNode,
          renderContext,
          renderContext.clippingContext
        );
        const { fragmentShader, vertexShader } =
          renderObject.getNodeBuilderState();
        return { fragmentShader, vertexShader };
      },
    };
  }
  /**
   * Initializes the renderer so it is ready for usage.
   *
   * @async
   * @return {Promise<this>} A Promise that resolves when the renderer has been initialized.
   */
  async init() {
    if (this._initialized) {
      throw new Error("Renderer: Backend has already been initialized.");
    }
    if (this._initPromise !== null) {
      return this._initPromise;
    }
    this._initPromise = new Promise(async (resolve, reject) => {
      let backend = this.backend;
      try {
        await backend.init(this);
      } catch (error) {
        if (this._getFallback !== null) {
          try {
            this.backend = backend = this._getFallback(error);
            await backend.init(this);
          } catch (error2) {
            reject(error2);
            return;
          }
        } else {
          reject(error);
          return;
        }
      }
      this._nodes = new Nodes(this, backend);
      this._animation = new Animation(this._nodes, this.info);
      this._attributes = new Attributes(backend);
      this._background = new Background(this, this._nodes);
      this._geometries = new Geometries(this._attributes, this.info);
      this._textures = new Textures(this, backend, this.info);
      this._pipelines = new Pipelines(backend, this._nodes);
      this._bindings = new Bindings(
        backend,
        this._nodes,
        this._textures,
        this._attributes,
        this._pipelines,
        this.info
      );
      this._objects = new RenderObjects(
        this,
        this._nodes,
        this._geometries,
        this._pipelines,
        this._bindings,
        this.info
      );
      this._renderLists = new RenderLists(this.lighting);
      this._bundles = new RenderBundles();
      this._renderContexts = new RenderContexts();
      this._animation.start();
      this._initialized = true;
      resolve(this);
    });
    return this._initPromise;
  }
  /**
   * The coordinate system of the renderer. The value of this property
   * depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or
   * `THREE.WebGPUCoordinateSystem`.
   *
   * @readonly
   * @type {number}
   */
  get coordinateSystem() {
    return this.backend.coordinateSystem;
  }
  /**
   * Compiles all materials in the given scene. This can be useful to avoid a
   * phenomenon which is called "shader compilation stutter", which occurs when
   * rendering an object with a new shader for the first time.
   *
   * If you want to add a 3D object to an existing scene, use the third optional
   * parameter for applying the target scene. Note that the (target) scene's lighting
   * and environment must be configured before calling this method.
   *
   * @async
   * @param {Object3D} scene - The scene or 3D object to precompile.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {?Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
   * @return {Promise<Array|undefined>} A Promise that resolves when the compile has been finished.
   */
  async compileAsync(scene2, camera2, targetScene = null) {
    if (this._isDeviceLost === true) return;
    if (this._initialized === false) await this.init();
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    const previousRenderContext = this._currentRenderContext;
    const previousRenderObjectFunction = this._currentRenderObjectFunction;
    const previousCompilationPromises = this._compilationPromises;
    const sceneRef = scene2.isScene === true ? scene2 : _scene;
    if (targetScene === null) targetScene = scene2;
    const renderTarget = this._renderTarget;
    const renderContext = this._renderContexts.get(
      targetScene,
      camera2,
      renderTarget
    );
    const activeMipmapLevel = this._activeMipmapLevel;
    const compilationPromises = [];
    this._currentRenderContext = renderContext;
    this._currentRenderObjectFunction = this.renderObject;
    this._handleObjectFunction = this._createObjectPipeline;
    this._compilationPromises = compilationPromises;
    nodeFrame.renderId++;
    nodeFrame.update();
    renderContext.depth = this.depth;
    renderContext.stencil = this.stencil;
    if (!renderContext.clippingContext)
      renderContext.clippingContext = new ClippingContext();
    renderContext.clippingContext.updateGlobal(sceneRef, camera2);
    sceneRef.onBeforeRender(this, scene2, camera2, renderTarget);
    const renderList = this._renderLists.get(scene2, camera2);
    renderList.begin();
    this._projectObject(
      scene2,
      camera2,
      0,
      renderList,
      renderContext.clippingContext
    );
    if (targetScene !== scene2) {
      targetScene.traverseVisible(function (object) {
        if (object.isLight && object.layers.test(camera2.layers)) {
          renderList.pushLight(object);
        }
      });
    }
    renderList.finish();
    if (renderTarget !== null) {
      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
      const renderTargetData = this._textures.get(renderTarget);
      renderContext.textures = renderTargetData.textures;
      renderContext.depthTexture = renderTargetData.depthTexture;
    } else {
      renderContext.textures = null;
      renderContext.depthTexture = null;
    }
    this._background.update(sceneRef, renderList, renderContext);
    const opaqueObjects = renderList.opaque;
    const transparentObjects = renderList.transparent;
    const transparentDoublePassObjects = renderList.transparentDoublePass;
    const lightsNode = renderList.lightsNode;
    if (this.opaque === true && opaqueObjects.length > 0)
      this._renderObjects(opaqueObjects, camera2, sceneRef, lightsNode);
    if (this.transparent === true && transparentObjects.length > 0)
      this._renderTransparents(
        transparentObjects,
        transparentDoublePassObjects,
        camera2,
        sceneRef,
        lightsNode
      );
    nodeFrame.renderId = previousRenderId;
    this._currentRenderContext = previousRenderContext;
    this._currentRenderObjectFunction = previousRenderObjectFunction;
    this._compilationPromises = previousCompilationPromises;
    this._handleObjectFunction = this._renderObjectDirect;
    await Promise.all(compilationPromises);
  }
  /**
   * Renders the scene in an async fashion.
   *
   * @async
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera.
   * @return {Promise} A Promise that resolves when the render has been finished.
   */
  async renderAsync(scene2, camera2) {
    if (this._initialized === false) await this.init();
    this._renderScene(scene2, camera2);
  }
  /**
   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
   * the CPU waits for the GPU to complete its operation (e.g. a compute task).
   *
   * @async
   * @return {Promise} A Promise that resolves when synchronization has been finished.
   */
  async waitForGPU() {
    await this.backend.waitForGPU();
  }
  /**
   * Enables or disables high precision for model-view and normal-view matrices.
   * When enabled, will use CPU 64-bit precision for higher precision instead of GPU 32-bit for higher performance.
   *
   * NOTE: 64-bit precision is not compatible with `InstancedMesh` and `SkinnedMesh`.
   *
   * @param {boolean} value - Whether to enable or disable high precision.
   * @type {boolean}
   */
  set highPrecision(value) {
    if (value === true) {
      this.overrideNodes.modelViewMatrix = highpModelViewMatrix;
      this.overrideNodes.modelNormalViewMatrix = highpModelNormalViewMatrix;
    } else if (this.highPrecision) {
      this.overrideNodes.modelViewMatrix = null;
      this.overrideNodes.modelNormalViewMatrix = null;
    }
  }
  /**
   * Returns whether high precision is enabled or not.
   *
   * @return {boolean} Whether high precision is enabled or not.
   * @type {boolean}
   */
  get highPrecision() {
    return (
      this.overrideNodes.modelViewMatrix === highpModelViewMatrix &&
      this.overrideNodes.modelNormalViewMatrix === highpModelNormalViewMatrix
    );
  }
  /**
   * Sets the given MRT configuration.
   *
   * @param {MRTNode} mrt - The MRT node to set.
   * @return {Renderer} A reference to this renderer.
   */
  setMRT(mrt2) {
    this._mrt = mrt2;
    return this;
  }
  /**
   * Returns the MRT configuration.
   *
   * @return {MRTNode} The MRT configuration.
   */
  getMRT() {
    return this._mrt;
  }
  /**
   * Returns the color buffer type.
   *
   * @return {number} The color buffer type.
   */
  getColorBufferType() {
    return this._colorBufferType;
  }
  /**
   * Default implementation of the device lost callback.
   *
   * @private
   * @param {Object} info - Information about the context lost.
   */
  _onDeviceLost(info) {
    let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:

Message: ${info.message}`;
    if (info.reason) {
      errorMessage += `
Reason: ${info.reason}`;
    }
    console.error(errorMessage);
    this._isDeviceLost = true;
  }
  /**
   * Renders the given render bundle.
   *
   * @private
   * @param {Object} bundle - Render bundle data.
   * @param {Scene} sceneRef - The scene the render bundle belongs to.
   * @param {LightsNode} lightsNode - The lights node.
   */
  _renderBundle(bundle, sceneRef, lightsNode) {
    const { bundleGroup, camera: camera2, renderList } = bundle;
    const renderContext = this._currentRenderContext;
    const renderBundle = this._bundles.get(bundleGroup, camera2);
    const renderBundleData = this.backend.get(renderBundle);
    if (renderBundleData.renderContexts === void 0)
      renderBundleData.renderContexts = /* @__PURE__ */ new Set();
    const needsUpdate = bundleGroup.version !== renderBundleData.version;
    const renderBundleNeedsUpdate =
      renderBundleData.renderContexts.has(renderContext) === false ||
      needsUpdate;
    renderBundleData.renderContexts.add(renderContext);
    if (renderBundleNeedsUpdate) {
      this.backend.beginBundle(renderContext);
      if (renderBundleData.renderObjects === void 0 || needsUpdate) {
        renderBundleData.renderObjects = [];
      }
      this._currentRenderBundle = renderBundle;
      const {
        transparentDoublePass: transparentDoublePassObjects,
        transparent: transparentObjects,
        opaque: opaqueObjects,
      } = renderList;
      if (this.opaque === true && opaqueObjects.length > 0)
        this._renderObjects(opaqueObjects, camera2, sceneRef, lightsNode);
      if (this.transparent === true && transparentObjects.length > 0)
        this._renderTransparents(
          transparentObjects,
          transparentDoublePassObjects,
          camera2,
          sceneRef,
          lightsNode
        );
      this._currentRenderBundle = null;
      this.backend.finishBundle(renderContext, renderBundle);
      renderBundleData.version = bundleGroup.version;
    } else {
      const { renderObjects } = renderBundleData;
      for (let i2 = 0, l2 = renderObjects.length; i2 < l2; i2++) {
        const renderObject = renderObjects[i2];
        if (this._nodes.needsRefresh(renderObject)) {
          this._nodes.updateBefore(renderObject);
          this._nodes.updateForRender(renderObject);
          this._bindings.updateForRender(renderObject);
          this._nodes.updateAfter(renderObject);
        }
      }
    }
    this.backend.addBundle(renderContext, renderBundle);
  }
  /**
   * Renders the scene or 3D object with the given camera. This method can only be called
   * if the renderer has been initialized.
   *
   * The target of the method is the default framebuffer (meaning the canvas)
   * or alternatively a render target when specified via `setRenderTarget()`.
   *
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera to render the scene with.
   * @return {?Promise} A Promise that resolve when the scene has been rendered.
   * Only returned when the renderer has not been initialized.
   */
  render(scene2, camera2) {
    if (this._initialized === false) {
      console.warn(
        "THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead."
      );
      return this.renderAsync(scene2, camera2);
    }
    this._renderScene(scene2, camera2);
  }
  /**
   * Returns an internal render target which is used when computing the output tone mapping
   * and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render
   * pass and not inline to achieve more correct results.
   *
   * @private
   * @return {?RenderTarget} The render target. The method returns `null` if no output conversion should be applied.
   */
  _getFrameBufferTarget() {
    const { currentToneMapping, currentColorSpace } = this;
    const useToneMapping = currentToneMapping !== NoToneMapping;
    const useColorSpace =
      currentColorSpace !== ColorManagement.workingColorSpace;
    if (useToneMapping === false && useColorSpace === false) return null;
    const { width, height } = this.getDrawingBufferSize(_drawingBufferSize);
    const { depth: depth2, stencil } = this;
    let frameBufferTarget = this._frameBufferTarget;
    if (frameBufferTarget === null) {
      frameBufferTarget = new RenderTarget(width, height, {
        depthBuffer: depth2,
        stencilBuffer: stencil,
        type: this._colorBufferType,
        format: RGBAFormat,
        colorSpace: ColorManagement.workingColorSpace,
        generateMipmaps: false,
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        samples: this.samples,
      });
      frameBufferTarget.isPostProcessingRenderTarget = true;
      this._frameBufferTarget = frameBufferTarget;
    }
    const outputRenderTarget = this.getOutputRenderTarget();
    frameBufferTarget.depthBuffer = depth2;
    frameBufferTarget.stencilBuffer = stencil;
    if (outputRenderTarget !== null) {
      frameBufferTarget.setSize(
        outputRenderTarget.width,
        outputRenderTarget.height,
        outputRenderTarget.depth
      );
    } else {
      frameBufferTarget.setSize(width, height, 1);
    }
    frameBufferTarget.viewport.copy(this._viewport);
    frameBufferTarget.scissor.copy(this._scissor);
    frameBufferTarget.viewport.multiplyScalar(this._pixelRatio);
    frameBufferTarget.scissor.multiplyScalar(this._pixelRatio);
    frameBufferTarget.scissorTest = this._scissorTest;
    frameBufferTarget.multiview =
      outputRenderTarget !== null ? outputRenderTarget.multiview : false;
    frameBufferTarget.resolveDepthBuffer =
      outputRenderTarget !== null
        ? outputRenderTarget.resolveDepthBuffer
        : true;
    frameBufferTarget._autoAllocateDepthBuffer =
      outputRenderTarget !== null
        ? outputRenderTarget._autoAllocateDepthBuffer
        : false;
    return frameBufferTarget;
  }
  /**
   * Renders the scene or 3D object with the given camera.
   *
   * @private
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera to render the scene with.
   * @param {boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.
   * @return {RenderContext} The current render context.
   */
  _renderScene(scene2, camera2, useFrameBufferTarget = true) {
    if (this._isDeviceLost === true) return;
    const frameBufferTarget = useFrameBufferTarget
      ? this._getFrameBufferTarget()
      : null;
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    const previousRenderContext = this._currentRenderContext;
    const previousRenderObjectFunction = this._currentRenderObjectFunction;
    const sceneRef = scene2.isScene === true ? scene2 : _scene;
    const outputRenderTarget = this._renderTarget || this._outputRenderTarget;
    const activeCubeFace = this._activeCubeFace;
    const activeMipmapLevel = this._activeMipmapLevel;
    let renderTarget;
    if (frameBufferTarget !== null) {
      renderTarget = frameBufferTarget;
      this.setRenderTarget(renderTarget);
    } else {
      renderTarget = outputRenderTarget;
    }
    const renderContext = this._renderContexts.get(
      scene2,
      camera2,
      renderTarget
    );
    this._currentRenderContext = renderContext;
    this._currentRenderObjectFunction =
      this._renderObjectFunction || this.renderObject;
    this.info.calls++;
    this.info.render.calls++;
    this.info.render.frameCalls++;
    nodeFrame.renderId = this.info.calls;
    const coordinateSystem = this.coordinateSystem;
    const xr = this.xr;
    if (
      camera2.coordinateSystem !== coordinateSystem &&
      xr.isPresenting === false
    ) {
      camera2.coordinateSystem = coordinateSystem;
      camera2.updateProjectionMatrix();
      if (camera2.isArrayCamera) {
        for (const subCamera of camera2.cameras) {
          subCamera.coordinateSystem = coordinateSystem;
          subCamera.updateProjectionMatrix();
        }
      }
    }
    if (scene2.matrixWorldAutoUpdate === true) scene2.updateMatrixWorld();
    if (camera2.parent === null && camera2.matrixWorldAutoUpdate === true)
      camera2.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      if (xr.cameraAutoUpdate === true) xr.updateCamera(camera2);
      camera2 = xr.getCamera();
    }
    let viewport2 = this._viewport;
    let scissor = this._scissor;
    let pixelRatio = this._pixelRatio;
    if (renderTarget !== null) {
      viewport2 = renderTarget.viewport;
      scissor = renderTarget.scissor;
      pixelRatio = 1;
    }
    this.getDrawingBufferSize(_drawingBufferSize);
    _screen.set(0, 0, _drawingBufferSize.width, _drawingBufferSize.height);
    const minDepth = viewport2.minDepth === void 0 ? 0 : viewport2.minDepth;
    const maxDepth = viewport2.maxDepth === void 0 ? 1 : viewport2.maxDepth;
    renderContext.viewportValue
      .copy(viewport2)
      .multiplyScalar(pixelRatio)
      .floor();
    renderContext.viewportValue.width >>= activeMipmapLevel;
    renderContext.viewportValue.height >>= activeMipmapLevel;
    renderContext.viewportValue.minDepth = minDepth;
    renderContext.viewportValue.maxDepth = maxDepth;
    renderContext.viewport =
      renderContext.viewportValue.equals(_screen) === false;
    renderContext.scissorValue.copy(scissor).multiplyScalar(pixelRatio).floor();
    renderContext.scissor =
      this._scissorTest && renderContext.scissorValue.equals(_screen) === false;
    renderContext.scissorValue.width >>= activeMipmapLevel;
    renderContext.scissorValue.height >>= activeMipmapLevel;
    if (!renderContext.clippingContext)
      renderContext.clippingContext = new ClippingContext();
    renderContext.clippingContext.updateGlobal(sceneRef, camera2);
    sceneRef.onBeforeRender(this, scene2, camera2, renderTarget);
    const frustum = camera2.isArrayCamera ? _frustumArray : _frustum;
    if (!camera2.isArrayCamera) {
      _projScreenMatrix.multiplyMatrices(
        camera2.projectionMatrix,
        camera2.matrixWorldInverse
      );
      frustum.setFromProjectionMatrix(
        _projScreenMatrix,
        camera2.coordinateSystem,
        camera2.reversedDepth
      );
    }
    const renderList = this._renderLists.get(scene2, camera2);
    renderList.begin();
    this._projectObject(
      scene2,
      camera2,
      0,
      renderList,
      renderContext.clippingContext
    );
    renderList.finish();
    if (this.sortObjects === true) {
      renderList.sort(this._opaqueSort, this._transparentSort);
    }
    if (renderTarget !== null) {
      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
      const renderTargetData = this._textures.get(renderTarget);
      renderContext.textures = renderTargetData.textures;
      renderContext.depthTexture = renderTargetData.depthTexture;
      renderContext.width = renderTargetData.width;
      renderContext.height = renderTargetData.height;
      renderContext.renderTarget = renderTarget;
      renderContext.depth = renderTarget.depthBuffer;
      renderContext.stencil = renderTarget.stencilBuffer;
    } else {
      renderContext.textures = null;
      renderContext.depthTexture = null;
      renderContext.width = this.domElement.width;
      renderContext.height = this.domElement.height;
      renderContext.depth = this.depth;
      renderContext.stencil = this.stencil;
    }
    renderContext.width >>= activeMipmapLevel;
    renderContext.height >>= activeMipmapLevel;
    renderContext.activeCubeFace = activeCubeFace;
    renderContext.activeMipmapLevel = activeMipmapLevel;
    renderContext.occlusionQueryCount = renderList.occlusionQueryCount;
    this._background.update(sceneRef, renderList, renderContext);
    renderContext.camera = camera2;
    this.backend.beginRender(renderContext);
    const {
      bundles,
      lightsNode,
      transparentDoublePass: transparentDoublePassObjects,
      transparent: transparentObjects,
      opaque: opaqueObjects,
    } = renderList;
    if (bundles.length > 0) this._renderBundles(bundles, sceneRef, lightsNode);
    if (this.opaque === true && opaqueObjects.length > 0)
      this._renderObjects(opaqueObjects, camera2, sceneRef, lightsNode);
    if (this.transparent === true && transparentObjects.length > 0)
      this._renderTransparents(
        transparentObjects,
        transparentDoublePassObjects,
        camera2,
        sceneRef,
        lightsNode
      );
    this.backend.finishRender(renderContext);
    nodeFrame.renderId = previousRenderId;
    this._currentRenderContext = previousRenderContext;
    this._currentRenderObjectFunction = previousRenderObjectFunction;
    if (frameBufferTarget !== null) {
      this.setRenderTarget(
        outputRenderTarget,
        activeCubeFace,
        activeMipmapLevel
      );
      this._renderOutput(renderTarget);
    }
    sceneRef.onAfterRender(this, scene2, camera2, renderTarget);
    return renderContext;
  }
  _setXRLayerSize(width, height) {
    this._width = width;
    this._height = height;
    this.setViewport(0, 0, width, height);
  }
  /**
   * The output pass performs tone mapping and color space conversion.
   *
   * @private
   * @param {RenderTarget} renderTarget - The current render target.
   */
  _renderOutput(renderTarget) {
    const quad = this._quad;
    if (this._nodes.hasOutputChange(renderTarget.texture)) {
      quad.material.fragmentNode = this._nodes.getOutputNode(
        renderTarget.texture
      );
      quad.material.needsUpdate = true;
    }
    const currentAutoClear = this.autoClear;
    const currentXR = this.xr.enabled;
    this.autoClear = false;
    this.xr.enabled = false;
    this._renderScene(quad, quad.camera, false);
    this.autoClear = currentAutoClear;
    this.xr.enabled = currentXR;
  }
  /**
   * Returns the maximum available anisotropy for texture filtering.
   *
   * @return {number} The maximum available anisotropy.
   */
  getMaxAnisotropy() {
    return this.backend.getMaxAnisotropy();
  }
  /**
   * Returns the active cube face.
   *
   * @return {number} The active cube face.
   */
  getActiveCubeFace() {
    return this._activeCubeFace;
  }
  /**
   * Returns the active mipmap level.
   *
   * @return {number} The active mipmap level.
   */
  getActiveMipmapLevel() {
    return this._activeMipmapLevel;
  }
  /**
   * Applications are advised to always define the animation loop
   * with this method and not manually with `requestAnimationFrame()`
   * for best compatibility.
   *
   * @async
   * @param {?Function} callback - The application's animation loop.
   * @return {Promise} A Promise that resolves when the set has been executed.
   */
  async setAnimationLoop(callback) {
    if (this._initialized === false) await this.init();
    this._animation.setAnimationLoop(callback);
  }
  /**
   * Can be used to transfer buffer data from a storage buffer attribute
   * from the GPU to the CPU in context of compute shaders.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute2) {
    return await this.backend.getArrayBufferAsync(attribute2);
  }
  /**
   * Returns the rendering context.
   *
   * @return {GPUCanvasContext|WebGL2RenderingContext} The rendering context.
   */
  getContext() {
    return this.backend.getContext();
  }
  /**
   * Returns the pixel ratio.
   *
   * @return {number} The pixel ratio.
   */
  getPixelRatio() {
    return this._pixelRatio;
  }
  /**
   * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
   *
   * @param {Vector2} target - The method writes the result in this target object.
   * @return {Vector2} The drawing buffer size.
   */
  getDrawingBufferSize(target) {
    return target
      .set(this._width * this._pixelRatio, this._height * this._pixelRatio)
      .floor();
  }
  /**
   * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
   *
   * @param {Vector2} target - The method writes the result in this target object.
   * @return {Vector2} The renderer's size in logical pixels.
   */
  getSize(target) {
    return target.set(this._width, this._height);
  }
  /**
   * Sets the given pixel ratio and resizes the canvas if necessary.
   *
   * @param {number} [value=1] - The pixel ratio.
   */
  setPixelRatio(value = 1) {
    if (this._pixelRatio === value) return;
    this._pixelRatio = value;
    this.setSize(this._width, this._height, false);
  }
  /**
   * This method allows to define the drawing buffer size by specifying
   * width, height and pixel ratio all at once. The size of the drawing
   * buffer is computed with this formula:
   * ```js
   * size.x = width * pixelRatio;
   * size.y = height * pixelRatio;
   * ```
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   * @param {number} pixelRatio - The pixel ratio.
   */
  setDrawingBufferSize(width, height, pixelRatio) {
    if (this.xr && this.xr.isPresenting) return;
    this._width = width;
    this._height = height;
    this._pixelRatio = pixelRatio;
    this.domElement.width = Math.floor(width * pixelRatio);
    this.domElement.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
    if (this._initialized) this.backend.updateSize();
  }
  /**
   * Sets the size of the renderer.
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
   */
  setSize(width, height, updateStyle = true) {
    if (this.xr && this.xr.isPresenting) return;
    this._width = width;
    this._height = height;
    this.domElement.width = Math.floor(width * this._pixelRatio);
    this.domElement.height = Math.floor(height * this._pixelRatio);
    if (updateStyle === true) {
      this.domElement.style.width = width + "px";
      this.domElement.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
    if (this._initialized) this.backend.updateSize();
  }
  /**
   * Defines a manual sort function for the opaque render list.
   * Pass `null` to use the default sort.
   *
   * @param {Function} method - The sort function.
   */
  setOpaqueSort(method) {
    this._opaqueSort = method;
  }
  /**
   * Defines a manual sort function for the transparent render list.
   * Pass `null` to use the default sort.
   *
   * @param {Function} method - The sort function.
   */
  setTransparentSort(method) {
    this._transparentSort = method;
  }
  /**
   * Returns the scissor rectangle.
   *
   * @param {Vector4} target - The method writes the result in this target object.
   * @return {Vector4} The scissor rectangle.
   */
  getScissor(target) {
    const scissor = this._scissor;
    target.x = scissor.x;
    target.y = scissor.y;
    target.width = scissor.width;
    target.height = scissor.height;
    return target;
  }
  /**
   * Defines the scissor rectangle.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
   * Instead of passing four arguments, the method also works with a single four-dimensional vector.
   * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
   * @param {number} width - The width of the scissor box in logical pixel unit.
   * @param {number} height - The height of the scissor box in logical pixel unit.
   */
  setScissor(x, y, width, height) {
    const scissor = this._scissor;
    if (x.isVector4) {
      scissor.copy(x);
    } else {
      scissor.set(x, y, width, height);
    }
  }
  /**
   * Returns the scissor test value.
   *
   * @return {boolean} Whether the scissor test should be enabled or not.
   */
  getScissorTest() {
    return this._scissorTest;
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(boolean) {
    this._scissorTest = boolean;
    this.backend.setScissorTest(boolean);
  }
  /**
   * Returns the viewport definition.
   *
   * @param {Vector4} target - The method writes the result in this target object.
   * @return {Vector4} The viewport definition.
   */
  getViewport(target) {
    return target.copy(this._viewport);
  }
  /**
   * Defines the viewport.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
   * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
   * @param {number} width - The width of the viewport in logical pixel unit.
   * @param {number} height - The height of the viewport in logical pixel unit.
   * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
   * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
   */
  setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
    const viewport2 = this._viewport;
    if (x.isVector4) {
      viewport2.copy(x);
    } else {
      viewport2.set(x, y, width, height);
    }
    viewport2.minDepth = minDepth;
    viewport2.maxDepth = maxDepth;
  }
  /**
   * Returns the clear color.
   *
   * @param {Color} target - The method writes the result in this target object.
   * @return {Color} The clear color.
   */
  getClearColor(target) {
    return target.copy(this._clearColor);
  }
  /**
   * Defines the clear color and optionally the clear alpha.
   *
   * @param {Color} color - The clear color.
   * @param {number} [alpha=1] - The clear alpha.
   */
  setClearColor(color2, alpha = 1) {
    this._clearColor.set(color2);
    this._clearColor.a = alpha;
  }
  /**
   * Returns the clear alpha.
   *
   * @return {number} The clear alpha.
   */
  getClearAlpha() {
    return this._clearColor.a;
  }
  /**
   * Defines the clear alpha.
   *
   * @param {number} alpha - The clear alpha.
   */
  setClearAlpha(alpha) {
    this._clearColor.a = alpha;
  }
  /**
   * Returns the clear depth.
   *
   * @return {number} The clear depth.
   */
  getClearDepth() {
    return this._clearDepth;
  }
  /**
   * Defines the clear depth.
   *
   * @param {number} depth - The clear depth.
   */
  setClearDepth(depth2) {
    this._clearDepth = depth2;
  }
  /**
   * Returns the clear stencil.
   *
   * @return {number} The clear stencil.
   */
  getClearStencil() {
    return this._clearStencil;
  }
  /**
   * Defines the clear stencil.
   *
   * @param {number} stencil - The clear stencil.
   */
  setClearStencil(stencil) {
    this._clearStencil = stencil;
  }
  /**
   * This method performs an occlusion query for the given 3D object.
   * It returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(object) {
    const renderContext = this._currentRenderContext;
    return renderContext && this.backend.isOccluded(renderContext, object);
  }
  /**
   * Performs a manual clear operation. This method ignores `autoClear` properties.
   *
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   * Only returned when the renderer has not been initialized.
   */
  clear(color2 = true, depth2 = true, stencil = true) {
    if (this._initialized === false) {
      console.warn(
        "THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead."
      );
      return this.clearAsync(color2, depth2, stencil);
    }
    const renderTarget = this._renderTarget || this._getFrameBufferTarget();
    let renderContext = null;
    if (renderTarget !== null) {
      this._textures.updateRenderTarget(renderTarget);
      const renderTargetData = this._textures.get(renderTarget);
      renderContext = this._renderContexts.getForClear(renderTarget);
      renderContext.textures = renderTargetData.textures;
      renderContext.depthTexture = renderTargetData.depthTexture;
      renderContext.width = renderTargetData.width;
      renderContext.height = renderTargetData.height;
      renderContext.renderTarget = renderTarget;
      renderContext.depth = renderTarget.depthBuffer;
      renderContext.stencil = renderTarget.stencilBuffer;
      renderContext.clearColorValue = this.backend.getClearColor();
      renderContext.activeCubeFace = this.getActiveCubeFace();
      renderContext.activeMipmapLevel = this.getActiveMipmapLevel();
    }
    this.backend.clear(color2, depth2, stencil, renderContext);
    if (renderTarget !== null && this._renderTarget === null) {
      this._renderOutput(renderTarget);
    }
  }
  /**
   * Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.
   *
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   * Only returned when the renderer has not been initialized.
   */
  clearColor() {
    return this.clear(true, false, false);
  }
  /**
   * Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.
   *
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   * Only returned when the renderer has not been initialized.
   */
  clearDepth() {
    return this.clear(false, true, false);
  }
  /**
   * Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.
   *
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   * Only returned when the renderer has not been initialized.
   */
  clearStencil() {
    return this.clear(false, false, true);
  }
  /**
   * Async version of {@link Renderer#clear}.
   *
   * @async
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearAsync(color2 = true, depth2 = true, stencil = true) {
    if (this._initialized === false) await this.init();
    this.clear(color2, depth2, stencil);
  }
  /**
   * Async version of {@link Renderer#clearColor}.
   *
   * @async
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearColorAsync() {
    this.clearAsync(true, false, false);
  }
  /**
   * Async version of {@link Renderer#clearDepth}.
   *
   * @async
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearDepthAsync() {
    this.clearAsync(false, true, false);
  }
  /**
   * Async version of {@link Renderer#clearStencil}.
   *
   * @async
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearStencilAsync() {
    this.clearAsync(false, false, true);
  }
  /**
   * The current tone mapping of the renderer. When not producing screen output,
   * the tone mapping is always `NoToneMapping`.
   *
   * @type {number}
   */
  get currentToneMapping() {
    return this.isOutputTarget ? this.toneMapping : NoToneMapping;
  }
  /**
   * The current color space of the renderer. When not producing screen output,
   * the color space is always the working color space.
   *
   * @type {string}
   */
  get currentColorSpace() {
    return this.isOutputTarget
      ? this.outputColorSpace
      : ColorManagement.workingColorSpace;
  }
  /**
   * Returns `true` if the rendering settings are set to screen output.
   *
   * @returns {boolean} True if the current render target is the same of output render target or `null`, otherwise false.
   */
  get isOutputTarget() {
    return (
      this._renderTarget === this._outputRenderTarget ||
      this._renderTarget === null
    );
  }
  /**
   * Frees all internal resources of the renderer. Call this method if the renderer
   * is no longer in use by your app.
   */
  dispose() {
    this.info.dispose();
    this.backend.dispose();
    this._animation.dispose();
    this._objects.dispose();
    this._pipelines.dispose();
    this._nodes.dispose();
    this._bindings.dispose();
    this._renderLists.dispose();
    this._renderContexts.dispose();
    this._textures.dispose();
    if (this._frameBufferTarget !== null) this._frameBufferTarget.dispose();
    Object.values(this.backend.timestampQueryPool).forEach((queryPool) => {
      if (queryPool !== null) queryPool.dispose();
    });
    this.setRenderTarget(null);
    this.setAnimationLoop(null);
  }
  /**
   * Sets the given render target. Calling this method means the renderer does not
   * target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.
   * Use `null` as the first argument to reset the state.
   *
   * @param {?RenderTarget} renderTarget - The render target to set.
   * @param {number} [activeCubeFace=0] - The active cube face.
   * @param {number} [activeMipmapLevel=0] - The active mipmap level.
   */
  setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    this._renderTarget = renderTarget;
    this._activeCubeFace = activeCubeFace;
    this._activeMipmapLevel = activeMipmapLevel;
  }
  /**
   * Returns the current render target.
   *
   * @return {?RenderTarget} The render target. Returns `null` if no render target is set.
   */
  getRenderTarget() {
    return this._renderTarget;
  }
  /**
   * Sets the output render target for the renderer.
   *
   * @param {Object} renderTarget - The render target to set as the output target.
   */
  setOutputRenderTarget(renderTarget) {
    this._outputRenderTarget = renderTarget;
  }
  /**
   * Returns the current output target.
   *
   * @return {?RenderTarget} The current output render target. Returns `null` if no output target is set.
   */
  getOutputRenderTarget() {
    return this._outputRenderTarget;
  }
  /**
   * Resets the renderer to the initial state before WebXR started.
   *
   */
  _resetXRState() {
    this.backend.setXRTarget(null);
    this.setOutputRenderTarget(null);
    this.setRenderTarget(null);
    this._frameBufferTarget.dispose();
    this._frameBufferTarget = null;
  }
  /**
   * Callback for {@link Renderer#setRenderObjectFunction}.
   *
   * @callback renderObjectFunction
   * @param {Object3D} object - The 3D object.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {BufferGeometry} geometry - The object's geometry.
   * @param {Material} material - The object's material.
   * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  /**
   * Sets the given render object function. Calling this method overwrites the default implementation
   * which is {@link Renderer#renderObject}. Defining a custom function can be useful
   * if you want to modify the way objects are rendered. For example you can define things like "every
   * object that has material of a certain type should perform a pre-pass with a special overwrite material".
   * The custom function must always call `renderObject()` in its implementation.
   *
   * Use `null` as the first argument to reset the state.
   *
   * @param {?renderObjectFunction} renderObjectFunction - The render object function.
   */
  setRenderObjectFunction(renderObjectFunction) {
    this._renderObjectFunction = renderObjectFunction;
  }
  /**
   * Returns the current render object function.
   *
   * @return {?Function} The current render object function. Returns `null` if no function is set.
   */
  getRenderObjectFunction() {
    return this._renderObjectFunction;
  }
  /**
   * Execute a single or an array of compute nodes. This method can only be called
   * if the renderer has been initialized.
   *
   * @param {Node|Array<Node>} computeNodes - The compute node(s).
   * @param {Array<number>|number} [dispatchSizeOrCount=null] - Array with [ x, y, z ] values for dispatch or a single number for the count.
   * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
   */
  compute(computeNodes, dispatchSizeOrCount = null) {
    if (this._isDeviceLost === true) return;
    if (this._initialized === false) {
      console.warn(
        "THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead."
      );
      return this.computeAsync(computeNodes);
    }
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    this.info.calls++;
    this.info.compute.calls++;
    this.info.compute.frameCalls++;
    nodeFrame.renderId = this.info.calls;
    const backend = this.backend;
    const pipelines = this._pipelines;
    const bindings = this._bindings;
    const nodes = this._nodes;
    const computeList = Array.isArray(computeNodes)
      ? computeNodes
      : [computeNodes];
    if (computeList[0] === void 0 || computeList[0].isComputeNode !== true) {
      throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");
    }
    backend.beginCompute(computeNodes);
    for (const computeNode of computeList) {
      if (pipelines.has(computeNode) === false) {
        const dispose = () => {
          computeNode.removeEventListener("dispose", dispose);
          pipelines.delete(computeNode);
          bindings.delete(computeNode);
          nodes.delete(computeNode);
        };
        computeNode.addEventListener("dispose", dispose);
        const onInitFn = computeNode.onInitFunction;
        if (onInitFn !== null) {
          onInitFn.call(computeNode, { renderer: this });
        }
      }
      nodes.updateForCompute(computeNode);
      bindings.updateForCompute(computeNode);
      const computeBindings = bindings.getForCompute(computeNode);
      const computePipeline = pipelines.getForCompute(
        computeNode,
        computeBindings
      );
      backend.compute(
        computeNodes,
        computeNode,
        computeBindings,
        computePipeline,
        dispatchSizeOrCount
      );
    }
    backend.finishCompute(computeNodes);
    nodeFrame.renderId = previousRenderId;
  }
  /**
   * Execute a single or an array of compute nodes.
   *
   * @async
   * @param {Node|Array<Node>} computeNodes - The compute node(s).
   * @param {Array<number>|number} [dispatchSizeOrCount=null] - Array with [ x, y, z ] values for dispatch or a single number for the count.
   * @return {Promise} A Promise that resolve when the compute has finished.
   */
  async computeAsync(computeNodes, dispatchSizeOrCount = null) {
    if (this._initialized === false) await this.init();
    this.compute(computeNodes, dispatchSizeOrCount);
  }
  /**
   * Checks if the given feature is supported by the selected backend.
   *
   * @async
   * @param {string} name - The feature's name.
   * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
   */
  async hasFeatureAsync(name) {
    if (this._initialized === false) await this.init();
    return this.backend.hasFeature(name);
  }
  async resolveTimestampsAsync(type = "render") {
    if (this._initialized === false) await this.init();
    return this.backend.resolveTimestampsAsync(type);
  }
  /**
   * Checks if the given feature is supported by the selected backend. If the
   * renderer has not been initialized, this method always returns `false`.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(name) {
    if (this._initialized === false) {
      console.warn(
        "THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead."
      );
      return false;
    }
    return this.backend.hasFeature(name);
  }
  /**
   * Returns `true` when the renderer has been initialized.
   *
   * @return {boolean} Whether the renderer has been initialized or not.
   */
  hasInitialized() {
    return this._initialized;
  }
  /**
   * Initializes the given textures. Useful for preloading a texture rather than waiting until first render
   * (which can cause noticeable lags due to decode and GPU upload overhead).
   *
   * @async
   * @param {Texture} texture - The texture.
   * @return {Promise} A Promise that resolves when the texture has been initialized.
   */
  async initTextureAsync(texture2) {
    if (this._initialized === false) await this.init();
    this._textures.updateTexture(texture2);
  }
  /**
   * Initializes the given texture. Useful for preloading a texture rather than waiting until first render
   * (which can cause noticeable lags due to decode and GPU upload overhead).
   *
   * This method can only be used if the renderer has been initialized.
   *
   * @param {Texture} texture - The texture.
   */
  initTexture(texture2) {
    if (this._initialized === false) {
      console.warn(
        "THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead."
      );
    }
    this._textures.updateTexture(texture2);
  }
  /**
   * Copies the current bound framebuffer into the given texture.
   *
   * @param {FramebufferTexture} framebufferTexture - The texture.
   * @param {?Vector2|Vector4} [rectangle=null] - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.
   */
  copyFramebufferToTexture(framebufferTexture, rectangle = null) {
    if (rectangle !== null) {
      if (rectangle.isVector2) {
        rectangle = _vector4
          .set(
            rectangle.x,
            rectangle.y,
            framebufferTexture.image.width,
            framebufferTexture.image.height
          )
          .floor();
      } else if (rectangle.isVector4) {
        rectangle = _vector4.copy(rectangle).floor();
      } else {
        console.error(
          "THREE.Renderer.copyFramebufferToTexture: Invalid rectangle."
        );
        return;
      }
    } else {
      rectangle = _vector4.set(
        0,
        0,
        framebufferTexture.image.width,
        framebufferTexture.image.height
      );
    }
    let renderContext = this._currentRenderContext;
    let renderTarget;
    if (renderContext !== null) {
      renderTarget = renderContext.renderTarget;
    } else {
      renderTarget = this._renderTarget || this._getFrameBufferTarget();
      if (renderTarget !== null) {
        this._textures.updateRenderTarget(renderTarget);
        renderContext = this._textures.get(renderTarget);
      }
    }
    this._textures.updateTexture(framebufferTexture, { renderTarget });
    this.backend.copyFramebufferToTexture(
      framebufferTexture,
      renderContext,
      rectangle
    );
  }
  /**
   * Copies data of the given source texture into a destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
   * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(
    srcTexture,
    dstTexture,
    srcRegion = null,
    dstPosition = null,
    srcLevel = 0,
    dstLevel = 0
  ) {
    this._textures.updateTexture(srcTexture);
    this._textures.updateTexture(dstTexture);
    this.backend.copyTextureToTexture(
      srcTexture,
      dstTexture,
      srcRegion,
      dstPosition,
      srcLevel,
      dstLevel
    );
  }
  /**
   * Reads pixel data from the given render target.
   *
   * @async
   * @param {RenderTarget} renderTarget - The render target to read from.
   * @param {number} x - The `x` coordinate of the copy region's origin.
   * @param {number} y - The `y` coordinate of the copy region's origin.
   * @param {number} width - The width of the copy region.
   * @param {number} height - The height of the copy region.
   * @param {number} [textureIndex=0] - The texture index of a MRT render target.
   * @param {number} [faceIndex=0] - The active cube face index.
   * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
   */
  async readRenderTargetPixelsAsync(
    renderTarget,
    x,
    y,
    width,
    height,
    textureIndex = 0,
    faceIndex = 0
  ) {
    return this.backend.copyTextureToBuffer(
      renderTarget.textures[textureIndex],
      x,
      y,
      width,
      height,
      faceIndex
    );
  }
  /**
   * Analyzes the given 3D object's hierarchy and builds render lists from the
   * processed hierarchy.
   *
   * @param {Object3D} object - The 3D object to process (usually a scene).
   * @param {Camera} camera - The camera the object is rendered with.
   * @param {number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.
   * @param {RenderList} renderList - The current render list.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  _projectObject(object, camera2, groupOrder, renderList, clippingContext) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera2.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
        if (object.isClippingGroup && object.enabled)
          clippingContext = clippingContext.getGroupContext(object);
      } else if (object.isLOD) {
        if (object.autoUpdate === true) object.update(camera2);
      } else if (object.isLight) {
        renderList.pushLight(object);
      } else if (object.isSprite) {
        const frustum = camera2.isArrayCamera ? _frustumArray : _frustum;
        if (
          !object.frustumCulled ||
          frustum.intersectsSprite(object, camera2)
        ) {
          if (this.sortObjects === true) {
            _vector4
              .setFromMatrixPosition(object.matrixWorld)
              .applyMatrix4(_projScreenMatrix);
          }
          const { geometry, material } = object;
          if (material.visible) {
            renderList.push(
              object,
              geometry,
              material,
              groupOrder,
              _vector4.z,
              null,
              clippingContext
            );
          }
        }
      } else if (object.isLineLoop) {
        console.error(
          "THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments."
        );
      } else if (object.isMesh || object.isLine || object.isPoints) {
        const frustum = camera2.isArrayCamera ? _frustumArray : _frustum;
        if (
          !object.frustumCulled ||
          frustum.intersectsObject(object, camera2)
        ) {
          const { geometry, material } = object;
          if (this.sortObjects === true) {
            if (geometry.boundingSphere === null)
              geometry.computeBoundingSphere();
            _vector4
              .copy(geometry.boundingSphere.center)
              .applyMatrix4(object.matrixWorld)
              .applyMatrix4(_projScreenMatrix);
          }
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
              const group = groups[i2];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                renderList.push(
                  object,
                  geometry,
                  groupMaterial,
                  groupOrder,
                  _vector4.z,
                  group,
                  clippingContext
                );
              }
            }
          } else if (material.visible) {
            renderList.push(
              object,
              geometry,
              material,
              groupOrder,
              _vector4.z,
              null,
              clippingContext
            );
          }
        }
      }
    }
    if (object.isBundleGroup === true && this.backend.beginBundle !== void 0) {
      const baseRenderList = renderList;
      renderList = this._renderLists.get(object, camera2);
      renderList.begin();
      baseRenderList.pushBundle({
        bundleGroup: object,
        camera: camera2,
        renderList,
      });
      renderList.finish();
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      this._projectObject(
        children[i2],
        camera2,
        groupOrder,
        renderList,
        clippingContext
      );
    }
  }
  /**
   * Renders the given render bundles.
   *
   * @private
   * @param {Array<Object>} bundles - Array with render bundle data.
   * @param {Scene} sceneRef - The scene the render bundles belong to.
   * @param {LightsNode} lightsNode - The current lights node.
   */
  _renderBundles(bundles, sceneRef, lightsNode) {
    for (const bundle of bundles) {
      this._renderBundle(bundle, sceneRef, lightsNode);
    }
  }
  /**
   * Renders the transparent objects from the given render lists.
   *
   * @private
   * @param {Array<Object>} renderList - The transparent render list.
   * @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).
   * @param {Camera} camera - The camera the render list should be rendered with.
   * @param {Scene} scene - The scene the render list belongs to.
   * @param {LightsNode} lightsNode - The current lights node.
   */
  _renderTransparents(renderList, doublePassList, camera2, scene2, lightsNode) {
    if (doublePassList.length > 0) {
      for (const { material } of doublePassList) {
        material.side = BackSide;
      }
      this._renderObjects(
        doublePassList,
        camera2,
        scene2,
        lightsNode,
        "backSide"
      );
      for (const { material } of doublePassList) {
        material.side = FrontSide;
      }
      this._renderObjects(renderList, camera2, scene2, lightsNode);
      for (const { material } of doublePassList) {
        material.side = DoubleSide;
      }
    } else {
      this._renderObjects(renderList, camera2, scene2, lightsNode);
    }
  }
  /**
   * Renders the objects from the given render list.
   *
   * @private
   * @param {Array<Object>} renderList - The render list.
   * @param {Camera} camera - The camera the render list should be rendered with.
   * @param {Scene} scene - The scene the render list belongs to.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  _renderObjects(renderList, camera2, scene2, lightsNode, passId = null) {
    for (let i2 = 0, il = renderList.length; i2 < il; i2++) {
      const { object, geometry, material, group, clippingContext } =
        renderList[i2];
      this._currentRenderObjectFunction(
        object,
        scene2,
        camera2,
        geometry,
        material,
        group,
        lightsNode,
        clippingContext,
        passId
      );
    }
  }
  /**
   * This method represents the default render object function that manages the render lifecycle
   * of the object.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {BufferGeometry} geometry - The object's geometry.
   * @param {Material} material - The object's material.
   * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?ClippingContext} clippingContext - The clipping context.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  renderObject(
    object,
    scene2,
    camera2,
    geometry,
    material,
    group,
    lightsNode,
    clippingContext = null,
    passId = null
  ) {
    let overridePositionNode;
    let overrideColorNode;
    let overrideDepthNode;
    object.onBeforeRender(this, scene2, camera2, geometry, material, group);
    if (material.allowOverride === true && scene2.overrideMaterial !== null) {
      const overrideMaterial = scene2.overrideMaterial;
      if (material.positionNode && material.positionNode.isNode) {
        overridePositionNode = overrideMaterial.positionNode;
        overrideMaterial.positionNode = material.positionNode;
      }
      overrideMaterial.alphaTest = material.alphaTest;
      overrideMaterial.alphaMap = material.alphaMap;
      overrideMaterial.transparent =
        material.transparent || material.transmission > 0;
      if (overrideMaterial.isShadowPassMaterial) {
        overrideMaterial.side =
          material.shadowSide === null ? material.side : material.shadowSide;
        if (material.depthNode && material.depthNode.isNode) {
          overrideDepthNode = overrideMaterial.depthNode;
          overrideMaterial.depthNode = material.depthNode;
        }
        if (material.castShadowNode && material.castShadowNode.isNode) {
          overrideColorNode = overrideMaterial.colorNode;
          overrideMaterial.colorNode = material.castShadowNode;
        }
        if (
          material.castShadowPositionNode &&
          material.castShadowPositionNode.isNode
        ) {
          overridePositionNode = overrideMaterial.positionNode;
          overrideMaterial.positionNode = material.castShadowPositionNode;
        }
      }
      material = overrideMaterial;
    }
    if (
      material.transparent === true &&
      material.side === DoubleSide &&
      material.forceSinglePass === false
    ) {
      material.side = BackSide;
      this._handleObjectFunction(
        object,
        material,
        scene2,
        camera2,
        lightsNode,
        group,
        clippingContext,
        "backSide"
      );
      material.side = FrontSide;
      this._handleObjectFunction(
        object,
        material,
        scene2,
        camera2,
        lightsNode,
        group,
        clippingContext,
        passId
      );
      material.side = DoubleSide;
    } else {
      this._handleObjectFunction(
        object,
        material,
        scene2,
        camera2,
        lightsNode,
        group,
        clippingContext,
        passId
      );
    }
    if (overridePositionNode !== void 0) {
      scene2.overrideMaterial.positionNode = overridePositionNode;
    }
    if (overrideDepthNode !== void 0) {
      scene2.overrideMaterial.depthNode = overrideDepthNode;
    }
    if (overrideColorNode !== void 0) {
      scene2.overrideMaterial.colorNode = overrideColorNode;
    }
    object.onAfterRender(this, scene2, camera2, geometry, material, group);
  }
  /**
   * This method represents the default `_handleObjectFunction` implementation which creates
   * a render object from the given data and performs the draw command with the selected backend.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   */
  _renderObjectDirect(
    object,
    material,
    scene2,
    camera2,
    lightsNode,
    group,
    clippingContext,
    passId
  ) {
    const renderObject = this._objects.get(
      object,
      material,
      scene2,
      camera2,
      lightsNode,
      this._currentRenderContext,
      clippingContext,
      passId
    );
    renderObject.drawRange = object.geometry.drawRange;
    renderObject.group = group;
    const needsRefresh = this._nodes.needsRefresh(renderObject);
    if (needsRefresh) {
      this._nodes.updateBefore(renderObject);
      this._geometries.updateForRender(renderObject);
      this._nodes.updateForRender(renderObject);
      this._bindings.updateForRender(renderObject);
    }
    this._pipelines.updateForRender(renderObject);
    if (this._currentRenderBundle !== null) {
      const renderBundleData = this.backend.get(this._currentRenderBundle);
      renderBundleData.renderObjects.push(renderObject);
      renderObject.bundle = this._currentRenderBundle.bundleGroup;
    }
    this.backend.draw(renderObject, this.info);
    if (needsRefresh) this._nodes.updateAfter(renderObject);
  }
  /**
   * A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.
   * Used in `compileAsync()`.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   */
  _createObjectPipeline(
    object,
    material,
    scene2,
    camera2,
    lightsNode,
    group,
    clippingContext,
    passId
  ) {
    const renderObject = this._objects.get(
      object,
      material,
      scene2,
      camera2,
      lightsNode,
      this._currentRenderContext,
      clippingContext,
      passId
    );
    renderObject.drawRange = object.geometry.drawRange;
    renderObject.group = group;
    this._nodes.updateBefore(renderObject);
    this._geometries.updateForRender(renderObject);
    this._nodes.updateForRender(renderObject);
    this._bindings.updateForRender(renderObject);
    this._pipelines.getForRender(renderObject, this._compilationPromises);
    this._nodes.updateAfter(renderObject);
  }
  /**
   * Alias for `compileAsync()`.
   *
   * @method
   * @param {Object3D} scene - The scene or 3D object to precompile.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
   * @return {function(Object3D, Camera, ?Scene): Promise|undefined} A Promise that resolves when the compile has been finished.
   */
  get compile() {
    return this.compileAsync;
  }
}
class Binding {
  /**
   * Constructs a new binding.
   *
   * @param {string} [name=''] - The binding's name.
   */
  constructor(name = "") {
    this.name = name;
    this.visibility = 0;
  }
  /**
   * Makes sure binding's resource is visible for the given shader stage.
   *
   * @param {number} visibility - The shader stage.
   */
  setVisibility(visibility) {
    this.visibility |= visibility;
  }
  /**
   * Clones the binding.
   *
   * @return {Binding} The cloned binding.
   */
  clone() {
    return Object.assign(new this.constructor(), this);
  }
}
function getFloatLength(floatLength) {
  return (
    floatLength +
    ((GPU_CHUNK_BYTES - (floatLength % GPU_CHUNK_BYTES)) % GPU_CHUNK_BYTES)
  );
}
class Buffer extends Binding {
  /**
   * Constructs a new buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {TypedArray} [buffer=null] - The buffer.
   */
  constructor(name, buffer2 = null) {
    super(name);
    this.isBuffer = true;
    this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;
    this._buffer = buffer2;
  }
  /**
   * The buffer's byte length.
   *
   * @type {number}
   * @readonly
   */
  get byteLength() {
    return getFloatLength(this._buffer.byteLength);
  }
  /**
   * A reference to the internal buffer.
   *
   * @type {Float32Array}
   * @readonly
   */
  get buffer() {
    return this._buffer;
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the buffer has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    return true;
  }
}
class UniformBuffer extends Buffer {
  /**
   * Constructs a new uniform buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {TypedArray} [buffer=null] - The buffer.
   */
  constructor(name, buffer2 = null) {
    super(name, buffer2);
    this.isUniformBuffer = true;
  }
}
let _id$4 = 0;
class NodeUniformBuffer extends UniformBuffer {
  /**
   * Constructs a new node-based uniform buffer.
   *
   * @param {BufferNode} nodeUniform - The uniform buffer node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(nodeUniform, groupNode) {
    super("UniformBuffer_" + _id$4++, nodeUniform ? nodeUniform.value : null);
    this.nodeUniform = nodeUniform;
    this.groupNode = groupNode;
  }
  /**
   * The uniform buffer.
   *
   * @type {Float32Array}
   */
  get buffer() {
    return this.nodeUniform.value;
  }
}
class UniformsGroup extends UniformBuffer {
  /**
   * Constructs a new uniforms group.
   *
   * @param {string} name - The group's name.
   */
  constructor(name) {
    super(name);
    this.isUniformsGroup = true;
    this._values = null;
    this.uniforms = [];
  }
  /**
   * Adds a uniform to this group.
   *
   * @param {Uniform} uniform - The uniform to add.
   * @return {UniformsGroup} A reference to this group.
   */
  addUniform(uniform2) {
    this.uniforms.push(uniform2);
    return this;
  }
  /**
   * Removes a uniform from this group.
   *
   * @param {Uniform} uniform - The uniform to remove.
   * @return {UniformsGroup} A reference to this group.
   */
  removeUniform(uniform2) {
    const index = this.uniforms.indexOf(uniform2);
    if (index !== -1) {
      this.uniforms.splice(index, 1);
    }
    return this;
  }
  /**
   * An array with the raw uniform values.
   *
   * @type {Array<number>}
   */
  get values() {
    if (this._values === null) {
      this._values = Array.from(this.buffer);
    }
    return this._values;
  }
  /**
   * A Float32 array buffer with the uniform values.
   *
   * @type {Float32Array}
   */
  get buffer() {
    let buffer2 = this._buffer;
    if (buffer2 === null) {
      const byteLength = this.byteLength;
      buffer2 = new Float32Array(new ArrayBuffer(byteLength));
      this._buffer = buffer2;
    }
    return buffer2;
  }
  /**
   * The byte length of the buffer with correct buffer alignment.
   *
   * @type {number}
   */
  get byteLength() {
    const bytesPerElement = this.bytesPerElement;
    let offset = 0;
    for (let i2 = 0, l2 = this.uniforms.length; i2 < l2; i2++) {
      const uniform2 = this.uniforms[i2];
      const boundary = uniform2.boundary;
      const itemSize = uniform2.itemSize * bytesPerElement;
      const chunkOffset = offset % GPU_CHUNK_BYTES;
      const chunkPadding = chunkOffset % boundary;
      const chunkStart = chunkOffset + chunkPadding;
      offset += chunkPadding;
      if (chunkStart !== 0 && GPU_CHUNK_BYTES - chunkStart < itemSize) {
        offset += GPU_CHUNK_BYTES - chunkStart;
      }
      uniform2.offset = offset / bytesPerElement;
      offset += itemSize;
    }
    return Math.ceil(offset / GPU_CHUNK_BYTES) * GPU_CHUNK_BYTES;
  }
  /**
   * Updates this group by updating each uniform object of
   * the internal uniform list. The uniform objects check if their
   * values has actually changed so this method only returns
   * `true` if there is a real value change.
   *
   * @return {boolean} Whether the uniforms have been updated and
   * must be uploaded to the GPU.
   */
  update() {
    let updated = false;
    for (const uniform2 of this.uniforms) {
      if (this.updateByType(uniform2) === true) {
        updated = true;
      }
    }
    return updated;
  }
  /**
   * Updates a given uniform by calling an update method matching
   * the uniforms type.
   *
   * @param {Uniform} uniform - The uniform to update.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateByType(uniform2) {
    if (uniform2.isNumberUniform) return this.updateNumber(uniform2);
    if (uniform2.isVector2Uniform) return this.updateVector2(uniform2);
    if (uniform2.isVector3Uniform) return this.updateVector3(uniform2);
    if (uniform2.isVector4Uniform) return this.updateVector4(uniform2);
    if (uniform2.isColorUniform) return this.updateColor(uniform2);
    if (uniform2.isMatrix3Uniform) return this.updateMatrix3(uniform2);
    if (uniform2.isMatrix4Uniform) return this.updateMatrix4(uniform2);
    console.error(
      "THREE.WebGPUUniformsGroup: Unsupported uniform type.",
      uniform2
    );
  }
  /**
   * Updates a given Number uniform.
   *
   * @param {NumberUniform} uniform - The Number uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateNumber(uniform2) {
    let updated = false;
    const a2 = this.values;
    const v = uniform2.getValue();
    const offset = uniform2.offset;
    const type = uniform2.getType();
    if (a2[offset] !== v) {
      const b = this._getBufferForType(type);
      b[offset] = a2[offset] = v;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Vector2 uniform.
   *
   * @param {Vector2Uniform} uniform - The Vector2 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector2(uniform2) {
    let updated = false;
    const a2 = this.values;
    const v = uniform2.getValue();
    const offset = uniform2.offset;
    const type = uniform2.getType();
    if (a2[offset + 0] !== v.x || a2[offset + 1] !== v.y) {
      const b = this._getBufferForType(type);
      b[offset + 0] = a2[offset + 0] = v.x;
      b[offset + 1] = a2[offset + 1] = v.y;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Vector3 uniform.
   *
   * @param {Vector3Uniform} uniform - The Vector3 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector3(uniform2) {
    let updated = false;
    const a2 = this.values;
    const v = uniform2.getValue();
    const offset = uniform2.offset;
    const type = uniform2.getType();
    if (
      a2[offset + 0] !== v.x ||
      a2[offset + 1] !== v.y ||
      a2[offset + 2] !== v.z
    ) {
      const b = this._getBufferForType(type);
      b[offset + 0] = a2[offset + 0] = v.x;
      b[offset + 1] = a2[offset + 1] = v.y;
      b[offset + 2] = a2[offset + 2] = v.z;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Vector4 uniform.
   *
   * @param {Vector4Uniform} uniform - The Vector4 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector4(uniform2) {
    let updated = false;
    const a2 = this.values;
    const v = uniform2.getValue();
    const offset = uniform2.offset;
    const type = uniform2.getType();
    if (
      a2[offset + 0] !== v.x ||
      a2[offset + 1] !== v.y ||
      a2[offset + 2] !== v.z ||
      a2[offset + 4] !== v.w
    ) {
      const b = this._getBufferForType(type);
      b[offset + 0] = a2[offset + 0] = v.x;
      b[offset + 1] = a2[offset + 1] = v.y;
      b[offset + 2] = a2[offset + 2] = v.z;
      b[offset + 3] = a2[offset + 3] = v.w;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Color uniform.
   *
   * @param {ColorUniform} uniform - The Color uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateColor(uniform2) {
    let updated = false;
    const a2 = this.values;
    const c2 = uniform2.getValue();
    const offset = uniform2.offset;
    if (
      a2[offset + 0] !== c2.r ||
      a2[offset + 1] !== c2.g ||
      a2[offset + 2] !== c2.b
    ) {
      const b = this.buffer;
      b[offset + 0] = a2[offset + 0] = c2.r;
      b[offset + 1] = a2[offset + 1] = c2.g;
      b[offset + 2] = a2[offset + 2] = c2.b;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Matrix3 uniform.
   *
   * @param {Matrix3Uniform} uniform - The Matrix3 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateMatrix3(uniform2) {
    let updated = false;
    const a2 = this.values;
    const e2 = uniform2.getValue().elements;
    const offset = uniform2.offset;
    if (
      a2[offset + 0] !== e2[0] ||
      a2[offset + 1] !== e2[1] ||
      a2[offset + 2] !== e2[2] ||
      a2[offset + 4] !== e2[3] ||
      a2[offset + 5] !== e2[4] ||
      a2[offset + 6] !== e2[5] ||
      a2[offset + 8] !== e2[6] ||
      a2[offset + 9] !== e2[7] ||
      a2[offset + 10] !== e2[8]
    ) {
      const b = this.buffer;
      b[offset + 0] = a2[offset + 0] = e2[0];
      b[offset + 1] = a2[offset + 1] = e2[1];
      b[offset + 2] = a2[offset + 2] = e2[2];
      b[offset + 4] = a2[offset + 4] = e2[3];
      b[offset + 5] = a2[offset + 5] = e2[4];
      b[offset + 6] = a2[offset + 6] = e2[5];
      b[offset + 8] = a2[offset + 8] = e2[6];
      b[offset + 9] = a2[offset + 9] = e2[7];
      b[offset + 10] = a2[offset + 10] = e2[8];
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Matrix4 uniform.
   *
   * @param {Matrix4Uniform} uniform - The Matrix4 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateMatrix4(uniform2) {
    let updated = false;
    const a2 = this.values;
    const e2 = uniform2.getValue().elements;
    const offset = uniform2.offset;
    if (arraysEqual(a2, e2, offset) === false) {
      const b = this.buffer;
      b.set(e2, offset);
      setArray(a2, e2, offset);
      updated = true;
    }
    return updated;
  }
  /**
   * Returns a typed array that matches the given data type.
   *
   * @param {string} type - The data type.
   * @return {TypedArray} The typed array.
   */
  _getBufferForType(type) {
    if (
      type === "int" ||
      type === "ivec2" ||
      type === "ivec3" ||
      type === "ivec4"
    )
      return new Int32Array(this.buffer.buffer);
    if (
      type === "uint" ||
      type === "uvec2" ||
      type === "uvec3" ||
      type === "uvec4"
    )
      return new Uint32Array(this.buffer.buffer);
    return this.buffer;
  }
}
function setArray(a2, b, offset) {
  for (let i2 = 0, l2 = b.length; i2 < l2; i2++) {
    a2[offset + i2] = b[i2];
  }
}
function arraysEqual(a2, b, offset) {
  for (let i2 = 0, l2 = b.length; i2 < l2; i2++) {
    if (a2[offset + i2] !== b[i2]) return false;
  }
  return true;
}
let _id$3 = 0;
class NodeUniformsGroup extends UniformsGroup {
  /**
   * Constructs a new node-based uniforms group.
   *
   * @param {string} name - The group's name.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(name, groupNode) {
    super(name);
    this.id = _id$3++;
    this.groupNode = groupNode;
    this.isNodeUniformsGroup = true;
  }
}
class Sampler extends Binding {
  /**
   * Constructs a new sampler.
   *
   * @param {string} name - The samplers's name.
   * @param {?Texture} texture - The texture this binding is referring to.
   */
  constructor(name, texture2) {
    super(name);
    this._onDisposeTexture = () => {
      this.texture = null;
    };
    this.texture = texture2;
    this.version = texture2 ? texture2.version : 0;
    this.generation = null;
    this.isSampler = true;
  }
  /**
   * Sets the texture of this sampler.
   * @param {?Texture} value - The texture to set.
   */
  set texture(value) {
    if (this._texture === value) return;
    if (this._texture) {
      this._texture.removeEventListener("dispose", this._onDisposeTexture);
    }
    this._texture = value;
    this.generation = null;
    this.version = 0;
    if (this._texture) {
      this._texture.addEventListener("dispose", this._onDisposeTexture);
    }
  }
  /**
   * Gets the texture of this sampler.
   * @return {?Texture} The texture.
   */
  get texture() {
    return this._texture;
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the texture has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    const { texture: texture2, version } = this;
    if (version !== texture2.version) {
      this.version = texture2.version;
      return true;
    }
    return false;
  }
}
let _id$2 = 0;
class SampledTexture extends Sampler {
  /**
   * Constructs a new sampled texture.
   *
   * @param {string} name - The sampled texture's name.
   * @param {?Texture} texture - The texture this binding is referring to.
   */
  constructor(name, texture2) {
    super(name, texture2);
    this.id = _id$2++;
    this.store = false;
    this.isSampledTexture = true;
  }
}
class NodeSampledTexture extends SampledTexture {
  /**
   * Constructs a new node-based sampled texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(name, textureNode, groupNode, access = null) {
    super(name, textureNode ? textureNode.value : null);
    this.textureNode = textureNode;
    this.groupNode = groupNode;
    this.access = access;
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the texture has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    const { textureNode } = this;
    if (this.texture !== textureNode.value) {
      this.texture = textureNode.value;
      return true;
    }
    return super.update();
  }
}
class NodeSampledCubeTexture extends NodeSampledTexture {
  /**
   * Constructs a new node-based sampled cube texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(name, textureNode, groupNode, access = null) {
    super(name, textureNode, groupNode, access);
    this.isSampledCubeTexture = true;
  }
}
class NodeSampledTexture3D extends NodeSampledTexture {
  /**
   * Constructs a new node-based sampled 3D texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(name, textureNode, groupNode, access = null) {
    super(name, textureNode, groupNode, access);
    this.isSampledTexture3D = true;
  }
}
const glslMethods = {
  textureDimensions: "textureSize",
  equals: "equal",
};
const precisionLib = {
  low: "lowp",
  medium: "mediump",
  high: "highp",
};
const supports$1 = {
  swizzleAssign: true,
  storageBuffer: false,
};
const interpolationTypeMap = {
  perspective: "smooth",
  linear: "noperspective",
};
const interpolationModeMap = {
  centroid: "centroid",
};
const defaultPrecisions = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
precision lowp sampler2DArrayShadow;
precision lowp samplerCubeShadow;
`;
class GLSLNodeBuilder extends NodeBuilder {
  /**
   * Constructs a new GLSL node builder renderer.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The renderer.
   */
  constructor(object, renderer2) {
    super(object, renderer2, new GLSLNodeParser());
    this.uniformGroups = {};
    this.transforms = [];
    this.extensions = {};
    this.builtins = { vertex: [], fragment: [], compute: [] };
  }
  /**
   * Checks if the given texture requires a manual conversion to the working color space.
   *
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture requires a conversion to working color space or not.
   */
  needsToWorkingColorSpace(texture2) {
    return (
      texture2.isVideoTexture === true && texture2.colorSpace !== NoColorSpace
    );
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved GLSL method name.
   */
  getMethod(method) {
    return glslMethods[method] || method;
  }
  /**
   * Returns the output struct name. Not relevant for GLSL.
   *
   * @return {string}
   */
  getOutputStructName() {
    return "";
  }
  /**
   * Builds the given shader node.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The GLSL function code.
   */
  buildFunctionCode(shaderNode) {
    const layout = shaderNode.layout;
    const flowData = this.flowShaderNode(shaderNode);
    const parameters = [];
    for (const input of layout.inputs) {
      parameters.push(this.getType(input.type) + " " + input.name);
    }
    const code2 = `${this.getType(layout.type)} ${
      layout.name
    }( ${parameters.join(", ")} ) {

	${flowData.vars}

${flowData.code}
	return ${flowData.result};

}`;
    return code2;
  }
  /**
   * Setups the Pixel Buffer Object (PBO) for the given storage
   * buffer node.
   *
   * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
   */
  setupPBO(storageBufferNode) {
    const attribute2 = storageBufferNode.value;
    if (attribute2.pbo === void 0) {
      const originalArray = attribute2.array;
      const numElements = attribute2.count * attribute2.itemSize;
      const { itemSize } = attribute2;
      const isInteger = attribute2.array.constructor.name
        .toLowerCase()
        .includes("int");
      let format = isInteger ? RedIntegerFormat : RedFormat;
      if (itemSize === 2) {
        format = isInteger ? RGIntegerFormat : RGFormat;
      } else if (itemSize === 3) {
        format = isInteger ? RGBIntegerFormat : RGBFormat;
      } else if (itemSize === 4) {
        format = isInteger ? RGBAIntegerFormat : RGBAFormat;
      }
      const typeMap = {
        Float32Array: FloatType,
        Uint8Array: UnsignedByteType,
        Uint16Array: UnsignedShortType,
        Uint32Array: UnsignedIntType,
        Int8Array: ByteType,
        Int16Array: ShortType,
        Int32Array: IntType,
        Uint8ClampedArray: UnsignedByteType,
      };
      const width = Math.pow(
        2,
        Math.ceil(Math.log2(Math.sqrt(numElements / itemSize)))
      );
      let height = Math.ceil(numElements / itemSize / width);
      if (width * height * itemSize < numElements) height++;
      const newSize = width * height * itemSize;
      const newArray = new originalArray.constructor(newSize);
      newArray.set(originalArray, 0);
      attribute2.array = newArray;
      const pboTexture = new DataTexture(
        attribute2.array,
        width,
        height,
        format,
        typeMap[attribute2.array.constructor.name] || FloatType
      );
      pboTexture.needsUpdate = true;
      pboTexture.isPBOTexture = true;
      const pbo = new TextureNode(pboTexture, null, null);
      pbo.setPrecision("high");
      attribute2.pboNode = pbo;
      attribute2.pbo = pbo.value;
      this.getUniformFromNode(
        attribute2.pboNode,
        "texture",
        this.shaderStage,
        this.context.nodeName
      );
    }
  }
  /**
   * Returns a GLSL snippet that represents the property name of the given node.
   *
   * @param {Node} node - The node.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getPropertyName(node, shaderStage = this.shaderStage) {
    if (
      node.isNodeUniform &&
      node.node.isTextureNode !== true &&
      node.node.isBufferNode !== true
    ) {
      return shaderStage.charAt(0) + "_" + node.name;
    }
    return super.getPropertyName(node, shaderStage);
  }
  /**
   * Setups the Pixel Buffer Object (PBO) for the given storage
   * buffer node.
   *
   * @param {StorageArrayElementNode} storageArrayElementNode - The storage array element node.
   * @return {string} The property name.
   */
  generatePBO(storageArrayElementNode) {
    const { node, indexNode } = storageArrayElementNode;
    const attribute2 = node.value;
    if (this.renderer.backend.has(attribute2)) {
      const attributeData = this.renderer.backend.get(attribute2);
      attributeData.pbo = attribute2.pbo;
    }
    const nodeUniform = this.getUniformFromNode(
      attribute2.pboNode,
      "texture",
      this.shaderStage,
      this.context.nodeName
    );
    const textureName = this.getPropertyName(nodeUniform);
    this.increaseUsage(indexNode);
    const indexSnippet = indexNode.build(this, "uint");
    const elementNodeData = this.getDataFromNode(storageArrayElementNode);
    let propertyName = elementNodeData.propertyName;
    if (propertyName === void 0) {
      const nodeVar = this.getVarFromNode(storageArrayElementNode);
      propertyName = this.getPropertyName(nodeVar);
      const bufferNodeData = this.getDataFromNode(node);
      let propertySizeName = bufferNodeData.propertySizeName;
      if (propertySizeName === void 0) {
        propertySizeName = propertyName + "Size";
        this.getVarFromNode(node, propertySizeName, "uint");
        this.addLineFlowCode(
          `${propertySizeName} = uint( textureSize( ${textureName}, 0 ).x )`,
          storageArrayElementNode
        );
        bufferNodeData.propertySizeName = propertySizeName;
      }
      const { itemSize } = attribute2;
      const channel = "." + vectorComponents.join("").slice(0, itemSize);
      const uvSnippet = `ivec2(${indexSnippet} % ${propertySizeName}, ${indexSnippet} / ${propertySizeName})`;
      const snippet = this.generateTextureLoad(
        null,
        textureName,
        uvSnippet,
        null,
        "0"
      );
      let prefix = "vec4";
      if (attribute2.pbo.type === UnsignedIntType) {
        prefix = "uvec4";
      } else if (attribute2.pbo.type === IntType) {
        prefix = "ivec4";
      }
      this.addLineFlowCode(
        `${propertyName} = ${prefix}(${snippet})${channel}`,
        storageArrayElementNode
      );
      elementNodeData.propertyName = propertyName;
    }
    return propertyName;
  }
  /**
   * Generates the GLSL snippet that reads a single texel from a texture without sampling or filtering.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A GLSL snippet that represents the 0-based texture array index to sample.
   * @param {string} [levelSnippet='0u'] - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureLoad(
    texture2,
    textureProperty,
    uvIndexSnippet,
    depthSnippet,
    levelSnippet = "0"
  ) {
    if (depthSnippet) {
      return `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`;
    } else {
      return `texelFetch( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;
    }
  }
  /**
   * Generates the GLSL snippet for sampling/loading the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet -  A GLSL snippet that represents the 0-based texture array index to sample.
   * @return {string} The GLSL snippet.
   */
  generateTexture(texture2, textureProperty, uvSnippet, depthSnippet) {
    if (texture2.isDepthTexture) {
      if (depthSnippet) uvSnippet = `vec4( ${uvSnippet}, ${depthSnippet} )`;
      return `texture( ${textureProperty}, ${uvSnippet} ).x`;
    } else {
      if (depthSnippet) uvSnippet = `vec3( ${uvSnippet}, ${depthSnippet} )`;
      return `texture( ${textureProperty}, ${uvSnippet} )`;
    }
  }
  /**
   * Generates the GLSL snippet when sampling textures with explicit mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet) {
    return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;
  }
  /**
   * Generates the GLSL snippet when sampling textures with a bias to the mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} biasSnippet - A GLSL snippet that represents the bias to apply to the mip level before sampling.
   * @return {string} The GLSL snippet.
   */
  generateTextureBias(texture2, textureProperty, uvSnippet, biasSnippet) {
    return `texture( ${textureProperty}, ${uvSnippet}, ${biasSnippet} )`;
  }
  /**
   * Generates the GLSL snippet for sampling/loading the given texture using explicit gradients.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {Array<string>} gradSnippet - An array holding both gradient GLSL snippets.
   * @return {string} The GLSL snippet.
   */
  generateTextureGrad(texture2, textureProperty, uvSnippet, gradSnippet) {
    return `textureGrad( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]} )`;
  }
  /**
   * Generates the GLSL snippet for sampling a depth texture and comparing the sampled depth values
   * against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} compareSnippet -  A GLSL snippet that represents the reference value.
   * @param {?string} depthSnippet - A GLSL snippet that represents 0-based texture array index to sample.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The GLSL snippet.
   */
  generateTextureCompare(
    texture2,
    textureProperty,
    uvSnippet,
    compareSnippet,
    depthSnippet,
    shaderStage = this.shaderStage
  ) {
    if (shaderStage === "fragment") {
      if (depthSnippet) {
        return `texture( ${textureProperty}, vec4( ${uvSnippet}, ${depthSnippet}, ${compareSnippet} ) )`;
      }
      return `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;
    } else {
      console.error(
        `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`
      );
    }
  }
  /**
   * Returns the variables of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the variables.
   */
  getVars(shaderStage) {
    const snippets = [];
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippets.push(
          `${this.getVar(variable.type, variable.name, variable.count)};`
        );
      }
    }
    return snippets.join("\n	");
  }
  /**
   * Returns the uniforms of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the uniforms.
   */
  getUniforms(shaderStage) {
    const uniforms = this.uniforms[shaderStage];
    const bindingSnippets = [];
    const uniformGroups = {};
    for (const uniform2 of uniforms) {
      let snippet = null;
      let group = false;
      if (uniform2.type === "texture" || uniform2.type === "texture3D") {
        const texture2 = uniform2.node.value;
        let typePrefix = "";
        if (
          texture2.isDataTexture === true ||
          texture2.isData3DTexture === true
        ) {
          if (texture2.type === UnsignedIntType) {
            typePrefix = "u";
          } else if (texture2.type === IntType) {
            typePrefix = "i";
          }
        }
        if (
          uniform2.type === "texture3D" &&
          texture2.isArrayTexture === false
        ) {
          snippet = `${typePrefix}sampler3D ${uniform2.name};`;
        } else if (texture2.compareFunction) {
          if (texture2.isArrayTexture === true) {
            snippet = `sampler2DArrayShadow ${uniform2.name};`;
          } else {
            snippet = `sampler2DShadow ${uniform2.name};`;
          }
        } else if (
          texture2.isArrayTexture === true ||
          texture2.isDataArrayTexture === true ||
          texture2.isCompressedArrayTexture === true
        ) {
          snippet = `${typePrefix}sampler2DArray ${uniform2.name};`;
        } else {
          snippet = `${typePrefix}sampler2D ${uniform2.name};`;
        }
      } else if (uniform2.type === "cubeTexture") {
        snippet = `samplerCube ${uniform2.name};`;
      } else if (uniform2.type === "buffer") {
        const bufferNode = uniform2.node;
        const bufferType = this.getType(bufferNode.bufferType);
        const bufferCount = bufferNode.bufferCount;
        const bufferCountSnippet = bufferCount > 0 ? bufferCount : "";
        snippet = `${bufferNode.name} {
	${bufferType} ${uniform2.name}[${bufferCountSnippet}];
};
`;
      } else {
        const vectorType = this.getVectorType(uniform2.type);
        snippet = `${vectorType} ${this.getPropertyName(
          uniform2,
          shaderStage
        )};`;
        group = true;
      }
      const precision = uniform2.node.precision;
      if (precision !== null) {
        snippet = precisionLib[precision] + " " + snippet;
      }
      if (group) {
        snippet = "	" + snippet;
        const groupName = uniform2.groupNode.name;
        const groupSnippets =
          uniformGroups[groupName] || (uniformGroups[groupName] = []);
        groupSnippets.push(snippet);
      } else {
        snippet = "uniform " + snippet;
        bindingSnippets.push(snippet);
      }
    }
    let output2 = "";
    for (const name in uniformGroups) {
      const groupSnippets = uniformGroups[name];
      output2 +=
        this._getGLSLUniformStruct(
          shaderStage + "_" + name,
          groupSnippets.join("\n")
        ) + "\n";
    }
    output2 += bindingSnippets.join("\n");
    return output2;
  }
  /**
   * Returns the type for a given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @return {string} The type.
   */
  getTypeFromAttribute(attribute2) {
    let nodeType = super.getTypeFromAttribute(attribute2);
    if (/^[iu]/.test(nodeType) && attribute2.gpuType !== IntType) {
      let dataAttribute = attribute2;
      if (attribute2.isInterleavedBufferAttribute)
        dataAttribute = attribute2.data;
      const array2 = dataAttribute.array;
      if (
        (array2 instanceof Uint32Array || array2 instanceof Int32Array) ===
        false
      ) {
        nodeType = nodeType.slice(1);
      }
    }
    return nodeType;
  }
  /**
   * Returns the shader attributes of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the shader attributes.
   */
  getAttributes(shaderStage) {
    let snippet = "";
    if (shaderStage === "vertex" || shaderStage === "compute") {
      const attributes = this.getAttributesArray();
      let location = 0;
      for (const attribute2 of attributes) {
        snippet += `layout( location = ${location++} ) in ${attribute2.type} ${
          attribute2.name
        };
`;
      }
    }
    return snippet;
  }
  /**
   * Returns the members of the given struct type node as a GLSL string.
   *
   * @param {StructTypeNode} struct - The struct type node.
   * @return {string} The GLSL snippet that defines the struct members.
   */
  getStructMembers(struct2) {
    const snippets = [];
    for (const member of struct2.members) {
      snippets.push(`	${member.type} ${member.name};`);
    }
    return snippets.join("\n");
  }
  /**
   * Returns the structs of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the structs.
   */
  getStructs(shaderStage) {
    const snippets = [];
    const structs = this.structs[shaderStage];
    const outputSnippet = [];
    for (const struct2 of structs) {
      if (struct2.output) {
        for (const member of struct2.members) {
          outputSnippet.push(
            `layout( location = ${member.index} ) out ${member.type} ${member.name};`
          );
        }
      } else {
        let snippet = "struct " + struct2.name + " {\n";
        snippet += this.getStructMembers(struct2);
        snippet += "\n};\n";
        snippets.push(snippet);
      }
    }
    if (outputSnippet.length === 0) {
      outputSnippet.push("layout( location = 0 ) out vec4 fragColor;");
    }
    return "\n" + outputSnippet.join("\n") + "\n\n" + snippets.join("\n");
  }
  /**
   * Returns the varyings of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the varyings.
   */
  getVaryings(shaderStage) {
    let snippet = "";
    const varyings = this.varyings;
    if (shaderStage === "vertex" || shaderStage === "compute") {
      for (const varying2 of varyings) {
        if (shaderStage === "compute") varying2.needsInterpolation = true;
        const type = this.getType(varying2.type);
        if (varying2.needsInterpolation) {
          if (varying2.interpolationType) {
            const interpolationType =
              interpolationTypeMap[varying2.interpolationType] ||
              varying2.interpolationType;
            const sampling =
              interpolationModeMap[varying2.interpolationSampling] || "";
            snippet += `${interpolationType} ${sampling} out ${type} ${varying2.name};
`;
          } else {
            const flat =
              type.includes("int") || type.includes("uv") || type.includes("iv")
                ? "flat "
                : "";
            snippet += `${flat}out ${type} ${varying2.name};
`;
          }
        } else {
          snippet += `${type} ${varying2.name};
`;
        }
      }
    } else if (shaderStage === "fragment") {
      for (const varying2 of varyings) {
        if (varying2.needsInterpolation) {
          const type = this.getType(varying2.type);
          if (varying2.interpolationType) {
            const interpolationType =
              interpolationTypeMap[varying2.interpolationType] ||
              varying2.interpolationType;
            const sampling =
              interpolationModeMap[varying2.interpolationSampling] || "";
            snippet += `${interpolationType} ${sampling} in ${type} ${varying2.name};
`;
          } else {
            const flat =
              type.includes("int") || type.includes("uv") || type.includes("iv")
                ? "flat "
                : "";
            snippet += `${flat}in ${type} ${varying2.name};
`;
          }
        }
      }
    }
    for (const builtin2 of this.builtins[shaderStage]) {
      snippet += `${builtin2};
`;
    }
    return snippet;
  }
  /**
   * Returns the vertex index builtin.
   *
   * @return {string} The vertex index.
   */
  getVertexIndex() {
    return "uint( gl_VertexID )";
  }
  /**
   * Returns the instance index builtin.
   *
   * @return {string} The instance index.
   */
  getInstanceIndex() {
    return "uint( gl_InstanceID )";
  }
  /**
   * Returns the invocation local index builtin.
   *
   * @return {string} The invocation local index.
   */
  getInvocationLocalIndex() {
    const workgroupSize = this.object.workgroupSize;
    const size = workgroupSize.reduce((acc, curr) => acc * curr, 1);
    return `uint( gl_InstanceID ) % ${size}u`;
  }
  /**
   * Returns the draw index builtin.
   *
   * @return {?string} The drawIndex shader string. Returns `null` if `WEBGL_multi_draw` isn't supported by the device.
   */
  getDrawIndex() {
    const extensions = this.renderer.backend.extensions;
    if (extensions.has("WEBGL_multi_draw")) {
      return "uint( gl_DrawID )";
    }
    return null;
  }
  /**
   * Returns the front facing builtin.
   *
   * @return {string} The front facing builtin.
   */
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  /**
   * Returns the frag coord builtin.
   *
   * @return {string} The frag coord builtin.
   */
  getFragCoord() {
    return "gl_FragCoord.xy";
  }
  /**
   * Returns the frag depth builtin.
   *
   * @return {string} The frag depth builtin.
   */
  getFragDepth() {
    return "gl_FragDepth";
  }
  /**
   * Enables the given extension.
   *
   * @param {string} name - The extension name.
   * @param {string} behavior - The extension behavior.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage.
   */
  enableExtension(name, behavior, shaderStage = this.shaderStage) {
    const map =
      this.extensions[shaderStage] ||
      (this.extensions[shaderStage] = /* @__PURE__ */ new Map());
    if (map.has(name) === false) {
      map.set(name, {
        name,
        behavior,
      });
    }
  }
  /**
   * Returns the enabled extensions of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the enabled extensions.
   */
  getExtensions(shaderStage) {
    const snippets = [];
    if (shaderStage === "vertex") {
      const ext = this.renderer.backend.extensions;
      const isBatchedMesh = this.object.isBatchedMesh;
      if (isBatchedMesh && ext.has("WEBGL_multi_draw")) {
        this.enableExtension("GL_ANGLE_multi_draw", "require", shaderStage);
      }
    }
    const extensions = this.extensions[shaderStage];
    if (extensions !== void 0) {
      for (const { name, behavior } of extensions.values()) {
        snippets.push(`#extension ${name} : ${behavior}`);
      }
    }
    return snippets.join("\n");
  }
  /**
   * Returns the clip distances builtin.
   *
   * @return {string} The clip distances builtin.
   */
  getClipDistance() {
    return "gl_ClipDistance";
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable(name) {
    let result = supports$1[name];
    if (result === void 0) {
      let extensionName;
      result = false;
      switch (name) {
        case "float32Filterable":
          extensionName = "OES_texture_float_linear";
          break;
        case "clipDistance":
          extensionName = "WEBGL_clip_cull_distance";
          break;
      }
      if (extensionName !== void 0) {
        const extensions = this.renderer.backend.extensions;
        if (extensions.has(extensionName)) {
          extensions.get(extensionName);
          result = true;
        }
      }
      supports$1[name] = result;
    }
    return result;
  }
  /**
   * Whether to flip texture data along its vertical axis or not.
   *
   * @return {boolean} Returns always `true` in context of GLSL.
   */
  isFlipY() {
    return true;
  }
  /**
   * Enables hardware clipping.
   *
   * @param {string} planeCount - The clipping plane count.
   */
  enableHardwareClipping(planeCount) {
    this.enableExtension("GL_ANGLE_clip_cull_distance", "require");
    this.builtins["vertex"].push(`out float gl_ClipDistance[ ${planeCount} ]`);
  }
  /**
   * Enables multiview.
   */
  enableMultiview() {
    this.enableExtension("GL_OVR_multiview2", "require", "fragment");
    this.enableExtension("GL_OVR_multiview2", "require", "vertex");
    this.builtins["vertex"].push("layout(num_views = 2) in");
  }
  /**
   * Registers a transform in context of Transform Feedback.
   *
   * @param {string} varyingName - The varying name.
   * @param {AttributeNode} attributeNode - The attribute node.
   */
  registerTransform(varyingName, attributeNode) {
    this.transforms.push({ varyingName, attributeNode });
  }
  /**
   * Returns the transforms of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the transforms.
   */
  getTransforms() {
    const transforms = this.transforms;
    let snippet = "";
    for (let i2 = 0; i2 < transforms.length; i2++) {
      const transform = transforms[i2];
      const attributeName = this.getPropertyName(transform.attributeNode);
      if (attributeName)
        snippet += `${transform.varyingName} = ${attributeName};
	`;
    }
    return snippet;
  }
  /**
   * Returns a GLSL struct based on the given name and variables.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @return {string} The GLSL snippet representing a struct.
   */
  _getGLSLUniformStruct(name, vars) {
    return `
layout( std140 ) uniform ${name} {
${vars}
};`;
  }
  /**
   * Returns a GLSL vertex shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getGLSLVertexCode(shaderData) {
    return `#version 300 es

${this.getSignature()}

// extensions
${shaderData.extensions}

// precision
${defaultPrecisions}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// attributes
${shaderData.attributes}

// codes
${shaderData.codes}

void main() {

	// vars
	${shaderData.vars}

	// transforms
	${shaderData.transforms}

	// flow
	${shaderData.flow}

	gl_PointSize = 1.0;

}
`;
  }
  /**
   * Returns a GLSL fragment shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getGLSLFragmentCode(shaderData) {
    return `#version 300 es

${this.getSignature()}

// extensions
${shaderData.extensions}

// precision
${defaultPrecisions}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// codes
${shaderData.codes}

// structs
${shaderData.structs}

void main() {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  /**
   * Controls the code build of the shader stages.
   */
  buildCode() {
    const shadersData =
      this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const shaderStage in shadersData) {
      let flow = "// code\n\n";
      flow += this.flowCode[shaderStage];
      const flowNodes = this.flowNodes[shaderStage];
      const mainNode = flowNodes[flowNodes.length - 1];
      for (const node of flowNodes) {
        const flowSlotData = this.getFlowData(
          node
          /*, shaderStage*/
        );
        const slotName = node.name;
        if (slotName) {
          if (flow.length > 0) flow += "\n";
          flow += `	// flow -> ${slotName}
	`;
        }
        flow += `${flowSlotData.code}
	`;
        if (node === mainNode && shaderStage !== "compute") {
          flow += "// result\n	";
          if (shaderStage === "vertex") {
            flow += "gl_Position = ";
            flow += `${flowSlotData.result};`;
          } else if (shaderStage === "fragment") {
            if (!node.outputNode.isOutputStructNode) {
              flow += "fragColor = ";
              flow += `${flowSlotData.result};`;
            }
          }
        }
      }
      const stageData = shadersData[shaderStage];
      stageData.extensions = this.getExtensions(shaderStage);
      stageData.uniforms = this.getUniforms(shaderStage);
      stageData.attributes = this.getAttributes(shaderStage);
      stageData.varyings = this.getVaryings(shaderStage);
      stageData.vars = this.getVars(shaderStage);
      stageData.structs = this.getStructs(shaderStage);
      stageData.codes = this.getCodes(shaderStage);
      stageData.transforms = this.getTransforms(shaderStage);
      stageData.flow = flow;
    }
    if (this.material !== null) {
      this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);
      this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);
    } else {
      this.computeShader = this._getGLSLVertexCode(shadersData.compute);
    }
  }
  /**
   * This method is one of the more important ones since it's responsible
   * for generating a matching binding instance for the given uniform node.
   *
   * These bindings are later used in the renderer to create bind groups
   * and layouts.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The node data type.
   * @param {string} shaderStage - The shader stage.
   * @param {?string} [name=null] - An optional uniform name.
   * @return {NodeUniform} The node uniform object.
   */
  getUniformFromNode(node, type, shaderStage, name = null) {
    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    let uniformGPU = nodeData.uniformGPU;
    if (uniformGPU === void 0) {
      const group = node.groupNode;
      const groupName = group.name;
      const bindings = this.getBindGroupArray(groupName, shaderStage);
      if (type === "texture") {
        uniformGPU = new NodeSampledTexture(
          uniformNode.name,
          uniformNode.node,
          group
        );
        bindings.push(uniformGPU);
      } else if (type === "cubeTexture") {
        uniformGPU = new NodeSampledCubeTexture(
          uniformNode.name,
          uniformNode.node,
          group
        );
        bindings.push(uniformGPU);
      } else if (type === "texture3D") {
        uniformGPU = new NodeSampledTexture3D(
          uniformNode.name,
          uniformNode.node,
          group
        );
        bindings.push(uniformGPU);
      } else if (type === "buffer") {
        node.name = `NodeBuffer_${node.id}`;
        uniformNode.name = `buffer${node.id}`;
        const buffer2 = new NodeUniformBuffer(node, group);
        buffer2.name = node.name;
        bindings.push(buffer2);
        uniformGPU = buffer2;
      } else {
        const uniformsStage =
          this.uniformGroups[shaderStage] ||
          (this.uniformGroups[shaderStage] = {});
        let uniformsGroup = uniformsStage[groupName];
        if (uniformsGroup === void 0) {
          uniformsGroup = new NodeUniformsGroup(
            shaderStage + "_" + groupName,
            group
          );
          uniformsStage[groupName] = uniformsGroup;
          bindings.push(uniformsGroup);
        }
        uniformGPU = this.getNodeUniform(uniformNode, type);
        uniformsGroup.addUniform(uniformGPU);
      }
      nodeData.uniformGPU = uniformGPU;
    }
    return uniformNode;
  }
}
let _vector2 = null;
let _color4 = null;
class Backend {
  /**
   * Constructs a new backend.
   *
   * @param {Object} parameters - An object holding parameters for the backend.
   */
  constructor(parameters = {}) {
    this.parameters = Object.assign({}, parameters);
    this.data = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.domElement = null;
    this.timestampQueryPool = {
      render: null,
      compute: null,
    };
    this.trackTimestamp = parameters.trackTimestamp === true;
  }
  /**
   * Initializes the backend so it is ready for usage. Concrete backends
   * are supposed to implement their rendering context creation and related
   * operations in this method.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the backend has been initialized.
   */
  async init(renderer2) {
    this.renderer = renderer2;
  }
  /**
   * The coordinate system of the backend.
   *
   * @abstract
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {}
  // render context
  /**
   * This method is executed at the beginning of a render call and
   * can be used by the backend to prepare the state for upcoming
   * draw calls.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender() {}
  /**
   * This method is executed at the end of a render call and
   * can be used by the backend to finalize work after draw
   * calls.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender() {}
  /**
   * This method is executed at the beginning of a compute call and
   * can be used by the backend to prepare the state for upcoming
   * compute tasks.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute() {}
  /**
   * This method is executed at the end of a compute call and
   * can be used by the backend to finalize work after compute
   * tasks.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute() {}
  // render object
  /**
   * Executes a draw command for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw() {}
  // compute node
  /**
   * Executes a compute command for the given compute node.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   */
  compute() {}
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @abstract
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram() {}
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @abstract
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram() {}
  // bindings
  /**
   * Creates bindings from the given bind group definition.
   *
   * @abstract
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings() {}
  /**
   * Updates the given bind group definition.
   *
   * @abstract
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings() {}
  /**
   * Updates a buffer binding.
   *
   * @abstract
   * @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding() {}
  // pipeline
  /**
   * Creates a render pipeline for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline() {}
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @abstract
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline() {}
  // cache key
  /**
   * Returns `true` if the render pipeline requires an update.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate() {}
  /**
   * Returns a cache key that is used to identify render pipelines.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey() {}
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {NodeBuilder} The node builder.
   */
  createNodeBuilder() {}
  // textures
  /**
   * Creates a GPU sampler for the given texture.
   *
   * @abstract
   * @param {Texture} texture - The texture to create the sampler for.
   */
  createSampler() {}
  /**
   * Destroys the GPU sampler for the given texture.
   *
   * @abstract
   * @param {Texture} texture - The texture to destroy the sampler for.
   */
  destroySampler() {}
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @abstract
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture() {}
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture() {}
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture() {}
  /**
   * Generates mipmaps for the given texture.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   */
  generateMipmaps() {}
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   */
  destroyTexture() {}
  /**
   * Returns texture data as a typed array.
   *
   * @abstract
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer() {}
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @abstract
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture() {}
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @abstract
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture() {}
  // attributes
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute() {}
  /**
   * Creates the GPU buffer of an indexed shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute() {}
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute() {}
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute() {}
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute() {}
  // canvas
  /**
   * Returns the backend's rendering context.
   *
   * @abstract
   * @return {Object} The rendering context.
   */
  getContext() {}
  /**
   * Backends can use this method if they have to run
   * logic when the renderer gets resized.
   *
   * @abstract
   */
  updateSize() {}
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport() {}
  // utils
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene. Backends must implement this method by using
   * a Occlusion Query API.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded() {}
  /**
   * Resolves the time stamp for the given render context and type.
   *
   * @async
   * @abstract
   * @param {string} [type='render'] - The type of the time stamp.
   * @return {Promise<number>} A Promise that resolves with the time stamp.
   */
  async resolveTimestampsAsync(type = "render") {
    if (!this.trackTimestamp) {
      warnOnce("WebGPURenderer: Timestamp tracking is disabled.");
      return;
    }
    const queryPool = this.timestampQueryPool[type];
    if (!queryPool) {
      warnOnce(
        `WebGPURenderer: No timestamp query pool for type '${type}' found.`
      );
      return;
    }
    const duration = await queryPool.resolveQueriesAsync();
    this.renderer.info[type].timestamp = duration;
    return duration;
  }
  /**
   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
   * the CPU waits for the GPU to complete its operation (e.g. a compute task).
   *
   * @async
   * @abstract
   * @return {Promise} A Promise that resolves when synchronization has been finished.
   */
  async waitForGPU() {}
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync() {}
  /**
   * Checks if the given feature is supported by the backend.
   *
   * @async
   * @abstract
   * @param {string} name - The feature's name.
   * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
   */
  async hasFeatureAsync() {}
  /**
   * Checks if the given feature is supported  by the backend.
   *
   * @abstract
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature() {}
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @abstract
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {}
  /**
   * Returns the drawing buffer size.
   *
   * @return {Vector2} The drawing buffer size.
   */
  getDrawingBufferSize() {
    _vector2 = _vector2 || new Vector2();
    return this.renderer.getDrawingBufferSize(_vector2);
  }
  /**
   * Defines the scissor test.
   *
   * @abstract
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest() {}
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const renderer2 = this.renderer;
    _color4 = _color4 || new Color4();
    renderer2.getClearColor(_color4);
    _color4.getRGB(_color4);
    return _color4;
  }
  /**
   * Returns the DOM element. If no DOM element exists, the backend
   * creates a new one.
   *
   * @return {HTMLCanvasElement} The DOM element.
   */
  getDomElement() {
    let domElement = this.domElement;
    if (domElement === null) {
      domElement =
        this.parameters.canvas !== void 0
          ? this.parameters.canvas
          : createCanvasElement();
      if ("setAttribute" in domElement)
        domElement.setAttribute("data-engine", `three.js r${REVISION} webgpu`);
      this.domElement = domElement;
    }
    return domElement;
  }
  /**
   * Sets a dictionary for the given object into the
   * internal data structure.
   *
   * @param {Object} object - The object.
   * @param {Object} value - The dictionary to set.
   */
  set(object, value) {
    this.data.set(object, value);
  }
  /**
   * Returns the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {Object} The object's dictionary.
   */
  get(object) {
    let map = this.data.get(object);
    if (map === void 0) {
      map = {};
      this.data.set(object, map);
    }
    return map;
  }
  /**
   * Checks if the given object has a dictionary
   * with data defined.
   *
   * @param {Object} object - The object.
   * @return {boolean} Whether a dictionary for the given object as been defined or not.
   */
  has(object) {
    return this.data.has(object);
  }
  /**
   * Deletes an object from the internal data structure.
   *
   * @param {Object} object - The object to delete.
   */
  delete(object) {
    this.data.delete(object);
  }
  /**
   * Frees internal resources.
   *
   * @abstract
   */
  dispose() {}
}
let _id$1 = 0;
class DualAttributeData {
  constructor(attributeData, dualBuffer) {
    this.buffers = [attributeData.bufferGPU, dualBuffer];
    this.type = attributeData.type;
    this.bufferType = attributeData.bufferType;
    this.pbo = attributeData.pbo;
    this.byteLength = attributeData.byteLength;
    this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;
    this.version = attributeData.version;
    this.isInteger = attributeData.isInteger;
    this.activeBufferIndex = 0;
    this.baseId = attributeData.id;
  }
  get id() {
    return `${this.baseId}|${this.activeBufferIndex}`;
  }
  get bufferGPU() {
    return this.buffers[this.activeBufferIndex];
  }
  get transformBuffer() {
    return this.buffers[this.activeBufferIndex ^ 1];
  }
  switchBuffers() {
    this.activeBufferIndex ^= 1;
  }
}
class WebGLAttributeUtils {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
  }
  /**
   * Creates the GPU buffer for the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.
   */
  createAttribute(attribute2, bufferType) {
    const backend = this.backend;
    const { gl } = backend;
    const array2 = attribute2.array;
    const usage = attribute2.usage || gl.STATIC_DRAW;
    const bufferAttribute2 = attribute2.isInterleavedBufferAttribute
      ? attribute2.data
      : attribute2;
    const bufferData = backend.get(bufferAttribute2);
    let bufferGPU = bufferData.bufferGPU;
    if (bufferGPU === void 0) {
      bufferGPU = this._createBuffer(gl, bufferType, array2, usage);
      bufferData.bufferGPU = bufferGPU;
      bufferData.bufferType = bufferType;
      bufferData.version = bufferAttribute2.version;
    }
    let type;
    if (array2 instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (
      typeof Float16Array !== "undefined" &&
      array2 instanceof Float16Array
    ) {
      type = gl.HALF_FLOAT;
    } else if (array2 instanceof Uint16Array) {
      if (attribute2.isFloat16BufferAttribute) {
        type = gl.HALF_FLOAT;
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array2 instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array2 instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array2 instanceof Int32Array) {
      type = gl.INT;
    } else if (array2 instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array2 instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array2 instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error(
        "THREE.WebGLBackend: Unsupported buffer data format: " + array2
      );
    }
    let attributeData = {
      bufferGPU,
      bufferType,
      type,
      byteLength: array2.byteLength,
      bytesPerElement: array2.BYTES_PER_ELEMENT,
      version: attribute2.version,
      pbo: attribute2.pbo,
      isInteger:
        type === gl.INT ||
        type === gl.UNSIGNED_INT ||
        attribute2.gpuType === IntType,
      id: _id$1++,
    };
    if (
      attribute2.isStorageBufferAttribute ||
      attribute2.isStorageInstancedBufferAttribute
    ) {
      const bufferGPUDual = this._createBuffer(gl, bufferType, array2, usage);
      attributeData = new DualAttributeData(attributeData, bufferGPUDual);
    }
    backend.set(attribute2, attributeData);
  }
  /**
   * Updates the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  updateAttribute(attribute2) {
    const backend = this.backend;
    const { gl } = backend;
    const array2 = attribute2.array;
    const bufferAttribute2 = attribute2.isInterleavedBufferAttribute
      ? attribute2.data
      : attribute2;
    const bufferData = backend.get(bufferAttribute2);
    const bufferType = bufferData.bufferType;
    const updateRanges = attribute2.isInterleavedBufferAttribute
      ? attribute2.data.updateRanges
      : attribute2.updateRanges;
    gl.bindBuffer(bufferType, bufferData.bufferGPU);
    if (updateRanges.length === 0) {
      gl.bufferSubData(bufferType, 0, array2);
    } else {
      for (let i2 = 0, l2 = updateRanges.length; i2 < l2; i2++) {
        const range2 = updateRanges[i2];
        gl.bufferSubData(
          bufferType,
          range2.start * array2.BYTES_PER_ELEMENT,
          array2,
          range2.start,
          range2.count
        );
      }
      bufferAttribute2.clearUpdateRanges();
    }
    gl.bindBuffer(bufferType, null);
    bufferData.version = bufferAttribute2.version;
  }
  /**
   * Destroys the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  destroyAttribute(attribute2) {
    const backend = this.backend;
    const { gl } = backend;
    if (attribute2.isInterleavedBufferAttribute) {
      backend.delete(attribute2.data);
    }
    const attributeData = backend.get(attribute2);
    gl.deleteBuffer(attributeData.bufferGPU);
    backend.delete(attribute2);
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute2) {
    const backend = this.backend;
    const { gl } = backend;
    const bufferAttribute2 = attribute2.isInterleavedBufferAttribute
      ? attribute2.data
      : attribute2;
    const { bufferGPU } = backend.get(bufferAttribute2);
    const array2 = attribute2.array;
    const byteLength = array2.byteLength;
    gl.bindBuffer(gl.COPY_READ_BUFFER, bufferGPU);
    const writeBuffer = gl.createBuffer();
    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);
    gl.bufferData(gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ);
    gl.copyBufferSubData(
      gl.COPY_READ_BUFFER,
      gl.COPY_WRITE_BUFFER,
      0,
      0,
      byteLength
    );
    await backend.utils._clientWaitAsync();
    const dstBuffer = new attribute2.array.constructor(array2.length);
    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);
    gl.getBufferSubData(gl.COPY_WRITE_BUFFER, 0, dstBuffer);
    gl.deleteBuffer(writeBuffer);
    gl.bindBuffer(gl.COPY_READ_BUFFER, null);
    gl.bindBuffer(gl.COPY_WRITE_BUFFER, null);
    return dstBuffer.buffer;
  }
  /**
   * Creates a WebGL buffer with the given data.
   *
   * @private
   * @param {WebGL2RenderingContext} gl - The rendering context.
   * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.
   * @param {TypedArray} array - The array of the buffer attribute.
   * @param {GLenum} usage - The usage.
   * @return {WebGLBuffer} The WebGL buffer.
   */
  _createBuffer(gl, bufferType, array2, usage) {
    const bufferGPU = gl.createBuffer();
    gl.bindBuffer(bufferType, bufferGPU);
    gl.bufferData(bufferType, array2, usage);
    gl.bindBuffer(bufferType, null);
    return bufferGPU;
  }
}
let equationToGL, factorToGL;
class WebGLState {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.enabled = {};
    this.currentFlipSided = null;
    this.currentCullFace = null;
    this.currentProgram = null;
    this.currentBlendingEnabled = false;
    this.currentBlending = null;
    this.currentBlendSrc = null;
    this.currentBlendDst = null;
    this.currentBlendSrcAlpha = null;
    this.currentBlendDstAlpha = null;
    this.currentPremultipledAlpha = null;
    this.currentPolygonOffsetFactor = null;
    this.currentPolygonOffsetUnits = null;
    this.currentColorMask = null;
    this.currentDepthFunc = null;
    this.currentDepthMask = null;
    this.currentStencilFunc = null;
    this.currentStencilRef = null;
    this.currentStencilFuncMask = null;
    this.currentStencilFail = null;
    this.currentStencilZFail = null;
    this.currentStencilZPass = null;
    this.currentStencilMask = null;
    this.currentLineWidth = null;
    this.currentClippingPlanes = 0;
    this.currentVAO = null;
    this.currentIndex = null;
    this.currentBoundFramebuffers = {};
    this.currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
    this.currentTextureSlot = null;
    this.currentBoundTextures = {};
    this.currentBoundBufferBases = {};
    this._init();
  }
  /**
   * Inits the state of the utility.
   *
   * @private
   */
  _init() {
    const gl = this.gl;
    equationToGL = {
      [AddEquation]: gl.FUNC_ADD,
      [SubtractEquation]: gl.FUNC_SUBTRACT,
      [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT,
    };
    factorToGL = {
      [ZeroFactor]: gl.ZERO,
      [OneFactor]: gl.ONE,
      [SrcColorFactor]: gl.SRC_COLOR,
      [SrcAlphaFactor]: gl.SRC_ALPHA,
      [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
      [DstColorFactor]: gl.DST_COLOR,
      [DstAlphaFactor]: gl.DST_ALPHA,
      [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
      [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
      [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
      [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA,
    };
    const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
    const viewportParam = gl.getParameter(gl.VIEWPORT);
    this.currentScissor = new Vector4().fromArray(scissorParam);
    this.currentViewport = new Vector4().fromArray(viewportParam);
    this._tempVec4 = new Vector4();
  }
  /**
   * Enables the given WebGL capability.
   *
   * This method caches the capability state so
   * `gl.enable()` is only called when necessary.
   *
   * @param {GLenum} id - The capability to enable.
   */
  enable(id) {
    const { enabled } = this;
    if (enabled[id] !== true) {
      this.gl.enable(id);
      enabled[id] = true;
    }
  }
  /**
   * Disables the given WebGL capability.
   *
   * This method caches the capability state so
   * `gl.disable()` is only called when necessary.
   *
   * @param {GLenum} id - The capability to enable.
   */
  disable(id) {
    const { enabled } = this;
    if (enabled[id] !== false) {
      this.gl.disable(id);
      enabled[id] = false;
    }
  }
  /**
   * Specifies whether polygons are front- or back-facing
   * by setting the winding orientation.
   *
   * This method caches the state so `gl.frontFace()` is only
   * called when necessary.
   *
   * @param {boolean} flipSided - Whether triangles flipped their sides or not.
   */
  setFlipSided(flipSided) {
    if (this.currentFlipSided !== flipSided) {
      const { gl } = this;
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      this.currentFlipSided = flipSided;
    }
  }
  /**
   * Specifies whether or not front- and/or back-facing
   * polygons can be culled.
   *
   * This method caches the state so `gl.cullFace()` is only
   * called when necessary.
   *
   * @param {number} cullFace - Defines which polygons are candidates for culling.
   */
  setCullFace(cullFace) {
    const { gl } = this;
    if (cullFace !== CullFaceNone) {
      this.enable(gl.CULL_FACE);
      if (cullFace !== this.currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      this.disable(gl.CULL_FACE);
    }
    this.currentCullFace = cullFace;
  }
  /**
   * Specifies the width of line primitives.
   *
   * This method caches the state so `gl.lineWidth()` is only
   * called when necessary.
   *
   * @param {number} width - The line width.
   */
  setLineWidth(width) {
    const { currentLineWidth, gl } = this;
    if (width !== currentLineWidth) {
      gl.lineWidth(width);
      this.currentLineWidth = width;
    }
  }
  /**
   * Defines the blending.
   *
   * This method caches the state so `gl.blendEquation()`, `gl.blendEquationSeparate()`,
   * `gl.blendFunc()` and  `gl.blendFuncSeparate()` are only called when necessary.
   *
   * @param {number} blending - The blending type.
   * @param {number} blendEquation - The blending equation.
   * @param {number} blendSrc - Only relevant for custom blending. The RGB source blending factor.
   * @param {number} blendDst - Only relevant for custom blending. The RGB destination blending factor.
   * @param {number} blendEquationAlpha - Only relevant for custom blending. The blending equation for alpha.
   * @param {number} blendSrcAlpha - Only relevant for custom blending. The alpha source blending factor.
   * @param {number} blendDstAlpha - Only relevant for custom blending. The alpha destination blending factor.
   * @param {boolean} premultipliedAlpha - Whether premultiplied alpha is enabled or not.
   */
  setBlending(
    blending,
    blendEquation,
    blendSrc,
    blendDst,
    blendEquationAlpha,
    blendSrcAlpha,
    blendDstAlpha,
    premultipliedAlpha
  ) {
    const { gl } = this;
    if (blending === NoBlending) {
      if (this.currentBlendingEnabled === true) {
        this.disable(gl.BLEND);
        this.currentBlendingEnabled = false;
      }
      return;
    }
    if (this.currentBlendingEnabled === false) {
      this.enable(gl.BLEND);
      this.currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (
        blending !== this.currentBlending ||
        premultipliedAlpha !== this.currentPremultipledAlpha
      ) {
        if (
          this.currentBlendEquation !== AddEquation ||
          this.currentBlendEquationAlpha !== AddEquation
        ) {
          gl.blendEquation(gl.FUNC_ADD);
          this.currentBlendEquation = AddEquation;
          this.currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(
                gl.ONE,
                gl.ONE_MINUS_SRC_ALPHA,
                gl.ONE,
                gl.ONE_MINUS_SRC_ALPHA
              );
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(
                gl.ZERO,
                gl.ONE_MINUS_SRC_COLOR,
                gl.ZERO,
                gl.ONE
              );
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(
                gl.DST_COLOR,
                gl.ONE_MINUS_SRC_ALPHA,
                gl.ZERO,
                gl.ONE
              );
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(
                gl.SRC_ALPHA,
                gl.ONE_MINUS_SRC_ALPHA,
                gl.ONE,
                gl.ONE_MINUS_SRC_ALPHA
              );
              break;
            case AdditiveBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              console.error(
                "THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true"
              );
              break;
            case MultiplyBlending:
              console.error(
                "THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true"
              );
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        this.currentBlendSrc = null;
        this.currentBlendDst = null;
        this.currentBlendSrcAlpha = null;
        this.currentBlendDstAlpha = null;
        this.currentBlending = blending;
        this.currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (
      blendEquation !== this.currentBlendEquation ||
      blendEquationAlpha !== this.currentBlendEquationAlpha
    ) {
      gl.blendEquationSeparate(
        equationToGL[blendEquation],
        equationToGL[blendEquationAlpha]
      );
      this.currentBlendEquation = blendEquation;
      this.currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (
      blendSrc !== this.currentBlendSrc ||
      blendDst !== this.currentBlendDst ||
      blendSrcAlpha !== this.currentBlendSrcAlpha ||
      blendDstAlpha !== this.currentBlendDstAlpha
    ) {
      gl.blendFuncSeparate(
        factorToGL[blendSrc],
        factorToGL[blendDst],
        factorToGL[blendSrcAlpha],
        factorToGL[blendDstAlpha]
      );
      this.currentBlendSrc = blendSrc;
      this.currentBlendDst = blendDst;
      this.currentBlendSrcAlpha = blendSrcAlpha;
      this.currentBlendDstAlpha = blendDstAlpha;
    }
    this.currentBlending = blending;
    this.currentPremultipledAlpha = false;
  }
  /**
   * Specifies whether colors can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.colorMask()` is only
   * called when necessary.
   *
   * @param {boolean} colorMask - The color mask.
   */
  setColorMask(colorMask) {
    if (this.currentColorMask !== colorMask) {
      this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
      this.currentColorMask = colorMask;
    }
  }
  /**
   * Specifies whether the depth test is enabled or not.
   *
   * @param {boolean} depthTest - Whether the depth test is enabled or not.
   */
  setDepthTest(depthTest) {
    const { gl } = this;
    if (depthTest) {
      this.enable(gl.DEPTH_TEST);
    } else {
      this.disable(gl.DEPTH_TEST);
    }
  }
  /**
   * Specifies whether depth values can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.depthMask()` is only
   * called when necessary.
   *
   * @param {boolean} depthMask - The depth mask.
   */
  setDepthMask(depthMask) {
    if (this.currentDepthMask !== depthMask) {
      this.gl.depthMask(depthMask);
      this.currentDepthMask = depthMask;
    }
  }
  /**
   * Specifies the depth compare function.
   *
   * This method caches the state so `gl.depthFunc()` is only
   * called when necessary.
   *
   * @param {number} depthFunc - The depth compare function.
   */
  setDepthFunc(depthFunc) {
    if (this.currentDepthFunc !== depthFunc) {
      const { gl } = this;
      switch (depthFunc) {
        case NeverDepth:
          gl.depthFunc(gl.NEVER);
          break;
        case AlwaysDepth:
          gl.depthFunc(gl.ALWAYS);
          break;
        case LessDepth:
          gl.depthFunc(gl.LESS);
          break;
        case LessEqualDepth:
          gl.depthFunc(gl.LEQUAL);
          break;
        case EqualDepth:
          gl.depthFunc(gl.EQUAL);
          break;
        case GreaterEqualDepth:
          gl.depthFunc(gl.GEQUAL);
          break;
        case GreaterDepth:
          gl.depthFunc(gl.GREATER);
          break;
        case NotEqualDepth:
          gl.depthFunc(gl.NOTEQUAL);
          break;
        default:
          gl.depthFunc(gl.LEQUAL);
      }
      this.currentDepthFunc = depthFunc;
    }
  }
  /**
   * Specifies the scissor box.
   *
   * @param {number} x - The x-coordinate of the lower left corner of the viewport.
   * @param {number} y - The y-coordinate of the lower left corner of the viewport.
   * @param {number} width - The width of the viewport.
   * @param {number} height - The height of the viewport.
   *
   */
  scissor(x, y, width, height) {
    const scissor = this._tempVec4.set(x, y, width, height);
    if (this.currentScissor.equals(scissor) === false) {
      const { gl } = this;
      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
      this.currentScissor.copy(scissor);
    }
  }
  /**
   * Specifies the viewport.
   *
   * @param {number} x - The x-coordinate of the lower left corner of the viewport.
   * @param {number} y - The y-coordinate of the lower left corner of the viewport.
   * @param {number} width - The width of the viewport.
   * @param {number} height - The height of the viewport.
   *
   */
  viewport(x, y, width, height) {
    const viewport2 = this._tempVec4.set(x, y, width, height);
    if (this.currentViewport.equals(viewport2) === false) {
      const { gl } = this;
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      this.currentViewport.copy(viewport2);
    }
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(boolean) {
    const gl = this.gl;
    if (boolean) {
      gl.enable(gl.SCISSOR_TEST);
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  }
  /**
   * Specifies whether the stencil test is enabled or not.
   *
   * @param {boolean} stencilTest - Whether the stencil test is enabled or not.
   */
  setStencilTest(stencilTest) {
    const { gl } = this;
    if (stencilTest) {
      this.enable(gl.STENCIL_TEST);
    } else {
      this.disable(gl.STENCIL_TEST);
    }
  }
  /**
   * Specifies whether stencil values can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.stencilMask()` is only
   * called when necessary.
   *
   * @param {boolean} stencilMask - The stencil mask.
   */
  setStencilMask(stencilMask) {
    if (this.currentStencilMask !== stencilMask) {
      this.gl.stencilMask(stencilMask);
      this.currentStencilMask = stencilMask;
    }
  }
  /**
   * Specifies whether the stencil test functions.
   *
   * This method caches the state so `gl.stencilFunc()` is only
   * called when necessary.
   *
   * @param {number} stencilFunc - The stencil compare function.
   * @param {number} stencilRef - The reference value for the stencil test.
   * @param {number} stencilMask - A bit-wise mask that is used to AND the reference value and the stored stencil value when the test is done.
   */
  setStencilFunc(stencilFunc, stencilRef, stencilMask) {
    if (
      this.currentStencilFunc !== stencilFunc ||
      this.currentStencilRef !== stencilRef ||
      this.currentStencilFuncMask !== stencilMask
    ) {
      this.gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
      this.currentStencilFunc = stencilFunc;
      this.currentStencilRef = stencilRef;
      this.currentStencilFuncMask = stencilMask;
    }
  }
  /**
   * Specifies whether the stencil test operation.
   *
   * This method caches the state so `gl.stencilOp()` is only
   * called when necessary.
   *
   * @param {number} stencilFail - The function to use when the stencil test fails.
   * @param {number} stencilZFail - The function to use when the stencil test passes, but the depth test fail.
   * @param {number} stencilZPass - The function to use when both the stencil test and the depth test pass,
   * or when the stencil test passes and there is no depth buffer or depth testing is disabled.
   */
  setStencilOp(stencilFail, stencilZFail, stencilZPass) {
    if (
      this.currentStencilFail !== stencilFail ||
      this.currentStencilZFail !== stencilZFail ||
      this.currentStencilZPass !== stencilZPass
    ) {
      this.gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
      this.currentStencilFail = stencilFail;
      this.currentStencilZFail = stencilZFail;
      this.currentStencilZPass = stencilZPass;
    }
  }
  /**
   * Configures the WebGL state for the given material.
   *
   * @param {Material} material - The material to configure the state for.
   * @param {number} frontFaceCW - Whether the front faces are counter-clockwise or not.
   * @param {number} hardwareClippingPlanes - The number of hardware clipping planes.
   */
  setMaterial(material, frontFaceCW, hardwareClippingPlanes) {
    const { gl } = this;
    material.side === DoubleSide
      ? this.disable(gl.CULL_FACE)
      : this.enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    this.setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false
      ? this.setBlending(NoBlending)
      : this.setBlending(
          material.blending,
          material.blendEquation,
          material.blendSrc,
          material.blendDst,
          material.blendEquationAlpha,
          material.blendSrcAlpha,
          material.blendDstAlpha,
          material.premultipliedAlpha
        );
    this.setDepthFunc(material.depthFunc);
    this.setDepthTest(material.depthTest);
    this.setDepthMask(material.depthWrite);
    this.setColorMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    this.setStencilTest(stencilWrite);
    if (stencilWrite) {
      this.setStencilMask(material.stencilWriteMask);
      this.setStencilFunc(
        material.stencilFunc,
        material.stencilRef,
        material.stencilFuncMask
      );
      this.setStencilOp(
        material.stencilFail,
        material.stencilZFail,
        material.stencilZPass
      );
    }
    this.setPolygonOffset(
      material.polygonOffset,
      material.polygonOffsetFactor,
      material.polygonOffsetUnits
    );
    material.alphaToCoverage === true && this.backend.renderer.samples > 1
      ? this.enable(gl.SAMPLE_ALPHA_TO_COVERAGE)
      : this.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    if (hardwareClippingPlanes > 0) {
      if (this.currentClippingPlanes !== hardwareClippingPlanes) {
        const CLIP_DISTANCE0_WEBGL = 12288;
        for (let i2 = 0; i2 < 8; i2++) {
          if (i2 < hardwareClippingPlanes) {
            this.enable(CLIP_DISTANCE0_WEBGL + i2);
          } else {
            this.disable(CLIP_DISTANCE0_WEBGL + i2);
          }
        }
      }
    }
  }
  /**
   * Specifies the polygon offset.
   *
   * This method caches the state so `gl.polygonOffset()` is only
   * called when necessary.
   *
   * @param {boolean} polygonOffset - Whether polygon offset is enabled or not.
   * @param {number} factor - The scale factor for the variable depth offset for each polygon.
   * @param {number} units - The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset.
   */
  setPolygonOffset(polygonOffset, factor, units) {
    const { gl } = this;
    if (polygonOffset) {
      this.enable(gl.POLYGON_OFFSET_FILL);
      if (
        this.currentPolygonOffsetFactor !== factor ||
        this.currentPolygonOffsetUnits !== units
      ) {
        gl.polygonOffset(factor, units);
        this.currentPolygonOffsetFactor = factor;
        this.currentPolygonOffsetUnits = units;
      }
    } else {
      this.disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  /**
   * Defines the usage of the given WebGL program.
   *
   * This method caches the state so `gl.useProgram()` is only
   * called when necessary.
   *
   * @param {WebGLProgram} program - The WebGL program to use.
   * @return {boolean} Whether a program change has been executed or not.
   */
  useProgram(program2) {
    if (this.currentProgram !== program2) {
      this.gl.useProgram(program2);
      this.currentProgram = program2;
      return true;
    }
    return false;
  }
  /**
   * Sets the vertex state by binding the given VAO and element buffer.
   *
   * @param {WebGLVertexArrayObject} vao - The VAO.
   * @param {WebGLBuffer} indexBuffer - The index buffer.
   * @return {boolean} Whether a vertex state has been changed or not.
   */
  setVertexState(vao, indexBuffer = null) {
    const gl = this.gl;
    if (this.currentVAO !== vao || this.currentIndex !== indexBuffer) {
      gl.bindVertexArray(vao);
      if (indexBuffer !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      }
      this.currentVAO = vao;
      this.currentIndex = indexBuffer;
      return true;
    }
    return false;
  }
  /**
   * Resets the vertex array state by resetting the VAO and element buffer.
   */
  resetVertexState() {
    const gl = this.gl;
    gl.bindVertexArray(null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    this.currentVAO = null;
    this.currentIndex = null;
  }
  // framebuffer
  /**
   * Binds the given framebuffer.
   *
   * This method caches the state so `gl.bindFramebuffer()` is only
   * called when necessary.
   *
   * @param {number} target - The binding point (target).
   * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer to bind.
   * @return {boolean} Whether a bind has been executed or not.
   */
  bindFramebuffer(target, framebuffer) {
    const { gl, currentBoundFramebuffers } = this;
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (target === gl.DRAW_FRAMEBUFFER) {
        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
      }
      if (target === gl.FRAMEBUFFER) {
        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
      }
      return true;
    }
    return false;
  }
  /**
   * Defines draw buffers to which fragment colors are written into.
   * Configures the MRT setup of custom framebuffers.
   *
   * This method caches the state so `gl.drawBuffers()` is only
   * called when necessary.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer.
   */
  drawBuffers(renderContext, framebuffer) {
    const { gl } = this;
    let drawBuffers = [];
    let needsUpdate = false;
    if (renderContext.textures !== null) {
      drawBuffers = this.currentDrawbuffers.get(framebuffer);
      if (drawBuffers === void 0) {
        drawBuffers = [];
        this.currentDrawbuffers.set(framebuffer, drawBuffers);
      }
      const textures = renderContext.textures;
      if (
        drawBuffers.length !== textures.length ||
        drawBuffers[0] !== gl.COLOR_ATTACHMENT0
      ) {
        for (let i2 = 0, il = textures.length; i2 < il; i2++) {
          drawBuffers[i2] = gl.COLOR_ATTACHMENT0 + i2;
        }
        drawBuffers.length = textures.length;
        needsUpdate = true;
      }
    } else {
      if (drawBuffers[0] !== gl.BACK) {
        drawBuffers[0] = gl.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      gl.drawBuffers(drawBuffers);
    }
  }
  // texture
  /**
   * Makes the given texture unit active.
   *
   * This method caches the state so `gl.activeTexture()` is only
   * called when necessary.
   *
   * @param {number} webglSlot - The texture unit to make active.
   */
  activeTexture(webglSlot) {
    const { gl, currentTextureSlot, maxTextures } = this;
    if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      this.currentTextureSlot = webglSlot;
    }
  }
  /**
   * Binds the given WebGL texture to a target.
   *
   * This method caches the state so `gl.bindTexture()` is only
   * called when necessary.
   *
   * @param {number} webglType - The binding point (target).
   * @param {WebGLTexture} webglTexture - The WebGL texture to bind.
   * @param {number} webglSlot - The texture.
   */
  bindTexture(webglType, webglTexture, webglSlot) {
    const { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;
    if (webglSlot === void 0) {
      if (currentTextureSlot === null) {
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (
      boundTexture.type !== webglType ||
      boundTexture.texture !== webglTexture
    ) {
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        this.currentTextureSlot = webglSlot;
      }
      gl.bindTexture(webglType, webglTexture);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  /**
   * Binds a given WebGL buffer to a given binding point (target) at a given index.
   *
   * This method caches the state so `gl.bindBufferBase()` is only
   * called when necessary.
   *
   * @param {number} target - The target for the bind operation.
   * @param {number} index - The index of the target.
   * @param {WebGLBuffer} buffer - The WebGL buffer.
   * @return {boolean} Whether a bind has been executed or not.
   */
  bindBufferBase(target, index, buffer2) {
    const { gl } = this;
    const key = `${target}-${index}`;
    if (this.currentBoundBufferBases[key] !== buffer2) {
      gl.bindBufferBase(target, index, buffer2);
      this.currentBoundBufferBases[key] = buffer2;
      return true;
    }
    return false;
  }
  /**
   * Unbinds the current bound texture.
   *
   * This method caches the state so `gl.bindTexture()` is only
   * called when necessary.
   */
  unbindTexture() {
    const { gl, currentTextureSlot, currentBoundTextures } = this;
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
}
class WebGLUtils {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.extensions = backend.extensions;
  }
  /**
   * Converts the given three.js constant into a WebGL constant.
   * The method currently supports the conversion of texture formats
   * and types.
   *
   * @param {number} p - The three.js constant.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   * @return {?number} The corresponding WebGL constant.
   */
  convert(p2, colorSpace = NoColorSpace) {
    const { gl, extensions } = this;
    let extension;
    const transfer = ColorManagement.getTransfer(colorSpace);
    if (p2 === UnsignedByteType) return gl.UNSIGNED_BYTE;
    if (p2 === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p2 === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p2 === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
    if (p2 === ByteType) return gl.BYTE;
    if (p2 === ShortType) return gl.SHORT;
    if (p2 === UnsignedShortType) return gl.UNSIGNED_SHORT;
    if (p2 === IntType) return gl.INT;
    if (p2 === UnsignedIntType) return gl.UNSIGNED_INT;
    if (p2 === FloatType) return gl.FLOAT;
    if (p2 === HalfFloatType) {
      return gl.HALF_FLOAT;
    }
    if (p2 === AlphaFormat) return gl.ALPHA;
    if (p2 === RGBFormat) return gl.RGB;
    if (p2 === RGBAFormat) return gl.RGBA;
    if (p2 === DepthFormat) return gl.DEPTH_COMPONENT;
    if (p2 === DepthStencilFormat) return gl.DEPTH_STENCIL;
    if (p2 === RedFormat) return gl.RED;
    if (p2 === RedIntegerFormat) return gl.RED_INTEGER;
    if (p2 === RGFormat) return gl.RG;
    if (p2 === RGIntegerFormat) return gl.RG_INTEGER;
    if (p2 === RGBAIntegerFormat) return gl.RGBA_INTEGER;
    if (
      p2 === RGB_S3TC_DXT1_Format ||
      p2 === RGBA_S3TC_DXT1_Format ||
      p2 === RGBA_S3TC_DXT3_Format ||
      p2 === RGBA_S3TC_DXT5_Format
    ) {
      if (transfer === SRGBTransfer) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p2 === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p2 === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p2 === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p2 === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (
      p2 === RGB_PVRTC_4BPPV1_Format ||
      p2 === RGB_PVRTC_2BPPV1_Format ||
      p2 === RGBA_PVRTC_4BPPV1_Format ||
      p2 === RGBA_PVRTC_2BPPV1_Format
    ) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p2 === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p2 === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p2 === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p2 === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (
      p2 === RGB_ETC1_Format ||
      p2 === RGB_ETC2_Format ||
      p2 === RGBA_ETC2_EAC_Format
    ) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p2 === RGB_ETC1_Format || p2 === RGB_ETC2_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ETC2
            : extension.COMPRESSED_RGB8_ETC2;
        if (p2 === RGBA_ETC2_EAC_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (
      p2 === RGBA_ASTC_4x4_Format ||
      p2 === RGBA_ASTC_5x4_Format ||
      p2 === RGBA_ASTC_5x5_Format ||
      p2 === RGBA_ASTC_6x5_Format ||
      p2 === RGBA_ASTC_6x6_Format ||
      p2 === RGBA_ASTC_8x5_Format ||
      p2 === RGBA_ASTC_8x6_Format ||
      p2 === RGBA_ASTC_8x8_Format ||
      p2 === RGBA_ASTC_10x5_Format ||
      p2 === RGBA_ASTC_10x6_Format ||
      p2 === RGBA_ASTC_10x8_Format ||
      p2 === RGBA_ASTC_10x10_Format ||
      p2 === RGBA_ASTC_12x10_Format ||
      p2 === RGBA_ASTC_12x12_Format
    ) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p2 === RGBA_ASTC_4x4_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p2 === RGBA_ASTC_5x4_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p2 === RGBA_ASTC_5x5_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p2 === RGBA_ASTC_6x5_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p2 === RGBA_ASTC_6x6_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p2 === RGBA_ASTC_8x5_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p2 === RGBA_ASTC_8x6_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p2 === RGBA_ASTC_8x8_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p2 === RGBA_ASTC_10x5_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p2 === RGBA_ASTC_10x6_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p2 === RGBA_ASTC_10x8_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p2 === RGBA_ASTC_10x10_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p2 === RGBA_ASTC_12x10_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p2 === RGBA_ASTC_12x12_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p2 === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p2 === RGBA_BPTC_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else {
        return null;
      }
    }
    if (
      p2 === RED_RGTC1_Format ||
      p2 === SIGNED_RED_RGTC1_Format ||
      p2 === RED_GREEN_RGTC2_Format ||
      p2 === SIGNED_RED_GREEN_RGTC2_Format
    ) {
      extension = extensions.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p2 === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p2 === SIGNED_RED_RGTC1_Format)
          return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p2 === RED_GREEN_RGTC2_Format)
          return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p2 === SIGNED_RED_GREEN_RGTC2_Format)
          return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p2 === UnsignedInt248Type) {
      return gl.UNSIGNED_INT_24_8;
    }
    return gl[p2] !== void 0 ? gl[p2] : null;
  }
  /**
   * This method can be used to synchronize the CPU with the GPU by waiting until
   * ongoing GPU commands have been completed.
   *
   * @private
   * @return {Promise} A promise that resolves when all ongoing GPU commands have been completed.
   */
  _clientWaitAsync() {
    const { gl } = this;
    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
    gl.flush();
    return new Promise((resolve, reject) => {
      function test() {
        const res = gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0);
        if (res === gl.WAIT_FAILED) {
          gl.deleteSync(sync);
          reject();
          return;
        }
        if (res === gl.TIMEOUT_EXPIRED) {
          requestAnimationFrame(test);
          return;
        }
        gl.deleteSync(sync);
        resolve();
      }
      test();
    });
  }
}
let initialized = false,
  wrappingToGL,
  filterToGL,
  compareToGL;
class WebGLTextureUtils {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.gl = backend.gl;
    this.extensions = backend.extensions;
    this.defaultTextures = {};
    if (initialized === false) {
      this._init();
      initialized = true;
    }
  }
  /**
   * Inits the state of the utility.
   *
   * @private
   */
  _init() {
    const gl = this.gl;
    wrappingToGL = {
      [RepeatWrapping]: gl.REPEAT,
      [ClampToEdgeWrapping]: gl.CLAMP_TO_EDGE,
      [MirroredRepeatWrapping]: gl.MIRRORED_REPEAT,
    };
    filterToGL = {
      [NearestFilter]: gl.NEAREST,
      [NearestMipmapNearestFilter]: gl.NEAREST_MIPMAP_NEAREST,
      [NearestMipmapLinearFilter]: gl.NEAREST_MIPMAP_LINEAR,
      [LinearFilter]: gl.LINEAR,
      [LinearMipmapNearestFilter]: gl.LINEAR_MIPMAP_NEAREST,
      [LinearMipmapLinearFilter]: gl.LINEAR_MIPMAP_LINEAR,
    };
    compareToGL = {
      [NeverCompare]: gl.NEVER,
      [AlwaysCompare]: gl.ALWAYS,
      [LessCompare]: gl.LESS,
      [LessEqualCompare]: gl.LEQUAL,
      [EqualCompare]: gl.EQUAL,
      [GreaterEqualCompare]: gl.GEQUAL,
      [GreaterCompare]: gl.GREATER,
      [NotEqualCompare]: gl.NOTEQUAL,
    };
  }
  /**
   * Returns the native texture type for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {GLenum} The native texture type.
   */
  getGLTextureType(texture2) {
    const { gl } = this;
    let glTextureType;
    if (texture2.isCubeTexture === true) {
      glTextureType = gl.TEXTURE_CUBE_MAP;
    } else if (
      texture2.isArrayTexture === true ||
      texture2.isDataArrayTexture === true ||
      texture2.isCompressedArrayTexture === true
    ) {
      glTextureType = gl.TEXTURE_2D_ARRAY;
    } else if (texture2.isData3DTexture === true) {
      glTextureType = gl.TEXTURE_3D;
    } else {
      glTextureType = gl.TEXTURE_2D;
    }
    return glTextureType;
  }
  /**
   * Returns the native texture type for the given texture.
   *
   * @param {?string} internalFormatName - The internal format name. When `null`, the internal format is derived from the subsequent parameters.
   * @param {GLenum} glFormat - The WebGL format.
   * @param {GLenum} glType - The WebGL type.
   * @param {string} colorSpace - The texture's color space.
   * @param {boolean} [forceLinearTransfer=false] - Whether to force a linear transfer or not.
   * @return {GLenum} The internal format.
   */
  getInternalFormat(
    internalFormatName,
    glFormat,
    glType,
    colorSpace,
    forceLinearTransfer = false
  ) {
    const { gl, extensions } = this;
    if (internalFormatName !== null) {
      if (gl[internalFormatName] !== void 0) return gl[internalFormatName];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          internalFormatName +
          "'"
      );
    }
    let internalFormat = glFormat;
    if (glFormat === gl.RED) {
      if (glType === gl.FLOAT) internalFormat = gl.R32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.R16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;
      if (glType === gl.BYTE) internalFormat = gl.R8I;
      if (glType === gl.SHORT) internalFormat = gl.R16I;
      if (glType === gl.INT) internalFormat = gl.R32I;
    }
    if (glFormat === gl.RED_INTEGER) {
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8UI;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16UI;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;
      if (glType === gl.BYTE) internalFormat = gl.R8I;
      if (glType === gl.SHORT) internalFormat = gl.R16I;
      if (glType === gl.INT) internalFormat = gl.R32I;
    }
    if (glFormat === gl.RG) {
      if (glType === gl.FLOAT) internalFormat = gl.RG32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.RG16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;
      if (glType === gl.BYTE) internalFormat = gl.RG8I;
      if (glType === gl.SHORT) internalFormat = gl.RG16I;
      if (glType === gl.INT) internalFormat = gl.RG32I;
    }
    if (glFormat === gl.RG_INTEGER) {
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8UI;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16UI;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;
      if (glType === gl.BYTE) internalFormat = gl.RG8I;
      if (glType === gl.SHORT) internalFormat = gl.RG16I;
      if (glType === gl.INT) internalFormat = gl.RG32I;
    }
    if (glFormat === gl.RGB) {
      const transfer = forceLinearTransfer
        ? LinearTransfer
        : ColorManagement.getTransfer(colorSpace);
      if (glType === gl.FLOAT) internalFormat = gl.RGB32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.RGB16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;
      if (glType === gl.BYTE) internalFormat = gl.RGB8I;
      if (glType === gl.SHORT) internalFormat = gl.RGB16I;
      if (glType === gl.INT) internalFormat = gl.RGB32I;
      if (glType === gl.UNSIGNED_BYTE)
        internalFormat = transfer === SRGBTransfer ? gl.SRGB8 : gl.RGB8;
      if (glType === gl.UNSIGNED_SHORT_5_6_5) internalFormat = gl.RGB565;
      if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;
      if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGB4;
      if (glType === gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = gl.RGB9_E5;
    }
    if (glFormat === gl.RGB_INTEGER) {
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8UI;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16UI;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;
      if (glType === gl.BYTE) internalFormat = gl.RGB8I;
      if (glType === gl.SHORT) internalFormat = gl.RGB16I;
      if (glType === gl.INT) internalFormat = gl.RGB32I;
    }
    if (glFormat === gl.RGBA) {
      const transfer = forceLinearTransfer
        ? LinearTransfer
        : ColorManagement.getTransfer(colorSpace);
      if (glType === gl.FLOAT) internalFormat = gl.RGBA32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.RGBA16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;
      if (glType === gl.BYTE) internalFormat = gl.RGBA8I;
      if (glType === gl.SHORT) internalFormat = gl.RGBA16I;
      if (glType === gl.INT) internalFormat = gl.RGBA32I;
      if (glType === gl.UNSIGNED_BYTE)
        internalFormat = transfer === SRGBTransfer ? gl.SRGB8_ALPHA8 : gl.RGBA8;
      if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGBA4;
      if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;
    }
    if (glFormat === gl.RGBA_INTEGER) {
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8UI;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16UI;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;
      if (glType === gl.BYTE) internalFormat = gl.RGBA8I;
      if (glType === gl.SHORT) internalFormat = gl.RGBA16I;
      if (glType === gl.INT) internalFormat = gl.RGBA32I;
    }
    if (glFormat === gl.DEPTH_COMPONENT) {
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.DEPTH_COMPONENT16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.DEPTH_COMPONENT24;
      if (glType === gl.FLOAT) internalFormat = gl.DEPTH_COMPONENT32F;
    }
    if (glFormat === gl.DEPTH_STENCIL) {
      if (glType === gl.UNSIGNED_INT_24_8) internalFormat = gl.DEPTH24_STENCIL8;
    }
    if (
      internalFormat === gl.R16F ||
      internalFormat === gl.R32F ||
      internalFormat === gl.RG16F ||
      internalFormat === gl.RG32F ||
      internalFormat === gl.RGBA16F ||
      internalFormat === gl.RGBA32F
    ) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  /**
   * Sets the texture parameters for the given texture.
   *
   * @param {GLenum} textureType - The texture type.
   * @param {Texture} texture - The texture.
   */
  setTextureParameters(textureType, texture2) {
    const { gl, extensions, backend } = this;
    const workingPrimaries = ColorManagement.getPrimaries(
      ColorManagement.workingColorSpace
    );
    const texturePrimaries =
      texture2.colorSpace === NoColorSpace
        ? null
        : ColorManagement.getPrimaries(texture2.colorSpace);
    const unpackConversion =
      texture2.colorSpace === NoColorSpace ||
      workingPrimaries === texturePrimaries
        ? gl.NONE
        : gl.BROWSER_DEFAULT_WEBGL;
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture2.flipY);
    gl.pixelStorei(
      gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
      texture2.premultiplyAlpha
    );
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, texture2.unpackAlignment);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
    gl.texParameteri(
      textureType,
      gl.TEXTURE_WRAP_S,
      wrappingToGL[texture2.wrapS]
    );
    gl.texParameteri(
      textureType,
      gl.TEXTURE_WRAP_T,
      wrappingToGL[texture2.wrapT]
    );
    if (textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY) {
      if (!texture2.isArrayTexture) {
        gl.texParameteri(
          textureType,
          gl.TEXTURE_WRAP_R,
          wrappingToGL[texture2.wrapR]
        );
      }
    }
    gl.texParameteri(
      textureType,
      gl.TEXTURE_MAG_FILTER,
      filterToGL[texture2.magFilter]
    );
    const hasMipmaps =
      texture2.mipmaps !== void 0 && texture2.mipmaps.length > 0;
    const minFilter =
      texture2.minFilter === LinearFilter && hasMipmaps
        ? LinearMipmapLinearFilter
        : texture2.minFilter;
    gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, filterToGL[minFilter]);
    if (texture2.compareFunction) {
      gl.texParameteri(
        textureType,
        gl.TEXTURE_COMPARE_MODE,
        gl.COMPARE_REF_TO_TEXTURE
      );
      gl.texParameteri(
        textureType,
        gl.TEXTURE_COMPARE_FUNC,
        compareToGL[texture2.compareFunction]
      );
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      if (texture2.magFilter === NearestFilter) return;
      if (
        texture2.minFilter !== NearestMipmapLinearFilter &&
        texture2.minFilter !== LinearMipmapLinearFilter
      )
        return;
      if (
        texture2.type === FloatType &&
        extensions.has("OES_texture_float_linear") === false
      )
        return;
      if (texture2.anisotropy > 1) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        gl.texParameterf(
          textureType,
          extension.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(texture2.anisotropy, backend.getMaxAnisotropy())
        );
      }
    }
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(texture2) {
    const { gl, backend, defaultTextures } = this;
    const glTextureType = this.getGLTextureType(texture2);
    let textureGPU = defaultTextures[glTextureType];
    if (textureGPU === void 0) {
      textureGPU = gl.createTexture();
      backend.state.bindTexture(glTextureType, textureGPU);
      gl.texParameteri(glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      defaultTextures[glTextureType] = textureGPU;
    }
    backend.set(texture2, {
      textureGPU,
      glTextureType,
      isDefault: true,
    });
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   * @return {undefined}
   */
  createTexture(texture2, options) {
    const { gl, backend } = this;
    const { levels, width, height, depth: depth2 } = options;
    const glFormat = backend.utils.convert(
      texture2.format,
      texture2.colorSpace
    );
    const glType = backend.utils.convert(texture2.type);
    const glInternalFormat = this.getInternalFormat(
      texture2.internalFormat,
      glFormat,
      glType,
      texture2.colorSpace,
      texture2.isVideoTexture
    );
    const textureGPU = gl.createTexture();
    const glTextureType = this.getGLTextureType(texture2);
    backend.state.bindTexture(glTextureType, textureGPU);
    this.setTextureParameters(glTextureType, texture2);
    if (
      texture2.isArrayTexture ||
      texture2.isDataArrayTexture ||
      texture2.isCompressedArrayTexture
    ) {
      gl.texStorage3D(
        gl.TEXTURE_2D_ARRAY,
        levels,
        glInternalFormat,
        width,
        height,
        depth2
      );
    } else if (texture2.isData3DTexture) {
      gl.texStorage3D(
        gl.TEXTURE_3D,
        levels,
        glInternalFormat,
        width,
        height,
        depth2
      );
    } else if (!texture2.isVideoTexture) {
      gl.texStorage2D(glTextureType, levels, glInternalFormat, width, height);
    }
    backend.set(texture2, {
      textureGPU,
      glTextureType,
      glFormat,
      glType,
      glInternalFormat,
    });
  }
  /**
   * Uploads texture buffer data to the GPU memory.
   *
   * @param {WebGLBuffer} buffer - The buffer data.
   * @param {Texture} texture - The texture,
   */
  copyBufferToTexture(buffer2, texture2) {
    const { gl, backend } = this;
    const { textureGPU, glTextureType, glFormat, glType } =
      backend.get(texture2);
    const { width, height } = texture2.source.data;
    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, buffer2);
    backend.state.bindTexture(glTextureType, textureGPU);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.texSubImage2D(
      glTextureType,
      0,
      0,
      0,
      width,
      height,
      glFormat,
      glType,
      0
    );
    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);
    backend.state.unbindTexture();
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(texture2, options) {
    const { gl } = this;
    const { width, height } = options;
    const { textureGPU, glTextureType, glFormat, glType, glInternalFormat } =
      this.backend.get(texture2);
    if (texture2.isRenderTargetTexture || textureGPU === void 0) return;
    this.backend.state.bindTexture(glTextureType, textureGPU);
    this.setTextureParameters(glTextureType, texture2);
    if (texture2.isCompressedTexture) {
      const mipmaps = texture2.mipmaps;
      const image = options.image;
      for (let i2 = 0; i2 < mipmaps.length; i2++) {
        const mipmap = mipmaps[i2];
        if (texture2.isCompressedArrayTexture) {
          if (texture2.format !== gl.RGBA) {
            if (glFormat !== null) {
              gl.compressedTexSubImage3D(
                gl.TEXTURE_2D_ARRAY,
                i2,
                0,
                0,
                0,
                mipmap.width,
                mipmap.height,
                image.depth,
                glFormat,
                mipmap.data
              );
            } else {
              console.warn(
                "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
              );
            }
          } else {
            gl.texSubImage3D(
              gl.TEXTURE_2D_ARRAY,
              i2,
              0,
              0,
              0,
              mipmap.width,
              mipmap.height,
              image.depth,
              glFormat,
              glType,
              mipmap.data
            );
          }
        } else {
          if (glFormat !== null) {
            gl.compressedTexSubImage2D(
              gl.TEXTURE_2D,
              i2,
              0,
              0,
              mipmap.width,
              mipmap.height,
              glFormat,
              mipmap.data
            );
          } else {
            console.warn("Unsupported compressed texture format");
          }
        }
      }
    } else if (texture2.isCubeTexture) {
      const images = options.images;
      for (let i2 = 0; i2 < 6; i2++) {
        const image = getImage(images[i2]);
        gl.texSubImage2D(
          gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2,
          0,
          0,
          0,
          width,
          height,
          glFormat,
          glType,
          image
        );
      }
    } else if (texture2.isDataArrayTexture || texture2.isArrayTexture) {
      const image = options.image;
      gl.texSubImage3D(
        gl.TEXTURE_2D_ARRAY,
        0,
        0,
        0,
        0,
        image.width,
        image.height,
        image.depth,
        glFormat,
        glType,
        image.data
      );
    } else if (texture2.isData3DTexture) {
      const image = options.image;
      gl.texSubImage3D(
        gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        image.width,
        image.height,
        image.depth,
        glFormat,
        glType,
        image.data
      );
    } else if (texture2.isVideoTexture) {
      texture2.update();
      gl.texImage2D(
        glTextureType,
        0,
        glInternalFormat,
        glFormat,
        glType,
        options.image
      );
    } else {
      const image = getImage(options.image);
      gl.texSubImage2D(
        glTextureType,
        0,
        0,
        0,
        width,
        height,
        glFormat,
        glType,
        image
      );
    }
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(texture2) {
    const { gl, backend } = this;
    const { textureGPU, glTextureType } = backend.get(texture2);
    backend.state.bindTexture(glTextureType, textureGPU);
    gl.generateMipmap(glTextureType);
  }
  /**
   * Deallocates the render buffers of the given render target.
   *
   * @param {RenderTarget} renderTarget - The render target.
   */
  deallocateRenderBuffers(renderTarget) {
    const { gl, backend } = this;
    if (renderTarget) {
      const renderContextData = backend.get(renderTarget);
      renderContextData.renderBufferStorageSetup = void 0;
      if (renderContextData.framebuffers) {
        for (const cacheKey in renderContextData.framebuffers) {
          gl.deleteFramebuffer(renderContextData.framebuffers[cacheKey]);
        }
        delete renderContextData.framebuffers;
      }
      if (renderContextData.depthRenderbuffer) {
        gl.deleteRenderbuffer(renderContextData.depthRenderbuffer);
        delete renderContextData.depthRenderbuffer;
      }
      if (renderContextData.stencilRenderbuffer) {
        gl.deleteRenderbuffer(renderContextData.stencilRenderbuffer);
        delete renderContextData.stencilRenderbuffer;
      }
      if (renderContextData.msaaFrameBuffer) {
        gl.deleteFramebuffer(renderContextData.msaaFrameBuffer);
        delete renderContextData.msaaFrameBuffer;
      }
      if (renderContextData.msaaRenderbuffers) {
        for (
          let i2 = 0;
          i2 < renderContextData.msaaRenderbuffers.length;
          i2++
        ) {
          gl.deleteRenderbuffer(renderContextData.msaaRenderbuffers[i2]);
        }
        delete renderContextData.msaaRenderbuffers;
      }
    }
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   */
  destroyTexture(texture2) {
    const { gl, backend } = this;
    const { textureGPU, renderTarget } = backend.get(texture2);
    this.deallocateRenderBuffers(renderTarget);
    gl.deleteTexture(textureGPU);
    backend.delete(texture2);
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(
    srcTexture,
    dstTexture,
    srcRegion = null,
    dstPosition = null,
    srcLevel = 0,
    dstLevel = 0
  ) {
    const { gl, backend } = this;
    const { state } = this.backend;
    const {
      textureGPU: dstTextureGPU,
      glTextureType,
      glType,
      glFormat,
    } = backend.get(dstTexture);
    state.bindTexture(glTextureType, dstTextureGPU);
    let width, height, depth2, minX, minY, minZ;
    let dstX, dstY, dstZ;
    const image = srcTexture.isCompressedTexture
      ? srcTexture.mipmaps[dstLevel]
      : srcTexture.image;
    if (srcRegion !== null) {
      width = srcRegion.max.x - srcRegion.min.x;
      height = srcRegion.max.y - srcRegion.min.y;
      depth2 = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
      minX = srcRegion.min.x;
      minY = srcRegion.min.y;
      minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;
    } else {
      const levelScale = Math.pow(2, -srcLevel);
      width = Math.floor(image.width * levelScale);
      height = Math.floor(image.height * levelScale);
      if (srcTexture.isDataArrayTexture || srcTexture.isArrayTexture) {
        depth2 = image.depth;
      } else if (srcTexture.isData3DTexture) {
        depth2 = Math.floor(image.depth * levelScale);
      } else {
        depth2 = 1;
      }
      minX = 0;
      minY = 0;
      minZ = 0;
    }
    if (dstPosition !== null) {
      dstX = dstPosition.x;
      dstY = dstPosition.y;
      dstZ = dstPosition.z;
    } else {
      dstX = 0;
      dstY = 0;
      dstZ = 0;
    }
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
    gl.pixelStorei(
      gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
      dstTexture.premultiplyAlpha
    );
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
    const currentUnpackRowLen = gl.getParameter(gl.UNPACK_ROW_LENGTH);
    const currentUnpackImageHeight = gl.getParameter(gl.UNPACK_IMAGE_HEIGHT);
    const currentUnpackSkipPixels = gl.getParameter(gl.UNPACK_SKIP_PIXELS);
    const currentUnpackSkipRows = gl.getParameter(gl.UNPACK_SKIP_ROWS);
    const currentUnpackSkipImages = gl.getParameter(gl.UNPACK_SKIP_IMAGES);
    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, image.width);
    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, image.height);
    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, minX);
    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, minY);
    gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, minZ);
    const isDst3D =
      dstTexture.isDataArrayTexture ||
      dstTexture.isData3DTexture ||
      dstTexture.isArrayTexture;
    if (srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture) {
      const srcTextureData = backend.get(srcTexture);
      const dstTextureData = backend.get(dstTexture);
      const srcRenderContextData = backend.get(srcTextureData.renderTarget);
      const dstRenderContextData = backend.get(dstTextureData.renderTarget);
      const srcFramebuffer =
        srcRenderContextData.framebuffers[srcTextureData.cacheKey];
      const dstFramebuffer =
        dstRenderContextData.framebuffers[dstTextureData.cacheKey];
      state.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFramebuffer);
      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFramebuffer);
      let mask = gl.COLOR_BUFFER_BIT;
      if (srcTexture.isDepthTexture) mask = gl.DEPTH_BUFFER_BIT;
      gl.blitFramebuffer(
        minX,
        minY,
        width,
        height,
        dstX,
        dstY,
        width,
        height,
        mask,
        gl.NEAREST
      );
      state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    } else {
      if (isDst3D) {
        if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
          gl.texSubImage3D(
            glTextureType,
            dstLevel,
            dstX,
            dstY,
            dstZ,
            width,
            height,
            depth2,
            glFormat,
            glType,
            image.data
          );
        } else if (dstTexture.isCompressedArrayTexture) {
          gl.compressedTexSubImage3D(
            glTextureType,
            dstLevel,
            dstX,
            dstY,
            dstZ,
            width,
            height,
            depth2,
            glFormat,
            image.data
          );
        } else {
          gl.texSubImage3D(
            glTextureType,
            dstLevel,
            dstX,
            dstY,
            dstZ,
            width,
            height,
            depth2,
            glFormat,
            glType,
            image
          );
        }
      } else {
        if (srcTexture.isDataTexture) {
          gl.texSubImage2D(
            glTextureType,
            dstLevel,
            dstX,
            dstY,
            width,
            height,
            glFormat,
            glType,
            image.data
          );
        } else if (srcTexture.isCompressedTexture) {
          gl.compressedTexSubImage2D(
            glTextureType,
            dstLevel,
            dstX,
            dstY,
            image.width,
            image.height,
            glFormat,
            image.data
          );
        } else {
          gl.texSubImage2D(
            glTextureType,
            dstLevel,
            dstX,
            dstY,
            width,
            height,
            glFormat,
            glType,
            image
          );
        }
      }
    }
    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
    gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
    if (dstLevel === 0 && dstTexture.generateMipmaps) {
      gl.generateMipmap(glTextureType);
    }
    state.unbindTexture();
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(texture2, renderContext, rectangle) {
    const { gl } = this;
    const { state } = this.backend;
    const { textureGPU } = this.backend.get(texture2);
    const { x, y, z: width, w: height } = rectangle;
    const requireDrawFrameBuffer =
      texture2.isDepthTexture === true ||
      (renderContext.renderTarget && renderContext.renderTarget.samples > 0);
    const srcHeight = renderContext.renderTarget
      ? renderContext.renderTarget.height
      : this.backend.getDrawingBufferSize().y;
    if (requireDrawFrameBuffer) {
      const partial = x !== 0 || y !== 0;
      let mask;
      let attachment;
      if (texture2.isDepthTexture === true) {
        mask = gl.DEPTH_BUFFER_BIT;
        attachment = gl.DEPTH_ATTACHMENT;
        if (renderContext.stencil) {
          mask |= gl.STENCIL_BUFFER_BIT;
        }
      } else {
        mask = gl.COLOR_BUFFER_BIT;
        attachment = gl.COLOR_ATTACHMENT0;
      }
      if (partial) {
        const renderTargetContextData = this.backend.get(
          renderContext.renderTarget
        );
        const fb =
          renderTargetContextData.framebuffers[renderContext.getCacheKey()];
        const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
        state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);
        const flippedY = srcHeight - y - height;
        gl.blitFramebuffer(
          x,
          flippedY,
          x + width,
          flippedY + height,
          x,
          flippedY,
          x + width,
          flippedY + height,
          mask,
          gl.NEAREST
        );
        state.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);
        state.bindTexture(gl.TEXTURE_2D, textureGPU);
        gl.copyTexSubImage2D(
          gl.TEXTURE_2D,
          0,
          0,
          0,
          x,
          flippedY,
          width,
          height
        );
        state.unbindTexture();
      } else {
        const fb = gl.createFramebuffer();
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
        gl.framebufferTexture2D(
          gl.DRAW_FRAMEBUFFER,
          attachment,
          gl.TEXTURE_2D,
          textureGPU,
          0
        );
        gl.blitFramebuffer(
          0,
          0,
          width,
          height,
          0,
          0,
          width,
          height,
          mask,
          gl.NEAREST
        );
        gl.deleteFramebuffer(fb);
      }
    } else {
      state.bindTexture(gl.TEXTURE_2D, textureGPU);
      gl.copyTexSubImage2D(
        gl.TEXTURE_2D,
        0,
        0,
        0,
        x,
        srcHeight - height - y,
        width,
        height
      );
      state.unbindTexture();
    }
    if (texture2.generateMipmaps) this.generateMipmaps(texture2);
    this.backend._setFramebuffer(renderContext);
  }
  /**
   * SetupS storage for internal depth/stencil buffers and bind to correct framebuffer.
   *
   * @param {WebGLRenderbuffer} renderbuffer - The render buffer.
   * @param {RenderContext} renderContext - The render context.
   * @param {number} samples - The MSAA sample count.
   * @param {boolean} [useMultisampledRTT=false] - Whether to use WEBGL_multisampled_render_to_texture or not.
   */
  setupRenderBufferStorage(
    renderbuffer,
    renderContext,
    samples,
    useMultisampledRTT = false
  ) {
    const { gl } = this;
    const renderTarget = renderContext.renderTarget;
    const { depthTexture, depthBuffer, stencilBuffer, width, height } =
      renderTarget;
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    if (depthBuffer && !stencilBuffer) {
      let glInternalFormat = gl.DEPTH_COMPONENT24;
      if (useMultisampledRTT === true) {
        const multisampledRTTExt = this.extensions.get(
          "WEBGL_multisampled_render_to_texture"
        );
        multisampledRTTExt.renderbufferStorageMultisampleEXT(
          gl.RENDERBUFFER,
          renderTarget.samples,
          glInternalFormat,
          width,
          height
        );
      } else if (samples > 0) {
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === gl.FLOAT) {
            glInternalFormat = gl.DEPTH_COMPONENT32F;
          }
        }
        gl.renderbufferStorageMultisample(
          gl.RENDERBUFFER,
          samples,
          glInternalFormat,
          width,
          height
        );
      } else {
        gl.renderbufferStorage(
          gl.RENDERBUFFER,
          glInternalFormat,
          width,
          height
        );
      }
      gl.framebufferRenderbuffer(
        gl.FRAMEBUFFER,
        gl.DEPTH_ATTACHMENT,
        gl.RENDERBUFFER,
        renderbuffer
      );
    } else if (depthBuffer && stencilBuffer) {
      if (samples > 0) {
        gl.renderbufferStorageMultisample(
          gl.RENDERBUFFER,
          samples,
          gl.DEPTH24_STENCIL8,
          width,
          height
        );
      } else {
        gl.renderbufferStorage(
          gl.RENDERBUFFER,
          gl.DEPTH_STENCIL,
          width,
          height
        );
      }
      gl.framebufferRenderbuffer(
        gl.FRAMEBUFFER,
        gl.DEPTH_STENCIL_ATTACHMENT,
        gl.RENDERBUFFER,
        renderbuffer
      );
    }
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(texture2, x, y, width, height, faceIndex) {
    const { backend, gl } = this;
    const { textureGPU, glFormat, glType } = this.backend.get(texture2);
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);
    const target = texture2.isCubeTexture
      ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex
      : gl.TEXTURE_2D;
    gl.framebufferTexture2D(
      gl.READ_FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      target,
      textureGPU,
      0
    );
    const typedArrayType = this._getTypedArrayType(glType);
    const bytesPerTexel = this._getBytesPerTexel(glType, glFormat);
    const elementCount = width * height;
    const byteLength = elementCount * bytesPerTexel;
    const buffer2 = gl.createBuffer();
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer2);
    gl.bufferData(gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ);
    gl.readPixels(x, y, width, height, glFormat, glType, 0);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    await backend.utils._clientWaitAsync();
    const dstBuffer = new typedArrayType(
      byteLength / typedArrayType.BYTES_PER_ELEMENT
    );
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer2);
    gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dstBuffer);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    gl.deleteFramebuffer(fb);
    return dstBuffer;
  }
  /**
   * Returns the corresponding typed array type for the given WebGL data type.
   *
   * @private
   * @param {GLenum} glType - The WebGL data type.
   * @return {TypedArray.constructor} The typed array type.
   */
  _getTypedArrayType(glType) {
    const { gl } = this;
    if (glType === gl.UNSIGNED_BYTE) return Uint8Array;
    if (glType === gl.UNSIGNED_SHORT_4_4_4_4) return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT_5_5_5_1) return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT_5_6_5) return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT) return Uint16Array;
    if (glType === gl.UNSIGNED_INT) return Uint32Array;
    if (glType === gl.HALF_FLOAT) return Uint16Array;
    if (glType === gl.FLOAT) return Float32Array;
    throw new Error(`Unsupported WebGL type: ${glType}`);
  }
  /**
   * Returns the bytes-per-texel value for the given WebGL data type and texture format.
   *
   * @private
   * @param {GLenum} glType - The WebGL data type.
   * @param {GLenum} glFormat - The WebGL texture format.
   * @return {number} The bytes-per-texel.
   */
  _getBytesPerTexel(glType, glFormat) {
    const { gl } = this;
    let bytesPerComponent = 0;
    if (glType === gl.UNSIGNED_BYTE) bytesPerComponent = 1;
    if (
      glType === gl.UNSIGNED_SHORT_4_4_4_4 ||
      glType === gl.UNSIGNED_SHORT_5_5_5_1 ||
      glType === gl.UNSIGNED_SHORT_5_6_5 ||
      glType === gl.UNSIGNED_SHORT ||
      glType === gl.HALF_FLOAT
    )
      bytesPerComponent = 2;
    if (glType === gl.UNSIGNED_INT || glType === gl.FLOAT)
      bytesPerComponent = 4;
    if (glFormat === gl.RGBA) return bytesPerComponent * 4;
    if (glFormat === gl.RGB) return bytesPerComponent * 3;
    if (glFormat === gl.ALPHA) return bytesPerComponent;
  }
}
function getImage(source) {
  if (source.isDataTexture) {
    return source.image.data;
  } else if (
    (typeof HTMLImageElement !== "undefined" &&
      source instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement !== "undefined" &&
      source instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap !== "undefined" && source instanceof ImageBitmap) ||
    (typeof OffscreenCanvas !== "undefined" &&
      source instanceof OffscreenCanvas)
  ) {
    return source;
  }
  return source.data;
}
class WebGLExtensions {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.availableExtensions = this.gl.getSupportedExtensions();
    this.extensions = {};
  }
  /**
   * Returns the extension object for the given extension name.
   *
   * @param {string} name - The extension name.
   * @return {Object} The extension object.
   */
  get(name) {
    let extension = this.extensions[name];
    if (extension === void 0) {
      extension = this.gl.getExtension(name);
      this.extensions[name] = extension;
    }
    return extension;
  }
  /**
   * Returns `true` if the requested extension is available.
   *
   * @param {string} name - The extension name.
   * @return {boolean} Whether the given extension is available or not.
   */
  has(name) {
    return this.availableExtensions.includes(name);
  }
}
class WebGLCapabilities {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.maxAnisotropy = null;
  }
  /**
   * Returns the maximum anisotropy texture filtering value. This value
   * depends on the device and is reported by the `EXT_texture_filter_anisotropic`
   * WebGL extension.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    if (this.maxAnisotropy !== null) return this.maxAnisotropy;
    const gl = this.backend.gl;
    const extensions = this.backend.extensions;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      this.maxAnisotropy = gl.getParameter(
        extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT
      );
    } else {
      this.maxAnisotropy = 0;
    }
    return this.maxAnisotropy;
  }
}
const GLFeatureName = {
  WEBGL_multi_draw: "WEBGL_multi_draw",
  WEBGL_compressed_texture_astc: "texture-compression-astc",
  WEBGL_compressed_texture_etc: "texture-compression-etc2",
  WEBGL_compressed_texture_etc1: "texture-compression-etc1",
  WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
  WEBKIT_WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
  WEBGL_compressed_texture_s3tc: "texture-compression-bc",
  EXT_texture_compression_bptc: "texture-compression-bptc",
  EXT_disjoint_timer_query_webgl2: "timestamp-query",
  OVR_multiview2: "OVR_multiview2",
};
class WebGLBufferRenderer {
  constructor(backend) {
    this.gl = backend.gl;
    this.extensions = backend.extensions;
    this.info = backend.renderer.info;
    this.mode = null;
    this.index = 0;
    this.type = null;
    this.object = null;
  }
  render(start, count) {
    const { gl, mode, object, type, info, index } = this;
    if (index !== 0) {
      gl.drawElements(mode, count, type, start);
    } else {
      gl.drawArrays(mode, start, count);
    }
    info.update(object, count, 1);
  }
  renderInstances(start, count, primcount) {
    const { gl, mode, type, index, object, info } = this;
    if (primcount === 0) return;
    if (index !== 0) {
      gl.drawElementsInstanced(mode, count, type, start, primcount);
    } else {
      gl.drawArraysInstanced(mode, start, count, primcount);
    }
    info.update(object, count, primcount);
  }
  renderMultiDraw(starts, counts, drawCount) {
    const { extensions, mode, object, info } = this;
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i2 = 0; i2 < drawCount; i2++) {
        this.render(starts[i2], counts[i2]);
      }
    } else {
      if (this.index !== 0) {
        extension.multiDrawElementsWEBGL(
          mode,
          counts,
          0,
          this.type,
          starts,
          0,
          drawCount
        );
      } else {
        extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
      }
      let elementCount = 0;
      for (let i2 = 0; i2 < drawCount; i2++) {
        elementCount += counts[i2];
      }
      info.update(object, elementCount, 1);
    }
  }
  renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    const { extensions, mode, object, info } = this;
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i2 = 0; i2 < drawCount; i2++) {
        this.renderInstances(starts[i2], counts[i2], primcount[i2]);
      }
    } else {
      if (this.index !== 0) {
        extension.multiDrawElementsInstancedWEBGL(
          mode,
          counts,
          0,
          this.type,
          starts,
          0,
          primcount,
          0,
          drawCount
        );
      } else {
        extension.multiDrawArraysInstancedWEBGL(
          mode,
          starts,
          0,
          counts,
          0,
          primcount,
          0,
          drawCount
        );
      }
      let elementCount = 0;
      for (let i2 = 0; i2 < drawCount; i2++) {
        elementCount += counts[i2] * primcount[i2];
      }
      info.update(object, elementCount, 1);
    }
  }
  //
}
class TimestampQueryPool {
  /**
   * Creates a new timestamp query pool.
   *
   * @param {number} [maxQueries=256] - Maximum number of queries this pool can hold.
   */
  constructor(maxQueries = 256) {
    this.trackTimestamp = true;
    this.maxQueries = maxQueries;
    this.currentQueryIndex = 0;
    this.queryOffsets = /* @__PURE__ */ new Map();
    this.isDisposed = false;
    this.lastValue = 0;
    this.pendingResolve = false;
  }
  /**
   * Allocate queries for a specific renderContext.
   *
   * @abstract
   * @param {Object} renderContext - The render context to allocate queries for.
   * @returns {?number}
   */
  allocateQueriesForContext() {}
  /**
   * Resolve all timestamps and return data (or process them).
   *
   * @abstract
   * @async
   * @returns {Promise<number>|number} The resolved timestamp value.
   */
  async resolveQueriesAsync() {}
  /**
   * Dispose of the query pool.
   *
   * @abstract
   */
  dispose() {}
}
class WebGLTimestampQueryPool extends TimestampQueryPool {
  /**
   * Creates a new WebGL timestamp query pool.
   *
   * @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context.
   * @param {string} type - The type identifier for this query pool.
   * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.
   */
  constructor(gl, type, maxQueries = 2048) {
    super(maxQueries);
    this.gl = gl;
    this.type = type;
    this.ext =
      gl.getExtension("EXT_disjoint_timer_query_webgl2") ||
      gl.getExtension("EXT_disjoint_timer_query");
    if (!this.ext) {
      console.warn(
        "EXT_disjoint_timer_query not supported; timestamps will be disabled."
      );
      this.trackTimestamp = false;
      return;
    }
    this.queries = [];
    for (let i2 = 0; i2 < this.maxQueries; i2++) {
      this.queries.push(gl.createQuery());
    }
    this.activeQuery = null;
    this.queryStates = /* @__PURE__ */ new Map();
  }
  /**
   * Allocates a pair of queries for a given render context.
   *
   * @param {Object} renderContext - The render context to allocate queries for.
   * @returns {?number} The base offset for the allocated queries, or null if allocation failed.
   */
  allocateQueriesForContext(renderContext) {
    if (!this.trackTimestamp) return null;
    if (this.currentQueryIndex + 2 > this.maxQueries) {
      warnOnce(
        `WebGPUTimestampQueryPool [${
          this.type
        }]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`
      );
      return null;
    }
    const baseOffset = this.currentQueryIndex;
    this.currentQueryIndex += 2;
    this.queryStates.set(baseOffset, "inactive");
    this.queryOffsets.set(renderContext.id, baseOffset);
    return baseOffset;
  }
  /**
   * Begins a timestamp query for the specified render context.
   *
   * @param {Object} renderContext - The render context to begin timing for.
   */
  beginQuery(renderContext) {
    if (!this.trackTimestamp || this.isDisposed) {
      return;
    }
    const baseOffset = this.queryOffsets.get(renderContext.id);
    if (baseOffset == null) {
      return;
    }
    if (this.activeQuery !== null) {
      return;
    }
    const query = this.queries[baseOffset];
    if (!query) {
      return;
    }
    try {
      if (this.queryStates.get(baseOffset) === "inactive") {
        this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, query);
        this.activeQuery = baseOffset;
        this.queryStates.set(baseOffset, "started");
      }
    } catch (error) {
      console.error("Error in beginQuery:", error);
      this.activeQuery = null;
      this.queryStates.set(baseOffset, "inactive");
    }
  }
  /**
   * Ends the active timestamp query for the specified render context.
   *
   * @param {Object} renderContext - The render context to end timing for.
   * @param {string} renderContext.id - Unique identifier for the render context.
   */
  endQuery(renderContext) {
    if (!this.trackTimestamp || this.isDisposed) {
      return;
    }
    const baseOffset = this.queryOffsets.get(renderContext.id);
    if (baseOffset == null) {
      return;
    }
    if (this.activeQuery !== baseOffset) {
      return;
    }
    try {
      this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);
      this.queryStates.set(baseOffset, "ended");
      this.activeQuery = null;
    } catch (error) {
      console.error("Error in endQuery:", error);
      this.queryStates.set(baseOffset, "inactive");
      this.activeQuery = null;
    }
  }
  /**
   * Asynchronously resolves all completed queries and returns the total duration.
   *
   * @async
   * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.
   */
  async resolveQueriesAsync() {
    if (!this.trackTimestamp || this.pendingResolve) {
      return this.lastValue;
    }
    this.pendingResolve = true;
    try {
      const resolvePromises = [];
      for (const [baseOffset, state] of this.queryStates) {
        if (state === "ended") {
          const query = this.queries[baseOffset];
          resolvePromises.push(this.resolveQuery(query));
        }
      }
      if (resolvePromises.length === 0) {
        return this.lastValue;
      }
      const results = await Promise.all(resolvePromises);
      const totalDuration = results.reduce((acc, val) => acc + val, 0);
      this.lastValue = totalDuration;
      this.currentQueryIndex = 0;
      this.queryOffsets.clear();
      this.queryStates.clear();
      this.activeQuery = null;
      return totalDuration;
    } catch (error) {
      console.error("Error resolving queries:", error);
      return this.lastValue;
    } finally {
      this.pendingResolve = false;
    }
  }
  /**
   * Resolves a single query, checking for completion and disjoint operation.
   *
   * @async
   * @param {WebGLQuery} query - The query object to resolve.
   * @returns {Promise<number>} The elapsed time in milliseconds.
   */
  async resolveQuery(query) {
    return new Promise((resolve) => {
      if (this.isDisposed) {
        resolve(this.lastValue);
        return;
      }
      let timeoutId;
      let isResolved = false;
      const cleanup = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      };
      const finalizeResolution = (value) => {
        if (!isResolved) {
          isResolved = true;
          cleanup();
          resolve(value);
        }
      };
      const checkQuery = () => {
        if (this.isDisposed) {
          finalizeResolution(this.lastValue);
          return;
        }
        try {
          const disjoint = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);
          if (disjoint) {
            finalizeResolution(this.lastValue);
            return;
          }
          const available = this.gl.getQueryParameter(
            query,
            this.gl.QUERY_RESULT_AVAILABLE
          );
          if (!available) {
            timeoutId = setTimeout(checkQuery, 1);
            return;
          }
          const elapsed = this.gl.getQueryParameter(
            query,
            this.gl.QUERY_RESULT
          );
          resolve(Number(elapsed) / 1e6);
        } catch (error) {
          console.error("Error checking query:", error);
          resolve(this.lastValue);
        }
      };
      checkQuery();
    });
  }
  /**
   * Releases all resources held by this query pool.
   * This includes deleting all query objects and clearing internal state.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.isDisposed = true;
    if (!this.trackTimestamp) return;
    for (const query of this.queries) {
      this.gl.deleteQuery(query);
    }
    this.queries = [];
    this.queryStates.clear();
    this.queryOffsets.clear();
    this.lastValue = 0;
    this.activeQuery = null;
  }
}
class WebGLBackend extends Backend {
  /**
   * WebGLBackend options.
   *
   * @typedef {Object} WebGLBackend~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {WebGL2RenderingContext} [context=undefined] - A WebGL 2 rendering context.
   */
  /**
   * Constructs a new WebGPU backend.
   *
   * @param {WebGLBackend~Options} [parameters] - The configuration parameter.
   */
  constructor(parameters = {}) {
    super(parameters);
    this.isWebGLBackend = true;
    this.attributeUtils = null;
    this.extensions = null;
    this.capabilities = null;
    this.textureUtils = null;
    this.bufferRenderer = null;
    this.gl = null;
    this.state = null;
    this.utils = null;
    this.vaoCache = {};
    this.transformFeedbackCache = {};
    this.discard = false;
    this.disjoint = null;
    this.parallel = null;
    this._currentContext = null;
    this._knownBindings = /* @__PURE__ */ new WeakSet();
    this._supportsInvalidateFramebuffer =
      typeof navigator === "undefined"
        ? false
        : /OculusBrowser/g.test(navigator.userAgent);
    this._xrFramebuffer = null;
  }
  /**
   * Initializes the backend so it is ready for usage.
   *
   * @param {Renderer} renderer - The renderer.
   */
  init(renderer2) {
    super.init(renderer2);
    const parameters = this.parameters;
    const contextAttributes = {
      antialias: renderer2.samples > 0,
      alpha: true,
      // always true for performance reasons
      depth: renderer2.depth,
      stencil: renderer2.stencil,
    };
    const glContext =
      parameters.context !== void 0
        ? parameters.context
        : renderer2.domElement.getContext("webgl2", contextAttributes);
    function onContextLost(event) {
      event.preventDefault();
      const contextLossInfo = {
        api: "WebGL",
        message: event.statusMessage || "Unknown reason",
        reason: null,
        originalEvent: event,
      };
      renderer2.onDeviceLost(contextLossInfo);
    }
    this._onContextLost = onContextLost;
    renderer2.domElement.addEventListener(
      "webglcontextlost",
      onContextLost,
      false
    );
    this.gl = glContext;
    this.extensions = new WebGLExtensions(this);
    this.capabilities = new WebGLCapabilities(this);
    this.attributeUtils = new WebGLAttributeUtils(this);
    this.textureUtils = new WebGLTextureUtils(this);
    this.bufferRenderer = new WebGLBufferRenderer(this);
    this.state = new WebGLState(this);
    this.utils = new WebGLUtils(this);
    this.extensions.get("EXT_color_buffer_float");
    this.extensions.get("WEBGL_clip_cull_distance");
    this.extensions.get("OES_texture_float_linear");
    this.extensions.get("EXT_color_buffer_half_float");
    this.extensions.get("WEBGL_multisampled_render_to_texture");
    this.extensions.get("WEBGL_render_shared_exponent");
    this.extensions.get("WEBGL_multi_draw");
    this.extensions.get("OVR_multiview2");
    this.disjoint = this.extensions.get("EXT_disjoint_timer_query_webgl2");
    this.parallel = this.extensions.get("KHR_parallel_shader_compile");
  }
  /**
   * The coordinate system of the backend.
   *
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute2) {
    return await this.attributeUtils.getArrayBufferAsync(attribute2);
  }
  /**
   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
   * the CPU waits for the GPU to complete its operation (e.g. a compute task).
   *
   * @async
   * @return {Promise} A Promise that resolves when synchronization has been finished.
   */
  async waitForGPU() {
    await this.utils._clientWaitAsync();
  }
  /**
   * Ensures the backend is XR compatible.
   *
   * @async
   * @return {Promise} A Promise that resolve when the renderer is XR compatible.
   */
  async makeXRCompatible() {
    const attributes = this.gl.getContextAttributes();
    if (attributes.xrCompatible !== true) {
      await this.gl.makeXRCompatible();
    }
  }
  /**
   * Sets the XR rendering destination.
   *
   * @param {WebGLFramebuffer} xrFramebuffer - The XR framebuffer.
   */
  setXRTarget(xrFramebuffer) {
    this._xrFramebuffer = xrFramebuffer;
  }
  /**
   * Configures the given XR render target with external textures.
   *
   * This method is only relevant when using the WebXR Layers API.
   *
   * @param {XRRenderTarget} renderTarget - The XR render target.
   * @param {WebGLTexture} colorTexture - A native color texture.
   * @param {?WebGLTexture} [depthTexture=null] - A native depth texture.
   */
  setXRRenderTargetTextures(renderTarget, colorTexture, depthTexture = null) {
    const gl = this.gl;
    this.set(renderTarget.texture, {
      textureGPU: colorTexture,
      glInternalFormat: gl.RGBA8,
    });
    if (depthTexture !== null) {
      const glInternalFormat = renderTarget.stencilBuffer
        ? gl.DEPTH24_STENCIL8
        : gl.DEPTH_COMPONENT24;
      this.set(renderTarget.depthTexture, {
        textureGPU: depthTexture,
        glInternalFormat,
      });
      if (
        this.extensions.has("WEBGL_multisampled_render_to_texture") === true &&
        renderTarget._autoAllocateDepthBuffer === true &&
        renderTarget.multiview === false
      ) {
        console.warn(
          "THREE.WebGLBackend: Render-to-texture extension was disabled because an external texture was provided"
        );
      }
      renderTarget._autoAllocateDepthBuffer = false;
    }
  }
  /**
   * Inits a time stamp query for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  initTimestampQuery(renderContext) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const type = renderContext.isComputeNode ? "compute" : "render";
    if (!this.timestampQueryPool[type]) {
      this.timestampQueryPool[type] = new WebGLTimestampQueryPool(
        this.gl,
        type,
        2048
      );
    }
    const timestampQueryPool = this.timestampQueryPool[type];
    const baseOffset =
      timestampQueryPool.allocateQueriesForContext(renderContext);
    if (baseOffset !== null) {
      timestampQueryPool.beginQuery(renderContext);
    }
  }
  // timestamp utils
  /**
   * Prepares the timestamp buffer.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  prepareTimestampBuffer(renderContext) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const type = renderContext.isComputeNode ? "compute" : "render";
    const timestampQueryPool = this.timestampQueryPool[type];
    timestampQueryPool.endQuery(renderContext);
  }
  /**
   * Returns the backend's rendering context.
   *
   * @return {WebGL2RenderingContext} The rendering context.
   */
  getContext() {
    return this.gl;
  }
  /**
   * This method is executed at the beginning of a render call and prepares
   * the WebGL state for upcoming render calls
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender(renderContext) {
    const { state } = this;
    const renderContextData = this.get(renderContext);
    if (renderContext.viewport) {
      this.updateViewport(renderContext);
    } else {
      const { width, height } = this.getDrawingBufferSize();
      state.viewport(0, 0, width, height);
    }
    if (renderContext.scissor) {
      const { x, y, width, height } = renderContext.scissorValue;
      state.scissor(x, renderContext.height - height - y, width, height);
    }
    this.initTimestampQuery(renderContext);
    renderContextData.previousContext = this._currentContext;
    this._currentContext = renderContext;
    this._setFramebuffer(renderContext);
    this.clear(
      renderContext.clearColor,
      renderContext.clearDepth,
      renderContext.clearStencil,
      renderContext,
      false
    );
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (occlusionQueryCount > 0) {
      renderContextData.currentOcclusionQueries =
        renderContextData.occlusionQueries;
      renderContextData.currentOcclusionQueryObjects =
        renderContextData.occlusionQueryObjects;
      renderContextData.lastOcclusionObject = null;
      renderContextData.occlusionQueries = new Array(occlusionQueryCount);
      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
      renderContextData.occlusionQueryIndex = 0;
    }
  }
  /**
   * This method is executed at the end of a render call and finalizes work
   * after draw calls.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender(renderContext) {
    const { gl, state } = this;
    const renderContextData = this.get(renderContext);
    const previousContext = renderContextData.previousContext;
    state.resetVertexState();
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (occlusionQueryCount > 0) {
      if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {
        gl.endQuery(gl.ANY_SAMPLES_PASSED);
      }
      this.resolveOccludedAsync(renderContext);
    }
    const textures = renderContext.textures;
    if (textures !== null) {
      for (let i2 = 0; i2 < textures.length; i2++) {
        const texture2 = textures[i2];
        if (texture2.generateMipmaps) {
          this.generateMipmaps(texture2);
        }
      }
    }
    this._currentContext = previousContext;
    const renderTarget = renderContext.renderTarget;
    if (renderContext.textures !== null && renderTarget) {
      const renderTargetContextData = this.get(renderTarget);
      if (
        renderTarget.samples > 0 &&
        this._useMultisampledExtension(renderTarget) === false
      ) {
        const fb =
          renderTargetContextData.framebuffers[renderContext.getCacheKey()];
        let mask = gl.COLOR_BUFFER_BIT;
        if (renderTarget.resolveDepthBuffer) {
          if (renderTarget.depthBuffer) mask |= gl.DEPTH_BUFFER_BIT;
          if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer)
            mask |= gl.STENCIL_BUFFER_BIT;
        }
        const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;
        const msaaRenderbuffers = renderTargetContextData.msaaRenderbuffers;
        const textures2 = renderContext.textures;
        const isMRT = textures2.length > 1;
        state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
        if (isMRT) {
          for (let i2 = 0; i2 < textures2.length; i2++) {
            gl.framebufferRenderbuffer(
              gl.READ_FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i2,
              gl.RENDERBUFFER,
              null
            );
            gl.framebufferTexture2D(
              gl.DRAW_FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i2,
              gl.TEXTURE_2D,
              null,
              0
            );
          }
        }
        for (let i2 = 0; i2 < textures2.length; i2++) {
          if (isMRT) {
            const { textureGPU } = this.get(textures2[i2]);
            gl.framebufferRenderbuffer(
              gl.READ_FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0,
              gl.RENDERBUFFER,
              msaaRenderbuffers[i2]
            );
            gl.framebufferTexture2D(
              gl.DRAW_FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0,
              gl.TEXTURE_2D,
              textureGPU,
              0
            );
          }
          if (renderContext.scissor) {
            const { x, y, width, height } = renderContext.scissorValue;
            const viewY = renderContext.height - height - y;
            gl.blitFramebuffer(
              x,
              viewY,
              x + width,
              viewY + height,
              x,
              viewY,
              x + width,
              viewY + height,
              mask,
              gl.NEAREST
            );
          } else {
            gl.blitFramebuffer(
              0,
              0,
              renderContext.width,
              renderContext.height,
              0,
              0,
              renderContext.width,
              renderContext.height,
              mask,
              gl.NEAREST
            );
          }
        }
        if (isMRT) {
          for (let i2 = 0; i2 < textures2.length; i2++) {
            const { textureGPU } = this.get(textures2[i2]);
            gl.framebufferRenderbuffer(
              gl.READ_FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i2,
              gl.RENDERBUFFER,
              msaaRenderbuffers[i2]
            );
            gl.framebufferTexture2D(
              gl.DRAW_FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i2,
              gl.TEXTURE_2D,
              textureGPU,
              0
            );
          }
        }
        if (this._supportsInvalidateFramebuffer === true) {
          gl.invalidateFramebuffer(
            gl.READ_FRAMEBUFFER,
            renderTargetContextData.invalidationArray
          );
        }
      } else if (
        renderTarget.resolveDepthBuffer === false &&
        renderTargetContextData.framebuffers
      ) {
        const fb =
          renderTargetContextData.framebuffers[renderContext.getCacheKey()];
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
        gl.invalidateFramebuffer(
          gl.DRAW_FRAMEBUFFER,
          renderTargetContextData.depthInvalidationArray
        );
      }
    }
    if (previousContext !== null) {
      this._setFramebuffer(previousContext);
      if (previousContext.viewport) {
        this.updateViewport(previousContext);
      } else {
        const { width, height } = this.getDrawingBufferSize();
        state.viewport(0, 0, width, height);
      }
    }
    this.prepareTimestampBuffer(renderContext);
  }
  /**
   * This method processes the result of occlusion queries and writes it
   * into render context data.
   *
   * @async
   * @param {RenderContext} renderContext - The render context.
   */
  resolveOccludedAsync(renderContext) {
    const renderContextData = this.get(renderContext);
    const { currentOcclusionQueries, currentOcclusionQueryObjects } =
      renderContextData;
    if (currentOcclusionQueries && currentOcclusionQueryObjects) {
      const occluded = /* @__PURE__ */ new WeakSet();
      const { gl } = this;
      renderContextData.currentOcclusionQueryObjects = null;
      renderContextData.currentOcclusionQueries = null;
      const check = () => {
        let completed = 0;
        for (let i2 = 0; i2 < currentOcclusionQueries.length; i2++) {
          const query = currentOcclusionQueries[i2];
          if (query === null) continue;
          if (gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {
            if (gl.getQueryParameter(query, gl.QUERY_RESULT) === 0)
              occluded.add(currentOcclusionQueryObjects[i2]);
            currentOcclusionQueries[i2] = null;
            gl.deleteQuery(query);
            completed++;
          }
        }
        if (completed < currentOcclusionQueries.length) {
          requestAnimationFrame(check);
        } else {
          renderContextData.occluded = occluded;
        }
      };
      check();
    }
  }
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(renderContext, object) {
    const renderContextData = this.get(renderContext);
    return renderContextData.occluded && renderContextData.occluded.has(object);
  }
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport(renderContext) {
    const { state } = this;
    const { x, y, width, height } = renderContext.viewportValue;
    state.viewport(x, renderContext.height - height - y, width, height);
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(boolean) {
    const state = this.state;
    state.setScissorTest(boolean);
  }
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const clearColor = super.getClearColor();
    clearColor.r *= clearColor.a;
    clearColor.g *= clearColor.a;
    clearColor.b *= clearColor.a;
    return clearColor;
  }
  /**
   * Performs a clear operation.
   *
   * @param {boolean} color - Whether the color buffer should be cleared or not.
   * @param {boolean} depth - Whether the depth buffer should be cleared or not.
   * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.
   * @param {?Object} [descriptor=null] - The render context of the current set render target.
   * @param {boolean} [setFrameBuffer=true] - TODO.
   */
  clear(color2, depth2, stencil, descriptor = null, setFrameBuffer = true) {
    const { gl, renderer: renderer2 } = this;
    if (descriptor === null) {
      const clearColor = this.getClearColor();
      descriptor = {
        textures: null,
        clearColorValue: clearColor,
      };
    }
    let clear = 0;
    if (color2) clear |= gl.COLOR_BUFFER_BIT;
    if (depth2) clear |= gl.DEPTH_BUFFER_BIT;
    if (stencil) clear |= gl.STENCIL_BUFFER_BIT;
    if (clear !== 0) {
      let clearColor;
      if (descriptor.clearColorValue) {
        clearColor = descriptor.clearColorValue;
      } else {
        clearColor = this.getClearColor();
      }
      const clearDepth = renderer2.getClearDepth();
      const clearStencil = renderer2.getClearStencil();
      if (depth2) this.state.setDepthMask(true);
      if (descriptor.textures === null) {
        gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
        gl.clear(clear);
      } else {
        if (setFrameBuffer) this._setFramebuffer(descriptor);
        if (color2) {
          for (let i2 = 0; i2 < descriptor.textures.length; i2++) {
            if (i2 === 0) {
              gl.clearBufferfv(gl.COLOR, i2, [
                clearColor.r,
                clearColor.g,
                clearColor.b,
                clearColor.a,
              ]);
            } else {
              gl.clearBufferfv(gl.COLOR, i2, [0, 0, 0, 1]);
            }
          }
        }
        if (depth2 && stencil) {
          gl.clearBufferfi(gl.DEPTH_STENCIL, 0, clearDepth, clearStencil);
        } else if (depth2) {
          gl.clearBufferfv(gl.DEPTH, 0, [clearDepth]);
        } else if (stencil) {
          gl.clearBufferiv(gl.STENCIL, 0, [clearStencil]);
        }
      }
    }
  }
  /**
   * This method is executed at the beginning of a compute call and
   * prepares the state for upcoming compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute(computeGroup) {
    const { state, gl } = this;
    state.bindFramebuffer(gl.FRAMEBUFFER, null);
    this.initTimestampQuery(computeGroup);
  }
  /**
   * Executes a compute command for the given compute node.
   *
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} pipeline - The compute pipeline.
   * @param {number|null} [count=null] - The count of compute invocations. If `null`, the count is determined by the compute node.
   */
  compute(computeGroup, computeNode, bindings, pipeline, count = null) {
    const { state, gl } = this;
    if (this.discard === false) {
      gl.enable(gl.RASTERIZER_DISCARD);
      this.discard = true;
    }
    const { programGPU, transformBuffers, attributes } = this.get(pipeline);
    const vaoKey = this._getVaoKey(attributes);
    const vaoGPU = this.vaoCache[vaoKey];
    if (vaoGPU === void 0) {
      this.vaoCache[vaoKey] = this._createVao(attributes);
    } else {
      state.setVertexState(vaoGPU);
    }
    state.useProgram(programGPU);
    this._bindUniforms(bindings);
    const transformFeedbackGPU = this._getTransformFeedback(transformBuffers);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);
    gl.beginTransformFeedback(gl.POINTS);
    count = count !== null ? count : computeNode.count;
    if (Array.isArray(count)) {
      warnOnce(
        "WebGLBackend.compute(): The count parameter must be a single number, not an array."
      );
      count = count[0];
    }
    if (attributes[0].isStorageInstancedBufferAttribute) {
      gl.drawArraysInstanced(gl.POINTS, 0, 1, count);
    } else {
      gl.drawArrays(gl.POINTS, 0, count);
    }
    gl.endTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    for (let i2 = 0; i2 < transformBuffers.length; i2++) {
      const dualAttributeData = transformBuffers[i2];
      if (dualAttributeData.pbo && this.has(dualAttributeData.pbo)) {
        this.textureUtils.copyBufferToTexture(
          dualAttributeData.transformBuffer,
          dualAttributeData.pbo
        );
      }
      dualAttributeData.switchBuffers();
    }
  }
  /**
   * This method is executed at the end of a compute call and
   * finalizes work after compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute(computeGroup) {
    const gl = this.gl;
    this.discard = false;
    gl.disable(gl.RASTERIZER_DISCARD);
    this.prepareTimestampBuffer(computeGroup);
    if (this._currentContext) {
      this._setFramebuffer(this._currentContext);
    }
  }
  /**
   * Internal to determine if the current render target is a render target array with depth 2D array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {boolean} Whether the render target is a render target array with depth 2D array texture.
   *
   * @private
   */
  _isRenderCameraDepthArray(renderContext) {
    return (
      renderContext.depthTexture &&
      renderContext.depthTexture.isArrayTexture &&
      renderContext.camera.isArrayCamera
    );
  }
  /**
   * Executes a draw command for the given render object.
   *
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw(renderObject) {
    const {
      object,
      pipeline,
      material,
      context: context2,
      hardwareClippingPlanes,
    } = renderObject;
    const { programGPU } = this.get(pipeline);
    const { gl, state } = this;
    const contextData = this.get(context2);
    const drawParams = renderObject.getDrawParameters();
    if (drawParams === null) return;
    this._bindUniforms(renderObject.getBindings());
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    state.setMaterial(material, frontFaceCW, hardwareClippingPlanes);
    state.useProgram(programGPU);
    const attributes = renderObject.getAttributes();
    const attributesData = this.get(attributes);
    let vaoGPU = attributesData.vaoGPU;
    if (vaoGPU === void 0) {
      const vaoKey = this._getVaoKey(attributes);
      vaoGPU = this.vaoCache[vaoKey];
      if (vaoGPU === void 0) {
        vaoGPU = this._createVao(attributes);
        this.vaoCache[vaoKey] = vaoGPU;
        attributesData.vaoGPU = vaoGPU;
      }
    }
    const index = renderObject.getIndex();
    const indexGPU = index !== null ? this.get(index).bufferGPU : null;
    state.setVertexState(vaoGPU, indexGPU);
    const lastObject = contextData.lastOcclusionObject;
    if (lastObject !== object && lastObject !== void 0) {
      if (lastObject !== null && lastObject.occlusionTest === true) {
        gl.endQuery(gl.ANY_SAMPLES_PASSED);
        contextData.occlusionQueryIndex++;
      }
      if (object.occlusionTest === true) {
        const query = gl.createQuery();
        gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);
        contextData.occlusionQueries[contextData.occlusionQueryIndex] = query;
        contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] =
          object;
      }
      contextData.lastOcclusionObject = object;
    }
    const renderer2 = this.bufferRenderer;
    if (object.isPoints) renderer2.mode = gl.POINTS;
    else if (object.isLineSegments) renderer2.mode = gl.LINES;
    else if (object.isLine) renderer2.mode = gl.LINE_STRIP;
    else if (object.isLineLoop) renderer2.mode = gl.LINE_LOOP;
    else {
      if (material.wireframe === true) {
        state.setLineWidth(
          material.wireframeLinewidth * this.renderer.getPixelRatio()
        );
        renderer2.mode = gl.LINES;
      } else {
        renderer2.mode = gl.TRIANGLES;
      }
    }
    const { vertexCount, instanceCount } = drawParams;
    let { firstVertex } = drawParams;
    renderer2.object = object;
    if (index !== null) {
      firstVertex *= index.array.BYTES_PER_ELEMENT;
      const indexData = this.get(index);
      renderer2.index = index.count;
      renderer2.type = indexData.type;
    } else {
      renderer2.index = 0;
    }
    const draw = () => {
      if (object.isBatchedMesh) {
        if (object._multiDrawInstances !== null) {
          warnOnce(
            "THREE.WebGLBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."
          );
          renderer2.renderMultiDrawInstances(
            object._multiDrawStarts,
            object._multiDrawCounts,
            object._multiDrawCount,
            object._multiDrawInstances
          );
        } else if (!this.hasFeature("WEBGL_multi_draw")) {
          warnOnce("THREE.WebGLRenderer: WEBGL_multi_draw not supported.");
        } else {
          renderer2.renderMultiDraw(
            object._multiDrawStarts,
            object._multiDrawCounts,
            object._multiDrawCount
          );
        }
      } else if (instanceCount > 1) {
        renderer2.renderInstances(firstVertex, vertexCount, instanceCount);
      } else {
        renderer2.render(firstVertex, vertexCount);
      }
    };
    if (
      renderObject.camera.isArrayCamera === true &&
      renderObject.camera.cameras.length > 0 &&
      renderObject.camera.isMultiViewCamera === false
    ) {
      const cameraData = this.get(renderObject.camera);
      const cameras = renderObject.camera.cameras;
      const cameraIndex2 =
        renderObject.getBindingGroup("cameraIndex").bindings[0];
      if (
        cameraData.indexesGPU === void 0 ||
        cameraData.indexesGPU.length !== cameras.length
      ) {
        const data = new Uint32Array([0, 0, 0, 0]);
        const indexesGPU = [];
        for (let i2 = 0, len = cameras.length; i2 < len; i2++) {
          const bufferGPU = gl.createBuffer();
          data[0] = i2;
          gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
          gl.bufferData(gl.UNIFORM_BUFFER, data, gl.STATIC_DRAW);
          indexesGPU.push(bufferGPU);
        }
        cameraData.indexesGPU = indexesGPU;
      }
      const cameraIndexData = this.get(cameraIndex2);
      const pixelRatio = this.renderer.getPixelRatio();
      const renderTarget = this._currentContext.renderTarget;
      const isRenderCameraDepthArray = this._isRenderCameraDepthArray(
        this._currentContext
      );
      const prevActiveCubeFace = this._currentContext.activeCubeFace;
      if (isRenderCameraDepthArray) {
        const textureData = this.get(renderTarget.depthTexture);
        if (
          textureData.clearedRenderId !==
          this.renderer._nodes.nodeFrame.renderId
        ) {
          textureData.clearedRenderId = this.renderer._nodes.nodeFrame.renderId;
          const { stencilBuffer } = renderTarget;
          for (let i2 = 0, len = cameras.length; i2 < len; i2++) {
            this.renderer._activeCubeFace = i2;
            this._currentContext.activeCubeFace = i2;
            this._setFramebuffer(this._currentContext);
            this.clear(false, true, stencilBuffer, this._currentContext, false);
          }
          this.renderer._activeCubeFace = prevActiveCubeFace;
          this._currentContext.activeCubeFace = prevActiveCubeFace;
        }
      }
      for (let i2 = 0, len = cameras.length; i2 < len; i2++) {
        const subCamera = cameras[i2];
        if (object.layers.test(subCamera.layers)) {
          if (isRenderCameraDepthArray) {
            this.renderer._activeCubeFace = i2;
            this._currentContext.activeCubeFace = i2;
            this._setFramebuffer(this._currentContext);
          }
          const vp = subCamera.viewport;
          if (vp !== void 0) {
            const x = vp.x * pixelRatio;
            const y = vp.y * pixelRatio;
            const width = vp.width * pixelRatio;
            const height = vp.height * pixelRatio;
            state.viewport(
              Math.floor(x),
              Math.floor(renderObject.context.height - height - y),
              Math.floor(width),
              Math.floor(height)
            );
          }
          state.bindBufferBase(
            gl.UNIFORM_BUFFER,
            cameraIndexData.index,
            cameraData.indexesGPU[i2]
          );
          draw();
        }
        this._currentContext.activeCubeFace = prevActiveCubeFace;
        this.renderer._activeCubeFace = prevActiveCubeFace;
      }
    } else {
      draw();
    }
  }
  /**
   * Explain why always null is returned.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate() {
    return false;
  }
  /**
   * Explain why no cache key is computed.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey() {
    return "";
  }
  // textures
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(texture2) {
    this.textureUtils.createDefaultTexture(texture2);
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(texture2, options) {
    this.textureUtils.createTexture(texture2, options);
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(texture2, options) {
    this.textureUtils.updateTexture(texture2, options);
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(texture2) {
    this.textureUtils.generateMipmaps(texture2);
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   */
  destroyTexture(texture2) {
    this.textureUtils.destroyTexture(texture2);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(texture2, x, y, width, height, faceIndex) {
    return this.textureUtils.copyTextureToBuffer(
      texture2,
      x,
      y,
      width,
      height,
      faceIndex
    );
  }
  /**
   * This method does nothing since WebGL 2 has no concept of samplers.
   *
   * @param {Texture} texture - The texture to create the sampler for.
   */
  createSampler() {}
  /**
   * This method does nothing since WebGL 2 has no concept of samplers.
   *
   * @param {Texture} texture - The texture to destroy the sampler for.
   */
  destroySampler() {}
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {GLSLNodeBuilder} The node builder.
   */
  createNodeBuilder(object, renderer2) {
    return new GLSLNodeBuilder(object, renderer2);
  }
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram(program2) {
    const gl = this.gl;
    const { stage, code: code2 } = program2;
    const shader =
      stage === "fragment"
        ? gl.createShader(gl.FRAGMENT_SHADER)
        : gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(shader, code2);
    gl.compileShader(shader);
    this.set(program2, {
      shaderGPU: shader,
    });
  }
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram(program2) {
    this.delete(program2);
  }
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(renderObject, promises) {
    const gl = this.gl;
    const pipeline = renderObject.pipeline;
    const { fragmentProgram, vertexProgram } = pipeline;
    const programGPU = gl.createProgram();
    const fragmentShader = this.get(fragmentProgram).shaderGPU;
    const vertexShader = this.get(vertexProgram).shaderGPU;
    gl.attachShader(programGPU, fragmentShader);
    gl.attachShader(programGPU, vertexShader);
    gl.linkProgram(programGPU);
    this.set(pipeline, {
      programGPU,
      fragmentShader,
      vertexShader,
    });
    if (promises !== null && this.parallel) {
      const p2 = new Promise((resolve) => {
        const parallel = this.parallel;
        const checkStatus = () => {
          if (
            gl.getProgramParameter(programGPU, parallel.COMPLETION_STATUS_KHR)
          ) {
            this._completeCompile(renderObject, pipeline);
            resolve();
          } else {
            requestAnimationFrame(checkStatus);
          }
        };
        checkStatus();
      });
      promises.push(p2);
      return;
    }
    this._completeCompile(renderObject, pipeline);
  }
  /**
   * Formats the source code of error messages.
   *
   * @private
   * @param {string} string - The code.
   * @param {number} errorLine - The error line.
   * @return {string} The formatted code.
   */
  _handleSource(string2, errorLine) {
    const lines = string2.split("\n");
    const lines2 = [];
    const from = Math.max(errorLine - 6, 0);
    const to = Math.min(errorLine + 6, lines.length);
    for (let i2 = from; i2 < to; i2++) {
      const line = i2 + 1;
      lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i2]}`);
    }
    return lines2.join("\n");
  }
  /**
   * Gets the shader compilation errors from the info log.
   *
   * @private
   * @param {WebGL2RenderingContext} gl - The rendering context.
   * @param {WebGLShader} shader - The WebGL shader object.
   * @param {string} type - The shader type.
   * @return {string} The shader errors.
   */
  _getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    const shaderInfoLog = gl.getShaderInfoLog(shader) || "";
    const errors = shaderInfoLog.trim();
    if (status && errors === "") return "";
    const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
    if (errorMatches) {
      const errorLine = parseInt(errorMatches[1]);
      return (
        type.toUpperCase() +
        "\n\n" +
        errors +
        "\n\n" +
        this._handleSource(gl.getShaderSource(shader), errorLine)
      );
    } else {
      return errors;
    }
  }
  /**
   * Logs shader compilation errors.
   *
   * @private
   * @param {WebGLProgram} programGPU - The WebGL program.
   * @param {WebGLShader} glFragmentShader - The fragment shader as a native WebGL shader object.
   * @param {WebGLShader} glVertexShader - The vertex shader as a native WebGL shader object.
   */
  _logProgramError(programGPU, glFragmentShader, glVertexShader) {
    if (this.renderer.debug.checkShaderErrors) {
      const gl = this.gl;
      const programInfoLog = gl.getProgramInfoLog(programGPU) || "";
      const programLog = programInfoLog.trim();
      if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
        if (typeof this.renderer.debug.onShaderError === "function") {
          this.renderer.debug.onShaderError(
            gl,
            programGPU,
            glVertexShader,
            glFragmentShader
          );
        } else {
          const vertexErrors = this._getShaderErrors(
            gl,
            glVertexShader,
            "vertex"
          );
          const fragmentErrors = this._getShaderErrors(
            gl,
            glFragmentShader,
            "fragment"
          );
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              gl.getError() +
              " - VALIDATE_STATUS " +
              gl.getProgramParameter(programGPU, gl.VALIDATE_STATUS) +
              "\n\nProgram Info Log: " +
              programLog +
              "\n" +
              vertexErrors +
              "\n" +
              fragmentErrors
          );
        }
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      }
    }
  }
  /**
   * Completes the shader program setup for the given render object.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {RenderPipeline} pipeline - The render pipeline.
   */
  _completeCompile(renderObject, pipeline) {
    const { state, gl } = this;
    const pipelineData = this.get(pipeline);
    const { programGPU, fragmentShader, vertexShader } = pipelineData;
    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
      this._logProgramError(programGPU, fragmentShader, vertexShader);
    }
    state.useProgram(programGPU);
    const bindings = renderObject.getBindings();
    this._setupBindings(bindings, programGPU);
    this.set(pipeline, {
      programGPU,
    });
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(computePipeline, bindings) {
    const { state, gl } = this;
    const fragmentProgram = {
      stage: "fragment",
      code: "#version 300 es\nprecision highp float;\nvoid main() {}",
    };
    this.createProgram(fragmentProgram);
    const { computeProgram } = computePipeline;
    const programGPU = gl.createProgram();
    const fragmentShader = this.get(fragmentProgram).shaderGPU;
    const vertexShader = this.get(computeProgram).shaderGPU;
    const transforms = computeProgram.transforms;
    const transformVaryingNames = [];
    const transformAttributeNodes = [];
    for (let i2 = 0; i2 < transforms.length; i2++) {
      const transform = transforms[i2];
      transformVaryingNames.push(transform.varyingName);
      transformAttributeNodes.push(transform.attributeNode);
    }
    gl.attachShader(programGPU, fragmentShader);
    gl.attachShader(programGPU, vertexShader);
    gl.transformFeedbackVaryings(
      programGPU,
      transformVaryingNames,
      gl.SEPARATE_ATTRIBS
    );
    gl.linkProgram(programGPU);
    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
      this._logProgramError(programGPU, fragmentShader, vertexShader);
    }
    state.useProgram(programGPU);
    this._setupBindings(bindings, programGPU);
    const attributeNodes = computeProgram.attributes;
    const attributes = [];
    const transformBuffers = [];
    for (let i2 = 0; i2 < attributeNodes.length; i2++) {
      const attribute2 = attributeNodes[i2].node.attribute;
      attributes.push(attribute2);
      if (!this.has(attribute2))
        this.attributeUtils.createAttribute(attribute2, gl.ARRAY_BUFFER);
    }
    for (let i2 = 0; i2 < transformAttributeNodes.length; i2++) {
      const attribute2 = transformAttributeNodes[i2].attribute;
      if (!this.has(attribute2))
        this.attributeUtils.createAttribute(attribute2, gl.ARRAY_BUFFER);
      const attributeData = this.get(attribute2);
      transformBuffers.push(attributeData);
    }
    this.set(computePipeline, {
      programGPU,
      transformBuffers,
      attributes,
    });
  }
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(bindGroup, bindings) {
    if (this._knownBindings.has(bindings) === false) {
      this._knownBindings.add(bindings);
      let uniformBuffers = 0;
      let textures = 0;
      for (const bindGroup2 of bindings) {
        this.set(bindGroup2, {
          textures,
          uniformBuffers,
        });
        for (const binding of bindGroup2.bindings) {
          if (binding.isUniformBuffer) uniformBuffers++;
          if (binding.isSampledTexture) textures++;
        }
      }
    }
    this.updateBindings(bindGroup, bindings);
  }
  /**
   * Updates the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings(bindGroup) {
    const { gl } = this;
    const bindGroupData = this.get(bindGroup);
    let i2 = bindGroupData.uniformBuffers;
    let t2 = bindGroupData.textures;
    for (const binding of bindGroup.bindings) {
      if (binding.isUniformsGroup || binding.isUniformBuffer) {
        const data = binding.buffer;
        const bufferGPU = gl.createBuffer();
        gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
        gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
        this.set(binding, {
          index: i2++,
          bufferGPU,
        });
      } else if (binding.isSampledTexture) {
        const { textureGPU, glTextureType } = this.get(binding.texture);
        this.set(binding, {
          index: t2++,
          textureGPU,
          glTextureType,
        });
      }
    }
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(binding) {
    const gl = this.gl;
    if (binding.isUniformsGroup || binding.isUniformBuffer) {
      const bindingData = this.get(binding);
      const bufferGPU = bindingData.bufferGPU;
      const data = binding.buffer;
      gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
      gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
    }
  }
  // attributes
  /**
   * Creates the GPU buffer of an indexed shader attribute.
   *
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute(attribute2) {
    const gl = this.gl;
    this.attributeUtils.createAttribute(attribute2, gl.ELEMENT_ARRAY_BUFFER);
  }
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute(attribute2) {
    if (this.has(attribute2)) return;
    const gl = this.gl;
    this.attributeUtils.createAttribute(attribute2, gl.ARRAY_BUFFER);
  }
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute(attribute2) {
    if (this.has(attribute2)) return;
    const gl = this.gl;
    this.attributeUtils.createAttribute(attribute2, gl.ARRAY_BUFFER);
  }
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute(attribute2) {
    this.attributeUtils.updateAttribute(attribute2);
  }
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute(attribute2) {
    this.attributeUtils.destroyAttribute(attribute2);
  }
  /**
   * Checks if the given feature is supported  by the backend.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(name) {
    const keysMatching = Object.keys(GLFeatureName).filter(
      (key) => GLFeatureName[key] === name
    );
    const extensions = this.extensions;
    for (let i2 = 0; i2 < keysMatching.length; i2++) {
      if (extensions.has(keysMatching[i2])) return true;
    }
    return false;
  }
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    return this.capabilities.getMaxAnisotropy();
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(
    srcTexture,
    dstTexture,
    srcRegion = null,
    dstPosition = null,
    srcLevel = 0,
    dstLevel = 0
  ) {
    this.textureUtils.copyTextureToTexture(
      srcTexture,
      dstTexture,
      srcRegion,
      dstPosition,
      srcLevel,
      dstLevel
    );
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(texture2, renderContext, rectangle) {
    this.textureUtils.copyFramebufferToTexture(
      texture2,
      renderContext,
      rectangle
    );
  }
  /**
   * Configures the active framebuffer from the given render context.
   *
   * @private
   * @param {RenderContext} descriptor - The render context.
   */
  _setFramebuffer(descriptor) {
    const { gl, state } = this;
    let currentFrameBuffer = null;
    if (descriptor.textures !== null) {
      const renderTarget = descriptor.renderTarget;
      const renderTargetContextData = this.get(renderTarget);
      const { samples, depthBuffer, stencilBuffer } = renderTarget;
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      const isRenderTarget3D = renderTarget.isRenderTarget3D === true;
      const isRenderTargetArray = renderTarget.depth > 1;
      const isXRRenderTarget = renderTarget.isXRRenderTarget === true;
      const _hasExternalTextures =
        isXRRenderTarget === true && renderTarget._hasExternalTextures === true;
      let msaaFb = renderTargetContextData.msaaFrameBuffer;
      let depthRenderbuffer = renderTargetContextData.depthRenderbuffer;
      const multisampledRTTExt = this.extensions.get(
        "WEBGL_multisampled_render_to_texture"
      );
      const multiviewExt = this.extensions.get("OVR_multiview2");
      const useMultisampledRTT = this._useMultisampledExtension(renderTarget);
      const cacheKey = getCacheKey(descriptor);
      let fb;
      if (isCube) {
        renderTargetContextData.cubeFramebuffers ||
          (renderTargetContextData.cubeFramebuffers = {});
        fb = renderTargetContextData.cubeFramebuffers[cacheKey];
      } else if (isXRRenderTarget && _hasExternalTextures === false) {
        fb = this._xrFramebuffer;
      } else {
        renderTargetContextData.framebuffers ||
          (renderTargetContextData.framebuffers = {});
        fb = renderTargetContextData.framebuffers[cacheKey];
      }
      if (fb === void 0) {
        fb = gl.createFramebuffer();
        state.bindFramebuffer(gl.FRAMEBUFFER, fb);
        const textures = descriptor.textures;
        const depthInvalidationArray = [];
        if (isCube) {
          renderTargetContextData.cubeFramebuffers[cacheKey] = fb;
          const { textureGPU } = this.get(textures[0]);
          const cubeFace = this.renderer._activeCubeFace;
          gl.framebufferTexture2D(
            gl.FRAMEBUFFER,
            gl.COLOR_ATTACHMENT0,
            gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace,
            textureGPU,
            0
          );
        } else {
          renderTargetContextData.framebuffers[cacheKey] = fb;
          for (let i2 = 0; i2 < textures.length; i2++) {
            const texture2 = textures[i2];
            const textureData = this.get(texture2);
            textureData.renderTarget = descriptor.renderTarget;
            textureData.cacheKey = cacheKey;
            const attachment = gl.COLOR_ATTACHMENT0 + i2;
            if (renderTarget.multiview) {
              multiviewExt.framebufferTextureMultisampleMultiviewOVR(
                gl.FRAMEBUFFER,
                attachment,
                textureData.textureGPU,
                0,
                samples,
                0,
                2
              );
            } else if (isRenderTarget3D || isRenderTargetArray) {
              const layer = this.renderer._activeCubeFace;
              gl.framebufferTextureLayer(
                gl.FRAMEBUFFER,
                attachment,
                textureData.textureGPU,
                0,
                layer
              );
            } else {
              if (useMultisampledRTT) {
                multisampledRTTExt.framebufferTexture2DMultisampleEXT(
                  gl.FRAMEBUFFER,
                  attachment,
                  gl.TEXTURE_2D,
                  textureData.textureGPU,
                  0,
                  samples
                );
              } else {
                gl.framebufferTexture2D(
                  gl.FRAMEBUFFER,
                  attachment,
                  gl.TEXTURE_2D,
                  textureData.textureGPU,
                  0
                );
              }
            }
          }
        }
        const depthStyle = stencilBuffer
          ? gl.DEPTH_STENCIL_ATTACHMENT
          : gl.DEPTH_ATTACHMENT;
        if (renderTarget._autoAllocateDepthBuffer === true) {
          const renderbuffer = gl.createRenderbuffer();
          this.textureUtils.setupRenderBufferStorage(
            renderbuffer,
            descriptor,
            0,
            useMultisampledRTT
          );
          renderTargetContextData.xrDepthRenderbuffer = renderbuffer;
          depthInvalidationArray.push(
            stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT
          );
          gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
          gl.framebufferRenderbuffer(
            gl.FRAMEBUFFER,
            depthStyle,
            gl.RENDERBUFFER,
            renderbuffer
          );
        } else {
          if (descriptor.depthTexture !== null) {
            depthInvalidationArray.push(
              stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT
            );
            const textureData = this.get(descriptor.depthTexture);
            textureData.renderTarget = descriptor.renderTarget;
            textureData.cacheKey = cacheKey;
            if (renderTarget.multiview) {
              multiviewExt.framebufferTextureMultisampleMultiviewOVR(
                gl.FRAMEBUFFER,
                depthStyle,
                textureData.textureGPU,
                0,
                samples,
                0,
                2
              );
            } else if (_hasExternalTextures && useMultisampledRTT) {
              multisampledRTTExt.framebufferTexture2DMultisampleEXT(
                gl.FRAMEBUFFER,
                depthStyle,
                gl.TEXTURE_2D,
                textureData.textureGPU,
                0,
                samples
              );
            } else {
              if (descriptor.depthTexture.isArrayTexture) {
                const layer = this.renderer._activeCubeFace;
                gl.framebufferTextureLayer(
                  gl.FRAMEBUFFER,
                  depthStyle,
                  textureData.textureGPU,
                  0,
                  layer
                );
              } else {
                gl.framebufferTexture2D(
                  gl.FRAMEBUFFER,
                  depthStyle,
                  gl.TEXTURE_2D,
                  textureData.textureGPU,
                  0
                );
              }
            }
          }
        }
        renderTargetContextData.depthInvalidationArray = depthInvalidationArray;
      } else {
        const isRenderCameraDepthArray =
          this._isRenderCameraDepthArray(descriptor);
        if (isRenderCameraDepthArray) {
          state.bindFramebuffer(gl.FRAMEBUFFER, fb);
          const layer = this.renderer._activeCubeFace;
          const depthData = this.get(descriptor.depthTexture);
          const depthStyle = stencilBuffer
            ? gl.DEPTH_STENCIL_ATTACHMENT
            : gl.DEPTH_ATTACHMENT;
          gl.framebufferTextureLayer(
            gl.FRAMEBUFFER,
            depthStyle,
            depthData.textureGPU,
            0,
            layer
          );
        }
        if (
          (isXRRenderTarget || useMultisampledRTT || renderTarget.multiview) &&
          renderTarget._isOpaqueFramebuffer !== true
        ) {
          state.bindFramebuffer(gl.FRAMEBUFFER, fb);
          const textureData = this.get(descriptor.textures[0]);
          if (renderTarget.multiview) {
            multiviewExt.framebufferTextureMultisampleMultiviewOVR(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0,
              textureData.textureGPU,
              0,
              samples,
              0,
              2
            );
          } else if (useMultisampledRTT) {
            multisampledRTTExt.framebufferTexture2DMultisampleEXT(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0,
              gl.TEXTURE_2D,
              textureData.textureGPU,
              0,
              samples
            );
          } else {
            gl.framebufferTexture2D(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0,
              gl.TEXTURE_2D,
              textureData.textureGPU,
              0
            );
          }
          const depthStyle = stencilBuffer
            ? gl.DEPTH_STENCIL_ATTACHMENT
            : gl.DEPTH_ATTACHMENT;
          if (renderTarget._autoAllocateDepthBuffer === true) {
            const renderbuffer = renderTargetContextData.xrDepthRenderbuffer;
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
            gl.framebufferRenderbuffer(
              gl.FRAMEBUFFER,
              depthStyle,
              gl.RENDERBUFFER,
              renderbuffer
            );
          } else {
            const textureData2 = this.get(descriptor.depthTexture);
            if (renderTarget.multiview) {
              multiviewExt.framebufferTextureMultisampleMultiviewOVR(
                gl.FRAMEBUFFER,
                depthStyle,
                textureData2.textureGPU,
                0,
                samples,
                0,
                2
              );
            } else if (useMultisampledRTT) {
              multisampledRTTExt.framebufferTexture2DMultisampleEXT(
                gl.FRAMEBUFFER,
                depthStyle,
                gl.TEXTURE_2D,
                textureData2.textureGPU,
                0,
                samples
              );
            } else {
              gl.framebufferTexture2D(
                gl.FRAMEBUFFER,
                depthStyle,
                gl.TEXTURE_2D,
                textureData2.textureGPU,
                0
              );
            }
          }
        }
      }
      if (
        samples > 0 &&
        useMultisampledRTT === false &&
        !renderTarget.multiview
      ) {
        if (msaaFb === void 0) {
          const invalidationArray = [];
          msaaFb = gl.createFramebuffer();
          state.bindFramebuffer(gl.FRAMEBUFFER, msaaFb);
          const msaaRenderbuffers = [];
          const textures = descriptor.textures;
          for (let i2 = 0; i2 < textures.length; i2++) {
            msaaRenderbuffers[i2] = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderbuffers[i2]);
            invalidationArray.push(gl.COLOR_ATTACHMENT0 + i2);
            const texture2 = descriptor.textures[i2];
            const textureData = this.get(texture2);
            gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              samples,
              textureData.glInternalFormat,
              descriptor.width,
              descriptor.height
            );
            gl.framebufferRenderbuffer(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i2,
              gl.RENDERBUFFER,
              msaaRenderbuffers[i2]
            );
          }
          gl.bindRenderbuffer(gl.RENDERBUFFER, null);
          renderTargetContextData.msaaFrameBuffer = msaaFb;
          renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;
          if (depthBuffer && depthRenderbuffer === void 0) {
            depthRenderbuffer = gl.createRenderbuffer();
            this.textureUtils.setupRenderBufferStorage(
              depthRenderbuffer,
              descriptor,
              samples
            );
            renderTargetContextData.depthRenderbuffer = depthRenderbuffer;
            const depthStyle = stencilBuffer
              ? gl.DEPTH_STENCIL_ATTACHMENT
              : gl.DEPTH_ATTACHMENT;
            invalidationArray.push(depthStyle);
          }
          renderTargetContextData.invalidationArray = invalidationArray;
        }
        currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;
      } else {
        currentFrameBuffer = fb;
      }
      state.drawBuffers(descriptor, fb);
    }
    state.bindFramebuffer(gl.FRAMEBUFFER, currentFrameBuffer);
  }
  /**
   * Computes the VAO key for the given index and attributes.
   *
   * @private
   * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
   * @return {string} The VAO key.
   */
  _getVaoKey(attributes) {
    let key = "";
    for (let i2 = 0; i2 < attributes.length; i2++) {
      const attributeData = this.get(attributes[i2]);
      key += ":" + attributeData.id;
    }
    return key;
  }
  /**
   * Creates a VAO from the index and attributes.
   *
   * @private
   * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
   * @return {Object} The VAO data.
   */
  _createVao(attributes) {
    const { gl } = this;
    const vaoGPU = gl.createVertexArray();
    gl.bindVertexArray(vaoGPU);
    for (let i2 = 0; i2 < attributes.length; i2++) {
      const attribute2 = attributes[i2];
      const attributeData = this.get(attribute2);
      gl.bindBuffer(gl.ARRAY_BUFFER, attributeData.bufferGPU);
      gl.enableVertexAttribArray(i2);
      let stride, offset;
      if (attribute2.isInterleavedBufferAttribute === true) {
        stride = attribute2.data.stride * attributeData.bytesPerElement;
        offset = attribute2.offset * attributeData.bytesPerElement;
      } else {
        stride = 0;
        offset = 0;
      }
      if (attributeData.isInteger) {
        gl.vertexAttribIPointer(
          i2,
          attribute2.itemSize,
          attributeData.type,
          stride,
          offset
        );
      } else {
        gl.vertexAttribPointer(
          i2,
          attribute2.itemSize,
          attributeData.type,
          attribute2.normalized,
          stride,
          offset
        );
      }
      if (
        attribute2.isInstancedBufferAttribute &&
        !attribute2.isInterleavedBufferAttribute
      ) {
        gl.vertexAttribDivisor(i2, attribute2.meshPerAttribute);
      } else if (
        attribute2.isInterleavedBufferAttribute &&
        attribute2.data.isInstancedInterleavedBuffer
      ) {
        gl.vertexAttribDivisor(i2, attribute2.data.meshPerAttribute);
      }
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return vaoGPU;
  }
  /**
   * Creates a transform feedback from the given transform buffers.
   *
   * @private
   * @param {Array<DualAttributeData>} transformBuffers - The transform buffers.
   * @return {WebGLTransformFeedback} The transform feedback.
   */
  _getTransformFeedback(transformBuffers) {
    let key = "";
    for (let i2 = 0; i2 < transformBuffers.length; i2++) {
      key += ":" + transformBuffers[i2].id;
    }
    let transformFeedbackGPU = this.transformFeedbackCache[key];
    if (transformFeedbackGPU !== void 0) {
      return transformFeedbackGPU;
    }
    const { gl } = this;
    transformFeedbackGPU = gl.createTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);
    for (let i2 = 0; i2 < transformBuffers.length; i2++) {
      const attributeData = transformBuffers[i2];
      gl.bindBufferBase(
        gl.TRANSFORM_FEEDBACK_BUFFER,
        i2,
        attributeData.transformBuffer
      );
    }
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    this.transformFeedbackCache[key] = transformFeedbackGPU;
    return transformFeedbackGPU;
  }
  /**
   * Setups the given bindings.
   *
   * @private
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {WebGLProgram} programGPU - The WebGL program.
   */
  _setupBindings(bindings, programGPU) {
    const gl = this.gl;
    for (const bindGroup of bindings) {
      for (const binding of bindGroup.bindings) {
        const bindingData = this.get(binding);
        const index = bindingData.index;
        if (binding.isUniformsGroup || binding.isUniformBuffer) {
          const location = gl.getUniformBlockIndex(programGPU, binding.name);
          gl.uniformBlockBinding(programGPU, location, index);
        } else if (binding.isSampledTexture) {
          const location = gl.getUniformLocation(programGPU, binding.name);
          gl.uniform1i(location, index);
        }
      }
    }
  }
  /**
   * Binds the given uniforms.
   *
   * @private
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  _bindUniforms(bindings) {
    const { gl, state } = this;
    for (const bindGroup of bindings) {
      for (const binding of bindGroup.bindings) {
        const bindingData = this.get(binding);
        const index = bindingData.index;
        if (binding.isUniformsGroup || binding.isUniformBuffer) {
          state.bindBufferBase(gl.UNIFORM_BUFFER, index, bindingData.bufferGPU);
        } else if (binding.isSampledTexture) {
          state.bindTexture(
            bindingData.glTextureType,
            bindingData.textureGPU,
            gl.TEXTURE0 + index
          );
        }
      }
    }
  }
  /**
   * Returns `true` if the `WEBGL_multisampled_render_to_texture` extension
   * should be used when MSAA is enabled.
   *
   * @private
   * @param {RenderTarget} renderTarget - The render target that should be multisampled.
   * @return {boolean} Whether to use the `WEBGL_multisampled_render_to_texture` extension for MSAA or not.
   */
  _useMultisampledExtension(renderTarget) {
    if (renderTarget.multiview === true) {
      return true;
    }
    return (
      renderTarget.samples > 0 &&
      this.extensions.has("WEBGL_multisampled_render_to_texture") === true &&
      renderTarget._autoAllocateDepthBuffer !== false
    );
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    const extension = this.extensions.get("WEBGL_lose_context");
    if (extension) extension.loseContext();
    this.renderer.domElement.removeEventListener(
      "webglcontextlost",
      this._onContextLost
    );
  }
}
const GPUPrimitiveTopology = {
  PointList: "point-list",
  LineList: "line-list",
  LineStrip: "line-strip",
  TriangleList: "triangle-list",
  TriangleStrip: "triangle-strip",
};
const GPUCompareFunction = {
  Never: "never",
  Less: "less",
  Equal: "equal",
  LessEqual: "less-equal",
  Greater: "greater",
  NotEqual: "not-equal",
  GreaterEqual: "greater-equal",
  Always: "always",
};
const GPUStoreOp = {
  Store: "store",
};
const GPULoadOp = {
  Load: "load",
  Clear: "clear",
};
const GPUFrontFace = {
  CCW: "ccw",
};
const GPUCullMode = {
  None: "none",
  Front: "front",
  Back: "back",
};
const GPUIndexFormat = {
  Uint16: "uint16",
  Uint32: "uint32",
};
const GPUTextureFormat = {
  // 8-bit formats
  R8Unorm: "r8unorm",
  R8Snorm: "r8snorm",
  R8Uint: "r8uint",
  R8Sint: "r8sint",
  // 16-bit formats
  R16Uint: "r16uint",
  R16Sint: "r16sint",
  R16Float: "r16float",
  RG8Unorm: "rg8unorm",
  RG8Snorm: "rg8snorm",
  RG8Uint: "rg8uint",
  RG8Sint: "rg8sint",
  // 32-bit formats
  R32Uint: "r32uint",
  R32Sint: "r32sint",
  R32Float: "r32float",
  RG16Uint: "rg16uint",
  RG16Sint: "rg16sint",
  RG16Float: "rg16float",
  RGBA8Unorm: "rgba8unorm",
  RGBA8UnormSRGB: "rgba8unorm-srgb",
  RGBA8Snorm: "rgba8snorm",
  RGBA8Uint: "rgba8uint",
  RGBA8Sint: "rgba8sint",
  BGRA8Unorm: "bgra8unorm",
  BGRA8UnormSRGB: "bgra8unorm-srgb",
  // Packed 32-bit formats
  RGB9E5UFloat: "rgb9e5ufloat",
  RGB10A2Unorm: "rgb10a2unorm",
  RG11B10UFloat: "rgb10a2unorm",
  // 64-bit formats
  RG32Uint: "rg32uint",
  RG32Sint: "rg32sint",
  RG32Float: "rg32float",
  RGBA16Uint: "rgba16uint",
  RGBA16Sint: "rgba16sint",
  RGBA16Float: "rgba16float",
  // 128-bit formats
  RGBA32Uint: "rgba32uint",
  RGBA32Sint: "rgba32sint",
  RGBA32Float: "rgba32float",
  Depth16Unorm: "depth16unorm",
  Depth24Plus: "depth24plus",
  Depth24PlusStencil8: "depth24plus-stencil8",
  Depth32Float: "depth32float",
  // 'depth32float-stencil8' extension
  Depth32FloatStencil8: "depth32float-stencil8",
  // BC compressed formats usable if 'texture-compression-bc' is both
  // supported by the device/user agent and enabled in requestDevice.
  BC1RGBAUnorm: "bc1-rgba-unorm",
  BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
  BC2RGBAUnorm: "bc2-rgba-unorm",
  BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
  BC3RGBAUnorm: "bc3-rgba-unorm",
  BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
  BC4RUnorm: "bc4-r-unorm",
  BC4RSnorm: "bc4-r-snorm",
  BC5RGUnorm: "bc5-rg-unorm",
  BC5RGSnorm: "bc5-rg-snorm",
  BC6HRGBUFloat: "bc6h-rgb-ufloat",
  BC6HRGBFloat: "bc6h-rgb-float",
  BC7RGBAUnorm: "bc7-rgba-unorm",
  BC7RGBAUnormSRGB: "bc7-rgba-srgb",
  // ETC2 compressed formats usable if 'texture-compression-etc2' is both
  // supported by the device/user agent and enabled in requestDevice.
  ETC2RGB8Unorm: "etc2-rgb8unorm",
  ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
  ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
  ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
  ETC2RGBA8Unorm: "etc2-rgba8unorm",
  ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
  EACR11Unorm: "eac-r11unorm",
  EACR11Snorm: "eac-r11snorm",
  EACRG11Unorm: "eac-rg11unorm",
  EACRG11Snorm: "eac-rg11snorm",
  // ASTC compressed formats usable if 'texture-compression-astc' is both
  // supported by the device/user agent and enabled in requestDevice.
  ASTC4x4Unorm: "astc-4x4-unorm",
  ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
  ASTC5x4Unorm: "astc-5x4-unorm",
  ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
  ASTC5x5Unorm: "astc-5x5-unorm",
  ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
  ASTC6x5Unorm: "astc-6x5-unorm",
  ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
  ASTC6x6Unorm: "astc-6x6-unorm",
  ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
  ASTC8x5Unorm: "astc-8x5-unorm",
  ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
  ASTC8x6Unorm: "astc-8x6-unorm",
  ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
  ASTC8x8Unorm: "astc-8x8-unorm",
  ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
  ASTC10x5Unorm: "astc-10x5-unorm",
  ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
  ASTC10x6Unorm: "astc-10x6-unorm",
  ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
  ASTC10x8Unorm: "astc-10x8-unorm",
  ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
  ASTC10x10Unorm: "astc-10x10-unorm",
  ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
  ASTC12x10Unorm: "astc-12x10-unorm",
  ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
  ASTC12x12Unorm: "astc-12x12-unorm",
  ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb",
};
const GPUAddressMode = {
  ClampToEdge: "clamp-to-edge",
  Repeat: "repeat",
  MirrorRepeat: "mirror-repeat",
};
const GPUFilterMode = {
  Linear: "linear",
  Nearest: "nearest",
};
const GPUBlendFactor = {
  Zero: "zero",
  One: "one",
  Src: "src",
  OneMinusSrc: "one-minus-src",
  SrcAlpha: "src-alpha",
  OneMinusSrcAlpha: "one-minus-src-alpha",
  Dst: "dst",
  OneMinusDst: "one-minus-dst",
  DstAlpha: "dst-alpha",
  OneMinusDstAlpha: "one-minus-dst-alpha",
  SrcAlphaSaturated: "src-alpha-saturated",
  Constant: "constant",
  OneMinusConstant: "one-minus-constant",
};
const GPUBlendOperation = {
  Add: "add",
  Subtract: "subtract",
  ReverseSubtract: "reverse-subtract",
  Min: "min",
  Max: "max",
};
const GPUColorWriteFlags = {
  None: 0,
  All: 15,
};
const GPUStencilOperation = {
  Keep: "keep",
  Zero: "zero",
  Replace: "replace",
  Invert: "invert",
  IncrementClamp: "increment-clamp",
  DecrementClamp: "decrement-clamp",
  IncrementWrap: "increment-wrap",
  DecrementWrap: "decrement-wrap",
};
const GPUBufferBindingType = {
  Storage: "storage",
  ReadOnlyStorage: "read-only-storage",
};
const GPUStorageTextureAccess = {
  WriteOnly: "write-only",
  ReadOnly: "read-only",
  ReadWrite: "read-write",
};
const GPUSamplerBindingType = {
  NonFiltering: "non-filtering",
  Comparison: "comparison",
};
const GPUTextureSampleType = {
  Float: "float",
  UnfilterableFloat: "unfilterable-float",
  Depth: "depth",
  SInt: "sint",
  UInt: "uint",
};
const GPUTextureDimension = {
  TwoD: "2d",
  ThreeD: "3d",
};
const GPUTextureViewDimension = {
  TwoD: "2d",
  TwoDArray: "2d-array",
  Cube: "cube",
  ThreeD: "3d",
};
const GPUTextureAspect = {
  All: "all",
};
const GPUInputStepMode = {
  Vertex: "vertex",
  Instance: "instance",
};
const GPUFeatureName = {
  CoreFeaturesAndLimits: "core-features-and-limits",
  DepthClipControl: "depth-clip-control",
  Depth32FloatStencil8: "depth32float-stencil8",
  TextureCompressionBC: "texture-compression-bc",
  TextureCompressionBCSliced3D: "texture-compression-bc-sliced-3d",
  TextureCompressionETC2: "texture-compression-etc2",
  TextureCompressionASTC: "texture-compression-astc",
  TextureCompressionASTCSliced3D: "texture-compression-astc-sliced-3d",
  TimestampQuery: "timestamp-query",
  IndirectFirstInstance: "indirect-first-instance",
  ShaderF16: "shader-f16",
  RG11B10UFloat: "rg11b10ufloat-renderable",
  BGRA8UNormStorage: "bgra8unorm-storage",
  Float32Filterable: "float32-filterable",
  Float32Blendable: "float32-blendable",
  ClipDistances: "clip-distances",
  DualSourceBlending: "dual-source-blending",
  Subgroups: "subgroups",
  TextureFormatsTier1: "texture-formats-tier1",
  TextureFormatsTier2: "texture-formats-tier2",
};
class NodeSampler extends Sampler {
  /**
   * Constructs a new node-based sampler.
   *
   * @param {string} name - The samplers's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(name, textureNode, groupNode) {
    super(name, textureNode ? textureNode.value : null);
    this.textureNode = textureNode;
    this.groupNode = groupNode;
  }
  /**
   * Updates the texture value of this sampler.
   */
  update() {
    this.texture = this.textureNode.value;
  }
}
class StorageBuffer extends Buffer {
  /**
   * Constructs a new uniform buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  constructor(name, attribute2) {
    super(name, attribute2 ? attribute2.array : null);
    this.attribute = attribute2;
    this.isStorageBuffer = true;
  }
}
let _id = 0;
class NodeStorageBuffer extends StorageBuffer {
  /**
   * Constructs a new node-based storage buffer.
   *
   * @param {StorageBufferNode} nodeUniform - The storage buffer node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(nodeUniform, groupNode) {
    super("StorageBuffer_" + _id++, nodeUniform ? nodeUniform.value : null);
    this.nodeUniform = nodeUniform;
    this.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;
    this.groupNode = groupNode;
  }
  /**
   * The storage buffer.
   *
   * @type {BufferAttribute}
   */
  get buffer() {
    return this.nodeUniform.value;
  }
}
class WebGPUTexturePassUtils extends DataMap {
  /**
   * Constructs a new utility object.
   *
   * @param {GPUDevice} device - The WebGPU device.
   */
  constructor(device) {
    super();
    this.device = device;
    const mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`;
    const mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;
    const flipYFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
    this.mipmapSampler = device.createSampler({
      minFilter: GPUFilterMode.Linear,
    });
    this.flipYSampler = device.createSampler({
      minFilter: GPUFilterMode.Nearest,
    });
    this.transferPipelines = {};
    this.flipYPipelines = {};
    this.mipmapVertexShaderModule = device.createShaderModule({
      label: "mipmapVertex",
      code: mipmapVertexSource,
    });
    this.mipmapFragmentShaderModule = device.createShaderModule({
      label: "mipmapFragment",
      code: mipmapFragmentSource,
    });
    this.flipYFragmentShaderModule = device.createShaderModule({
      label: "flipYFragment",
      code: flipYFragmentSource,
    });
  }
  /**
   * Returns a render pipeline for the internal copy render pass. The pass
   * requires a unique render pipeline for each texture format.
   *
   * @param {string} format - The GPU texture format
   * @return {GPURenderPipeline} The GPU render pipeline.
   */
  getTransferPipeline(format) {
    let pipeline = this.transferPipelines[format];
    if (pipeline === void 0) {
      pipeline = this.device.createRenderPipeline({
        label: `mipmap-${format}`,
        vertex: {
          module: this.mipmapVertexShaderModule,
          entryPoint: "main",
        },
        fragment: {
          module: this.mipmapFragmentShaderModule,
          entryPoint: "main",
          targets: [{ format }],
        },
        primitive: {
          topology: GPUPrimitiveTopology.TriangleStrip,
          stripIndexFormat: GPUIndexFormat.Uint32,
        },
        layout: "auto",
      });
      this.transferPipelines[format] = pipeline;
    }
    return pipeline;
  }
  /**
   * Returns a render pipeline for the flipY render pass. The pass
   * requires a unique render pipeline for each texture format.
   *
   * @param {string} format - The GPU texture format
   * @return {GPURenderPipeline} The GPU render pipeline.
   */
  getFlipYPipeline(format) {
    let pipeline = this.flipYPipelines[format];
    if (pipeline === void 0) {
      pipeline = this.device.createRenderPipeline({
        label: `flipY-${format}`,
        vertex: {
          module: this.mipmapVertexShaderModule,
          entryPoint: "main",
        },
        fragment: {
          module: this.flipYFragmentShaderModule,
          entryPoint: "main",
          targets: [{ format }],
        },
        primitive: {
          topology: GPUPrimitiveTopology.TriangleStrip,
          stripIndexFormat: GPUIndexFormat.Uint32,
        },
        layout: "auto",
      });
      this.flipYPipelines[format] = pipeline;
    }
    return pipeline;
  }
  /**
   * Flip the contents of the given GPU texture along its vertical axis.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   */
  flipY(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {
    const format = textureGPUDescriptor.format;
    const { width, height } = textureGPUDescriptor.size;
    const transferPipeline = this.getTransferPipeline(format);
    const flipYPipeline = this.getFlipYPipeline(format);
    const tempTexture = this.device.createTexture({
      size: { width, height, depthOrArrayLayers: 1 },
      format,
      usage:
        GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
    });
    const srcView = textureGPU.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer,
    });
    const dstView = tempTexture.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer: 0,
    });
    const commandEncoder = this.device.createCommandEncoder({});
    const pass2 = (pipeline, sourceView, destinationView) => {
      const bindGroupLayout = pipeline.getBindGroupLayout(0);
      const bindGroup = this.device.createBindGroup({
        layout: bindGroupLayout,
        entries: [
          {
            binding: 0,
            resource: this.flipYSampler,
          },
          {
            binding: 1,
            resource: sourceView,
          },
        ],
      });
      const passEncoder = commandEncoder.beginRenderPass({
        colorAttachments: [
          {
            view: destinationView,
            loadOp: GPULoadOp.Clear,
            storeOp: GPUStoreOp.Store,
            clearValue: [0, 0, 0, 0],
          },
        ],
      });
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4, 1, 0, 0);
      passEncoder.end();
    };
    pass2(transferPipeline, srcView, dstView);
    pass2(flipYPipeline, dstView, srcView);
    this.device.queue.submit([commandEncoder.finish()]);
    tempTexture.destroy();
  }
  /**
   * Generates mipmaps for the given GPU texture.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   */
  generateMipmaps(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {
    const textureData = this.get(textureGPU);
    if (textureData.useCount === void 0) {
      textureData.useCount = 0;
      textureData.layers = [];
    }
    const passes =
      textureData.layers[baseArrayLayer] ||
      this._mipmapCreateBundles(
        textureGPU,
        textureGPUDescriptor,
        baseArrayLayer
      );
    const commandEncoder = this.device.createCommandEncoder({});
    this._mipmapRunBundles(commandEncoder, passes);
    this.device.queue.submit([commandEncoder.finish()]);
    if (textureData.useCount !== 0) textureData.layers[baseArrayLayer] = passes;
    textureData.useCount++;
  }
  /**
   * Since multiple copy render passes are required to generate mipmaps, the passes
   * are managed as render bundles to improve performance.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} baseArrayLayer - The index of the first array layer accessible to the texture view.
   * @return {Array<Object>} An array of render bundles.
   */
  _mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer) {
    const pipeline = this.getTransferPipeline(textureGPUDescriptor.format);
    const bindGroupLayout = pipeline.getBindGroupLayout(0);
    let srcView = textureGPU.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer,
    });
    const passes = [];
    for (let i2 = 1; i2 < textureGPUDescriptor.mipLevelCount; i2++) {
      const bindGroup = this.device.createBindGroup({
        layout: bindGroupLayout,
        entries: [
          {
            binding: 0,
            resource: this.mipmapSampler,
          },
          {
            binding: 1,
            resource: srcView,
          },
        ],
      });
      const dstView = textureGPU.createView({
        baseMipLevel: i2,
        mipLevelCount: 1,
        dimension: GPUTextureViewDimension.TwoD,
        baseArrayLayer,
      });
      const passDescriptor = {
        colorAttachments: [
          {
            view: dstView,
            loadOp: GPULoadOp.Clear,
            storeOp: GPUStoreOp.Store,
            clearValue: [0, 0, 0, 0],
          },
        ],
      };
      const passEncoder = this.device.createRenderBundleEncoder({
        colorFormats: [textureGPUDescriptor.format],
      });
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4, 1, 0, 0);
      passes.push({
        renderBundles: [passEncoder.finish()],
        passDescriptor,
      });
      srcView = dstView;
    }
    return passes;
  }
  /**
   * Executes the render bundles.
   *
   * @param {GPUCommandEncoder} commandEncoder - The GPU command encoder.
   * @param {Array<Object>} passes - An array of render bundles.
   */
  _mipmapRunBundles(commandEncoder, passes) {
    const levels = passes.length;
    for (let i2 = 0; i2 < levels; i2++) {
      const pass2 = passes[i2];
      const passEncoder = commandEncoder.beginRenderPass(pass2.passDescriptor);
      passEncoder.executeBundles(pass2.renderBundles);
      passEncoder.end();
    }
  }
}
const _compareToWebGPU = {
  [NeverCompare]: "never",
  [LessCompare]: "less",
  [EqualCompare]: "equal",
  [LessEqualCompare]: "less-equal",
  [GreaterCompare]: "greater",
  [GreaterEqualCompare]: "greater-equal",
  [AlwaysCompare]: "always",
  [NotEqualCompare]: "not-equal",
};
const _flipMap = [0, 1, 3, 2, 4, 5];
class WebGPUTextureUtils {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
    this._passUtils = null;
    this.defaultTexture = {};
    this.defaultCubeTexture = {};
    this.defaultVideoFrame = null;
    this.colorBuffer = null;
    this.depthTexture = new DepthTexture();
    this.depthTexture.name = "depthBuffer";
  }
  /**
   * Creates a GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to create the sampler for.
   */
  createSampler(texture2) {
    const backend = this.backend;
    const device = backend.device;
    const textureGPU = backend.get(texture2);
    const samplerDescriptorGPU = {
      addressModeU: this._convertAddressMode(texture2.wrapS),
      addressModeV: this._convertAddressMode(texture2.wrapT),
      addressModeW: this._convertAddressMode(texture2.wrapR),
      magFilter: this._convertFilterMode(texture2.magFilter),
      minFilter: this._convertFilterMode(texture2.minFilter),
      mipmapFilter: this._convertFilterMode(texture2.minFilter),
      maxAnisotropy: 1,
    };
    if (
      samplerDescriptorGPU.magFilter === GPUFilterMode.Linear &&
      samplerDescriptorGPU.minFilter === GPUFilterMode.Linear &&
      samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear
    ) {
      samplerDescriptorGPU.maxAnisotropy = texture2.anisotropy;
    }
    if (texture2.isDepthTexture && texture2.compareFunction !== null) {
      samplerDescriptorGPU.compare = _compareToWebGPU[texture2.compareFunction];
    }
    textureGPU.sampler = device.createSampler(samplerDescriptorGPU);
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(texture2) {
    let textureGPU;
    const format = getFormat(texture2);
    if (texture2.isCubeTexture) {
      textureGPU = this._getDefaultCubeTextureGPU(format);
    } else {
      textureGPU = this._getDefaultTextureGPU(format);
    }
    this.backend.get(texture2).texture = textureGPU;
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(texture2, options = {}) {
    const backend = this.backend;
    const textureData = backend.get(texture2);
    if (textureData.initialized) {
      throw new Error("WebGPUTextureUtils: Texture already initialized.");
    }
    if (options.needsMipmaps === void 0) options.needsMipmaps = false;
    if (options.levels === void 0) options.levels = 1;
    if (options.depth === void 0) options.depth = 1;
    const { width, height, depth: depth2, levels } = options;
    if (texture2.isFramebufferTexture) {
      if (options.renderTarget) {
        options.format = this.backend.utils.getCurrentColorFormat(
          options.renderTarget
        );
      } else {
        options.format = this.backend.utils.getPreferredCanvasFormat();
      }
    }
    const dimension = this._getDimension(texture2);
    const format =
      texture2.internalFormat ||
      options.format ||
      getFormat(texture2, backend.device);
    textureData.format = format;
    const { samples, primarySamples, isMSAA } =
      backend.utils.getTextureSampleData(texture2);
    let usage =
      GPUTextureUsage.TEXTURE_BINDING |
      GPUTextureUsage.COPY_DST |
      GPUTextureUsage.COPY_SRC;
    if (texture2.isStorageTexture === true) {
      usage |= GPUTextureUsage.STORAGE_BINDING;
    }
    if (
      texture2.isCompressedTexture !== true &&
      texture2.isCompressedArrayTexture !== true
    ) {
      usage |= GPUTextureUsage.RENDER_ATTACHMENT;
    }
    const textureDescriptorGPU = {
      label: texture2.name,
      size: {
        width,
        height,
        depthOrArrayLayers: depth2,
      },
      mipLevelCount: levels,
      sampleCount: primarySamples,
      dimension,
      format,
      usage,
    };
    if (format === void 0) {
      console.warn("WebGPURenderer: Texture format not supported.");
      this.createDefaultTexture(texture2);
      return;
    }
    if (texture2.isCubeTexture) {
      textureDescriptorGPU.textureBindingViewDimension =
        GPUTextureViewDimension.Cube;
    }
    textureData.texture = backend.device.createTexture(textureDescriptorGPU);
    if (isMSAA) {
      const msaaTextureDescriptorGPU = Object.assign({}, textureDescriptorGPU);
      msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + "-msaa";
      msaaTextureDescriptorGPU.sampleCount = samples;
      textureData.msaaTexture = backend.device.createTexture(
        msaaTextureDescriptorGPU
      );
    }
    textureData.initialized = true;
    textureData.textureDescriptorGPU = textureDescriptorGPU;
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   */
  destroyTexture(texture2) {
    const backend = this.backend;
    const textureData = backend.get(texture2);
    if (textureData.texture !== void 0) textureData.texture.destroy();
    if (textureData.msaaTexture !== void 0) textureData.msaaTexture.destroy();
    backend.delete(texture2);
  }
  /**
   * Destroys the GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to destroy the sampler for.
   */
  destroySampler(texture2) {
    const backend = this.backend;
    const textureData = backend.get(texture2);
    delete textureData.sampler;
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(texture2) {
    const textureData = this.backend.get(texture2);
    if (texture2.isCubeTexture) {
      for (let i2 = 0; i2 < 6; i2++) {
        this._generateMipmaps(
          textureData.texture,
          textureData.textureDescriptorGPU,
          i2
        );
      }
    } else {
      const depth2 = texture2.image.depth || 1;
      for (let i2 = 0; i2 < depth2; i2++) {
        this._generateMipmaps(
          textureData.texture,
          textureData.textureDescriptorGPU,
          i2
        );
      }
    }
  }
  /**
   * Returns the color buffer representing the color
   * attachment of the default framebuffer.
   *
   * @return {GPUTexture} The color buffer.
   */
  getColorBuffer() {
    if (this.colorBuffer) this.colorBuffer.destroy();
    const backend = this.backend;
    const { width, height } = backend.getDrawingBufferSize();
    this.colorBuffer = backend.device.createTexture({
      label: "colorBuffer",
      size: {
        width,
        height,
        depthOrArrayLayers: 1,
      },
      sampleCount: backend.utils.getSampleCount(backend.renderer.samples),
      format: backend.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
    });
    return this.colorBuffer;
  }
  /**
   * Returns the depth buffer representing the depth
   * attachment of the default framebuffer.
   *
   * @param {boolean} [depth=true] - Whether depth is enabled or not.
   * @param {boolean} [stencil=false] -  Whether stencil is enabled or not.
   * @return {GPUTexture} The depth buffer.
   */
  getDepthBuffer(depth2 = true, stencil = false) {
    const backend = this.backend;
    const { width, height } = backend.getDrawingBufferSize();
    const depthTexture = this.depthTexture;
    const depthTextureGPU = backend.get(depthTexture).texture;
    let format, type;
    if (stencil) {
      format = DepthStencilFormat;
      type = UnsignedInt248Type;
    } else if (depth2) {
      format = DepthFormat;
      type = UnsignedIntType;
    }
    if (depthTextureGPU !== void 0) {
      if (
        depthTexture.image.width === width &&
        depthTexture.image.height === height &&
        depthTexture.format === format &&
        depthTexture.type === type
      ) {
        return depthTextureGPU;
      }
      this.destroyTexture(depthTexture);
    }
    depthTexture.name = "depthBuffer";
    depthTexture.format = format;
    depthTexture.type = type;
    depthTexture.image.width = width;
    depthTexture.image.height = height;
    this.createTexture(depthTexture, { width, height });
    return backend.get(depthTexture).texture;
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(texture2, options) {
    const textureData = this.backend.get(texture2);
    const { textureDescriptorGPU } = textureData;
    if (texture2.isRenderTargetTexture || textureDescriptorGPU === void 0)
      return;
    if (texture2.isDataTexture) {
      this._copyBufferToTexture(
        options.image,
        textureData.texture,
        textureDescriptorGPU,
        0,
        texture2.flipY
      );
    } else if (
      texture2.isArrayTexture ||
      texture2.isDataArrayTexture ||
      texture2.isData3DTexture
    ) {
      for (let i2 = 0; i2 < options.image.depth; i2++) {
        this._copyBufferToTexture(
          options.image,
          textureData.texture,
          textureDescriptorGPU,
          i2,
          texture2.flipY,
          i2
        );
      }
    } else if (
      texture2.isCompressedTexture ||
      texture2.isCompressedArrayTexture
    ) {
      this._copyCompressedBufferToTexture(
        texture2.mipmaps,
        textureData.texture,
        textureDescriptorGPU
      );
    } else if (texture2.isCubeTexture) {
      this._copyCubeMapToTexture(
        options.images,
        textureData.texture,
        textureDescriptorGPU,
        texture2.flipY,
        texture2.premultiplyAlpha
      );
    } else {
      this._copyImageToTexture(
        options.image,
        textureData.texture,
        textureDescriptorGPU,
        0,
        texture2.flipY,
        texture2.premultiplyAlpha
      );
    }
    textureData.version = texture2.version;
    if (texture2.onUpdate) texture2.onUpdate(texture2);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(texture2, x, y, width, height, faceIndex) {
    const device = this.backend.device;
    const textureData = this.backend.get(texture2);
    const textureGPU = textureData.texture;
    const format = textureData.textureDescriptorGPU.format;
    const bytesPerTexel = this._getBytesPerTexel(format);
    let bytesPerRow = width * bytesPerTexel;
    bytesPerRow = Math.ceil(bytesPerRow / 256) * 256;
    const readBuffer = device.createBuffer({
      size: width * height * bytesPerTexel,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
    });
    const encoder = device.createCommandEncoder();
    encoder.copyTextureToBuffer(
      {
        texture: textureGPU,
        origin: { x, y, z: faceIndex },
      },
      {
        buffer: readBuffer,
        bytesPerRow,
      },
      {
        width,
        height,
      }
    );
    const typedArrayType = this._getTypedArrayType(format);
    device.queue.submit([encoder.finish()]);
    await readBuffer.mapAsync(GPUMapMode.READ);
    const buffer2 = readBuffer.getMappedRange();
    return new typedArrayType(buffer2);
  }
  /**
   * Returns the default GPU texture for the given format.
   *
   * @private
   * @param {string} format - The GPU format.
   * @return {GPUTexture} The GPU texture.
   */
  _getDefaultTextureGPU(format) {
    let defaultTexture = this.defaultTexture[format];
    if (defaultTexture === void 0) {
      const texture2 = new Texture();
      texture2.minFilter = NearestFilter;
      texture2.magFilter = NearestFilter;
      this.createTexture(texture2, { width: 1, height: 1, format });
      this.defaultTexture[format] = defaultTexture = texture2;
    }
    return this.backend.get(defaultTexture).texture;
  }
  /**
   * Returns the default GPU cube texture for the given format.
   *
   * @private
   * @param {string} format - The GPU format.
   * @return {GPUTexture} The GPU texture.
   */
  _getDefaultCubeTextureGPU(format) {
    let defaultCubeTexture = this.defaultTexture[format];
    if (defaultCubeTexture === void 0) {
      const texture2 = new CubeTexture();
      texture2.minFilter = NearestFilter;
      texture2.magFilter = NearestFilter;
      this.createTexture(texture2, { width: 1, height: 1, depth: 6 });
      this.defaultCubeTexture[format] = defaultCubeTexture = texture2;
    }
    return this.backend.get(defaultCubeTexture).texture;
  }
  /**
   * Uploads cube texture image data to the GPU memory.
   *
   * @private
   * @param {Array} images - The cube image data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
   * @param {boolean} premultiplyAlpha - Whether the texture should have its RGB channels premultiplied by the alpha channel or not.
   */
  _copyCubeMapToTexture(
    images,
    textureGPU,
    textureDescriptorGPU,
    flipY,
    premultiplyAlpha2
  ) {
    for (let i2 = 0; i2 < 6; i2++) {
      const image = images[i2];
      const flipIndex = flipY === true ? _flipMap[i2] : i2;
      if (image.isDataTexture) {
        this._copyBufferToTexture(
          image.image,
          textureGPU,
          textureDescriptorGPU,
          flipIndex,
          flipY
        );
      } else {
        this._copyImageToTexture(
          image,
          textureGPU,
          textureDescriptorGPU,
          flipIndex,
          flipY,
          premultiplyAlpha2
        );
      }
    }
  }
  /**
   * Uploads texture image data to the GPU memory.
   *
   * @private
   * @param {HTMLImageElement|ImageBitmap|HTMLCanvasElement} image - The image data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   * @param {number} originDepth - The origin depth.
   * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
   * @param {boolean} premultiplyAlpha - Whether the texture should have its RGB channels premultiplied by the alpha channel or not.
   */
  _copyImageToTexture(
    image,
    textureGPU,
    textureDescriptorGPU,
    originDepth,
    flipY,
    premultiplyAlpha2
  ) {
    const device = this.backend.device;
    device.queue.copyExternalImageToTexture(
      {
        source: image,
        flipY,
      },
      {
        texture: textureGPU,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: originDepth },
        premultipliedAlpha: premultiplyAlpha2,
      },
      {
        width: textureDescriptorGPU.size.width,
        height: textureDescriptorGPU.size.height,
        depthOrArrayLayers: 1,
      }
    );
  }
  /**
   * Returns the pass utils singleton.
   *
   * @private
   * @return {WebGPUTexturePassUtils} The utils instance.
   */
  _getPassUtils() {
    let passUtils = this._passUtils;
    if (passUtils === null) {
      this._passUtils = passUtils = new WebGPUTexturePassUtils(
        this.backend.device
      );
    }
    return passUtils;
  }
  /**
   * Generates mipmaps for the given GPU texture.
   *
   * @private
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureDescriptorGPU - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   */
  _generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer = 0) {
    this._getPassUtils().generateMipmaps(
      textureGPU,
      textureDescriptorGPU,
      baseArrayLayer
    );
  }
  /**
   * Flip the contents of the given GPU texture along its vertical axis.
   *
   * @private
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureDescriptorGPU - The texture descriptor.
   * @param {number} [originDepth=0] - The origin depth.
   */
  _flipY(textureGPU, textureDescriptorGPU, originDepth = 0) {
    this._getPassUtils().flipY(textureGPU, textureDescriptorGPU, originDepth);
  }
  /**
   * Uploads texture buffer data to the GPU memory.
   *
   * @private
   * @param {Object} image - An object defining the image buffer data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   * @param {number} originDepth - The origin depth.
   * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
   * @param {number} [depth=0] - TODO.
   */
  _copyBufferToTexture(
    image,
    textureGPU,
    textureDescriptorGPU,
    originDepth,
    flipY,
    depth2 = 0
  ) {
    const device = this.backend.device;
    const data = image.data;
    const bytesPerTexel = this._getBytesPerTexel(textureDescriptorGPU.format);
    const bytesPerRow = image.width * bytesPerTexel;
    device.queue.writeTexture(
      {
        texture: textureGPU,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: originDepth },
      },
      data,
      {
        offset: image.width * image.height * bytesPerTexel * depth2,
        bytesPerRow,
      },
      {
        width: image.width,
        height: image.height,
        depthOrArrayLayers: 1,
      }
    );
    if (flipY === true) {
      this._flipY(textureGPU, textureDescriptorGPU, originDepth);
    }
  }
  /**
   * Uploads compressed texture data to the GPU memory.
   *
   * @private
   * @param {Array<Object>} mipmaps - An array with mipmap data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   */
  _copyCompressedBufferToTexture(mipmaps, textureGPU, textureDescriptorGPU) {
    const device = this.backend.device;
    const blockData = this._getBlockData(textureDescriptorGPU.format);
    const isArrayTexture = textureDescriptorGPU.size.depthOrArrayLayers > 1;
    for (let i2 = 0; i2 < mipmaps.length; i2++) {
      const mipmap = mipmaps[i2];
      const width = mipmap.width;
      const height = mipmap.height;
      const depth2 = isArrayTexture
        ? textureDescriptorGPU.size.depthOrArrayLayers
        : 1;
      const bytesPerRow =
        Math.ceil(width / blockData.width) * blockData.byteLength;
      const bytesPerImage = bytesPerRow * Math.ceil(height / blockData.height);
      for (let j = 0; j < depth2; j++) {
        device.queue.writeTexture(
          {
            texture: textureGPU,
            mipLevel: i2,
            origin: { x: 0, y: 0, z: j },
          },
          mipmap.data,
          {
            offset: j * bytesPerImage,
            bytesPerRow,
            rowsPerImage: Math.ceil(height / blockData.height),
          },
          {
            width: Math.ceil(width / blockData.width) * blockData.width,
            height: Math.ceil(height / blockData.height) * blockData.height,
            depthOrArrayLayers: 1,
          }
        );
      }
    }
  }
  /**
   * This method is only relevant for compressed texture formats. It returns a block
   * data descriptor for the given GPU compressed texture format.
   *
   * @private
   * @param {string} format - The GPU compressed texture format.
   * @return {Object} The block data descriptor.
   */
  _getBlockData(format) {
    if (
      format === GPUTextureFormat.BC1RGBAUnorm ||
      format === GPUTextureFormat.BC1RGBAUnormSRGB
    )
      return { byteLength: 8, width: 4, height: 4 };
    if (
      format === GPUTextureFormat.BC2RGBAUnorm ||
      format === GPUTextureFormat.BC2RGBAUnormSRGB
    )
      return { byteLength: 16, width: 4, height: 4 };
    if (
      format === GPUTextureFormat.BC3RGBAUnorm ||
      format === GPUTextureFormat.BC3RGBAUnormSRGB
    )
      return { byteLength: 16, width: 4, height: 4 };
    if (
      format === GPUTextureFormat.BC4RUnorm ||
      format === GPUTextureFormat.BC4RSnorm
    )
      return { byteLength: 8, width: 4, height: 4 };
    if (
      format === GPUTextureFormat.BC5RGUnorm ||
      format === GPUTextureFormat.BC5RGSnorm
    )
      return { byteLength: 16, width: 4, height: 4 };
    if (
      format === GPUTextureFormat.BC6HRGBUFloat ||
      format === GPUTextureFormat.BC6HRGBFloat
    )
      return { byteLength: 16, width: 4, height: 4 };
    if (
      format === GPUTextureFormat.BC7RGBAUnorm ||
      format === GPUTextureFormat.BC7RGBAUnormSRGB
    )
      return { byteLength: 16, width: 4, height: 4 };
    if (
      format === GPUTextureFormat.ETC2RGB8Unorm ||
      format === GPUTextureFormat.ETC2RGB8UnormSRGB
    )
      return { byteLength: 8, width: 4, height: 4 };
    if (
      format === GPUTextureFormat.ETC2RGB8A1Unorm ||
      format === GPUTextureFormat.ETC2RGB8A1UnormSRGB
    )
      return { byteLength: 8, width: 4, height: 4 };
    if (
      format === GPUTextureFormat.ETC2RGBA8Unorm ||
      format === GPUTextureFormat.ETC2RGBA8UnormSRGB
    )
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACR11Unorm)
      return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACR11Snorm)
      return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACRG11Unorm)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACRG11Snorm)
      return { byteLength: 16, width: 4, height: 4 };
    if (
      format === GPUTextureFormat.ASTC4x4Unorm ||
      format === GPUTextureFormat.ASTC4x4UnormSRGB
    )
      return { byteLength: 16, width: 4, height: 4 };
    if (
      format === GPUTextureFormat.ASTC5x4Unorm ||
      format === GPUTextureFormat.ASTC5x4UnormSRGB
    )
      return { byteLength: 16, width: 5, height: 4 };
    if (
      format === GPUTextureFormat.ASTC5x5Unorm ||
      format === GPUTextureFormat.ASTC5x5UnormSRGB
    )
      return { byteLength: 16, width: 5, height: 5 };
    if (
      format === GPUTextureFormat.ASTC6x5Unorm ||
      format === GPUTextureFormat.ASTC6x5UnormSRGB
    )
      return { byteLength: 16, width: 6, height: 5 };
    if (
      format === GPUTextureFormat.ASTC6x6Unorm ||
      format === GPUTextureFormat.ASTC6x6UnormSRGB
    )
      return { byteLength: 16, width: 6, height: 6 };
    if (
      format === GPUTextureFormat.ASTC8x5Unorm ||
      format === GPUTextureFormat.ASTC8x5UnormSRGB
    )
      return { byteLength: 16, width: 8, height: 5 };
    if (
      format === GPUTextureFormat.ASTC8x6Unorm ||
      format === GPUTextureFormat.ASTC8x6UnormSRGB
    )
      return { byteLength: 16, width: 8, height: 6 };
    if (
      format === GPUTextureFormat.ASTC8x8Unorm ||
      format === GPUTextureFormat.ASTC8x8UnormSRGB
    )
      return { byteLength: 16, width: 8, height: 8 };
    if (
      format === GPUTextureFormat.ASTC10x5Unorm ||
      format === GPUTextureFormat.ASTC10x5UnormSRGB
    )
      return { byteLength: 16, width: 10, height: 5 };
    if (
      format === GPUTextureFormat.ASTC10x6Unorm ||
      format === GPUTextureFormat.ASTC10x6UnormSRGB
    )
      return { byteLength: 16, width: 10, height: 6 };
    if (
      format === GPUTextureFormat.ASTC10x8Unorm ||
      format === GPUTextureFormat.ASTC10x8UnormSRGB
    )
      return { byteLength: 16, width: 10, height: 8 };
    if (
      format === GPUTextureFormat.ASTC10x10Unorm ||
      format === GPUTextureFormat.ASTC10x10UnormSRGB
    )
      return { byteLength: 16, width: 10, height: 10 };
    if (
      format === GPUTextureFormat.ASTC12x10Unorm ||
      format === GPUTextureFormat.ASTC12x10UnormSRGB
    )
      return { byteLength: 16, width: 12, height: 10 };
    if (
      format === GPUTextureFormat.ASTC12x12Unorm ||
      format === GPUTextureFormat.ASTC12x12UnormSRGB
    )
      return { byteLength: 16, width: 12, height: 12 };
  }
  /**
   * Converts the three.js uv wrapping constants to GPU address mode constants.
   *
   * @private
   * @param {number} value - The three.js constant defining a uv wrapping mode.
   * @return {string} The GPU address mode.
   */
  _convertAddressMode(value) {
    let addressMode = GPUAddressMode.ClampToEdge;
    if (value === RepeatWrapping) {
      addressMode = GPUAddressMode.Repeat;
    } else if (value === MirroredRepeatWrapping) {
      addressMode = GPUAddressMode.MirrorRepeat;
    }
    return addressMode;
  }
  /**
   * Converts the three.js filter constants to GPU filter constants.
   *
   * @private
   * @param {number} value - The three.js constant defining a filter mode.
   * @return {string} The GPU filter mode.
   */
  _convertFilterMode(value) {
    let filterMode = GPUFilterMode.Linear;
    if (
      value === NearestFilter ||
      value === NearestMipmapNearestFilter ||
      value === NearestMipmapLinearFilter
    ) {
      filterMode = GPUFilterMode.Nearest;
    }
    return filterMode;
  }
  /**
   * Returns the bytes-per-texel value for the given GPU texture format.
   *
   * @private
   * @param {string} format - The GPU texture format.
   * @return {number} The bytes-per-texel.
   */
  _getBytesPerTexel(format) {
    if (
      format === GPUTextureFormat.R8Unorm ||
      format === GPUTextureFormat.R8Snorm ||
      format === GPUTextureFormat.R8Uint ||
      format === GPUTextureFormat.R8Sint
    )
      return 1;
    if (
      format === GPUTextureFormat.R16Uint ||
      format === GPUTextureFormat.R16Sint ||
      format === GPUTextureFormat.R16Float ||
      format === GPUTextureFormat.RG8Unorm ||
      format === GPUTextureFormat.RG8Snorm ||
      format === GPUTextureFormat.RG8Uint ||
      format === GPUTextureFormat.RG8Sint
    )
      return 2;
    if (
      format === GPUTextureFormat.R32Uint ||
      format === GPUTextureFormat.R32Sint ||
      format === GPUTextureFormat.R32Float ||
      format === GPUTextureFormat.RG16Uint ||
      format === GPUTextureFormat.RG16Sint ||
      format === GPUTextureFormat.RG16Float ||
      format === GPUTextureFormat.RGBA8Unorm ||
      format === GPUTextureFormat.RGBA8UnormSRGB ||
      format === GPUTextureFormat.RGBA8Snorm ||
      format === GPUTextureFormat.RGBA8Uint ||
      format === GPUTextureFormat.RGBA8Sint ||
      format === GPUTextureFormat.BGRA8Unorm ||
      format === GPUTextureFormat.BGRA8UnormSRGB || // Packed 32-bit formats
      format === GPUTextureFormat.RGB9E5UFloat ||
      format === GPUTextureFormat.RGB10A2Unorm ||
      format === GPUTextureFormat.RG11B10UFloat ||
      format === GPUTextureFormat.Depth32Float ||
      format === GPUTextureFormat.Depth24Plus ||
      format === GPUTextureFormat.Depth24PlusStencil8 ||
      format === GPUTextureFormat.Depth32FloatStencil8
    )
      return 4;
    if (
      format === GPUTextureFormat.RG32Uint ||
      format === GPUTextureFormat.RG32Sint ||
      format === GPUTextureFormat.RG32Float ||
      format === GPUTextureFormat.RGBA16Uint ||
      format === GPUTextureFormat.RGBA16Sint ||
      format === GPUTextureFormat.RGBA16Float
    )
      return 8;
    if (
      format === GPUTextureFormat.RGBA32Uint ||
      format === GPUTextureFormat.RGBA32Sint ||
      format === GPUTextureFormat.RGBA32Float
    )
      return 16;
  }
  /**
   * Returns the corresponding typed array type for the given GPU texture format.
   *
   * @private
   * @param {string} format - The GPU texture format.
   * @return {TypedArray.constructor} The typed array type.
   */
  _getTypedArrayType(format) {
    if (format === GPUTextureFormat.R8Uint) return Uint8Array;
    if (format === GPUTextureFormat.R8Sint) return Int8Array;
    if (format === GPUTextureFormat.R8Unorm) return Uint8Array;
    if (format === GPUTextureFormat.R8Snorm) return Int8Array;
    if (format === GPUTextureFormat.RG8Uint) return Uint8Array;
    if (format === GPUTextureFormat.RG8Sint) return Int8Array;
    if (format === GPUTextureFormat.RG8Unorm) return Uint8Array;
    if (format === GPUTextureFormat.RG8Snorm) return Int8Array;
    if (format === GPUTextureFormat.RGBA8Uint) return Uint8Array;
    if (format === GPUTextureFormat.RGBA8Sint) return Int8Array;
    if (format === GPUTextureFormat.RGBA8Unorm) return Uint8Array;
    if (format === GPUTextureFormat.RGBA8Snorm) return Int8Array;
    if (format === GPUTextureFormat.R16Uint) return Uint16Array;
    if (format === GPUTextureFormat.R16Sint) return Int16Array;
    if (format === GPUTextureFormat.RG16Uint) return Uint16Array;
    if (format === GPUTextureFormat.RG16Sint) return Int16Array;
    if (format === GPUTextureFormat.RGBA16Uint) return Uint16Array;
    if (format === GPUTextureFormat.RGBA16Sint) return Int16Array;
    if (format === GPUTextureFormat.R16Float) return Uint16Array;
    if (format === GPUTextureFormat.RG16Float) return Uint16Array;
    if (format === GPUTextureFormat.RGBA16Float) return Uint16Array;
    if (format === GPUTextureFormat.R32Uint) return Uint32Array;
    if (format === GPUTextureFormat.R32Sint) return Int32Array;
    if (format === GPUTextureFormat.R32Float) return Float32Array;
    if (format === GPUTextureFormat.RG32Uint) return Uint32Array;
    if (format === GPUTextureFormat.RG32Sint) return Int32Array;
    if (format === GPUTextureFormat.RG32Float) return Float32Array;
    if (format === GPUTextureFormat.RGBA32Uint) return Uint32Array;
    if (format === GPUTextureFormat.RGBA32Sint) return Int32Array;
    if (format === GPUTextureFormat.RGBA32Float) return Float32Array;
    if (format === GPUTextureFormat.BGRA8Unorm) return Uint8Array;
    if (format === GPUTextureFormat.BGRA8UnormSRGB) return Uint8Array;
    if (format === GPUTextureFormat.RGB10A2Unorm) return Uint32Array;
    if (format === GPUTextureFormat.RGB9E5UFloat) return Uint32Array;
    if (format === GPUTextureFormat.RG11B10UFloat) return Uint32Array;
    if (format === GPUTextureFormat.Depth32Float) return Float32Array;
    if (format === GPUTextureFormat.Depth24Plus) return Uint32Array;
    if (format === GPUTextureFormat.Depth24PlusStencil8) return Uint32Array;
    if (format === GPUTextureFormat.Depth32FloatStencil8) return Float32Array;
  }
  /**
   * Returns the GPU dimensions for the given texture.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @return {string} The GPU dimension.
   */
  _getDimension(texture2) {
    let dimension;
    if (texture2.is3DTexture || texture2.isData3DTexture) {
      dimension = GPUTextureDimension.ThreeD;
    } else {
      dimension = GPUTextureDimension.TwoD;
    }
    return dimension;
  }
}
function getFormat(texture2, device = null) {
  const format = texture2.format;
  const type = texture2.type;
  const colorSpace = texture2.colorSpace;
  const transfer = ColorManagement.getTransfer(colorSpace);
  let formatGPU;
  if (
    texture2.isCompressedTexture === true ||
    texture2.isCompressedArrayTexture === true
  ) {
    switch (format) {
      case RGBA_S3TC_DXT1_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.BC1RGBAUnormSRGB
            : GPUTextureFormat.BC1RGBAUnorm;
        break;
      case RGBA_S3TC_DXT3_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.BC2RGBAUnormSRGB
            : GPUTextureFormat.BC2RGBAUnorm;
        break;
      case RGBA_S3TC_DXT5_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.BC3RGBAUnormSRGB
            : GPUTextureFormat.BC3RGBAUnorm;
        break;
      case RGB_ETC2_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ETC2RGB8UnormSRGB
            : GPUTextureFormat.ETC2RGB8Unorm;
        break;
      case RGBA_ETC2_EAC_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ETC2RGBA8UnormSRGB
            : GPUTextureFormat.ETC2RGBA8Unorm;
        break;
      case RGBA_ASTC_4x4_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ASTC4x4UnormSRGB
            : GPUTextureFormat.ASTC4x4Unorm;
        break;
      case RGBA_ASTC_5x4_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ASTC5x4UnormSRGB
            : GPUTextureFormat.ASTC5x4Unorm;
        break;
      case RGBA_ASTC_5x5_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ASTC5x5UnormSRGB
            : GPUTextureFormat.ASTC5x5Unorm;
        break;
      case RGBA_ASTC_6x5_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ASTC6x5UnormSRGB
            : GPUTextureFormat.ASTC6x5Unorm;
        break;
      case RGBA_ASTC_6x6_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ASTC6x6UnormSRGB
            : GPUTextureFormat.ASTC6x6Unorm;
        break;
      case RGBA_ASTC_8x5_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ASTC8x5UnormSRGB
            : GPUTextureFormat.ASTC8x5Unorm;
        break;
      case RGBA_ASTC_8x6_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ASTC8x6UnormSRGB
            : GPUTextureFormat.ASTC8x6Unorm;
        break;
      case RGBA_ASTC_8x8_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ASTC8x8UnormSRGB
            : GPUTextureFormat.ASTC8x8Unorm;
        break;
      case RGBA_ASTC_10x5_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ASTC10x5UnormSRGB
            : GPUTextureFormat.ASTC10x5Unorm;
        break;
      case RGBA_ASTC_10x6_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ASTC10x6UnormSRGB
            : GPUTextureFormat.ASTC10x6Unorm;
        break;
      case RGBA_ASTC_10x8_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ASTC10x8UnormSRGB
            : GPUTextureFormat.ASTC10x8Unorm;
        break;
      case RGBA_ASTC_10x10_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ASTC10x10UnormSRGB
            : GPUTextureFormat.ASTC10x10Unorm;
        break;
      case RGBA_ASTC_12x10_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ASTC12x10UnormSRGB
            : GPUTextureFormat.ASTC12x10Unorm;
        break;
      case RGBA_ASTC_12x12_Format:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.ASTC12x12UnormSRGB
            : GPUTextureFormat.ASTC12x12Unorm;
        break;
      case RGBAFormat:
        formatGPU =
          transfer === SRGBTransfer
            ? GPUTextureFormat.RGBA8UnormSRGB
            : GPUTextureFormat.RGBA8Unorm;
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", format);
    }
  } else {
    switch (format) {
      case RGBAFormat:
        switch (type) {
          case ByteType:
            formatGPU = GPUTextureFormat.RGBA8Snorm;
            break;
          case ShortType:
            formatGPU = GPUTextureFormat.RGBA16Sint;
            break;
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.RGBA16Uint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RGBA32Uint;
            break;
          case IntType:
            formatGPU = GPUTextureFormat.RGBA32Sint;
            break;
          case UnsignedByteType:
            formatGPU =
              transfer === SRGBTransfer
                ? GPUTextureFormat.RGBA8UnormSRGB
                : GPUTextureFormat.RGBA8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.RGBA16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.RGBA32Float;
            break;
          default:
            console.error(
              "WebGPURenderer: Unsupported texture type with RGBAFormat.",
              type
            );
        }
        break;
      case RGBFormat:
        switch (type) {
          case UnsignedInt5999Type:
            formatGPU = GPUTextureFormat.RGB9E5UFloat;
            break;
          default:
            console.error(
              "WebGPURenderer: Unsupported texture type with RGBFormat.",
              type
            );
        }
        break;
      case RedFormat:
        switch (type) {
          case ByteType:
            formatGPU = GPUTextureFormat.R8Snorm;
            break;
          case ShortType:
            formatGPU = GPUTextureFormat.R16Sint;
            break;
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.R16Uint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.R32Uint;
            break;
          case IntType:
            formatGPU = GPUTextureFormat.R32Sint;
            break;
          case UnsignedByteType:
            formatGPU = GPUTextureFormat.R8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.R16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.R32Float;
            break;
          default:
            console.error(
              "WebGPURenderer: Unsupported texture type with RedFormat.",
              type
            );
        }
        break;
      case RGFormat:
        switch (type) {
          case ByteType:
            formatGPU = GPUTextureFormat.RG8Snorm;
            break;
          case ShortType:
            formatGPU = GPUTextureFormat.RG16Sint;
            break;
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.RG16Uint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RG32Uint;
            break;
          case IntType:
            formatGPU = GPUTextureFormat.RG32Sint;
            break;
          case UnsignedByteType:
            formatGPU = GPUTextureFormat.RG8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.RG16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.RG32Float;
            break;
          default:
            console.error(
              "WebGPURenderer: Unsupported texture type with RGFormat.",
              type
            );
        }
        break;
      case DepthFormat:
        switch (type) {
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.Depth16Unorm;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.Depth24Plus;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.Depth32Float;
            break;
          default:
            console.error(
              "WebGPURenderer: Unsupported texture type with DepthFormat.",
              type
            );
        }
        break;
      case DepthStencilFormat:
        switch (type) {
          case UnsignedInt248Type:
            formatGPU = GPUTextureFormat.Depth24PlusStencil8;
            break;
          case FloatType:
            if (
              device &&
              device.features.has(GPUFeatureName.Depth32FloatStencil8) === false
            ) {
              console.error(
                'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.'
              );
            }
            formatGPU = GPUTextureFormat.Depth32FloatStencil8;
            break;
          default:
            console.error(
              "WebGPURenderer: Unsupported texture type with DepthStencilFormat.",
              type
            );
        }
        break;
      case RedIntegerFormat:
        switch (type) {
          case IntType:
            formatGPU = GPUTextureFormat.R32Sint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.R32Uint;
            break;
          default:
            console.error(
              "WebGPURenderer: Unsupported texture type with RedIntegerFormat.",
              type
            );
        }
        break;
      case RGIntegerFormat:
        switch (type) {
          case IntType:
            formatGPU = GPUTextureFormat.RG32Sint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RG32Uint;
            break;
          default:
            console.error(
              "WebGPURenderer: Unsupported texture type with RGIntegerFormat.",
              type
            );
        }
        break;
      case RGBAIntegerFormat:
        switch (type) {
          case IntType:
            formatGPU = GPUTextureFormat.RGBA32Sint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RGBA32Uint;
            break;
          default:
            console.error(
              "WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.",
              type
            );
        }
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", format);
    }
  }
  return formatGPU;
}
const declarationRegexp =
  /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i;
const propertiesRegexp = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/gi;
const wgslTypeLib$1 = {
  f32: "float",
  i32: "int",
  u32: "uint",
  bool: "bool",
  "vec2<f32>": "vec2",
  "vec2<i32>": "ivec2",
  "vec2<u32>": "uvec2",
  "vec2<bool>": "bvec2",
  vec2f: "vec2",
  vec2i: "ivec2",
  vec2u: "uvec2",
  vec2b: "bvec2",
  "vec3<f32>": "vec3",
  "vec3<i32>": "ivec3",
  "vec3<u32>": "uvec3",
  "vec3<bool>": "bvec3",
  vec3f: "vec3",
  vec3i: "ivec3",
  vec3u: "uvec3",
  vec3b: "bvec3",
  "vec4<f32>": "vec4",
  "vec4<i32>": "ivec4",
  "vec4<u32>": "uvec4",
  "vec4<bool>": "bvec4",
  vec4f: "vec4",
  vec4i: "ivec4",
  vec4u: "uvec4",
  vec4b: "bvec4",
  "mat2x2<f32>": "mat2",
  mat2x2f: "mat2",
  "mat3x3<f32>": "mat3",
  mat3x3f: "mat3",
  "mat4x4<f32>": "mat4",
  mat4x4f: "mat4",
  sampler: "sampler",
  texture_1d: "texture",
  texture_2d: "texture",
  texture_2d_array: "texture",
  texture_multisampled_2d: "cubeTexture",
  texture_depth_2d: "depthTexture",
  texture_depth_2d_array: "depthTexture",
  texture_depth_multisampled_2d: "depthTexture",
  texture_depth_cube: "depthTexture",
  texture_depth_cube_array: "depthTexture",
  texture_3d: "texture3D",
  texture_cube: "cubeTexture",
  texture_cube_array: "cubeTexture",
  texture_storage_1d: "storageTexture",
  texture_storage_2d: "storageTexture",
  texture_storage_2d_array: "storageTexture",
  texture_storage_3d: "storageTexture",
};
const parse = (source) => {
  source = source.trim();
  const declaration = source.match(declarationRegexp);
  if (declaration !== null && declaration.length === 4) {
    const inputsCode = declaration[2];
    const propsMatches = [];
    let match = null;
    while ((match = propertiesRegexp.exec(inputsCode)) !== null) {
      propsMatches.push({ name: match[1], type: match[2] });
    }
    const inputs = [];
    for (let i2 = 0; i2 < propsMatches.length; i2++) {
      const { name: name2, type: type2 } = propsMatches[i2];
      let resolvedType = type2;
      if (resolvedType.startsWith("ptr")) {
        resolvedType = "pointer";
      } else {
        if (resolvedType.startsWith("texture")) {
          resolvedType = type2.split("<")[0];
        }
        resolvedType = wgslTypeLib$1[resolvedType];
      }
      inputs.push(new NodeFunctionInput(resolvedType, name2));
    }
    const blockCode = source.substring(declaration[0].length);
    const outputType = declaration[3] || "void";
    const name = declaration[1] !== void 0 ? declaration[1] : "";
    const type = wgslTypeLib$1[outputType] || outputType;
    return {
      type,
      inputs,
      name,
      inputsCode,
      blockCode,
      outputType,
    };
  } else {
    throw new Error("FunctionNode: Function is not a WGSL code.");
  }
};
class WGSLNodeFunction extends NodeFunction {
  /**
   * Constructs a new WGSL node function.
   *
   * @param {string} source - The WGSL source.
   */
  constructor(source) {
    const { type, inputs, name, inputsCode, blockCode, outputType } =
      parse(source);
    super(type, inputs, name);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
    this.outputType = outputType;
  }
  /**
   * This method returns the WGSL code of the node function.
   *
   * @param {string} [name=this.name] - The function's name.
   * @return {string} The shader code.
   */
  getCode(name = this.name) {
    const outputType =
      this.outputType !== "void" ? "-> " + this.outputType : "";
    return (
      `fn ${name} ( ${this.inputsCode.trim()} ) ${outputType}` + this.blockCode
    );
  }
}
class WGSLNodeParser extends NodeParser {
  /**
   * The method parses the given WGSL code an returns a node function.
   *
   * @param {string} source - The WGSL code.
   * @return {WGSLNodeFunction} A node function.
   */
  parseFunction(source) {
    return new WGSLNodeFunction(source);
  }
}
const GPUShaderStage =
  typeof self !== "undefined"
    ? self.GPUShaderStage
    : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };
const accessNames = {
  [NodeAccess.READ_ONLY]: "read",
  [NodeAccess.WRITE_ONLY]: "write",
  [NodeAccess.READ_WRITE]: "read_write",
};
const wrapNames = {
  [RepeatWrapping]: "repeat",
  [ClampToEdgeWrapping]: "clamp",
  [MirroredRepeatWrapping]: "mirror",
};
const gpuShaderStageLib = {
  vertex: GPUShaderStage ? GPUShaderStage.VERTEX : 1,
  fragment: GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,
  compute: GPUShaderStage ? GPUShaderStage.COMPUTE : 4,
};
const supports = {
  instance: true,
  swizzleAssign: false,
  storageBuffer: true,
};
const wgslFnOpLib = {
  "^^": "tsl_xor",
};
const wgslTypeLib = {
  float: "f32",
  int: "i32",
  uint: "u32",
  bool: "bool",
  color: "vec3<f32>",
  vec2: "vec2<f32>",
  ivec2: "vec2<i32>",
  uvec2: "vec2<u32>",
  bvec2: "vec2<bool>",
  vec3: "vec3<f32>",
  ivec3: "vec3<i32>",
  uvec3: "vec3<u32>",
  bvec3: "vec3<bool>",
  vec4: "vec4<f32>",
  ivec4: "vec4<i32>",
  uvec4: "vec4<u32>",
  bvec4: "vec4<bool>",
  mat2: "mat2x2<f32>",
  mat3: "mat3x3<f32>",
  mat4: "mat4x4<f32>",
};
const wgslCodeCache = {};
const wgslPolyfill = {
  tsl_xor: new CodeNode(
    "fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"
  ),
  mod_float: new CodeNode(
    "fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"
  ),
  mod_vec2: new CodeNode(
    "fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"
  ),
  mod_vec3: new CodeNode(
    "fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"
  ),
  mod_vec4: new CodeNode(
    "fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"
  ),
  equals_bool: new CodeNode(
    "fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"
  ),
  equals_bvec2: new CodeNode(
    "fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"
  ),
  equals_bvec3: new CodeNode(
    "fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"
  ),
  equals_bvec4: new CodeNode(
    "fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"
  ),
  repeatWrapping_float: new CodeNode(
    "fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"
  ),
  mirrorWrapping_float: new CodeNode(
    "fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"
  ),
  clampWrapping_float: new CodeNode(
    "fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"
  ),
  biquadraticTexture: new CodeNode(
    /* wgsl */
    `
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`
  ),
};
const wgslMethods = {
  dFdx: "dpdx",
  dFdy: "- dpdy",
  mod_float: "tsl_mod_float",
  mod_vec2: "tsl_mod_vec2",
  mod_vec3: "tsl_mod_vec3",
  mod_vec4: "tsl_mod_vec4",
  equals_bool: "tsl_equals_bool",
  equals_bvec2: "tsl_equals_bvec2",
  equals_bvec3: "tsl_equals_bvec3",
  equals_bvec4: "tsl_equals_bvec4",
  inversesqrt: "inverseSqrt",
  bitcast: "bitcast<f32>",
};
if (typeof navigator !== "undefined" && /Windows/g.test(navigator.userAgent)) {
  wgslPolyfill.pow_float = new CodeNode(
    "fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }"
  );
  wgslPolyfill.pow_vec2 = new CodeNode(
    "fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }",
    [wgslPolyfill.pow_float]
  );
  wgslPolyfill.pow_vec3 = new CodeNode(
    "fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }",
    [wgslPolyfill.pow_float]
  );
  wgslPolyfill.pow_vec4 = new CodeNode(
    "fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }",
    [wgslPolyfill.pow_float]
  );
  wgslMethods.pow_float = "tsl_pow_float";
  wgslMethods.pow_vec2 = "tsl_pow_vec2";
  wgslMethods.pow_vec3 = "tsl_pow_vec3";
  wgslMethods.pow_vec4 = "tsl_pow_vec4";
}
let diagnostics = "";
if (
  (typeof navigator !== "undefined" &&
    /Firefox|Deno/g.test(navigator.userAgent)) !== true
) {
  diagnostics += "diagnostic( off, derivative_uniformity );\n";
}
class WGSLNodeBuilder extends NodeBuilder {
  /**
   * Constructs a new WGSL node builder renderer.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The renderer.
   */
  constructor(object, renderer2) {
    super(object, renderer2, new WGSLNodeParser());
    this.uniformGroups = {};
    this.builtins = {};
    this.directives = {};
    this.scopedArrays = /* @__PURE__ */ new Map();
  }
  /**
   * Generates the WGSL snippet for sampled textures.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  _generateTextureSample(
    texture2,
    textureProperty,
    uvSnippet,
    depthSnippet,
    shaderStage = this.shaderStage
  ) {
    if (shaderStage === "fragment") {
      if (depthSnippet) {
        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;
      } else {
        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;
      }
    } else {
      return this.generateTextureSampleLevel(
        texture2,
        textureProperty,
        uvSnippet,
        "0",
        depthSnippet
      );
    }
  }
  /**
   * Generates the WGSL snippet when sampling textures with explicit mip level.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @return {string} The WGSL snippet.
   */
  generateTextureSampleLevel(
    texture2,
    textureProperty,
    uvSnippet,
    levelSnippet,
    depthSnippet
  ) {
    if (this.isUnfilterable(texture2) === false) {
      return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;
    } else if (this.isFilteredTexture(texture2)) {
      return this.generateFilteredTexture(
        texture2,
        textureProperty,
        uvSnippet,
        levelSnippet
      );
    } else {
      return this.generateTextureLod(
        texture2,
        textureProperty,
        uvSnippet,
        depthSnippet,
        levelSnippet
      );
    }
  }
  /**
   * Generates a wrap function used in context of textures.
   *
   * @param {Texture} texture - The texture to generate the function for.
   * @return {string} The name of the generated function.
   */
  generateWrapFunction(texture2) {
    const functionName = `tsl_coord_${wrapNames[texture2.wrapS]}S_${
      wrapNames[texture2.wrapT]
    }_${texture2.isData3DTexture ? "3d" : "2d"}T`;
    let nodeCode = wgslCodeCache[functionName];
    if (nodeCode === void 0) {
      const includes = [];
      const coordType = texture2.isData3DTexture ? "vec3f" : "vec2f";
      let code2 = `fn ${functionName}( coord : ${coordType} ) -> ${coordType} {

	return ${coordType}(
`;
      const addWrapSnippet = (wrap, axis) => {
        if (wrap === RepeatWrapping) {
          includes.push(wgslPolyfill.repeatWrapping_float);
          code2 += `		tsl_repeatWrapping_float( coord.${axis} )`;
        } else if (wrap === ClampToEdgeWrapping) {
          includes.push(wgslPolyfill.clampWrapping_float);
          code2 += `		tsl_clampWrapping_float( coord.${axis} )`;
        } else if (wrap === MirroredRepeatWrapping) {
          includes.push(wgslPolyfill.mirrorWrapping_float);
          code2 += `		tsl_mirrorWrapping_float( coord.${axis} )`;
        } else {
          code2 += `		coord.${axis}`;
          console.warn(
            `WebGPURenderer: Unsupported texture wrap type "${wrap}" for vertex shader.`
          );
        }
      };
      addWrapSnippet(texture2.wrapS, "x");
      code2 += ",\n";
      addWrapSnippet(texture2.wrapT, "y");
      if (texture2.isData3DTexture) {
        code2 += ",\n";
        addWrapSnippet(texture2.wrapR, "z");
      }
      code2 += "\n	);\n\n}\n";
      wgslCodeCache[functionName] = nodeCode = new CodeNode(code2, includes);
    }
    nodeCode.build(this);
    return functionName;
  }
  /**
   * Generates the array declaration string.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @return {string} The generated value as a shader string.
   */
  generateArrayDeclaration(type, count) {
    return `array< ${this.getType(type)}, ${count} >`;
  }
  /**
   * Generates a WGSL variable that holds the texture dimension of the given texture.
   * It also returns information about the number of layers (elements) of an arrayed
   * texture as well as the cube face count of cube textures.
   *
   * @param {Texture} texture - The texture to generate the function for.
   * @param {string} textureProperty - The name of the video texture uniform in the shader.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The name of the dimension variable.
   */
  generateTextureDimension(texture2, textureProperty, levelSnippet) {
    const textureData = this.getDataFromNode(
      texture2,
      this.shaderStage,
      this.globalCache
    );
    if (textureData.dimensionsSnippet === void 0)
      textureData.dimensionsSnippet = {};
    let textureDimensionNode = textureData.dimensionsSnippet[levelSnippet];
    if (textureData.dimensionsSnippet[levelSnippet] === void 0) {
      let textureDimensionsParams;
      let dimensionType;
      const { primarySamples } =
        this.renderer.backend.utils.getTextureSampleData(texture2);
      const isMultisampled = primarySamples > 1;
      if (texture2.isData3DTexture) {
        dimensionType = "vec3<u32>";
      } else {
        dimensionType = "vec2<u32>";
      }
      if (isMultisampled || texture2.isStorageTexture) {
        textureDimensionsParams = textureProperty;
      } else {
        textureDimensionsParams = `${textureProperty}${
          levelSnippet ? `, u32( ${levelSnippet} )` : ""
        }`;
      }
      textureDimensionNode = new VarNode(
        new ExpressionNode(
          `textureDimensions( ${textureDimensionsParams} )`,
          dimensionType
        )
      );
      textureData.dimensionsSnippet[levelSnippet] = textureDimensionNode;
      if (
        texture2.isArrayTexture ||
        texture2.isDataArrayTexture ||
        texture2.isData3DTexture
      ) {
        textureData.arrayLayerCount = new VarNode(
          new ExpressionNode(`textureNumLayers(${textureProperty})`, "u32")
        );
      }
      if (texture2.isTextureCube) {
        textureData.cubeFaceCount = new VarNode(
          new ExpressionNode("6u", "u32")
        );
      }
    }
    return textureDimensionNode.build(this);
  }
  /**
   * Generates the WGSL snippet for a manual filtered texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The WGSL snippet.
   */
  generateFilteredTexture(
    texture2,
    textureProperty,
    uvSnippet,
    levelSnippet = "0u"
  ) {
    this._include("biquadraticTexture");
    const wrapFunction = this.generateWrapFunction(texture2);
    const textureDimension = this.generateTextureDimension(
      texture2,
      textureProperty,
      levelSnippet
    );
    return `tsl_biquadraticTexture( ${textureProperty}, ${wrapFunction}( ${uvSnippet} ), ${textureDimension}, u32( ${levelSnippet} ) )`;
  }
  /**
   * Generates the WGSL snippet for a texture lookup with explicit level-of-detail.
   * Since it's a lookup, no sampling or filtering is applied.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The WGSL snippet.
   */
  generateTextureLod(
    texture2,
    textureProperty,
    uvSnippet,
    depthSnippet,
    levelSnippet = "0u"
  ) {
    const wrapFunction = this.generateWrapFunction(texture2);
    const textureDimension = this.generateTextureDimension(
      texture2,
      textureProperty,
      levelSnippet
    );
    const vecType = texture2.isData3DTexture ? "vec3" : "vec2";
    const coordSnippet = `${vecType}<u32>( ${wrapFunction}( ${uvSnippet} ) * ${vecType}<f32>( ${textureDimension} ) )`;
    return this.generateTextureLoad(
      texture2,
      textureProperty,
      coordSnippet,
      depthSnippet,
      levelSnippet
    );
  }
  /**
   * Generates the WGSL snippet that reads a single texel from a texture without sampling or filtering.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The WGSL snippet.
   */
  generateTextureLoad(
    texture2,
    textureProperty,
    uvIndexSnippet,
    depthSnippet,
    levelSnippet = "0u"
  ) {
    let snippet;
    if (depthSnippet) {
      snippet = `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, u32( ${levelSnippet} ) )`;
    } else {
      snippet = `textureLoad( ${textureProperty}, ${uvIndexSnippet}, u32( ${levelSnippet} ) )`;
      if (this.renderer.backend.compatibilityMode && texture2.isDepthTexture) {
        snippet += ".x";
      }
    }
    return snippet;
  }
  /**
   * Generates the WGSL snippet that writes a single texel to a texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} valueSnippet - A WGSL snippet that represent the new texel value.
   * @return {string} The WGSL snippet.
   */
  generateTextureStore(
    texture2,
    textureProperty,
    uvIndexSnippet,
    depthSnippet,
    valueSnippet
  ) {
    let snippet;
    if (depthSnippet) {
      snippet = `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, ${valueSnippet} )`;
    } else {
      snippet = `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${valueSnippet} )`;
    }
    return snippet;
  }
  /**
   * Returns `true` if the sampled values of the given texture should be compared against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether the sampled values of the given texture should be compared against a reference value or not.
   */
  isSampleCompare(texture2) {
    return (
      texture2.isDepthTexture === true && texture2.compareFunction !== null
    );
  }
  /**
   * Returns `true` if the given texture is unfilterable.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether the given texture is unfilterable or not.
   */
  isUnfilterable(texture2) {
    return (
      this.getComponentTypeFromTexture(texture2) !== "float" ||
      (!this.isAvailable("float32Filterable") &&
        texture2.isDataTexture === true &&
        texture2.type === FloatType) ||
      (this.isSampleCompare(texture2) === false &&
        texture2.minFilter === NearestFilter &&
        texture2.magFilter === NearestFilter) ||
      this.renderer.backend.utils.getTextureSampleData(texture2)
        .primarySamples > 1
    );
  }
  /**
   * Generates the WGSL snippet for sampling/loading the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTexture(
    texture2,
    textureProperty,
    uvSnippet,
    depthSnippet,
    shaderStage = this.shaderStage
  ) {
    let snippet = null;
    if (this.isUnfilterable(texture2)) {
      snippet = this.generateTextureLod(
        texture2,
        textureProperty,
        uvSnippet,
        depthSnippet,
        "0",
        shaderStage
      );
    } else {
      snippet = this._generateTextureSample(
        texture2,
        textureProperty,
        uvSnippet,
        depthSnippet,
        shaderStage
      );
    }
    return snippet;
  }
  /**
   * Generates the WGSL snippet for sampling/loading the given texture using explicit gradients.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {Array<string>} gradSnippet - An array holding both gradient WGSL snippets.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureGrad(
    texture2,
    textureProperty,
    uvSnippet,
    gradSnippet,
    depthSnippet,
    shaderStage = this.shaderStage
  ) {
    if (shaderStage === "fragment") {
      return `textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]} )`;
    } else {
      console.error(
        `WebGPURenderer: THREE.TextureNode.gradient() does not support ${shaderStage} shader.`
      );
    }
  }
  /**
   * Generates the WGSL snippet for sampling a depth texture and comparing the sampled depth values
   * against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} compareSnippet -  A WGSL snippet that represents the reference value.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureCompare(
    texture2,
    textureProperty,
    uvSnippet,
    compareSnippet,
    depthSnippet,
    shaderStage = this.shaderStage
  ) {
    if (shaderStage === "fragment") {
      if (
        texture2.isDepthTexture === true &&
        texture2.isArrayTexture === true
      ) {
        return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet}, ${compareSnippet} )`;
      }
      return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;
    } else {
      console.error(
        `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`
      );
    }
  }
  /**
   * Generates the WGSL snippet when sampling textures with explicit mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureLevel(
    texture2,
    textureProperty,
    uvSnippet,
    levelSnippet,
    depthSnippet
  ) {
    if (this.isUnfilterable(texture2) === false) {
      return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;
    } else if (this.isFilteredTexture(texture2)) {
      return this.generateFilteredTexture(
        texture2,
        textureProperty,
        uvSnippet,
        levelSnippet
      );
    } else {
      return this.generateTextureLod(
        texture2,
        textureProperty,
        uvSnippet,
        depthSnippet,
        levelSnippet
      );
    }
  }
  /**
   * Generates the WGSL snippet when sampling textures with a bias to the mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} biasSnippet - A WGSL snippet that represents the bias to apply to the mip level before sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureBias(
    texture2,
    textureProperty,
    uvSnippet,
    biasSnippet,
    depthSnippet,
    shaderStage = this.shaderStage
  ) {
    if (shaderStage === "fragment") {
      return `textureSampleBias( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;
    } else {
      console.error(
        `WebGPURenderer: THREE.TextureNode.biasNode does not support ${shaderStage} shader.`
      );
    }
  }
  /**
   * Returns a WGSL snippet that represents the property name of the given node.
   *
   * @param {Node} node - The node.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getPropertyName(node, shaderStage = this.shaderStage) {
    if (node.isNodeVarying === true && node.needsInterpolation === true) {
      if (shaderStage === "vertex") {
        return `varyings.${node.name}`;
      }
    } else if (node.isNodeUniform === true) {
      const name = node.name;
      const type = node.type;
      if (
        type === "texture" ||
        type === "cubeTexture" ||
        type === "storageTexture" ||
        type === "texture3D"
      ) {
        return name;
      } else if (
        type === "buffer" ||
        type === "storageBuffer" ||
        type === "indirectStorageBuffer"
      ) {
        if (this.isCustomStruct(node)) {
          return name;
        }
        return name + ".value";
      } else {
        return node.groupNode.name + "." + name;
      }
    }
    return super.getPropertyName(node);
  }
  /**
   * Returns the output struct name.
   *
   * @return {string} The name of the output struct.
   */
  getOutputStructName() {
    return "output";
  }
  /**
   * Returns the native shader operator name for a given generic name.
   *
   * @param {string} op - The operator name to resolve.
   * @return {?string} The resolved operator name.
   */
  getFunctionOperator(op) {
    const fnOp = wgslFnOpLib[op];
    if (fnOp !== void 0) {
      this._include(fnOp);
      return fnOp;
    }
    return null;
  }
  /**
   * Returns the node access for the given node and shader stage.
   *
   * @param {StorageTextureNode|StorageBufferNode} node - The storage node.
   * @param {string} shaderStage - The shader stage.
   * @return {string} The node access.
   */
  getNodeAccess(node, shaderStage) {
    if (shaderStage !== "compute") {
      if (node.isAtomic === true) {
        console.warn(
          "WebGPURenderer: Atomic operations are only supported in compute shaders."
        );
        return NodeAccess.READ_WRITE;
      }
      return NodeAccess.READ_ONLY;
    }
    return node.access;
  }
  /**
   * Returns A WGSL snippet representing the storage access.
   *
   * @param {StorageTextureNode|StorageBufferNode} node - The storage node.
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet representing the storage access.
   */
  getStorageAccess(node, shaderStage) {
    return accessNames[this.getNodeAccess(node, shaderStage)];
  }
  /**
   * This method is one of the more important ones since it's responsible
   * for generating a matching binding instance for the given uniform node.
   *
   * These bindings are later used in the renderer to create bind groups
   * and layouts.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The node data type.
   * @param {string} shaderStage - The shader stage.
   * @param {?string} [name=null] - An optional uniform name.
   * @return {NodeUniform} The node uniform object.
   */
  getUniformFromNode(node, type, shaderStage, name = null) {
    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    if (nodeData.uniformGPU === void 0) {
      let uniformGPU;
      const group = node.groupNode;
      const groupName = group.name;
      const bindings = this.getBindGroupArray(groupName, shaderStage);
      if (
        type === "texture" ||
        type === "cubeTexture" ||
        type === "storageTexture" ||
        type === "texture3D"
      ) {
        let texture2 = null;
        const access = this.getNodeAccess(node, shaderStage);
        if (type === "texture" || type === "storageTexture") {
          if (node.value.is3DTexture === true) {
            texture2 = new NodeSampledTexture3D(
              uniformNode.name,
              uniformNode.node,
              group,
              access
            );
          } else {
            texture2 = new NodeSampledTexture(
              uniformNode.name,
              uniformNode.node,
              group,
              access
            );
          }
        } else if (type === "cubeTexture") {
          texture2 = new NodeSampledCubeTexture(
            uniformNode.name,
            uniformNode.node,
            group,
            access
          );
        } else if (type === "texture3D") {
          texture2 = new NodeSampledTexture3D(
            uniformNode.name,
            uniformNode.node,
            group,
            access
          );
        }
        texture2.store = node.isStorageTextureNode === true;
        texture2.setVisibility(gpuShaderStageLib[shaderStage]);
        if (
          this.isUnfilterable(node.value) === false &&
          texture2.store === false
        ) {
          const sampler2 = new NodeSampler(
            `${uniformNode.name}_sampler`,
            uniformNode.node,
            group
          );
          sampler2.setVisibility(gpuShaderStageLib[shaderStage]);
          bindings.push(sampler2, texture2);
          uniformGPU = [sampler2, texture2];
        } else {
          bindings.push(texture2);
          uniformGPU = [texture2];
        }
      } else if (
        type === "buffer" ||
        type === "storageBuffer" ||
        type === "indirectStorageBuffer"
      ) {
        const bufferClass =
          type === "buffer" ? NodeUniformBuffer : NodeStorageBuffer;
        const buffer2 = new bufferClass(node, group);
        buffer2.setVisibility(gpuShaderStageLib[shaderStage]);
        bindings.push(buffer2);
        uniformGPU = buffer2;
        uniformNode.name = name ? name : "NodeBuffer_" + uniformNode.id;
      } else {
        const uniformsStage =
          this.uniformGroups[shaderStage] ||
          (this.uniformGroups[shaderStage] = {});
        let uniformsGroup = uniformsStage[groupName];
        if (uniformsGroup === void 0) {
          uniformsGroup = new NodeUniformsGroup(groupName, group);
          uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]);
          uniformsStage[groupName] = uniformsGroup;
          bindings.push(uniformsGroup);
        }
        uniformGPU = this.getNodeUniform(uniformNode, type);
        uniformsGroup.addUniform(uniformGPU);
      }
      nodeData.uniformGPU = uniformGPU;
    }
    return uniformNode;
  }
  /**
   * This method should be used whenever builtins are required in nodes.
   * The internal builtins data structure will make sure builtins are
   * defined in the WGSL source.
   *
   * @param {string} name - The builtin name.
   * @param {string} property - The property name.
   * @param {string} type - The node data type.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getBuiltin(name, property2, type, shaderStage = this.shaderStage) {
    const map =
      this.builtins[shaderStage] ||
      (this.builtins[shaderStage] = /* @__PURE__ */ new Map());
    if (map.has(name) === false) {
      map.set(name, {
        name,
        property: property2,
        type,
      });
    }
    return property2;
  }
  /**
   * Returns `true` if the given builtin is defined in the given shader stage.
   *
   * @param {string} name - The builtin name.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {boolean} Whether the given builtin is defined in the given shader stage or not.
   */
  hasBuiltin(name, shaderStage = this.shaderStage) {
    return (
      this.builtins[shaderStage] !== void 0 &&
      this.builtins[shaderStage].has(name)
    );
  }
  /**
   * Returns the vertex index builtin.
   *
   * @return {string} The vertex index.
   */
  getVertexIndex() {
    if (this.shaderStage === "vertex") {
      return this.getBuiltin("vertex_index", "vertexIndex", "u32", "attribute");
    }
    return "vertexIndex";
  }
  /**
   * Builds the given shader node.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The WGSL function code.
   */
  buildFunctionCode(shaderNode) {
    const layout = shaderNode.layout;
    const flowData = this.flowShaderNode(shaderNode);
    const parameters = [];
    for (const input of layout.inputs) {
      parameters.push(input.name + " : " + this.getType(input.type));
    }
    let code2 = `fn ${layout.name}( ${parameters.join(
      ", "
    )} ) -> ${this.getType(layout.type)} {
${flowData.vars}
${flowData.code}
`;
    if (flowData.result) {
      code2 += `	return ${flowData.result};
`;
    }
    code2 += "\n}\n";
    return code2;
  }
  /**
   * Returns the instance index builtin.
   *
   * @return {string} The instance index.
   */
  getInstanceIndex() {
    if (this.shaderStage === "vertex") {
      return this.getBuiltin(
        "instance_index",
        "instanceIndex",
        "u32",
        "attribute"
      );
    }
    return "instanceIndex";
  }
  /**
   * Returns the invocation local index builtin.
   *
   * @return {string} The invocation local index.
   */
  getInvocationLocalIndex() {
    return this.getBuiltin(
      "local_invocation_index",
      "invocationLocalIndex",
      "u32",
      "attribute"
    );
  }
  /**
   * Returns the subgroup size builtin.
   *
   * @return {string} The subgroup size.
   */
  getSubgroupSize() {
    this.enableSubGroups();
    return this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
  }
  /**
   * Returns the invocation subgroup index builtin.
   *
   * @return {string} The invocation subgroup index.
   */
  getInvocationSubgroupIndex() {
    this.enableSubGroups();
    return this.getBuiltin(
      "subgroup_invocation_id",
      "invocationSubgroupIndex",
      "u32",
      "attribute"
    );
  }
  /**
   * Returns the subgroup index builtin.
   *
   * @return {string} The subgroup index.
   */
  getSubgroupIndex() {
    this.enableSubGroups();
    return this.getBuiltin("subgroup_id", "subgroupIndex", "u32", "attribute");
  }
  /**
   * Overwritten as a NOP since this method is intended for the WebGL 2 backend.
   *
   * @return {null} Null.
   */
  getDrawIndex() {
    return null;
  }
  /**
   * Returns the front facing builtin.
   *
   * @return {string} The front facing builtin.
   */
  getFrontFacing() {
    return this.getBuiltin("front_facing", "isFront", "bool");
  }
  /**
   * Returns the frag coord builtin.
   *
   * @return {string} The frag coord builtin.
   */
  getFragCoord() {
    return this.getBuiltin("position", "fragCoord", "vec4<f32>") + ".xy";
  }
  /**
   * Returns the frag depth builtin.
   *
   * @return {string} The frag depth builtin.
   */
  getFragDepth() {
    return "output." + this.getBuiltin("frag_depth", "depth", "f32", "output");
  }
  /**
   * Returns the clip distances builtin.
   *
   * @return {string} The clip distances builtin.
   */
  getClipDistance() {
    return "varyings.hw_clip_distances";
  }
  /**
   * Whether to flip texture data along its vertical axis or not.
   *
   * @return {boolean} Returns always `false` in context of WGSL.
   */
  isFlipY() {
    return false;
  }
  /**
   * Enables the given directive for the given shader stage.
   *
   * @param {string} name - The directive name.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage to enable the directive for.
   */
  enableDirective(name, shaderStage = this.shaderStage) {
    const stage =
      this.directives[shaderStage] ||
      (this.directives[shaderStage] = /* @__PURE__ */ new Set());
    stage.add(name);
  }
  /**
   * Returns the directives of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} A WGSL snippet that enables the directives of the given stage.
   */
  getDirectives(shaderStage) {
    const snippets = [];
    const directives = this.directives[shaderStage];
    if (directives !== void 0) {
      for (const directive of directives) {
        snippets.push(`enable ${directive};`);
      }
    }
    return snippets.join("\n");
  }
  /**
   * Enables the 'subgroups' directive.
   */
  enableSubGroups() {
    this.enableDirective("subgroups");
  }
  /**
   * Enables the 'subgroups-f16' directive.
   */
  enableSubgroupsF16() {
    this.enableDirective("subgroups-f16");
  }
  /**
   * Enables the 'clip_distances' directive.
   */
  enableClipDistances() {
    this.enableDirective("clip_distances");
  }
  /**
   * Enables the 'f16' directive.
   */
  enableShaderF16() {
    this.enableDirective("f16");
  }
  /**
   * Enables the 'dual_source_blending' directive.
   */
  enableDualSourceBlending() {
    this.enableDirective("dual_source_blending");
  }
  /**
   * Enables hardware clipping.
   *
   * @param {string} planeCount - The clipping plane count.
   */
  enableHardwareClipping(planeCount) {
    this.enableClipDistances();
    this.getBuiltin(
      "clip_distances",
      "hw_clip_distances",
      `array<f32, ${planeCount} >`,
      "vertex"
    );
  }
  /**
   * Returns the builtins of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} A WGSL snippet that represents the builtins of the given stage.
   */
  getBuiltins(shaderStage) {
    const snippets = [];
    const builtins = this.builtins[shaderStage];
    if (builtins !== void 0) {
      for (const { name, property: property2, type } of builtins.values()) {
        snippets.push(`@builtin( ${name} ) ${property2} : ${type}`);
      }
    }
    return snippets.join(",\n	");
  }
  /**
   * This method should be used when a new scoped buffer is used in context of
   * compute shaders. It adds the array to the internal data structure which is
   * later used to generate the respective WGSL.
   *
   * @param {string} name - The array name.
   * @param {string} scope - The scope.
   * @param {string} bufferType - The buffer type.
   * @param {string} bufferCount - The buffer count.
   * @return {string} The array name.
   */
  getScopedArray(name, scope, bufferType, bufferCount) {
    if (this.scopedArrays.has(name) === false) {
      this.scopedArrays.set(name, {
        name,
        scope,
        bufferType,
        bufferCount,
      });
    }
    return name;
  }
  /**
   * Returns the scoped arrays of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string|undefined} The WGSL snippet that defines the scoped arrays.
   * Returns `undefined` when used in the vertex or fragment stage.
   */
  getScopedArrays(shaderStage) {
    if (shaderStage !== "compute") {
      return;
    }
    const snippets = [];
    for (const {
      name,
      scope,
      bufferType,
      bufferCount,
    } of this.scopedArrays.values()) {
      const type = this.getType(bufferType);
      snippets.push(`var<${scope}> ${name}: array< ${type}, ${bufferCount} >;`);
    }
    return snippets.join("\n");
  }
  /**
   * Returns the shader attributes of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the shader attributes.
   */
  getAttributes(shaderStage) {
    const snippets = [];
    if (shaderStage === "compute") {
      this.getBuiltin(
        "global_invocation_id",
        "globalId",
        "vec3<u32>",
        "attribute"
      );
      this.getBuiltin("workgroup_id", "workgroupId", "vec3<u32>", "attribute");
      this.getBuiltin(
        "local_invocation_id",
        "localId",
        "vec3<u32>",
        "attribute"
      );
      this.getBuiltin(
        "num_workgroups",
        "numWorkgroups",
        "vec3<u32>",
        "attribute"
      );
      if (this.renderer.hasFeature("subgroups")) {
        this.enableDirective("subgroups", shaderStage);
        this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
      }
    }
    if (shaderStage === "vertex" || shaderStage === "compute") {
      const builtins = this.getBuiltins("attribute");
      if (builtins) snippets.push(builtins);
      const attributes = this.getAttributesArray();
      for (
        let index = 0, length2 = attributes.length;
        index < length2;
        index++
      ) {
        const attribute2 = attributes[index];
        const name = attribute2.name;
        const type = this.getType(attribute2.type);
        snippets.push(`@location( ${index} ) ${name} : ${type}`);
      }
    }
    return snippets.join(",\n	");
  }
  /**
   * Returns the members of the given struct type node as a WGSL string.
   *
   * @param {StructTypeNode} struct - The struct type node.
   * @return {string} The WGSL snippet that defines the struct members.
   */
  getStructMembers(struct2) {
    const snippets = [];
    for (const member of struct2.members) {
      const prefix = struct2.output ? "@location( " + member.index + " ) " : "";
      let type = this.getType(member.type);
      if (member.atomic) {
        type = "atomic< " + type + " >";
      }
      snippets.push(`	${prefix + member.name} : ${type}`);
    }
    if (struct2.output) {
      snippets.push(`	${this.getBuiltins("output")}`);
    }
    return snippets.join(",\n");
  }
  /**
   * Returns the structs of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the structs.
   */
  getStructs(shaderStage) {
    let result = "";
    const structs = this.structs[shaderStage];
    if (structs.length > 0) {
      const snippets = [];
      for (const struct2 of structs) {
        let snippet = `struct ${struct2.name} {
`;
        snippet += this.getStructMembers(struct2);
        snippet += "\n};";
        snippets.push(snippet);
      }
      result = "\n" + snippets.join("\n\n") + "\n";
    }
    return result;
  }
  /**
   * Returns a WGSL string representing a variable.
   *
   * @param {string} type - The variable's type.
   * @param {string} name - The variable's name.
   * @param {?number} [count=null] - The array length.
   * @return {string} The WGSL snippet that defines a variable.
   */
  getVar(type, name, count = null) {
    let snippet = `var ${name} : `;
    if (count !== null) {
      snippet += this.generateArrayDeclaration(type, count);
    } else {
      snippet += this.getType(type);
    }
    return snippet;
  }
  /**
   * Returns the variables of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the variables.
   */
  getVars(shaderStage) {
    const snippets = [];
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippets.push(
          `	${this.getVar(variable.type, variable.name, variable.count)};`
        );
      }
    }
    return `
${snippets.join("\n")}
`;
  }
  /**
   * Returns the varyings of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the varyings.
   */
  getVaryings(shaderStage) {
    const snippets = [];
    if (shaderStage === "vertex") {
      this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex");
    }
    if (shaderStage === "vertex" || shaderStage === "fragment") {
      const varyings = this.varyings;
      const vars = this.vars[shaderStage];
      for (let index = 0; index < varyings.length; index++) {
        const varying2 = varyings[index];
        if (varying2.needsInterpolation) {
          let attributesSnippet = `@location( ${index} )`;
          if (varying2.interpolationType) {
            const samplingSnippet =
              varying2.interpolationSampling !== null
                ? `, ${varying2.interpolationSampling} )`
                : " )";
            attributesSnippet += ` @interpolate( ${varying2.interpolationType}${samplingSnippet}`;
          } else if (/^(int|uint|ivec|uvec)/.test(varying2.type)) {
            attributesSnippet += ` @interpolate( ${
              this.renderer.backend.compatibilityMode ? "flat, either" : "flat"
            } )`;
          }
          snippets.push(
            `${attributesSnippet} ${varying2.name} : ${this.getType(
              varying2.type
            )}`
          );
        } else if (
          shaderStage === "vertex" &&
          vars.includes(varying2) === false
        ) {
          vars.push(varying2);
        }
      }
    }
    const builtins = this.getBuiltins(shaderStage);
    if (builtins) snippets.push(builtins);
    const code2 = snippets.join(",\n	");
    return shaderStage === "vertex"
      ? this._getWGSLStruct("VaryingsStruct", "	" + code2)
      : code2;
  }
  isCustomStruct(nodeUniform) {
    const attribute2 = nodeUniform.value;
    const bufferNode = nodeUniform.node;
    const isAttributeStructType =
      (attribute2.isBufferAttribute || attribute2.isInstancedBufferAttribute) &&
      bufferNode.structTypeNode !== null;
    const isStructArray =
      bufferNode.value &&
      bufferNode.value.array &&
      typeof bufferNode.value.itemSize === "number" &&
      bufferNode.value.array.length > bufferNode.value.itemSize;
    return isAttributeStructType && !isStructArray;
  }
  /**
   * Returns the uniforms of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the uniforms.
   */
  getUniforms(shaderStage) {
    const uniforms = this.uniforms[shaderStage];
    const bindingSnippets = [];
    const bufferSnippets = [];
    const structSnippets = [];
    const uniformGroups = {};
    for (const uniform2 of uniforms) {
      const groupName = uniform2.groupNode.name;
      const uniformIndexes = this.bindingsIndexes[groupName];
      if (
        uniform2.type === "texture" ||
        uniform2.type === "cubeTexture" ||
        uniform2.type === "storageTexture" ||
        uniform2.type === "texture3D"
      ) {
        const texture2 = uniform2.node.value;
        if (
          this.isUnfilterable(texture2) === false &&
          uniform2.node.isStorageTextureNode !== true
        ) {
          if (this.isSampleCompare(texture2)) {
            bindingSnippets.push(
              `@binding( ${uniformIndexes.binding++} ) @group( ${
                uniformIndexes.group
              } ) var ${uniform2.name}_sampler : sampler_comparison;`
            );
          } else {
            bindingSnippets.push(
              `@binding( ${uniformIndexes.binding++} ) @group( ${
                uniformIndexes.group
              } ) var ${uniform2.name}_sampler : sampler;`
            );
          }
        }
        let textureType;
        let multisampled = "";
        const { primarySamples } =
          this.renderer.backend.utils.getTextureSampleData(texture2);
        if (primarySamples > 1) {
          multisampled = "_multisampled";
        }
        if (texture2.isCubeTexture === true) {
          textureType = "texture_cube<f32>";
        } else if (texture2.isDepthTexture === true) {
          if (
            this.renderer.backend.compatibilityMode &&
            texture2.compareFunction === null
          ) {
            textureType = `texture${multisampled}_2d<f32>`;
          } else {
            textureType = `texture_depth${multisampled}_2d${
              texture2.isArrayTexture === true ? "_array" : ""
            }`;
          }
        } else if (uniform2.node.isStorageTextureNode === true) {
          const format = getFormat(texture2);
          const access = this.getStorageAccess(uniform2.node, shaderStage);
          const is3D = uniform2.node.value.is3DTexture;
          const isArrayTexture = uniform2.node.value.isArrayTexture;
          const dimension = is3D ? "3d" : `2d${isArrayTexture ? "_array" : ""}`;
          textureType = `texture_storage_${dimension}<${format}, ${access}>`;
        } else if (
          texture2.isArrayTexture === true ||
          texture2.isDataArrayTexture === true ||
          texture2.isCompressedArrayTexture === true
        ) {
          textureType = "texture_2d_array<f32>";
        } else if (
          texture2.is3DTexture === true ||
          texture2.isData3DTexture === true
        ) {
          textureType = "texture_3d<f32>";
        } else {
          const componentPrefix =
            this.getComponentTypeFromTexture(texture2).charAt(0);
          textureType = `texture${multisampled}_2d<${componentPrefix}32>`;
        }
        bindingSnippets.push(
          `@binding( ${uniformIndexes.binding++} ) @group( ${
            uniformIndexes.group
          } ) var ${uniform2.name} : ${textureType};`
        );
      } else if (
        uniform2.type === "buffer" ||
        uniform2.type === "storageBuffer" ||
        uniform2.type === "indirectStorageBuffer"
      ) {
        const bufferNode = uniform2.node;
        const bufferType = this.getType(bufferNode.getNodeType(this));
        const bufferCount = bufferNode.bufferCount;
        const bufferCountSnippet =
          bufferCount > 0 && uniform2.type === "buffer"
            ? ", " + bufferCount
            : "";
        const bufferAccessMode = bufferNode.isStorageBufferNode
          ? `storage, ${this.getStorageAccess(bufferNode, shaderStage)}`
          : "uniform";
        if (this.isCustomStruct(uniform2)) {
          bufferSnippets.push(
            `@binding( ${uniformIndexes.binding++} ) @group( ${
              uniformIndexes.group
            } ) var<${bufferAccessMode}> ${uniform2.name} : ${bufferType};`
          );
        } else {
          const bufferTypeSnippet = bufferNode.isAtomic
            ? `atomic<${bufferType}>`
            : `${bufferType}`;
          const bufferSnippet = `	value : array< ${bufferTypeSnippet}${bufferCountSnippet} >`;
          bufferSnippets.push(
            this._getWGSLStructBinding(
              uniform2.name,
              bufferSnippet,
              bufferAccessMode,
              uniformIndexes.binding++,
              uniformIndexes.group
            )
          );
        }
      } else {
        const vectorType = this.getType(this.getVectorType(uniform2.type));
        const groupName2 = uniform2.groupNode.name;
        const group =
          uniformGroups[groupName2] ||
          (uniformGroups[groupName2] = {
            index: uniformIndexes.binding++,
            id: uniformIndexes.group,
            snippets: [],
          });
        group.snippets.push(`	${uniform2.name} : ${vectorType}`);
      }
    }
    for (const name in uniformGroups) {
      const group = uniformGroups[name];
      structSnippets.push(
        this._getWGSLStructBinding(
          name,
          group.snippets.join(",\n"),
          "uniform",
          group.index,
          group.id
        )
      );
    }
    let code2 = bindingSnippets.join("\n");
    code2 += bufferSnippets.join("\n");
    code2 += structSnippets.join("\n");
    return code2;
  }
  /**
   * Controls the code build of the shader stages.
   */
  buildCode() {
    const shadersData =
      this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const shaderStage in shadersData) {
      this.shaderStage = shaderStage;
      const stageData = shadersData[shaderStage];
      stageData.uniforms = this.getUniforms(shaderStage);
      stageData.attributes = this.getAttributes(shaderStage);
      stageData.varyings = this.getVaryings(shaderStage);
      stageData.structs = this.getStructs(shaderStage);
      stageData.vars = this.getVars(shaderStage);
      stageData.codes = this.getCodes(shaderStage);
      stageData.directives = this.getDirectives(shaderStage);
      stageData.scopedArrays = this.getScopedArrays(shaderStage);
      let flow = "// code\n\n";
      flow += this.flowCode[shaderStage];
      const flowNodes = this.flowNodes[shaderStage];
      const mainNode = flowNodes[flowNodes.length - 1];
      const outputNode = mainNode.outputNode;
      const isOutputStruct =
        outputNode !== void 0 && outputNode.isOutputStructNode === true;
      for (const node of flowNodes) {
        const flowSlotData = this.getFlowData(
          node
          /*, shaderStage*/
        );
        const slotName = node.name;
        if (slotName) {
          if (flow.length > 0) flow += "\n";
          flow += `	// flow -> ${slotName}
`;
        }
        flow += `${flowSlotData.code}
	`;
        if (node === mainNode && shaderStage !== "compute") {
          flow += "// result\n\n	";
          if (shaderStage === "vertex") {
            flow += `varyings.Vertex = ${flowSlotData.result};`;
          } else if (shaderStage === "fragment") {
            if (isOutputStruct) {
              stageData.returnType = outputNode.getNodeType(this);
              stageData.structs +=
                "var<private> output : " + stageData.returnType + ";";
              flow += `return ${flowSlotData.result};`;
            } else {
              let structSnippet = "	@location(0) color: vec4<f32>";
              const builtins = this.getBuiltins("output");
              if (builtins) structSnippet += ",\n	" + builtins;
              stageData.returnType = "OutputStruct";
              stageData.structs += this._getWGSLStruct(
                "OutputStruct",
                structSnippet
              );
              stageData.structs += "\nvar<private> output : OutputStruct;";
              flow += `output.color = ${flowSlotData.result};

	return output;`;
            }
          }
        }
      }
      stageData.flow = flow;
    }
    this.shaderStage = null;
    if (this.material !== null) {
      this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);
      this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);
    } else {
      const workgroupSize = this.object.workgroupSize;
      this.computeShader = this._getWGSLComputeCode(
        shadersData.compute,
        workgroupSize
      );
    }
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @param {string} method - The method name to resolve.
   * @param {?string} [output=null] - An optional output.
   * @return {string} The resolved WGSL method name.
   */
  getMethod(method, output2 = null) {
    let wgslMethod;
    if (output2 !== null) {
      wgslMethod = this._getWGSLMethod(method + "_" + output2);
    }
    if (wgslMethod === void 0) {
      wgslMethod = this._getWGSLMethod(method);
    }
    return wgslMethod || method;
  }
  /**
   * Returns the WGSL type of the given node data type.
   *
   * @param {string} type - The node data type.
   * @return {string} The WGSL type.
   */
  getType(type) {
    return wgslTypeLib[type] || type;
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable(name) {
    let result = supports[name];
    if (result === void 0) {
      if (name === "float32Filterable") {
        result = this.renderer.hasFeature("float32-filterable");
      } else if (name === "clipDistance") {
        result = this.renderer.hasFeature("clip-distances");
      }
      supports[name] = result;
    }
    return result;
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @private
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved WGSL method name.
   */
  _getWGSLMethod(method) {
    if (wgslPolyfill[method] !== void 0) {
      this._include(method);
    }
    return wgslMethods[method];
  }
  /**
   * Includes the given method name into the current
   * function node.
   *
   * @private
   * @param {string} name - The method name to include.
   * @return {CodeNode} The respective code node.
   */
  _include(name) {
    const codeNode = wgslPolyfill[name];
    codeNode.build(this);
    if (this.currentFunctionNode !== null) {
      this.currentFunctionNode.includes.push(codeNode);
    }
    return codeNode;
  }
  /**
   * Returns a WGSL vertex shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getWGSLVertexCode(shaderData) {
    return `${this.getSignature()}
// directives
${shaderData.directives}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}
var<private> varyings : VaryingsStruct;

// codes
${shaderData.codes}

@vertex
fn main( ${shaderData.attributes} ) -> VaryingsStruct {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	return varyings;

}
`;
  }
  /**
   * Returns a WGSL fragment shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getWGSLFragmentCode(shaderData) {
    return `${this.getSignature()}
// global
${diagnostics}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@fragment
fn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  /**
   * Returns a WGSL compute shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @param {string} workgroupSize - The workgroup size.
   * @return {string} The vertex shader.
   */
  _getWGSLComputeCode(shaderData, workgroupSize) {
    const [workgroupSizeX, workgroupSizeY, workgroupSizeZ] = workgroupSize;
    return `${this.getSignature()}
// directives
${shaderData.directives}

// system
var<private> instanceIndex : u32;

// locals
${shaderData.scopedArrays}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@compute @workgroup_size( ${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ} )
fn main( ${shaderData.attributes} ) {

	// system
	instanceIndex = globalId.x
		+ globalId.y * ( ${workgroupSizeX} * numWorkgroups.x )
		+ globalId.z * ( ${workgroupSizeX} * numWorkgroups.x ) * ( ${workgroupSizeY} * numWorkgroups.y );

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  /**
   * Returns a WGSL struct based on the given name and variables.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @return {string} The WGSL snippet representing a struct.
   */
  _getWGSLStruct(name, vars) {
    return `
struct ${name} {
${vars}
};`;
  }
  /**
   * Returns a WGSL struct binding.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @param {string} access - The access.
   * @param {number} [binding=0] - The binding index.
   * @param {number} [group=0] - The group index.
   * @return {string} The WGSL snippet representing a struct binding.
   */
  _getWGSLStructBinding(name, vars, access, binding = 0, group = 0) {
    const structName = name + "Struct";
    const structSnippet = this._getWGSLStruct(structName, vars);
    return `${structSnippet}
@binding( ${binding} ) @group( ${group} )
var<${access}> ${name} : ${structName};`;
  }
}
class WebGPUUtils {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
  }
  /**
   * Returns the depth/stencil GPU format for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The depth/stencil GPU texture format.
   */
  getCurrentDepthStencilFormat(renderContext) {
    let format;
    if (renderContext.depthTexture !== null) {
      format = this.getTextureFormatGPU(renderContext.depthTexture);
    } else if (renderContext.depth && renderContext.stencil) {
      format = GPUTextureFormat.Depth24PlusStencil8;
    } else if (renderContext.depth) {
      format = GPUTextureFormat.Depth24Plus;
    }
    return format;
  }
  /**
   * Returns the GPU format for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {string} The GPU texture format.
   */
  getTextureFormatGPU(texture2) {
    return this.backend.get(texture2).format;
  }
  /**
   * Returns an object that defines the multi-sampling state of the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {Object} The multi-sampling state.
   */
  getTextureSampleData(texture2) {
    let samples;
    if (texture2.isFramebufferTexture) {
      samples = 1;
    } else if (texture2.isDepthTexture && !texture2.renderTarget) {
      const renderer2 = this.backend.renderer;
      const renderTarget = renderer2.getRenderTarget();
      samples = renderTarget ? renderTarget.samples : renderer2.samples;
    } else if (texture2.renderTarget) {
      samples = texture2.renderTarget.samples;
    }
    samples = samples || 1;
    const isMSAA =
      samples > 1 &&
      texture2.renderTarget !== null &&
      texture2.isDepthTexture !== true &&
      texture2.isFramebufferTexture !== true;
    const primarySamples = isMSAA ? 1 : samples;
    return { samples, primarySamples, isMSAA };
  }
  /**
   * Returns the default color attachment's GPU format of the current render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The GPU texture format of the default color attachment.
   */
  getCurrentColorFormat(renderContext) {
    let format;
    if (renderContext.textures !== null) {
      format = this.getTextureFormatGPU(renderContext.textures[0]);
    } else {
      format = this.getPreferredCanvasFormat();
    }
    return format;
  }
  /**
   * Returns the output color space of the current render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The output color space.
   */
  getCurrentColorSpace(renderContext) {
    if (renderContext.textures !== null) {
      return renderContext.textures[0].colorSpace;
    }
    return this.backend.renderer.outputColorSpace;
  }
  /**
   * Returns GPU primitive topology for the given object and material.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The material.
   * @return {string} The GPU primitive topology.
   */
  getPrimitiveTopology(object, material) {
    if (object.isPoints) return GPUPrimitiveTopology.PointList;
    else if (
      object.isLineSegments ||
      (object.isMesh && material.wireframe === true)
    )
      return GPUPrimitiveTopology.LineList;
    else if (object.isLine) return GPUPrimitiveTopology.LineStrip;
    else if (object.isMesh) return GPUPrimitiveTopology.TriangleList;
  }
  /**
   * Returns a modified sample count from the given sample count value.
   *
   * That is required since WebGPU only supports either 1 or 4.
   *
   * @param {number} sampleCount - The input sample count.
   * @return {number} The (potentially updated) output sample count.
   */
  getSampleCount(sampleCount) {
    return sampleCount >= 4 ? 4 : 1;
  }
  /**
   * Returns the sample count of the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {number} The sample count.
   */
  getSampleCountRenderContext(renderContext) {
    if (renderContext.textures !== null) {
      return this.getSampleCount(renderContext.sampleCount);
    }
    return this.getSampleCount(this.backend.renderer.samples);
  }
  /**
   * Returns the preferred canvas format.
   *
   * There is a separate method for this so it's possible to
   * honor edge cases for specific devices.
   *
   * @return {string} The GPU texture format of the canvas.
   */
  getPreferredCanvasFormat() {
    const outputType = this.backend.parameters.outputType;
    if (outputType === void 0) {
      return navigator.gpu.getPreferredCanvasFormat();
    } else if (outputType === UnsignedByteType) {
      return GPUTextureFormat.BGRA8Unorm;
    } else if (outputType === HalfFloatType) {
      return GPUTextureFormat.RGBA16Float;
    } else {
      throw new Error("Unsupported outputType");
    }
  }
}
const typedArraysToVertexFormatPrefix = /* @__PURE__ */ new Map([
  [Int8Array, ["sint8", "snorm8"]],
  [Uint8Array, ["uint8", "unorm8"]],
  [Int16Array, ["sint16", "snorm16"]],
  [Uint16Array, ["uint16", "unorm16"]],
  [Int32Array, ["sint32", "snorm32"]],
  [Uint32Array, ["uint32", "unorm32"]],
  [Float32Array, ["float32"]],
]);
if (typeof Float16Array !== "undefined") {
  typedArraysToVertexFormatPrefix.set(Float16Array, ["float16"]);
}
const typedAttributeToVertexFormatPrefix = /* @__PURE__ */ new Map([
  [Float16BufferAttribute, ["float16"]],
]);
const typeArraysToVertexFormatPrefixForItemSize1 = /* @__PURE__ */ new Map([
  [Int32Array, "sint32"],
  [Int16Array, "sint32"],
  // patch for INT16
  [Uint32Array, "uint32"],
  [Uint16Array, "uint32"],
  // patch for UINT16
  [Float32Array, "float32"],
]);
class WebGPUAttributeUtils {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
  }
  /**
   * Creates the GPU buffer for the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @param {GPUBufferUsage} usage - A flag that indicates how the buffer may be used after its creation.
   */
  createAttribute(attribute2, usage) {
    const bufferAttribute2 = this._getBufferAttribute(attribute2);
    const backend = this.backend;
    const bufferData = backend.get(bufferAttribute2);
    let buffer2 = bufferData.buffer;
    if (buffer2 === void 0) {
      const device = backend.device;
      let array2 = bufferAttribute2.array;
      if (attribute2.normalized === false) {
        if (
          array2.constructor === Int16Array ||
          array2.constructor === Int8Array
        ) {
          array2 = new Int32Array(array2);
        } else if (
          array2.constructor === Uint16Array ||
          array2.constructor === Uint8Array
        ) {
          array2 = new Uint32Array(array2);
          if (usage & GPUBufferUsage.INDEX) {
            for (let i2 = 0; i2 < array2.length; i2++) {
              if (array2[i2] === 65535) array2[i2] = 4294967295;
            }
          }
        }
      }
      bufferAttribute2.array = array2;
      if (
        (bufferAttribute2.isStorageBufferAttribute ||
          bufferAttribute2.isStorageInstancedBufferAttribute) &&
        bufferAttribute2.itemSize === 3
      ) {
        array2 = new array2.constructor(bufferAttribute2.count * 4);
        for (let i2 = 0; i2 < bufferAttribute2.count; i2++) {
          array2.set(
            bufferAttribute2.array.subarray(i2 * 3, i2 * 3 + 3),
            i2 * 4
          );
        }
        bufferAttribute2.itemSize = 4;
        bufferAttribute2.array = array2;
        bufferData._force3to4BytesAlignment = true;
      }
      const byteLength = array2.byteLength;
      const size = byteLength + ((4 - (byteLength % 4)) % 4);
      buffer2 = device.createBuffer({
        label: bufferAttribute2.name,
        size,
        usage,
        mappedAtCreation: true,
      });
      const mappedRange = buffer2.getMappedRange();
      const mappedFloats = new array2.constructor(mappedRange);
      mappedFloats.set(array2);
      buffer2.unmap();
      bufferData.buffer = buffer2;
    }
  }
  /**
   * Updates the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  updateAttribute(attribute2) {
    const bufferAttribute2 = this._getBufferAttribute(attribute2);
    const backend = this.backend;
    const device = backend.device;
    const bufferData = backend.get(bufferAttribute2);
    const buffer2 = backend.get(bufferAttribute2).buffer;
    let array2 = bufferAttribute2.array;
    if (bufferData._force3to4BytesAlignment === true) {
      array2 = new array2.constructor(bufferAttribute2.count * 4);
      for (let i2 = 0; i2 < bufferAttribute2.count; i2++) {
        array2.set(bufferAttribute2.array.subarray(i2 * 3, i2 * 3 + 3), i2 * 4);
      }
      bufferAttribute2.array = array2;
    }
    const isTypedArray = this._isTypedArray(array2);
    const updateRanges = bufferAttribute2.updateRanges;
    if (updateRanges.length === 0) {
      device.queue.writeBuffer(buffer2, 0, array2, 0);
    } else {
      const byteOffsetFactor = isTypedArray ? 1 : array2.BYTES_PER_ELEMENT;
      for (let i2 = 0, l2 = updateRanges.length; i2 < l2; i2++) {
        const range2 = updateRanges[i2];
        let dataOffset, size;
        if (bufferData._force3to4BytesAlignment === true) {
          const vertexStart = Math.floor(range2.start / 3);
          const vertexCount = Math.ceil(range2.count / 3);
          dataOffset = vertexStart * 4 * byteOffsetFactor;
          size = vertexCount * 4 * byteOffsetFactor;
        } else {
          dataOffset = range2.start * byteOffsetFactor;
          size = range2.count * byteOffsetFactor;
        }
        const bufferOffset =
          dataOffset * (isTypedArray ? array2.BYTES_PER_ELEMENT : 1);
        device.queue.writeBuffer(
          buffer2,
          bufferOffset,
          array2,
          dataOffset,
          size
        );
      }
      bufferAttribute2.clearUpdateRanges();
    }
  }
  /**
   * This method creates the vertex buffer layout data which are
   * require when creating a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Array<Object>} An array holding objects which describe the vertex buffer layout.
   */
  createShaderVertexBuffers(renderObject) {
    const attributes = renderObject.getAttributes();
    const vertexBuffers = /* @__PURE__ */ new Map();
    for (let slot = 0; slot < attributes.length; slot++) {
      const geometryAttribute = attributes[slot];
      const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
      const bufferAttribute2 = this._getBufferAttribute(geometryAttribute);
      let vertexBufferLayout = vertexBuffers.get(bufferAttribute2);
      if (vertexBufferLayout === void 0) {
        let arrayStride, stepMode;
        if (geometryAttribute.isInterleavedBufferAttribute === true) {
          arrayStride = geometryAttribute.data.stride * bytesPerElement;
          stepMode = geometryAttribute.data.isInstancedInterleavedBuffer
            ? GPUInputStepMode.Instance
            : GPUInputStepMode.Vertex;
        } else {
          arrayStride = geometryAttribute.itemSize * bytesPerElement;
          stepMode = geometryAttribute.isInstancedBufferAttribute
            ? GPUInputStepMode.Instance
            : GPUInputStepMode.Vertex;
        }
        if (
          geometryAttribute.normalized === false &&
          (geometryAttribute.array.constructor === Int16Array ||
            geometryAttribute.array.constructor === Uint16Array)
        ) {
          arrayStride = 4;
        }
        vertexBufferLayout = {
          arrayStride,
          attributes: [],
          stepMode,
        };
        vertexBuffers.set(bufferAttribute2, vertexBufferLayout);
      }
      const format = this._getVertexFormat(geometryAttribute);
      const offset =
        geometryAttribute.isInterleavedBufferAttribute === true
          ? geometryAttribute.offset * bytesPerElement
          : 0;
      vertexBufferLayout.attributes.push({
        shaderLocation: slot,
        offset,
        format,
      });
    }
    return Array.from(vertexBuffers.values());
  }
  /**
   * Destroys the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  destroyAttribute(attribute2) {
    const backend = this.backend;
    const data = backend.get(this._getBufferAttribute(attribute2));
    data.buffer.destroy();
    backend.delete(attribute2);
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute2) {
    const backend = this.backend;
    const device = backend.device;
    const data = backend.get(this._getBufferAttribute(attribute2));
    const bufferGPU = data.buffer;
    const size = bufferGPU.size;
    const readBufferGPU = device.createBuffer({
      label: `${attribute2.name}_readback`,
      size,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
    });
    const cmdEncoder = device.createCommandEncoder({
      label: `readback_encoder_${attribute2.name}`,
    });
    cmdEncoder.copyBufferToBuffer(bufferGPU, 0, readBufferGPU, 0, size);
    const gpuCommands = cmdEncoder.finish();
    device.queue.submit([gpuCommands]);
    await readBufferGPU.mapAsync(GPUMapMode.READ);
    const arrayBuffer2 = readBufferGPU.getMappedRange();
    const dstBuffer = new attribute2.array.constructor(arrayBuffer2.slice(0));
    readBufferGPU.unmap();
    return dstBuffer.buffer;
  }
  /**
   * Returns the vertex format of the given buffer attribute.
   *
   * @private
   * @param {BufferAttribute} geometryAttribute - The buffer attribute.
   * @return {string|undefined} The vertex format (e.g. 'float32x3').
   */
  _getVertexFormat(geometryAttribute) {
    const { itemSize, normalized } = geometryAttribute;
    const ArrayType = geometryAttribute.array.constructor;
    const AttributeType2 = geometryAttribute.constructor;
    let format;
    if (itemSize === 1) {
      format = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);
    } else {
      const prefixOptions =
        typedAttributeToVertexFormatPrefix.get(AttributeType2) ||
        typedArraysToVertexFormatPrefix.get(ArrayType);
      const prefix = prefixOptions[normalized ? 1 : 0];
      if (prefix) {
        const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
        const paddedBytesPerUnit = Math.floor((bytesPerUnit + 3) / 4) * 4;
        const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;
        if (paddedItemSize % 1) {
          throw new Error(
            "THREE.WebGPUAttributeUtils: Bad vertex format item size."
          );
        }
        format = `${prefix}x${paddedItemSize}`;
      }
    }
    if (!format) {
      console.error(
        "THREE.WebGPUAttributeUtils: Vertex format not supported yet."
      );
    }
    return format;
  }
  /**
   * Returns `true` if the given array is a typed array.
   *
   * @private
   * @param {any} array - The array.
   * @return {boolean} Whether the given array is a typed array or not.
   */
  _isTypedArray(array2) {
    return ArrayBuffer.isView(array2) && !(array2 instanceof DataView);
  }
  /**
   * Utility method for handling interleaved buffer attributes correctly.
   * To process them, their `InterleavedBuffer` is returned.
   *
   * @private
   * @param {BufferAttribute} attribute - The attribute.
   * @return {BufferAttribute|InterleavedBuffer}
   */
  _getBufferAttribute(attribute2) {
    if (attribute2.isInterleavedBufferAttribute) attribute2 = attribute2.data;
    return attribute2;
  }
}
class WebGPUBindingUtils {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.bindGroupLayoutCache = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Creates a GPU bind group layout for the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @return {GPUBindGroupLayout} The GPU bind group layout.
   */
  createBindingsLayout(bindGroup) {
    const backend = this.backend;
    const device = backend.device;
    const entries = [];
    let index = 0;
    for (const binding of bindGroup.bindings) {
      const bindingGPU = {
        binding: index++,
        visibility: binding.visibility,
      };
      if (binding.isUniformBuffer || binding.isStorageBuffer) {
        const buffer2 = {};
        if (binding.isStorageBuffer) {
          if (binding.visibility & 4) {
            if (
              binding.access === NodeAccess.READ_WRITE ||
              binding.access === NodeAccess.WRITE_ONLY
            ) {
              buffer2.type = GPUBufferBindingType.Storage;
            } else {
              buffer2.type = GPUBufferBindingType.ReadOnlyStorage;
            }
          } else {
            buffer2.type = GPUBufferBindingType.ReadOnlyStorage;
          }
        }
        bindingGPU.buffer = buffer2;
      } else if (binding.isSampledTexture && binding.store) {
        const storageTexture2 = {};
        storageTexture2.format = this.backend.get(
          binding.texture
        ).texture.format;
        const access = binding.access;
        if (access === NodeAccess.READ_WRITE) {
          storageTexture2.access = GPUStorageTextureAccess.ReadWrite;
        } else if (access === NodeAccess.WRITE_ONLY) {
          storageTexture2.access = GPUStorageTextureAccess.WriteOnly;
        } else {
          storageTexture2.access = GPUStorageTextureAccess.ReadOnly;
        }
        if (binding.texture.isArrayTexture) {
          storageTexture2.viewDimension = GPUTextureViewDimension.TwoDArray;
        } else if (binding.texture.is3DTexture) {
          storageTexture2.viewDimension = GPUTextureViewDimension.ThreeD;
        }
        bindingGPU.storageTexture = storageTexture2;
      } else if (binding.isSampledTexture) {
        const texture2 = {};
        const { primarySamples } = backend.utils.getTextureSampleData(
          binding.texture
        );
        if (primarySamples > 1) {
          texture2.multisampled = true;
          if (!binding.texture.isDepthTexture) {
            texture2.sampleType = GPUTextureSampleType.UnfilterableFloat;
          }
        }
        if (binding.texture.isDepthTexture) {
          if (
            backend.compatibilityMode &&
            binding.texture.compareFunction === null
          ) {
            texture2.sampleType = GPUTextureSampleType.UnfilterableFloat;
          } else {
            texture2.sampleType = GPUTextureSampleType.Depth;
          }
        } else if (
          binding.texture.isDataTexture ||
          binding.texture.isDataArrayTexture ||
          binding.texture.isData3DTexture
        ) {
          const type = binding.texture.type;
          if (type === IntType) {
            texture2.sampleType = GPUTextureSampleType.SInt;
          } else if (type === UnsignedIntType) {
            texture2.sampleType = GPUTextureSampleType.UInt;
          } else if (type === FloatType) {
            if (this.backend.hasFeature("float32-filterable")) {
              texture2.sampleType = GPUTextureSampleType.Float;
            } else {
              texture2.sampleType = GPUTextureSampleType.UnfilterableFloat;
            }
          }
        }
        if (binding.isSampledCubeTexture) {
          texture2.viewDimension = GPUTextureViewDimension.Cube;
        } else if (
          binding.texture.isArrayTexture ||
          binding.texture.isDataArrayTexture ||
          binding.texture.isCompressedArrayTexture
        ) {
          texture2.viewDimension = GPUTextureViewDimension.TwoDArray;
        } else if (binding.isSampledTexture3D) {
          texture2.viewDimension = GPUTextureViewDimension.ThreeD;
        }
        bindingGPU.texture = texture2;
      } else if (binding.isSampler) {
        const sampler2 = {};
        if (binding.texture.isDepthTexture) {
          if (binding.texture.compareFunction !== null) {
            sampler2.type = GPUSamplerBindingType.Comparison;
          } else if (backend.compatibilityMode) {
            sampler2.type = GPUSamplerBindingType.NonFiltering;
          }
        }
        bindingGPU.sampler = sampler2;
      } else {
        console.error(`WebGPUBindingUtils: Unsupported binding "${binding}".`);
      }
      entries.push(bindingGPU);
    }
    return device.createBindGroupLayout({ entries });
  }
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(bindGroup, bindings, cacheIndex, version = 0) {
    const { backend, bindGroupLayoutCache } = this;
    const bindingsData = backend.get(bindGroup);
    let bindLayoutGPU = bindGroupLayoutCache.get(bindGroup.bindingsReference);
    if (bindLayoutGPU === void 0) {
      bindLayoutGPU = this.createBindingsLayout(bindGroup);
      bindGroupLayoutCache.set(bindGroup.bindingsReference, bindLayoutGPU);
    }
    let bindGroupGPU;
    if (cacheIndex > 0) {
      if (bindingsData.groups === void 0) {
        bindingsData.groups = [];
        bindingsData.versions = [];
      }
      if (bindingsData.versions[cacheIndex] === version) {
        bindGroupGPU = bindingsData.groups[cacheIndex];
      }
    }
    if (bindGroupGPU === void 0) {
      bindGroupGPU = this.createBindGroup(bindGroup, bindLayoutGPU);
      if (cacheIndex > 0) {
        bindingsData.groups[cacheIndex] = bindGroupGPU;
        bindingsData.versions[cacheIndex] = version;
      }
    }
    bindingsData.group = bindGroupGPU;
    bindingsData.layout = bindLayoutGPU;
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(binding) {
    const backend = this.backend;
    const device = backend.device;
    const buffer2 = binding.buffer;
    const bufferGPU = backend.get(binding).buffer;
    device.queue.writeBuffer(bufferGPU, 0, buffer2, 0);
  }
  /**
   * Creates a GPU bind group for the camera index.
   *
   * @param {Uint32Array} data - The index data.
   * @param {GPUBindGroupLayout} layout - The GPU bind group layout.
   * @return {GPUBindGroup} The GPU bind group.
   */
  createBindGroupIndex(data, layout) {
    const backend = this.backend;
    const device = backend.device;
    const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
    const index = data[0];
    const buffer2 = device.createBuffer({
      label: "bindingCameraIndex_" + index,
      size: 16,
      // uint(4) * 4
      usage,
    });
    device.queue.writeBuffer(buffer2, 0, data, 0);
    const entries = [{ binding: 0, resource: { buffer: buffer2 } }];
    return device.createBindGroup({
      label: "bindGroupCameraIndex_" + index,
      layout,
      entries,
    });
  }
  /**
   * Creates a GPU bind group for the given bind group and GPU layout.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {GPUBindGroupLayout} layoutGPU - The GPU bind group layout.
   * @return {GPUBindGroup} The GPU bind group.
   */
  createBindGroup(bindGroup, layoutGPU) {
    const backend = this.backend;
    const device = backend.device;
    let bindingPoint = 0;
    const entriesGPU = [];
    for (const binding of bindGroup.bindings) {
      if (binding.isUniformBuffer) {
        const bindingData = backend.get(binding);
        if (bindingData.buffer === void 0) {
          const byteLength = binding.byteLength;
          const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
          const bufferGPU = device.createBuffer({
            label: "bindingBuffer_" + binding.name,
            size: byteLength,
            usage,
          });
          bindingData.buffer = bufferGPU;
        }
        entriesGPU.push({
          binding: bindingPoint,
          resource: { buffer: bindingData.buffer },
        });
      } else if (binding.isStorageBuffer) {
        const bindingData = backend.get(binding);
        if (bindingData.buffer === void 0) {
          const attribute2 = binding.attribute;
          bindingData.buffer = backend.get(attribute2).buffer;
        }
        entriesGPU.push({
          binding: bindingPoint,
          resource: { buffer: bindingData.buffer },
        });
      } else if (binding.isSampledTexture) {
        const textureData = backend.get(binding.texture);
        let resourceGPU;
        if (textureData.externalTexture !== void 0) {
          resourceGPU = device.importExternalTexture({
            source: textureData.externalTexture,
          });
        } else {
          const mipLevelCount = binding.store
            ? 1
            : textureData.texture.mipLevelCount;
          let propertyName = `view-${textureData.texture.width}-${textureData.texture.height}`;
          if (textureData.texture.depthOrArrayLayers > 1) {
            propertyName += `-${textureData.texture.depthOrArrayLayers}`;
          }
          propertyName += `-${mipLevelCount}`;
          resourceGPU = textureData[propertyName];
          if (resourceGPU === void 0) {
            const aspectGPU = GPUTextureAspect.All;
            let dimensionViewGPU;
            if (binding.isSampledCubeTexture) {
              dimensionViewGPU = GPUTextureViewDimension.Cube;
            } else if (binding.isSampledTexture3D) {
              dimensionViewGPU = GPUTextureViewDimension.ThreeD;
            } else if (
              binding.texture.isArrayTexture ||
              binding.texture.isDataArrayTexture ||
              binding.texture.isCompressedArrayTexture
            ) {
              dimensionViewGPU = GPUTextureViewDimension.TwoDArray;
            } else {
              dimensionViewGPU = GPUTextureViewDimension.TwoD;
            }
            resourceGPU = textureData[propertyName] =
              textureData.texture.createView({
                aspect: aspectGPU,
                dimension: dimensionViewGPU,
                mipLevelCount,
              });
          }
        }
        entriesGPU.push({ binding: bindingPoint, resource: resourceGPU });
      } else if (binding.isSampler) {
        const textureGPU = backend.get(binding.texture);
        entriesGPU.push({
          binding: bindingPoint,
          resource: textureGPU.sampler,
        });
      }
      bindingPoint++;
    }
    return device.createBindGroup({
      label: "bindGroup_" + bindGroup.name,
      layout: layoutGPU,
      entries: entriesGPU,
    });
  }
}
class WebGPUPipelineUtils {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
    this._activePipelines = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Sets the given pipeline for the given pass. The method makes sure to only set the
   * pipeline when necessary.
   *
   * @param {(GPURenderPassEncoder|GPUComputePassEncoder)} pass - The pass encoder.
   * @param {(GPURenderPipeline|GPUComputePipeline)} pipeline - The pipeline.
   */
  setPipeline(pass2, pipeline) {
    const currentPipeline = this._activePipelines.get(pass2);
    if (currentPipeline !== pipeline) {
      pass2.setPipeline(pipeline);
      this._activePipelines.set(pass2, pipeline);
    }
  }
  /**
   * Returns the sample count derived from the given render context.
   *
   * @private
   * @param {RenderContext} renderContext - The render context.
   * @return {number} The sample count.
   */
  _getSampleCount(renderContext) {
    return this.backend.utils.getSampleCountRenderContext(renderContext);
  }
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(renderObject, promises) {
    const { object, material, geometry, pipeline } = renderObject;
    const { vertexProgram, fragmentProgram } = pipeline;
    const backend = this.backend;
    const device = backend.device;
    const utils = backend.utils;
    const pipelineData = backend.get(pipeline);
    const bindGroupLayouts = [];
    for (const bindGroup of renderObject.getBindings()) {
      const bindingsData = backend.get(bindGroup);
      bindGroupLayouts.push(bindingsData.layout);
    }
    const vertexBuffers =
      backend.attributeUtils.createShaderVertexBuffers(renderObject);
    let blending;
    if (
      material.blending !== NoBlending &&
      (material.blending !== NormalBlending || material.transparent !== false)
    ) {
      blending = this._getBlending(material);
    }
    let stencilFront = {};
    if (material.stencilWrite === true) {
      stencilFront = {
        compare: this._getStencilCompare(material),
        failOp: this._getStencilOperation(material.stencilFail),
        depthFailOp: this._getStencilOperation(material.stencilZFail),
        passOp: this._getStencilOperation(material.stencilZPass),
      };
    }
    const colorWriteMask = this._getColorWriteMask(material);
    const targets = [];
    if (renderObject.context.textures !== null) {
      const textures = renderObject.context.textures;
      for (let i2 = 0; i2 < textures.length; i2++) {
        const colorFormat = utils.getTextureFormatGPU(textures[i2]);
        targets.push({
          format: colorFormat,
          blend: blending,
          writeMask: colorWriteMask,
        });
      }
    } else {
      const colorFormat = utils.getCurrentColorFormat(renderObject.context);
      targets.push({
        format: colorFormat,
        blend: blending,
        writeMask: colorWriteMask,
      });
    }
    const vertexModule = backend.get(vertexProgram).module;
    const fragmentModule = backend.get(fragmentProgram).module;
    const primitiveState = this._getPrimitiveState(object, geometry, material);
    const depthCompare = this._getDepthCompare(material);
    const depthStencilFormat = utils.getCurrentDepthStencilFormat(
      renderObject.context
    );
    const sampleCount = this._getSampleCount(renderObject.context);
    const pipelineDescriptor = {
      label: `renderPipeline_${material.name || material.type}_${material.id}`,
      vertex: Object.assign({}, vertexModule, { buffers: vertexBuffers }),
      fragment: Object.assign({}, fragmentModule, { targets }),
      primitive: primitiveState,
      multisample: {
        count: sampleCount,
        alphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1,
      },
      layout: device.createPipelineLayout({
        bindGroupLayouts,
      }),
    };
    const depthStencil = {};
    const renderDepth = renderObject.context.depth;
    const renderStencil = renderObject.context.stencil;
    if (renderDepth === true || renderStencil === true) {
      if (renderDepth === true) {
        depthStencil.format = depthStencilFormat;
        depthStencil.depthWriteEnabled = material.depthWrite;
        depthStencil.depthCompare = depthCompare;
      }
      if (renderStencil === true) {
        depthStencil.stencilFront = stencilFront;
        depthStencil.stencilBack = {};
        depthStencil.stencilReadMask = material.stencilFuncMask;
        depthStencil.stencilWriteMask = material.stencilWriteMask;
      }
      if (material.polygonOffset === true) {
        depthStencil.depthBias = material.polygonOffsetUnits;
        depthStencil.depthBiasSlopeScale = material.polygonOffsetFactor;
        depthStencil.depthBiasClamp = 0;
      }
      pipelineDescriptor.depthStencil = depthStencil;
    }
    if (promises === null) {
      pipelineData.pipeline = device.createRenderPipeline(pipelineDescriptor);
    } else {
      const p2 = new Promise((resolve) => {
        device
          .createRenderPipelineAsync(pipelineDescriptor)
          .then((pipeline2) => {
            pipelineData.pipeline = pipeline2;
            resolve();
          });
      });
      promises.push(p2);
    }
  }
  /**
   * Creates GPU render bundle encoder for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {?string} [label='renderBundleEncoder'] - The label.
   * @return {GPURenderBundleEncoder} The GPU render bundle encoder.
   */
  createBundleEncoder(renderContext, label2 = "renderBundleEncoder") {
    const backend = this.backend;
    const { utils, device } = backend;
    const depthStencilFormat =
      utils.getCurrentDepthStencilFormat(renderContext);
    const colorFormat = utils.getCurrentColorFormat(renderContext);
    const sampleCount = this._getSampleCount(renderContext);
    const descriptor = {
      label: label2,
      colorFormats: [colorFormat],
      depthStencilFormat,
      sampleCount,
    };
    return device.createRenderBundleEncoder(descriptor);
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} pipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(pipeline, bindings) {
    const backend = this.backend;
    const device = backend.device;
    const computeProgram = backend.get(pipeline.computeProgram).module;
    const pipelineGPU = backend.get(pipeline);
    const bindGroupLayouts = [];
    for (const bindingsGroup of bindings) {
      const bindingsData = backend.get(bindingsGroup);
      bindGroupLayouts.push(bindingsData.layout);
    }
    pipelineGPU.pipeline = device.createComputePipeline({
      compute: computeProgram,
      layout: device.createPipelineLayout({
        bindGroupLayouts,
      }),
    });
  }
  /**
   * Returns the blending state as a descriptor object required
   * for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {Object} The blending state.
   */
  _getBlending(material) {
    let color2, alpha;
    const blending = material.blending;
    const blendSrc = material.blendSrc;
    const blendDst = material.blendDst;
    const blendEquation = material.blendEquation;
    if (blending === CustomBlending) {
      const blendSrcAlpha =
        material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;
      const blendDstAlpha =
        material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;
      const blendEquationAlpha =
        material.blendEquationAlpha !== null
          ? material.blendEquationAlpha
          : blendEquation;
      color2 = {
        srcFactor: this._getBlendFactor(blendSrc),
        dstFactor: this._getBlendFactor(blendDst),
        operation: this._getBlendOperation(blendEquation),
      };
      alpha = {
        srcFactor: this._getBlendFactor(blendSrcAlpha),
        dstFactor: this._getBlendFactor(blendDstAlpha),
        operation: this._getBlendOperation(blendEquationAlpha),
      };
    } else {
      const premultipliedAlpha = material.premultipliedAlpha;
      const setBlend = (srcRGB, dstRGB, srcAlpha, dstAlpha) => {
        color2 = {
          srcFactor: srcRGB,
          dstFactor: dstRGB,
          operation: GPUBlendOperation.Add,
        };
        alpha = {
          srcFactor: srcAlpha,
          dstFactor: dstAlpha,
          operation: GPUBlendOperation.Add,
        };
      };
      if (premultipliedAlpha) {
        switch (blending) {
          case NormalBlending:
            setBlend(
              GPUBlendFactor.One,
              GPUBlendFactor.OneMinusSrcAlpha,
              GPUBlendFactor.One,
              GPUBlendFactor.OneMinusSrcAlpha
            );
            break;
          case AdditiveBlending:
            setBlend(
              GPUBlendFactor.One,
              GPUBlendFactor.One,
              GPUBlendFactor.One,
              GPUBlendFactor.One
            );
            break;
          case SubtractiveBlending:
            setBlend(
              GPUBlendFactor.Zero,
              GPUBlendFactor.OneMinusSrc,
              GPUBlendFactor.Zero,
              GPUBlendFactor.One
            );
            break;
          case MultiplyBlending:
            setBlend(
              GPUBlendFactor.Dst,
              GPUBlendFactor.OneMinusSrcAlpha,
              GPUBlendFactor.Zero,
              GPUBlendFactor.One
            );
            break;
        }
      } else {
        switch (blending) {
          case NormalBlending:
            setBlend(
              GPUBlendFactor.SrcAlpha,
              GPUBlendFactor.OneMinusSrcAlpha,
              GPUBlendFactor.One,
              GPUBlendFactor.OneMinusSrcAlpha
            );
            break;
          case AdditiveBlending:
            setBlend(
              GPUBlendFactor.SrcAlpha,
              GPUBlendFactor.One,
              GPUBlendFactor.One,
              GPUBlendFactor.One
            );
            break;
          case SubtractiveBlending:
            console.error(
              "THREE.WebGPURenderer: SubtractiveBlending requires material.premultipliedAlpha = true"
            );
            break;
          case MultiplyBlending:
            console.error(
              "THREE.WebGPURenderer: MultiplyBlending requires material.premultipliedAlpha = true"
            );
            break;
        }
      }
    }
    if (color2 !== void 0 && alpha !== void 0) {
      return { color: color2, alpha };
    } else {
      console.error("THREE.WebGPURenderer: Invalid blending: ", blending);
    }
  }
  /**
   * Returns the GPU blend factor which is required for the pipeline creation.
   *
   * @private
   * @param {number} blend - The blend factor as a three.js constant.
   * @return {string} The GPU blend factor.
   */
  _getBlendFactor(blend) {
    let blendFactor;
    switch (blend) {
      case ZeroFactor:
        blendFactor = GPUBlendFactor.Zero;
        break;
      case OneFactor:
        blendFactor = GPUBlendFactor.One;
        break;
      case SrcColorFactor:
        blendFactor = GPUBlendFactor.Src;
        break;
      case OneMinusSrcColorFactor:
        blendFactor = GPUBlendFactor.OneMinusSrc;
        break;
      case SrcAlphaFactor:
        blendFactor = GPUBlendFactor.SrcAlpha;
        break;
      case OneMinusSrcAlphaFactor:
        blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
        break;
      case DstColorFactor:
        blendFactor = GPUBlendFactor.Dst;
        break;
      case OneMinusDstColorFactor:
        blendFactor = GPUBlendFactor.OneMinusDst;
        break;
      case DstAlphaFactor:
        blendFactor = GPUBlendFactor.DstAlpha;
        break;
      case OneMinusDstAlphaFactor:
        blendFactor = GPUBlendFactor.OneMinusDstAlpha;
        break;
      case SrcAlphaSaturateFactor:
        blendFactor = GPUBlendFactor.SrcAlphaSaturated;
        break;
      case BlendColorFactor:
        blendFactor = GPUBlendFactor.Constant;
        break;
      case OneMinusBlendColorFactor:
        blendFactor = GPUBlendFactor.OneMinusConstant;
        break;
      default:
        console.error(
          "THREE.WebGPURenderer: Blend factor not supported.",
          blend
        );
    }
    return blendFactor;
  }
  /**
   * Returns the GPU stencil compare function which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {string} The GPU stencil compare function.
   */
  _getStencilCompare(material) {
    let stencilCompare;
    const stencilFunc = material.stencilFunc;
    switch (stencilFunc) {
      case NeverStencilFunc:
        stencilCompare = GPUCompareFunction.Never;
        break;
      case AlwaysStencilFunc:
        stencilCompare = GPUCompareFunction.Always;
        break;
      case LessStencilFunc:
        stencilCompare = GPUCompareFunction.Less;
        break;
      case LessEqualStencilFunc:
        stencilCompare = GPUCompareFunction.LessEqual;
        break;
      case EqualStencilFunc:
        stencilCompare = GPUCompareFunction.Equal;
        break;
      case GreaterEqualStencilFunc:
        stencilCompare = GPUCompareFunction.GreaterEqual;
        break;
      case GreaterStencilFunc:
        stencilCompare = GPUCompareFunction.Greater;
        break;
      case NotEqualStencilFunc:
        stencilCompare = GPUCompareFunction.NotEqual;
        break;
      default:
        console.error(
          "THREE.WebGPURenderer: Invalid stencil function.",
          stencilFunc
        );
    }
    return stencilCompare;
  }
  /**
   * Returns the GPU stencil operation which is required for the pipeline creation.
   *
   * @private
   * @param {number} op - A three.js constant defining the stencil operation.
   * @return {string} The GPU stencil operation.
   */
  _getStencilOperation(op) {
    let stencilOperation;
    switch (op) {
      case KeepStencilOp:
        stencilOperation = GPUStencilOperation.Keep;
        break;
      case ZeroStencilOp:
        stencilOperation = GPUStencilOperation.Zero;
        break;
      case ReplaceStencilOp:
        stencilOperation = GPUStencilOperation.Replace;
        break;
      case InvertStencilOp:
        stencilOperation = GPUStencilOperation.Invert;
        break;
      case IncrementStencilOp:
        stencilOperation = GPUStencilOperation.IncrementClamp;
        break;
      case DecrementStencilOp:
        stencilOperation = GPUStencilOperation.DecrementClamp;
        break;
      case IncrementWrapStencilOp:
        stencilOperation = GPUStencilOperation.IncrementWrap;
        break;
      case DecrementWrapStencilOp:
        stencilOperation = GPUStencilOperation.DecrementWrap;
        break;
      default:
        console.error(
          "THREE.WebGPURenderer: Invalid stencil operation.",
          stencilOperation
        );
    }
    return stencilOperation;
  }
  /**
   * Returns the GPU blend operation which is required for the pipeline creation.
   *
   * @private
   * @param {number} blendEquation - A three.js constant defining the blend equation.
   * @return {string} The GPU blend operation.
   */
  _getBlendOperation(blendEquation) {
    let blendOperation;
    switch (blendEquation) {
      case AddEquation:
        blendOperation = GPUBlendOperation.Add;
        break;
      case SubtractEquation:
        blendOperation = GPUBlendOperation.Subtract;
        break;
      case ReverseSubtractEquation:
        blendOperation = GPUBlendOperation.ReverseSubtract;
        break;
      case MinEquation:
        blendOperation = GPUBlendOperation.Min;
        break;
      case MaxEquation:
        blendOperation = GPUBlendOperation.Max;
        break;
      default:
        console.error(
          "THREE.WebGPUPipelineUtils: Blend equation not supported.",
          blendEquation
        );
    }
    return blendOperation;
  }
  /**
   * Returns the primitive state as a descriptor object required
   * for the pipeline creation.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The geometry.
   * @param {Material} material - The material.
   * @return {Object} The primitive state.
   */
  _getPrimitiveState(object, geometry, material) {
    const descriptor = {};
    const utils = this.backend.utils;
    descriptor.topology = utils.getPrimitiveTopology(object, material);
    if (
      geometry.index !== null &&
      object.isLine === true &&
      object.isLineSegments !== true
    ) {
      descriptor.stripIndexFormat =
        geometry.index.array instanceof Uint16Array
          ? GPUIndexFormat.Uint16
          : GPUIndexFormat.Uint32;
    }
    switch (material.side) {
      case FrontSide:
        descriptor.frontFace = GPUFrontFace.CCW;
        descriptor.cullMode = GPUCullMode.Back;
        break;
      case BackSide:
        descriptor.frontFace = GPUFrontFace.CCW;
        descriptor.cullMode = GPUCullMode.Front;
        break;
      case DoubleSide:
        descriptor.frontFace = GPUFrontFace.CCW;
        descriptor.cullMode = GPUCullMode.None;
        break;
      default:
        console.error(
          "THREE.WebGPUPipelineUtils: Unknown material.side value.",
          material.side
        );
        break;
    }
    return descriptor;
  }
  /**
   * Returns the GPU color write mask which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {number} The GPU color write mask.
   */
  _getColorWriteMask(material) {
    return material.colorWrite === true
      ? GPUColorWriteFlags.All
      : GPUColorWriteFlags.None;
  }
  /**
   * Returns the GPU depth compare function which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {string} The GPU depth compare function.
   */
  _getDepthCompare(material) {
    let depthCompare;
    if (material.depthTest === false) {
      depthCompare = GPUCompareFunction.Always;
    } else {
      const depthFunc = material.depthFunc;
      switch (depthFunc) {
        case NeverDepth:
          depthCompare = GPUCompareFunction.Never;
          break;
        case AlwaysDepth:
          depthCompare = GPUCompareFunction.Always;
          break;
        case LessDepth:
          depthCompare = GPUCompareFunction.Less;
          break;
        case LessEqualDepth:
          depthCompare = GPUCompareFunction.LessEqual;
          break;
        case EqualDepth:
          depthCompare = GPUCompareFunction.Equal;
          break;
        case GreaterEqualDepth:
          depthCompare = GPUCompareFunction.GreaterEqual;
          break;
        case GreaterDepth:
          depthCompare = GPUCompareFunction.Greater;
          break;
        case NotEqualDepth:
          depthCompare = GPUCompareFunction.NotEqual;
          break;
        default:
          console.error(
            "THREE.WebGPUPipelineUtils: Invalid depth function.",
            depthFunc
          );
      }
    }
    return depthCompare;
  }
}
class WebGPUTimestampQueryPool extends TimestampQueryPool {
  /**
   * Creates a new WebGPU timestamp query pool.
   *
   * @param {GPUDevice} device - The WebGPU device to create queries on.
   * @param {string} type - The type identifier for this query pool.
   * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.
   */
  constructor(device, type, maxQueries = 2048) {
    super(maxQueries);
    this.device = device;
    this.type = type;
    this.querySet = this.device.createQuerySet({
      type: "timestamp",
      count: this.maxQueries,
      label: `queryset_global_timestamp_${type}`,
    });
    const bufferSize = this.maxQueries * 8;
    this.resolveBuffer = this.device.createBuffer({
      label: `buffer_timestamp_resolve_${type}`,
      size: bufferSize,
      usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
    });
    this.resultBuffer = this.device.createBuffer({
      label: `buffer_timestamp_result_${type}`,
      size: bufferSize,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
    });
  }
  /**
   * Allocates a pair of queries for a given render context.
   *
   * @param {Object} renderContext - The render context to allocate queries for.
   * @returns {?number} The base offset for the allocated queries, or null if allocation failed.
   */
  allocateQueriesForContext(renderContext) {
    if (!this.trackTimestamp || this.isDisposed) return null;
    if (this.currentQueryIndex + 2 > this.maxQueries) {
      warnOnce(
        `WebGPUTimestampQueryPool [${
          this.type
        }]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`
      );
      return null;
    }
    const baseOffset = this.currentQueryIndex;
    this.currentQueryIndex += 2;
    this.queryOffsets.set(renderContext.id, baseOffset);
    return baseOffset;
  }
  /**
   * Asynchronously resolves all pending queries and returns the total duration.
   * If there's already a pending resolve operation, returns that promise instead.
   *
   * @async
   * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.
   */
  async resolveQueriesAsync() {
    if (
      !this.trackTimestamp ||
      this.currentQueryIndex === 0 ||
      this.isDisposed
    ) {
      return this.lastValue;
    }
    if (this.pendingResolve) {
      return this.pendingResolve;
    }
    this.pendingResolve = this._resolveQueries();
    try {
      const result = await this.pendingResolve;
      return result;
    } finally {
      this.pendingResolve = null;
    }
  }
  /**
   * Internal method to resolve queries and calculate total duration.
   *
   * @async
   * @private
   * @returns {Promise<number>} The total duration in milliseconds.
   */
  async _resolveQueries() {
    if (this.isDisposed) {
      return this.lastValue;
    }
    try {
      if (this.resultBuffer.mapState !== "unmapped") {
        return this.lastValue;
      }
      const currentOffsets = new Map(this.queryOffsets);
      const queryCount = this.currentQueryIndex;
      const bytesUsed = queryCount * 8;
      this.currentQueryIndex = 0;
      this.queryOffsets.clear();
      const commandEncoder = this.device.createCommandEncoder();
      commandEncoder.resolveQuerySet(
        this.querySet,
        0,
        queryCount,
        this.resolveBuffer,
        0
      );
      commandEncoder.copyBufferToBuffer(
        this.resolveBuffer,
        0,
        this.resultBuffer,
        0,
        bytesUsed
      );
      const commandBuffer = commandEncoder.finish();
      this.device.queue.submit([commandBuffer]);
      if (this.resultBuffer.mapState !== "unmapped") {
        return this.lastValue;
      }
      await this.resultBuffer.mapAsync(GPUMapMode.READ, 0, bytesUsed);
      if (this.isDisposed) {
        if (this.resultBuffer.mapState === "mapped") {
          this.resultBuffer.unmap();
        }
        return this.lastValue;
      }
      const times = new BigUint64Array(
        this.resultBuffer.getMappedRange(0, bytesUsed)
      );
      let totalDuration = 0;
      for (const [, baseOffset] of currentOffsets) {
        const startTime = times[baseOffset];
        const endTime = times[baseOffset + 1];
        const duration = Number(endTime - startTime) / 1e6;
        totalDuration += duration;
      }
      this.resultBuffer.unmap();
      this.lastValue = totalDuration;
      return totalDuration;
    } catch (error) {
      console.error("Error resolving queries:", error);
      if (this.resultBuffer.mapState === "mapped") {
        this.resultBuffer.unmap();
      }
      return this.lastValue;
    }
  }
  /**
   * Dispose of the query pool.
   *
   * @async
   * @returns {Promise} A Promise that resolves when the dispose has been executed.
   */
  async dispose() {
    if (this.isDisposed) {
      return;
    }
    this.isDisposed = true;
    if (this.pendingResolve) {
      try {
        await this.pendingResolve;
      } catch (error) {
        console.error("Error waiting for pending resolve:", error);
      }
    }
    if (this.resultBuffer && this.resultBuffer.mapState === "mapped") {
      try {
        this.resultBuffer.unmap();
      } catch (error) {
        console.error("Error unmapping buffer:", error);
      }
    }
    if (this.querySet) {
      this.querySet.destroy();
      this.querySet = null;
    }
    if (this.resolveBuffer) {
      this.resolveBuffer.destroy();
      this.resolveBuffer = null;
    }
    if (this.resultBuffer) {
      this.resultBuffer.destroy();
      this.resultBuffer = null;
    }
    this.queryOffsets.clear();
    this.pendingResolve = null;
  }
}
class WebGPUBackend extends Backend {
  /**
   * WebGPUBackend options.
   *
   * @typedef {Object} WebGPUBackend~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [compatibilityMode=false] - Whether the backend should be in compatibility mode or not.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {boolean} [trackTimestamp=false] - Whether to track timestamps with a Timestamp Query API or not.
   * @property {string} [powerPreference=undefined] - The power preference.
   * @property {Object} [requiredLimits=undefined] - Specifies the limits that are required by the device request. The request will fail if the adapter cannot provide these limits.
   * @property {GPUDevice} [device=undefined] - If there is an existing GPU device on app level, it can be passed to the renderer as a parameter.
   * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.
   */
  /**
   * Constructs a new WebGPU backend.
   *
   * @param {WebGPUBackend~Options} [parameters] - The configuration parameter.
   */
  constructor(parameters = {}) {
    super(parameters);
    this.isWebGPUBackend = true;
    this.parameters.alpha =
      parameters.alpha === void 0 ? true : parameters.alpha;
    this.parameters.compatibilityMode =
      parameters.compatibilityMode === void 0
        ? false
        : parameters.compatibilityMode;
    this.parameters.requiredLimits =
      parameters.requiredLimits === void 0 ? {} : parameters.requiredLimits;
    this.compatibilityMode = this.parameters.compatibilityMode;
    this.device = null;
    this.context = null;
    this.colorBuffer = null;
    this.defaultRenderPassdescriptor = null;
    this.utils = new WebGPUUtils(this);
    this.attributeUtils = new WebGPUAttributeUtils(this);
    this.bindingUtils = new WebGPUBindingUtils(this);
    this.pipelineUtils = new WebGPUPipelineUtils(this);
    this.textureUtils = new WebGPUTextureUtils(this);
    this.occludedResolveCache = /* @__PURE__ */ new Map();
  }
  /**
   * Initializes the backend so it is ready for usage.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the backend has been initialized.
   */
  async init(renderer2) {
    await super.init(renderer2);
    const parameters = this.parameters;
    let device;
    if (parameters.device === void 0) {
      const adapterOptions = {
        powerPreference: parameters.powerPreference,
        featureLevel: parameters.compatibilityMode ? "compatibility" : void 0,
      };
      const adapter =
        typeof navigator !== "undefined"
          ? await navigator.gpu.requestAdapter(adapterOptions)
          : null;
      if (adapter === null) {
        throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");
      }
      const features = Object.values(GPUFeatureName);
      const supportedFeatures = [];
      for (const name of features) {
        if (adapter.features.has(name)) {
          supportedFeatures.push(name);
        }
      }
      const deviceDescriptor = {
        requiredFeatures: supportedFeatures,
        requiredLimits: parameters.requiredLimits,
      };
      device = await adapter.requestDevice(deviceDescriptor);
    } else {
      device = parameters.device;
    }
    device.lost.then((info) => {
      const deviceLossInfo = {
        api: "WebGPU",
        message: info.message || "Unknown reason",
        reason: info.reason || null,
        originalEvent: info,
      };
      renderer2.onDeviceLost(deviceLossInfo);
    });
    const context2 =
      parameters.context !== void 0
        ? parameters.context
        : renderer2.domElement.getContext("webgpu");
    this.device = device;
    this.context = context2;
    const alphaMode = parameters.alpha ? "premultiplied" : "opaque";
    this.trackTimestamp =
      this.trackTimestamp && this.hasFeature(GPUFeatureName.TimestampQuery);
    this.context.configure({
      device: this.device,
      format: this.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
      alphaMode,
    });
    this.updateSize();
  }
  /**
   * The coordinate system of the backend.
   *
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {
    return WebGPUCoordinateSystem;
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute2) {
    return await this.attributeUtils.getArrayBufferAsync(attribute2);
  }
  /**
   * Returns the backend's rendering context.
   *
   * @return {GPUCanvasContext} The rendering context.
   */
  getContext() {
    return this.context;
  }
  /**
   * Returns the default render pass descriptor.
   *
   * In WebGPU, the default framebuffer must be configured
   * like custom framebuffers so the backend needs a render
   * pass descriptor even when rendering directly to screen.
   *
   * @private
   * @return {Object} The render pass descriptor.
   */
  _getDefaultRenderPassDescriptor() {
    let descriptor = this.defaultRenderPassdescriptor;
    if (descriptor === null) {
      const renderer2 = this.renderer;
      descriptor = {
        colorAttachments: [
          {
            view: null,
          },
        ],
      };
      if (this.renderer.depth === true || this.renderer.stencil === true) {
        descriptor.depthStencilAttachment = {
          view: this.textureUtils
            .getDepthBuffer(renderer2.depth, renderer2.stencil)
            .createView(),
        };
      }
      const colorAttachment2 = descriptor.colorAttachments[0];
      if (this.renderer.samples > 0) {
        colorAttachment2.view = this.colorBuffer.createView();
      } else {
        colorAttachment2.resolveTarget = void 0;
      }
      this.defaultRenderPassdescriptor = descriptor;
    }
    const colorAttachment = descriptor.colorAttachments[0];
    if (this.renderer.samples > 0) {
      colorAttachment.resolveTarget = this.context
        .getCurrentTexture()
        .createView();
    } else {
      colorAttachment.view = this.context.getCurrentTexture().createView();
    }
    return descriptor;
  }
  /**
   * Internal to determine if the current render target is a render target array with depth 2D array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {boolean} Whether the render target is a render target array with depth 2D array texture.
   *
   * @private
   */
  _isRenderCameraDepthArray(renderContext) {
    return (
      renderContext.depthTexture &&
      renderContext.depthTexture.image.depth > 1 &&
      renderContext.camera.isArrayCamera
    );
  }
  /**
   * Returns the render pass descriptor for the given render context.
   *
   * @private
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} colorAttachmentsConfig - Configuration object for the color attachments.
   * @return {Object} The render pass descriptor.
   */
  _getRenderPassDescriptor(renderContext, colorAttachmentsConfig = {}) {
    const renderTarget = renderContext.renderTarget;
    const renderTargetData = this.get(renderTarget);
    let descriptors = renderTargetData.descriptors;
    if (
      descriptors === void 0 ||
      renderTargetData.width !== renderTarget.width ||
      renderTargetData.height !== renderTarget.height ||
      renderTargetData.dimensions !== renderTarget.dimensions ||
      renderTargetData.activeMipmapLevel !== renderContext.activeMipmapLevel ||
      renderTargetData.activeCubeFace !== renderContext.activeCubeFace ||
      renderTargetData.samples !== renderTarget.samples
    ) {
      descriptors = {};
      renderTargetData.descriptors = descriptors;
      const onDispose = () => {
        renderTarget.removeEventListener("dispose", onDispose);
        this.delete(renderTarget);
      };
      if (renderTarget.hasEventListener("dispose", onDispose) === false) {
        renderTarget.addEventListener("dispose", onDispose);
      }
    }
    const cacheKey = renderContext.getCacheKey();
    let descriptorBase = descriptors[cacheKey];
    if (descriptorBase === void 0) {
      const textures = renderContext.textures;
      const textureViews = [];
      let sliceIndex;
      const isRenderCameraDepthArray =
        this._isRenderCameraDepthArray(renderContext);
      for (let i2 = 0; i2 < textures.length; i2++) {
        const textureData = this.get(textures[i2]);
        const viewDescriptor = {
          label: `colorAttachment_${i2}`,
          baseMipLevel: renderContext.activeMipmapLevel,
          mipLevelCount: 1,
          baseArrayLayer: renderContext.activeCubeFace,
          arrayLayerCount: 1,
          dimension: GPUTextureViewDimension.TwoD,
        };
        if (renderTarget.isRenderTarget3D) {
          sliceIndex = renderContext.activeCubeFace;
          viewDescriptor.baseArrayLayer = 0;
          viewDescriptor.dimension = GPUTextureViewDimension.ThreeD;
          viewDescriptor.depthOrArrayLayers = textures[i2].image.depth;
        } else if (
          renderTarget.isRenderTarget &&
          textures[i2].image.depth > 1
        ) {
          if (isRenderCameraDepthArray === true) {
            const cameras = renderContext.camera.cameras;
            for (let layer = 0; layer < cameras.length; layer++) {
              const layerViewDescriptor = {
                ...viewDescriptor,
                baseArrayLayer: layer,
                arrayLayerCount: 1,
                dimension: GPUTextureViewDimension.TwoD,
              };
              const textureView =
                textureData.texture.createView(layerViewDescriptor);
              textureViews.push({
                view: textureView,
                resolveTarget: void 0,
                depthSlice: void 0,
              });
            }
          } else {
            viewDescriptor.dimension = GPUTextureViewDimension.TwoDArray;
            viewDescriptor.depthOrArrayLayers = textures[i2].image.depth;
          }
        }
        if (isRenderCameraDepthArray !== true) {
          const textureView = textureData.texture.createView(viewDescriptor);
          let view, resolveTarget;
          if (textureData.msaaTexture !== void 0) {
            view = textureData.msaaTexture.createView();
            resolveTarget = textureView;
          } else {
            view = textureView;
            resolveTarget = void 0;
          }
          textureViews.push({
            view,
            resolveTarget,
            depthSlice: sliceIndex,
          });
        }
      }
      descriptorBase = { textureViews };
      if (renderContext.depth) {
        const depthTextureData = this.get(renderContext.depthTexture);
        const options = {};
        if (renderContext.depthTexture.isArrayTexture) {
          options.dimension = GPUTextureViewDimension.TwoD;
          options.arrayLayerCount = 1;
          options.baseArrayLayer = renderContext.activeCubeFace;
        }
        descriptorBase.depthStencilView =
          depthTextureData.texture.createView(options);
      }
      descriptors[cacheKey] = descriptorBase;
      renderTargetData.width = renderTarget.width;
      renderTargetData.height = renderTarget.height;
      renderTargetData.samples = renderTarget.samples;
      renderTargetData.activeMipmapLevel = renderContext.activeMipmapLevel;
      renderTargetData.activeCubeFace = renderContext.activeCubeFace;
      renderTargetData.dimensions = renderTarget.dimensions;
    }
    const descriptor = {
      colorAttachments: [],
    };
    for (let i2 = 0; i2 < descriptorBase.textureViews.length; i2++) {
      const viewInfo = descriptorBase.textureViews[i2];
      let clearValue = { r: 0, g: 0, b: 0, a: 1 };
      if (i2 === 0 && colorAttachmentsConfig.clearValue) {
        clearValue = colorAttachmentsConfig.clearValue;
      }
      descriptor.colorAttachments.push({
        view: viewInfo.view,
        depthSlice: viewInfo.depthSlice,
        resolveTarget: viewInfo.resolveTarget,
        loadOp: colorAttachmentsConfig.loadOp || GPULoadOp.Load,
        storeOp: colorAttachmentsConfig.storeOp || GPUStoreOp.Store,
        clearValue,
      });
    }
    if (descriptorBase.depthStencilView) {
      descriptor.depthStencilAttachment = {
        view: descriptorBase.depthStencilView,
      };
    }
    return descriptor;
  }
  /**
   * This method is executed at the beginning of a render call and prepares
   * the WebGPU state for upcoming render calls
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender(renderContext) {
    const renderContextData = this.get(renderContext);
    const device = this.device;
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    let occlusionQuerySet;
    if (occlusionQueryCount > 0) {
      if (renderContextData.currentOcclusionQuerySet)
        renderContextData.currentOcclusionQuerySet.destroy();
      if (renderContextData.currentOcclusionQueryBuffer)
        renderContextData.currentOcclusionQueryBuffer.destroy();
      renderContextData.currentOcclusionQuerySet =
        renderContextData.occlusionQuerySet;
      renderContextData.currentOcclusionQueryBuffer =
        renderContextData.occlusionQueryBuffer;
      renderContextData.currentOcclusionQueryObjects =
        renderContextData.occlusionQueryObjects;
      occlusionQuerySet = device.createQuerySet({
        type: "occlusion",
        count: occlusionQueryCount,
        label: `occlusionQuerySet_${renderContext.id}`,
      });
      renderContextData.occlusionQuerySet = occlusionQuerySet;
      renderContextData.occlusionQueryIndex = 0;
      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
      renderContextData.lastOcclusionObject = null;
    }
    let descriptor;
    if (renderContext.textures === null) {
      descriptor = this._getDefaultRenderPassDescriptor();
    } else {
      descriptor = this._getRenderPassDescriptor(renderContext, {
        loadOp: GPULoadOp.Load,
      });
    }
    this.initTimestampQuery(renderContext, descriptor);
    descriptor.occlusionQuerySet = occlusionQuerySet;
    const depthStencilAttachment = descriptor.depthStencilAttachment;
    if (renderContext.textures !== null) {
      const colorAttachments = descriptor.colorAttachments;
      for (let i2 = 0; i2 < colorAttachments.length; i2++) {
        const colorAttachment = colorAttachments[i2];
        if (renderContext.clearColor) {
          colorAttachment.clearValue =
            i2 === 0
              ? renderContext.clearColorValue
              : { r: 0, g: 0, b: 0, a: 1 };
          colorAttachment.loadOp = GPULoadOp.Clear;
        } else {
          colorAttachment.loadOp = GPULoadOp.Load;
        }
        colorAttachment.storeOp = GPUStoreOp.Store;
      }
    } else {
      const colorAttachment = descriptor.colorAttachments[0];
      if (renderContext.clearColor) {
        colorAttachment.clearValue = renderContext.clearColorValue;
        colorAttachment.loadOp = GPULoadOp.Clear;
      } else {
        colorAttachment.loadOp = GPULoadOp.Load;
      }
      colorAttachment.storeOp = GPUStoreOp.Store;
    }
    if (renderContext.depth) {
      if (renderContext.clearDepth) {
        depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;
        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
      } else {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
      }
      depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
    }
    if (renderContext.stencil) {
      if (renderContext.clearStencil) {
        depthStencilAttachment.stencilClearValue =
          renderContext.clearStencilValue;
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
      } else {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
      }
      depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
    }
    const encoder = device.createCommandEncoder({
      label: "renderContext_" + renderContext.id,
    });
    if (this._isRenderCameraDepthArray(renderContext) === true) {
      const cameras = renderContext.camera.cameras;
      if (
        !renderContextData.layerDescriptors ||
        renderContextData.layerDescriptors.length !== cameras.length
      ) {
        this._createDepthLayerDescriptors(
          renderContext,
          renderContextData,
          descriptor,
          cameras
        );
      } else {
        this._updateDepthLayerDescriptors(
          renderContext,
          renderContextData,
          cameras
        );
      }
      renderContextData.bundleEncoders = [];
      renderContextData.bundleSets = [];
      for (let i2 = 0; i2 < cameras.length; i2++) {
        const bundleEncoder = this.pipelineUtils.createBundleEncoder(
          renderContext,
          "renderBundleArrayCamera_" + i2
        );
        const bundleSets = {
          attributes: {},
          bindingGroups: [],
          pipeline: null,
          index: null,
        };
        renderContextData.bundleEncoders.push(bundleEncoder);
        renderContextData.bundleSets.push(bundleSets);
      }
      renderContextData.currentPass = null;
    } else {
      const currentPass = encoder.beginRenderPass(descriptor);
      renderContextData.currentPass = currentPass;
      if (renderContext.viewport) {
        this.updateViewport(renderContext);
      }
      if (renderContext.scissor) {
        const { x, y, width, height } = renderContext.scissorValue;
        currentPass.setScissorRect(x, y, width, height);
      }
    }
    renderContextData.descriptor = descriptor;
    renderContextData.encoder = encoder;
    renderContextData.currentSets = {
      attributes: {},
      bindingGroups: [],
      pipeline: null,
      index: null,
    };
    renderContextData.renderBundles = [];
  }
  /**
   * This method creates layer descriptors for each camera in an array camera
   * to prepare for rendering to a depth array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} renderContextData - The render context data.
   * @param {Object} descriptor  - The render pass descriptor.
   * @param {ArrayCamera} cameras - The array camera.
   *
   * @private
   */
  _createDepthLayerDescriptors(
    renderContext,
    renderContextData,
    descriptor,
    cameras
  ) {
    const depthStencilAttachment = descriptor.depthStencilAttachment;
    renderContextData.layerDescriptors = [];
    const depthTextureData = this.get(renderContext.depthTexture);
    if (!depthTextureData.viewCache) {
      depthTextureData.viewCache = [];
    }
    for (let i2 = 0; i2 < cameras.length; i2++) {
      const layerDescriptor = {
        ...descriptor,
        colorAttachments: [
          {
            ...descriptor.colorAttachments[0],
            view: descriptor.colorAttachments[i2].view,
          },
        ],
      };
      if (descriptor.depthStencilAttachment) {
        const layerIndex = i2;
        if (!depthTextureData.viewCache[layerIndex]) {
          depthTextureData.viewCache[layerIndex] =
            depthTextureData.texture.createView({
              dimension: GPUTextureViewDimension.TwoD,
              baseArrayLayer: i2,
              arrayLayerCount: 1,
            });
        }
        layerDescriptor.depthStencilAttachment = {
          view: depthTextureData.viewCache[layerIndex],
          depthLoadOp: depthStencilAttachment.depthLoadOp || GPULoadOp.Clear,
          depthStoreOp: depthStencilAttachment.depthStoreOp || GPUStoreOp.Store,
          depthClearValue: depthStencilAttachment.depthClearValue || 1,
        };
        if (renderContext.stencil) {
          layerDescriptor.depthStencilAttachment.stencilLoadOp =
            depthStencilAttachment.stencilLoadOp;
          layerDescriptor.depthStencilAttachment.stencilStoreOp =
            depthStencilAttachment.stencilStoreOp;
          layerDescriptor.depthStencilAttachment.stencilClearValue =
            depthStencilAttachment.stencilClearValue;
        }
      } else {
        layerDescriptor.depthStencilAttachment = { ...depthStencilAttachment };
      }
      renderContextData.layerDescriptors.push(layerDescriptor);
    }
  }
  /**
   * This method updates the layer descriptors for each camera in an array camera
   * to prepare for rendering to a depth array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} renderContextData - The render context data.
   * @param {ArrayCamera} cameras - The array camera.
   *
   */
  _updateDepthLayerDescriptors(renderContext, renderContextData, cameras) {
    for (let i2 = 0; i2 < cameras.length; i2++) {
      const layerDescriptor = renderContextData.layerDescriptors[i2];
      if (layerDescriptor.depthStencilAttachment) {
        const depthAttachment = layerDescriptor.depthStencilAttachment;
        if (renderContext.depth) {
          if (renderContext.clearDepth) {
            depthAttachment.depthClearValue = renderContext.clearDepthValue;
            depthAttachment.depthLoadOp = GPULoadOp.Clear;
          } else {
            depthAttachment.depthLoadOp = GPULoadOp.Load;
          }
        }
        if (renderContext.stencil) {
          if (renderContext.clearStencil) {
            depthAttachment.stencilClearValue = renderContext.clearStencilValue;
            depthAttachment.stencilLoadOp = GPULoadOp.Clear;
          } else {
            depthAttachment.stencilLoadOp = GPULoadOp.Load;
          }
        }
      }
    }
  }
  /**
   * This method is executed at the end of a render call and finalizes work
   * after draw calls.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender(renderContext) {
    const renderContextData = this.get(renderContext);
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (renderContextData.renderBundles.length > 0) {
      renderContextData.currentPass.executeBundles(
        renderContextData.renderBundles
      );
    }
    if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {
      renderContextData.currentPass.endOcclusionQuery();
    }
    const encoder = renderContextData.encoder;
    if (this._isRenderCameraDepthArray(renderContext) === true) {
      const bundles = [];
      for (let i2 = 0; i2 < renderContextData.bundleEncoders.length; i2++) {
        const bundleEncoder = renderContextData.bundleEncoders[i2];
        bundles.push(bundleEncoder.finish());
      }
      for (let i2 = 0; i2 < renderContextData.layerDescriptors.length; i2++) {
        if (i2 < bundles.length) {
          const layerDescriptor = renderContextData.layerDescriptors[i2];
          const renderPass = encoder.beginRenderPass(layerDescriptor);
          if (renderContext.viewport) {
            const { x, y, width, height, minDepth, maxDepth } =
              renderContext.viewportValue;
            renderPass.setViewport(x, y, width, height, minDepth, maxDepth);
          }
          if (renderContext.scissor) {
            const { x, y, width, height } = renderContext.scissorValue;
            renderPass.setScissorRect(x, y, width, height);
          }
          renderPass.executeBundles([bundles[i2]]);
          renderPass.end();
        }
      }
    } else if (renderContextData.currentPass) {
      renderContextData.currentPass.end();
    }
    if (occlusionQueryCount > 0) {
      const bufferSize = occlusionQueryCount * 8;
      let queryResolveBuffer = this.occludedResolveCache.get(bufferSize);
      if (queryResolveBuffer === void 0) {
        queryResolveBuffer = this.device.createBuffer({
          size: bufferSize,
          usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
        });
        this.occludedResolveCache.set(bufferSize, queryResolveBuffer);
      }
      const readBuffer = this.device.createBuffer({
        size: bufferSize,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
      });
      renderContextData.encoder.resolveQuerySet(
        renderContextData.occlusionQuerySet,
        0,
        occlusionQueryCount,
        queryResolveBuffer,
        0
      );
      renderContextData.encoder.copyBufferToBuffer(
        queryResolveBuffer,
        0,
        readBuffer,
        0,
        bufferSize
      );
      renderContextData.occlusionQueryBuffer = readBuffer;
      this.resolveOccludedAsync(renderContext);
    }
    this.device.queue.submit([renderContextData.encoder.finish()]);
    if (renderContext.textures !== null) {
      const textures = renderContext.textures;
      for (let i2 = 0; i2 < textures.length; i2++) {
        const texture2 = textures[i2];
        if (texture2.generateMipmaps === true) {
          this.textureUtils.generateMipmaps(texture2);
        }
      }
    }
  }
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(renderContext, object) {
    const renderContextData = this.get(renderContext);
    return renderContextData.occluded && renderContextData.occluded.has(object);
  }
  /**
   * This method processes the result of occlusion queries and writes it
   * into render context data.
   *
   * @async
   * @param {RenderContext} renderContext - The render context.
   * @return {Promise} A Promise that resolves when the occlusion query results have been processed.
   */
  async resolveOccludedAsync(renderContext) {
    const renderContextData = this.get(renderContext);
    const { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } =
      renderContextData;
    if (currentOcclusionQueryBuffer && currentOcclusionQueryObjects) {
      const occluded = /* @__PURE__ */ new WeakSet();
      renderContextData.currentOcclusionQueryObjects = null;
      renderContextData.currentOcclusionQueryBuffer = null;
      await currentOcclusionQueryBuffer.mapAsync(GPUMapMode.READ);
      const buffer2 = currentOcclusionQueryBuffer.getMappedRange();
      const results = new BigUint64Array(buffer2);
      for (let i2 = 0; i2 < currentOcclusionQueryObjects.length; i2++) {
        if (results[i2] === BigInt(0)) {
          occluded.add(currentOcclusionQueryObjects[i2]);
        }
      }
      currentOcclusionQueryBuffer.destroy();
      renderContextData.occluded = occluded;
    }
  }
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport(renderContext) {
    const { currentPass } = this.get(renderContext);
    const { x, y, width, height, minDepth, maxDepth } =
      renderContext.viewportValue;
    currentPass.setViewport(x, y, width, height, minDepth, maxDepth);
  }
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const clearColor = super.getClearColor();
    if (this.renderer.alpha === true) {
      clearColor.r *= clearColor.a;
      clearColor.g *= clearColor.a;
      clearColor.b *= clearColor.a;
    }
    return clearColor;
  }
  /**
   * Performs a clear operation.
   *
   * @param {boolean} color - Whether the color buffer should be cleared or not.
   * @param {boolean} depth - Whether the depth buffer should be cleared or not.
   * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.
   * @param {?RenderContext} [renderTargetContext=null] - The render context of the current set render target.
   */
  clear(color2, depth2, stencil, renderTargetContext = null) {
    const device = this.device;
    const renderer2 = this.renderer;
    let colorAttachments = [];
    let depthStencilAttachment;
    let clearValue;
    let supportsDepth;
    let supportsStencil;
    if (color2) {
      const clearColor = this.getClearColor();
      clearValue = {
        r: clearColor.r,
        g: clearColor.g,
        b: clearColor.b,
        a: clearColor.a,
      };
    }
    if (renderTargetContext === null) {
      supportsDepth = renderer2.depth;
      supportsStencil = renderer2.stencil;
      const descriptor = this._getDefaultRenderPassDescriptor();
      if (color2) {
        colorAttachments = descriptor.colorAttachments;
        const colorAttachment = colorAttachments[0];
        colorAttachment.clearValue = clearValue;
        colorAttachment.loadOp = GPULoadOp.Clear;
        colorAttachment.storeOp = GPUStoreOp.Store;
      }
      if (supportsDepth || supportsStencil) {
        depthStencilAttachment = descriptor.depthStencilAttachment;
      }
    } else {
      supportsDepth = renderTargetContext.depth;
      supportsStencil = renderTargetContext.stencil;
      const clearConfig = {
        loadOp: color2 ? GPULoadOp.Clear : GPULoadOp.Load,
        clearValue: color2 ? clearValue : void 0,
      };
      if (supportsDepth) {
        clearConfig.depthLoadOp = depth2 ? GPULoadOp.Clear : GPULoadOp.Load;
        clearConfig.depthClearValue = depth2
          ? renderer2.getClearDepth()
          : void 0;
        clearConfig.depthStoreOp = GPUStoreOp.Store;
      }
      if (supportsStencil) {
        clearConfig.stencilLoadOp = stencil ? GPULoadOp.Clear : GPULoadOp.Load;
        clearConfig.stencilClearValue = stencil
          ? renderer2.getClearStencil()
          : void 0;
        clearConfig.stencilStoreOp = GPUStoreOp.Store;
      }
      const descriptor = this._getRenderPassDescriptor(
        renderTargetContext,
        clearConfig
      );
      colorAttachments = descriptor.colorAttachments;
      depthStencilAttachment = descriptor.depthStencilAttachment;
    }
    if (supportsDepth && depthStencilAttachment) {
      if (depth2) {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
        depthStencilAttachment.depthClearValue = renderer2.getClearDepth();
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      } else {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      }
    }
    if (supportsStencil && depthStencilAttachment) {
      if (stencil) {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
        depthStencilAttachment.stencilClearValue = renderer2.getClearStencil();
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      } else {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      }
    }
    const encoder = device.createCommandEncoder({ label: "clear" });
    const currentPass = encoder.beginRenderPass({
      colorAttachments,
      depthStencilAttachment,
    });
    currentPass.end();
    device.queue.submit([encoder.finish()]);
  }
  // compute
  /**
   * This method is executed at the beginning of a compute call and
   * prepares the state for upcoming compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute(computeGroup) {
    const groupGPU = this.get(computeGroup);
    const descriptor = {
      label: "computeGroup_" + computeGroup.id,
    };
    this.initTimestampQuery(computeGroup, descriptor);
    groupGPU.cmdEncoderGPU = this.device.createCommandEncoder({
      label: "computeGroup_" + computeGroup.id,
    });
    groupGPU.passEncoderGPU =
      groupGPU.cmdEncoderGPU.beginComputePass(descriptor);
  }
  /**
   * Executes a compute command for the given compute node.
   *
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} pipeline - The compute pipeline.
   * @param {Array<number>|number} [dispatchSizeOrCount=null] - Array with [ x, y, z ] values for dispatch or a single number for the count.
   */
  compute(
    computeGroup,
    computeNode,
    bindings,
    pipeline,
    dispatchSizeOrCount = null
  ) {
    const computeNodeData = this.get(computeNode);
    const { passEncoderGPU } = this.get(computeGroup);
    const pipelineGPU = this.get(pipeline).pipeline;
    this.pipelineUtils.setPipeline(passEncoderGPU, pipelineGPU);
    for (let i2 = 0, l2 = bindings.length; i2 < l2; i2++) {
      const bindGroup = bindings[i2];
      const bindingsData = this.get(bindGroup);
      passEncoderGPU.setBindGroup(i2, bindingsData.group);
    }
    let dispatchSize;
    if (dispatchSizeOrCount === null) {
      dispatchSizeOrCount = computeNode.count;
    }
    if (typeof dispatchSizeOrCount === "number") {
      const count = dispatchSizeOrCount;
      if (
        computeNodeData.dispatchSize === void 0 ||
        computeNodeData.count !== count
      ) {
        computeNodeData.dispatchSize = [0, 1, 1];
        computeNodeData.count = count;
        const workgroupSize = computeNode.workgroupSize;
        let size = workgroupSize[0];
        for (let i2 = 1; i2 < workgroupSize.length; i2++)
          size *= workgroupSize[i2];
        const dispatchCount = Math.ceil(count / size);
        const maxComputeWorkgroupsPerDimension =
          this.device.limits.maxComputeWorkgroupsPerDimension;
        dispatchSize = [dispatchCount, 1, 1];
        if (dispatchCount > maxComputeWorkgroupsPerDimension) {
          dispatchSize[0] = Math.min(
            dispatchCount,
            maxComputeWorkgroupsPerDimension
          );
          dispatchSize[1] = Math.ceil(
            dispatchCount / maxComputeWorkgroupsPerDimension
          );
        }
        computeNodeData.dispatchSize = dispatchSize;
      }
      dispatchSize = computeNodeData.dispatchSize;
    } else {
      dispatchSize = dispatchSizeOrCount;
    }
    passEncoderGPU.dispatchWorkgroups(
      dispatchSize[0],
      dispatchSize[1] || 1,
      dispatchSize[2] || 1
    );
  }
  /**
   * This method is executed at the end of a compute call and
   * finalizes work after compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute(computeGroup) {
    const groupData = this.get(computeGroup);
    groupData.passEncoderGPU.end();
    this.device.queue.submit([groupData.cmdEncoderGPU.finish()]);
  }
  /**
   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
   * the CPU waits for the GPU to complete its operation (e.g. a compute task).
   *
   * @async
   * @return {Promise} A Promise that resolves when synchronization has been finished.
   */
  async waitForGPU() {
    await this.device.queue.onSubmittedWorkDone();
  }
  // render object
  /**
   * Executes a draw command for the given render object.
   *
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw(renderObject, info) {
    const { object, material, context: context2, pipeline } = renderObject;
    const bindings = renderObject.getBindings();
    const renderContextData = this.get(context2);
    const pipelineGPU = this.get(pipeline).pipeline;
    const index = renderObject.getIndex();
    const hasIndex = index !== null;
    const drawParams = renderObject.getDrawParameters();
    if (drawParams === null) return;
    const setPipelineAndBindings = (passEncoderGPU, currentSets) => {
      this.pipelineUtils.setPipeline(passEncoderGPU, pipelineGPU);
      currentSets.pipeline = pipelineGPU;
      const currentBindingGroups = currentSets.bindingGroups;
      for (let i2 = 0, l2 = bindings.length; i2 < l2; i2++) {
        const bindGroup = bindings[i2];
        const bindingsData = this.get(bindGroup);
        if (currentBindingGroups[bindGroup.index] !== bindGroup.id) {
          passEncoderGPU.setBindGroup(bindGroup.index, bindingsData.group);
          currentBindingGroups[bindGroup.index] = bindGroup.id;
        }
      }
      if (hasIndex === true) {
        if (currentSets.index !== index) {
          const buffer2 = this.get(index).buffer;
          const indexFormat =
            index.array instanceof Uint16Array
              ? GPUIndexFormat.Uint16
              : GPUIndexFormat.Uint32;
          passEncoderGPU.setIndexBuffer(buffer2, indexFormat);
          currentSets.index = index;
        }
      }
      const vertexBuffers = renderObject.getVertexBuffers();
      for (let i2 = 0, l2 = vertexBuffers.length; i2 < l2; i2++) {
        const vertexBuffer = vertexBuffers[i2];
        if (currentSets.attributes[i2] !== vertexBuffer) {
          const buffer2 = this.get(vertexBuffer).buffer;
          passEncoderGPU.setVertexBuffer(i2, buffer2);
          currentSets.attributes[i2] = vertexBuffer;
        }
      }
      if (
        context2.stencil === true &&
        material.stencilWrite === true &&
        renderContextData.currentStencilRef !== material.stencilRef
      ) {
        passEncoderGPU.setStencilReference(material.stencilRef);
        renderContextData.currentStencilRef = material.stencilRef;
      }
    };
    const draw = (passEncoderGPU, currentSets) => {
      setPipelineAndBindings(passEncoderGPU, currentSets);
      if (object.isBatchedMesh === true) {
        const starts = object._multiDrawStarts;
        const counts = object._multiDrawCounts;
        const drawCount = object._multiDrawCount;
        const drawInstances = object._multiDrawInstances;
        if (drawInstances !== null) {
          warnOnce(
            "THREE.WebGPUBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."
          );
        }
        for (let i2 = 0; i2 < drawCount; i2++) {
          const count = drawInstances ? drawInstances[i2] : 1;
          const firstInstance = count > 1 ? 0 : i2;
          if (hasIndex === true) {
            passEncoderGPU.drawIndexed(
              counts[i2],
              count,
              starts[i2] / index.array.BYTES_PER_ELEMENT,
              0,
              firstInstance
            );
          } else {
            passEncoderGPU.draw(counts[i2], count, starts[i2], firstInstance);
          }
          info.update(object, counts[i2], count);
        }
      } else if (hasIndex === true) {
        const {
          vertexCount: indexCount,
          instanceCount,
          firstVertex: firstIndex,
        } = drawParams;
        const indirect = renderObject.getIndirect();
        if (indirect !== null) {
          const buffer2 = this.get(indirect).buffer;
          passEncoderGPU.drawIndexedIndirect(buffer2, 0);
        } else {
          passEncoderGPU.drawIndexed(
            indexCount,
            instanceCount,
            firstIndex,
            0,
            0
          );
        }
        info.update(object, indexCount, instanceCount);
      } else {
        const { vertexCount, instanceCount, firstVertex } = drawParams;
        const indirect = renderObject.getIndirect();
        if (indirect !== null) {
          const buffer2 = this.get(indirect).buffer;
          passEncoderGPU.drawIndirect(buffer2, 0);
        } else {
          passEncoderGPU.draw(vertexCount, instanceCount, firstVertex, 0);
        }
        info.update(object, vertexCount, instanceCount);
      }
    };
    if (
      renderObject.camera.isArrayCamera &&
      renderObject.camera.cameras.length > 0
    ) {
      const cameraData = this.get(renderObject.camera);
      const cameras = renderObject.camera.cameras;
      const cameraIndex2 = renderObject.getBindingGroup("cameraIndex");
      if (
        cameraData.indexesGPU === void 0 ||
        cameraData.indexesGPU.length !== cameras.length
      ) {
        const bindingsData = this.get(cameraIndex2);
        const indexesGPU = [];
        const data = new Uint32Array([0, 0, 0, 0]);
        for (let i2 = 0, len = cameras.length; i2 < len; i2++) {
          data[0] = i2;
          const bindGroupIndex = this.bindingUtils.createBindGroupIndex(
            data,
            bindingsData.layout
          );
          indexesGPU.push(bindGroupIndex);
        }
        cameraData.indexesGPU = indexesGPU;
      }
      const pixelRatio = this.renderer.getPixelRatio();
      for (let i2 = 0, len = cameras.length; i2 < len; i2++) {
        const subCamera = cameras[i2];
        if (object.layers.test(subCamera.layers)) {
          const vp = subCamera.viewport;
          let pass2 = renderContextData.currentPass;
          let sets = renderContextData.currentSets;
          if (renderContextData.bundleEncoders) {
            const bundleEncoder = renderContextData.bundleEncoders[i2];
            const bundleSets = renderContextData.bundleSets[i2];
            pass2 = bundleEncoder;
            sets = bundleSets;
          }
          if (vp) {
            pass2.setViewport(
              Math.floor(vp.x * pixelRatio),
              Math.floor(vp.y * pixelRatio),
              Math.floor(vp.width * pixelRatio),
              Math.floor(vp.height * pixelRatio),
              context2.viewportValue.minDepth,
              context2.viewportValue.maxDepth
            );
          }
          if (cameraIndex2 && cameraData.indexesGPU) {
            pass2.setBindGroup(cameraIndex2.index, cameraData.indexesGPU[i2]);
            sets.bindingGroups[cameraIndex2.index] = cameraIndex2.id;
          }
          draw(pass2, sets);
        }
      }
    } else {
      if (renderContextData.currentPass) {
        if (renderContextData.occlusionQuerySet !== void 0) {
          const lastObject = renderContextData.lastOcclusionObject;
          if (lastObject !== object) {
            if (lastObject !== null && lastObject.occlusionTest === true) {
              renderContextData.currentPass.endOcclusionQuery();
              renderContextData.occlusionQueryIndex++;
            }
            if (object.occlusionTest === true) {
              renderContextData.currentPass.beginOcclusionQuery(
                renderContextData.occlusionQueryIndex
              );
              renderContextData.occlusionQueryObjects[
                renderContextData.occlusionQueryIndex
              ] = object;
            }
            renderContextData.lastOcclusionObject = object;
          }
        }
        draw(renderContextData.currentPass, renderContextData.currentSets);
      }
    }
  }
  // cache key
  /**
   * Returns `true` if the render pipeline requires an update.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate(renderObject) {
    const data = this.get(renderObject);
    const { object, material } = renderObject;
    const utils = this.utils;
    const sampleCount = utils.getSampleCountRenderContext(renderObject.context);
    const colorSpace = utils.getCurrentColorSpace(renderObject.context);
    const colorFormat = utils.getCurrentColorFormat(renderObject.context);
    const depthStencilFormat = utils.getCurrentDepthStencilFormat(
      renderObject.context
    );
    const primitiveTopology = utils.getPrimitiveTopology(object, material);
    let needsUpdate = false;
    if (
      data.material !== material ||
      data.materialVersion !== material.version ||
      data.transparent !== material.transparent ||
      data.blending !== material.blending ||
      data.premultipliedAlpha !== material.premultipliedAlpha ||
      data.blendSrc !== material.blendSrc ||
      data.blendDst !== material.blendDst ||
      data.blendEquation !== material.blendEquation ||
      data.blendSrcAlpha !== material.blendSrcAlpha ||
      data.blendDstAlpha !== material.blendDstAlpha ||
      data.blendEquationAlpha !== material.blendEquationAlpha ||
      data.colorWrite !== material.colorWrite ||
      data.depthWrite !== material.depthWrite ||
      data.depthTest !== material.depthTest ||
      data.depthFunc !== material.depthFunc ||
      data.stencilWrite !== material.stencilWrite ||
      data.stencilFunc !== material.stencilFunc ||
      data.stencilFail !== material.stencilFail ||
      data.stencilZFail !== material.stencilZFail ||
      data.stencilZPass !== material.stencilZPass ||
      data.stencilFuncMask !== material.stencilFuncMask ||
      data.stencilWriteMask !== material.stencilWriteMask ||
      data.side !== material.side ||
      data.alphaToCoverage !== material.alphaToCoverage ||
      data.sampleCount !== sampleCount ||
      data.colorSpace !== colorSpace ||
      data.colorFormat !== colorFormat ||
      data.depthStencilFormat !== depthStencilFormat ||
      data.primitiveTopology !== primitiveTopology ||
      data.clippingContextCacheKey !== renderObject.clippingContextCacheKey
    ) {
      data.material = material;
      data.materialVersion = material.version;
      data.transparent = material.transparent;
      data.blending = material.blending;
      data.premultipliedAlpha = material.premultipliedAlpha;
      data.blendSrc = material.blendSrc;
      data.blendDst = material.blendDst;
      data.blendEquation = material.blendEquation;
      data.blendSrcAlpha = material.blendSrcAlpha;
      data.blendDstAlpha = material.blendDstAlpha;
      data.blendEquationAlpha = material.blendEquationAlpha;
      data.colorWrite = material.colorWrite;
      data.depthWrite = material.depthWrite;
      data.depthTest = material.depthTest;
      data.depthFunc = material.depthFunc;
      data.stencilWrite = material.stencilWrite;
      data.stencilFunc = material.stencilFunc;
      data.stencilFail = material.stencilFail;
      data.stencilZFail = material.stencilZFail;
      data.stencilZPass = material.stencilZPass;
      data.stencilFuncMask = material.stencilFuncMask;
      data.stencilWriteMask = material.stencilWriteMask;
      data.side = material.side;
      data.alphaToCoverage = material.alphaToCoverage;
      data.sampleCount = sampleCount;
      data.colorSpace = colorSpace;
      data.colorFormat = colorFormat;
      data.depthStencilFormat = depthStencilFormat;
      data.primitiveTopology = primitiveTopology;
      data.clippingContextCacheKey = renderObject.clippingContextCacheKey;
      needsUpdate = true;
    }
    return needsUpdate;
  }
  /**
   * Returns a cache key that is used to identify render pipelines.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey(renderObject) {
    const { object, material } = renderObject;
    const utils = this.utils;
    const renderContext = renderObject.context;
    return [
      material.transparent,
      material.blending,
      material.premultipliedAlpha,
      material.blendSrc,
      material.blendDst,
      material.blendEquation,
      material.blendSrcAlpha,
      material.blendDstAlpha,
      material.blendEquationAlpha,
      material.colorWrite,
      material.depthWrite,
      material.depthTest,
      material.depthFunc,
      material.stencilWrite,
      material.stencilFunc,
      material.stencilFail,
      material.stencilZFail,
      material.stencilZPass,
      material.stencilFuncMask,
      material.stencilWriteMask,
      material.side,
      utils.getSampleCountRenderContext(renderContext),
      utils.getCurrentColorSpace(renderContext),
      utils.getCurrentColorFormat(renderContext),
      utils.getCurrentDepthStencilFormat(renderContext),
      utils.getPrimitiveTopology(object, material),
      renderObject.getGeometryCacheKey(),
      renderObject.clippingContextCacheKey,
    ].join();
  }
  // textures
  /**
   * Creates a GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to create the sampler for.
   */
  createSampler(texture2) {
    this.textureUtils.createSampler(texture2);
  }
  /**
   * Destroys the GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to destroy the sampler for.
   */
  destroySampler(texture2) {
    this.textureUtils.destroySampler(texture2);
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(texture2) {
    this.textureUtils.createDefaultTexture(texture2);
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(texture2, options) {
    this.textureUtils.createTexture(texture2, options);
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(texture2, options) {
    this.textureUtils.updateTexture(texture2, options);
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(texture2) {
    this.textureUtils.generateMipmaps(texture2);
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   */
  destroyTexture(texture2) {
    this.textureUtils.destroyTexture(texture2);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(texture2, x, y, width, height, faceIndex) {
    return this.textureUtils.copyTextureToBuffer(
      texture2,
      x,
      y,
      width,
      height,
      faceIndex
    );
  }
  /**
   * Inits a time stamp query for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} descriptor - The query descriptor.
   */
  initTimestampQuery(renderContext, descriptor) {
    if (!this.trackTimestamp) return;
    const type = renderContext.isComputeNode ? "compute" : "render";
    if (!this.timestampQueryPool[type]) {
      this.timestampQueryPool[type] = new WebGPUTimestampQueryPool(
        this.device,
        type,
        2048
      );
    }
    const timestampQueryPool = this.timestampQueryPool[type];
    const baseOffset =
      timestampQueryPool.allocateQueriesForContext(renderContext);
    descriptor.timestampWrites = {
      querySet: timestampQueryPool.querySet,
      beginningOfPassWriteIndex: baseOffset,
      endOfPassWriteIndex: baseOffset + 1,
    };
  }
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {WGSLNodeBuilder} The node builder.
   */
  createNodeBuilder(object, renderer2) {
    return new WGSLNodeBuilder(object, renderer2);
  }
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram(program2) {
    const programGPU = this.get(program2);
    programGPU.module = {
      module: this.device.createShaderModule({
        code: program2.code,
        label:
          program2.stage + (program2.name !== "" ? `_${program2.name}` : ""),
      }),
      entryPoint: "main",
    };
  }
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram(program2) {
    this.delete(program2);
  }
  // pipelines
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(renderObject, promises) {
    this.pipelineUtils.createRenderPipeline(renderObject, promises);
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(computePipeline, bindings) {
    this.pipelineUtils.createComputePipeline(computePipeline, bindings);
  }
  /**
   * Prepares the state for encoding render bundles.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginBundle(renderContext) {
    const renderContextData = this.get(renderContext);
    renderContextData._currentPass = renderContextData.currentPass;
    renderContextData._currentSets = renderContextData.currentSets;
    renderContextData.currentSets = {
      attributes: {},
      bindingGroups: [],
      pipeline: null,
      index: null,
    };
    renderContextData.currentPass =
      this.pipelineUtils.createBundleEncoder(renderContext);
  }
  /**
   * After processing render bundles this method finalizes related work.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {RenderBundle} bundle - The render bundle.
   */
  finishBundle(renderContext, bundle) {
    const renderContextData = this.get(renderContext);
    const bundleEncoder = renderContextData.currentPass;
    const bundleGPU = bundleEncoder.finish();
    this.get(bundle).bundleGPU = bundleGPU;
    renderContextData.currentSets = renderContextData._currentSets;
    renderContextData.currentPass = renderContextData._currentPass;
  }
  /**
   * Adds a render bundle to the render context data.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {RenderBundle} bundle - The render bundle to add.
   */
  addBundle(renderContext, bundle) {
    const renderContextData = this.get(renderContext);
    renderContextData.renderBundles.push(this.get(bundle).bundleGPU);
  }
  // bindings
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(bindGroup, bindings, cacheIndex, version) {
    this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);
  }
  /**
   * Updates the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings(bindGroup, bindings, cacheIndex, version) {
    this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(binding) {
    this.bindingUtils.updateBinding(binding);
  }
  // attributes
  /**
   * Creates the buffer of an indexed shader attribute.
   *
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute(attribute2) {
    let usage =
      GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;
    if (
      attribute2.isStorageBufferAttribute ||
      attribute2.isStorageInstancedBufferAttribute
    ) {
      usage |= GPUBufferUsage.STORAGE;
    }
    this.attributeUtils.createAttribute(attribute2, usage);
  }
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute(attribute2) {
    this.attributeUtils.createAttribute(
      attribute2,
      GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    );
  }
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute(attribute2) {
    this.attributeUtils.createAttribute(
      attribute2,
      GPUBufferUsage.STORAGE |
        GPUBufferUsage.VERTEX |
        GPUBufferUsage.COPY_SRC |
        GPUBufferUsage.COPY_DST
    );
  }
  /**
   * Creates the GPU buffer of an indirect storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createIndirectStorageAttribute(attribute2) {
    this.attributeUtils.createAttribute(
      attribute2,
      GPUBufferUsage.STORAGE |
        GPUBufferUsage.INDIRECT |
        GPUBufferUsage.COPY_SRC |
        GPUBufferUsage.COPY_DST
    );
  }
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute(attribute2) {
    this.attributeUtils.updateAttribute(attribute2);
  }
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute(attribute2) {
    this.attributeUtils.destroyAttribute(attribute2);
  }
  // canvas
  /**
   * Triggers an update of the default render pass descriptor.
   */
  updateSize() {
    this.colorBuffer = this.textureUtils.getColorBuffer();
    this.defaultRenderPassdescriptor = null;
  }
  // utils public
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    return 16;
  }
  /**
   * Checks if the given feature is supported  by the backend.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(name) {
    return this.device.features.has(name);
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The mipmap level to copy.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(
    srcTexture,
    dstTexture,
    srcRegion = null,
    dstPosition = null,
    srcLevel = 0,
    dstLevel = 0
  ) {
    let dstX = 0;
    let dstY = 0;
    let dstZ = 0;
    let srcX = 0;
    let srcY = 0;
    let srcZ = 0;
    let srcWidth = srcTexture.image.width;
    let srcHeight = srcTexture.image.height;
    let srcDepth = 1;
    if (srcRegion !== null) {
      if (srcRegion.isBox3 === true) {
        srcX = srcRegion.min.x;
        srcY = srcRegion.min.y;
        srcZ = srcRegion.min.z;
        srcWidth = srcRegion.max.x - srcRegion.min.x;
        srcHeight = srcRegion.max.y - srcRegion.min.y;
        srcDepth = srcRegion.max.z - srcRegion.min.z;
      } else {
        srcX = srcRegion.min.x;
        srcY = srcRegion.min.y;
        srcWidth = srcRegion.max.x - srcRegion.min.x;
        srcHeight = srcRegion.max.y - srcRegion.min.y;
        srcDepth = 1;
      }
    }
    if (dstPosition !== null) {
      dstX = dstPosition.x;
      dstY = dstPosition.y;
      dstZ = dstPosition.z || 0;
    }
    const encoder = this.device.createCommandEncoder({
      label: "copyTextureToTexture_" + srcTexture.id + "_" + dstTexture.id,
    });
    const sourceGPU = this.get(srcTexture).texture;
    const destinationGPU = this.get(dstTexture).texture;
    encoder.copyTextureToTexture(
      {
        texture: sourceGPU,
        mipLevel: srcLevel,
        origin: { x: srcX, y: srcY, z: srcZ },
      },
      {
        texture: destinationGPU,
        mipLevel: dstLevel,
        origin: { x: dstX, y: dstY, z: dstZ },
      },
      [srcWidth, srcHeight, srcDepth]
    );
    this.device.queue.submit([encoder.finish()]);
    if (dstLevel === 0 && dstTexture.generateMipmaps) {
      this.textureUtils.generateMipmaps(dstTexture);
    }
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(texture2, renderContext, rectangle) {
    const renderContextData = this.get(renderContext);
    let sourceGPU = null;
    if (renderContext.renderTarget) {
      if (texture2.isDepthTexture) {
        sourceGPU = this.get(renderContext.depthTexture).texture;
      } else {
        sourceGPU = this.get(renderContext.textures[0]).texture;
      }
    } else {
      if (texture2.isDepthTexture) {
        sourceGPU = this.textureUtils.getDepthBuffer(
          renderContext.depth,
          renderContext.stencil
        );
      } else {
        sourceGPU = this.context.getCurrentTexture();
      }
    }
    const destinationGPU = this.get(texture2).texture;
    if (sourceGPU.format !== destinationGPU.format) {
      console.error(
        "WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.",
        sourceGPU.format,
        destinationGPU.format
      );
      return;
    }
    let encoder;
    if (renderContextData.currentPass) {
      renderContextData.currentPass.end();
      encoder = renderContextData.encoder;
    } else {
      encoder = this.device.createCommandEncoder({
        label: "copyFramebufferToTexture_" + texture2.id,
      });
    }
    encoder.copyTextureToTexture(
      {
        texture: sourceGPU,
        origin: [rectangle.x, rectangle.y, 0],
      },
      {
        texture: destinationGPU,
      },
      [rectangle.z, rectangle.w]
    );
    if (renderContextData.currentPass) {
      const { descriptor } = renderContextData;
      for (let i2 = 0; i2 < descriptor.colorAttachments.length; i2++) {
        descriptor.colorAttachments[i2].loadOp = GPULoadOp.Load;
      }
      if (renderContext.depth)
        descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
      if (renderContext.stencil)
        descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
      renderContextData.currentPass = encoder.beginRenderPass(descriptor);
      renderContextData.currentSets = {
        attributes: {},
        bindingGroups: [],
        pipeline: null,
        index: null,
      };
      if (renderContext.viewport) {
        this.updateViewport(renderContext);
      }
      if (renderContext.scissor) {
        const { x, y, width, height } = renderContext.scissorValue;
        renderContextData.currentPass.setScissorRect(x, y, width, height);
      }
    } else {
      this.device.queue.submit([encoder.finish()]);
    }
    if (texture2.generateMipmaps) {
      this.textureUtils.generateMipmaps(texture2);
    }
  }
}
class IESSpotLight extends SpotLight {
  /**
   * Constructs a new IES spot light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(color2, intensity, distance2, angle, penumbra, decay) {
    super(color2, intensity, distance2, angle, penumbra, decay);
    this.iesMap = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.iesMap = source.iesMap;
    return this;
  }
}
class ProjectorLight extends SpotLight {
  /**
   * Constructs a new projector light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(color2, intensity, distance2, angle, penumbra, decay) {
    super(color2, intensity, distance2, angle, penumbra, decay);
    this.aspect = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.aspect = source.aspect;
    return this;
  }
}
class StandardNodeLibrary extends NodeLibrary {
  /**
   * Constructs a new standard node library.
   */
  constructor() {
    super();
    this.addMaterial(MeshPhongNodeMaterial, "MeshPhongMaterial");
    this.addMaterial(MeshStandardNodeMaterial, "MeshStandardMaterial");
    this.addMaterial(MeshPhysicalNodeMaterial, "MeshPhysicalMaterial");
    this.addMaterial(MeshToonNodeMaterial, "MeshToonMaterial");
    this.addMaterial(MeshBasicNodeMaterial, "MeshBasicMaterial");
    this.addMaterial(MeshLambertNodeMaterial, "MeshLambertMaterial");
    this.addMaterial(MeshNormalNodeMaterial, "MeshNormalMaterial");
    this.addMaterial(MeshMatcapNodeMaterial, "MeshMatcapMaterial");
    this.addMaterial(LineBasicNodeMaterial, "LineBasicMaterial");
    this.addMaterial(LineDashedNodeMaterial, "LineDashedMaterial");
    this.addMaterial(PointsNodeMaterial, "PointsMaterial");
    this.addMaterial(SpriteNodeMaterial, "SpriteMaterial");
    this.addMaterial(ShadowNodeMaterial, "ShadowMaterial");
    this.addLight(PointLightNode, PointLight);
    this.addLight(DirectionalLightNode, DirectionalLight);
    this.addLight(RectAreaLightNode, RectAreaLight);
    this.addLight(SpotLightNode, SpotLight);
    this.addLight(AmbientLightNode, AmbientLight);
    this.addLight(HemisphereLightNode, HemisphereLight);
    this.addLight(LightProbeNode, LightProbe);
    this.addLight(IESSpotLightNode, IESSpotLight);
    this.addLight(ProjectorLightNode, ProjectorLight);
    this.addToneMapping(linearToneMapping, LinearToneMapping);
    this.addToneMapping(reinhardToneMapping, ReinhardToneMapping);
    this.addToneMapping(cineonToneMapping, CineonToneMapping);
    this.addToneMapping(acesFilmicToneMapping, ACESFilmicToneMapping);
    this.addToneMapping(agxToneMapping, AgXToneMapping);
    this.addToneMapping(neutralToneMapping, NeutralToneMapping);
  }
}
class WebGPURenderer extends Renderer {
  /**
   * WebGPURenderer options.
   *
   * @typedef {Object} WebGPURenderer~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
   * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.
   * @property {number} [colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best
   * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
   */
  /**
   * Constructs a new WebGPU renderer.
   *
   * @param {WebGPURenderer~Options} [parameters] - The configuration parameter.
   */
  constructor(parameters = {}) {
    let BackendClass;
    if (parameters.forceWebGL) {
      BackendClass = WebGLBackend;
    } else {
      BackendClass = WebGPUBackend;
      parameters.getFallback = () => {
        console.warn(
          "THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend."
        );
        return new WebGLBackend(parameters);
      };
    }
    const backend = new BackendClass(parameters);
    super(backend, parameters);
    this.library = new StandardNodeLibrary();
    this.isWebGPURenderer = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this })
      );
    }
  }
}
class IndirectStorageBufferAttribute extends StorageBufferAttribute {
  /**
   * Constructs a new storage buffer attribute.
   *
   * @param {number|Uint32Array} count - The item count. It is also valid to pass a `Uint32Array` as an argument.
   * The subsequent parameter is then obsolete.
   * @param {number} itemSize - The item size.
   */
  constructor(count, itemSize) {
    super(count, itemSize, Uint32Array);
    this.isIndirectStorageBufferAttribute = true;
  }
}
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
TSL.BRDF_GGX;
TSL.BRDF_Lambert;
TSL.BasicPointShadowFilter;
TSL.BasicShadowFilter;
TSL.Break;
TSL.Const;
TSL.Continue;
TSL.DFGApprox;
TSL.D_GGX;
TSL.Discard;
TSL.EPSILON;
TSL.F_Schlick;
TSL.Fn;
TSL.INFINITY;
TSL.If;
TSL.Loop;
TSL.NodeAccess;
TSL.NodeShaderStage;
TSL.NodeType;
TSL.NodeUpdateType;
TSL.PCFShadowFilter;
TSL.PCFSoftShadowFilter;
TSL.PI;
TSL.PI2;
TSL.PointShadowFilter;
TSL.Return;
TSL.Schlick_to_F0;
TSL.ScriptableNodeResources;
TSL.ShaderNode;
TSL.Stack;
TSL.Switch;
TSL.TBNViewMatrix;
TSL.VSMShadowFilter;
TSL.V_GGX_SmithCorrelated;
TSL.Var;
TSL.VarIntent;
TSL.abs;
TSL.acesFilmicToneMapping;
TSL.acos;
TSL.add;
TSL.addMethodChaining;
TSL.addNodeElement;
TSL.agxToneMapping;
TSL.all;
TSL.alphaT;
TSL.and;
TSL.anisotropy;
TSL.anisotropyB;
TSL.anisotropyT;
TSL.any;
TSL.append;
TSL.array;
TSL.arrayBuffer;
TSL.asin;
TSL.assign;
TSL.atan;
TSL.atan2;
TSL.atomicAdd;
TSL.atomicAnd;
TSL.atomicFunc;
TSL.atomicLoad;
TSL.atomicMax;
TSL.atomicMin;
TSL.atomicOr;
TSL.atomicStore;
TSL.atomicSub;
TSL.atomicXor;
TSL.attenuationColor;
TSL.attenuationDistance;
TSL.attribute;
TSL.attributeArray;
TSL.backgroundBlurriness;
TSL.backgroundIntensity;
TSL.backgroundRotation;
TSL.batch;
TSL.bentNormalView;
TSL.billboarding;
TSL.bitAnd;
TSL.bitNot;
TSL.bitOr;
TSL.bitXor;
TSL.bitangentGeometry;
TSL.bitangentLocal;
TSL.bitangentView;
TSL.bitangentWorld;
TSL.bitcast;
TSL.blendBurn;
TSL.blendColor;
TSL.blendDodge;
TSL.blendOverlay;
TSL.blendScreen;
TSL.blur;
TSL.bool;
TSL.buffer;
TSL.bufferAttribute;
TSL.bumpMap;
TSL.burn;
TSL.bvec2;
TSL.bvec3;
TSL.bvec4;
TSL.bypass;
TSL.cache;
TSL.call;
TSL.cameraFar;
TSL.cameraIndex;
TSL.cameraNear;
TSL.cameraNormalMatrix;
TSL.cameraPosition;
TSL.cameraProjectionMatrix;
TSL.cameraProjectionMatrixInverse;
TSL.cameraViewMatrix;
TSL.cameraWorldMatrix;
TSL.cbrt;
TSL.cdl;
TSL.ceil;
TSL.checker;
TSL.cineonToneMapping;
TSL.clamp;
TSL.clearcoat;
TSL.clearcoatNormalView;
TSL.clearcoatRoughness;
TSL.code;
const color = TSL.color;
TSL.colorSpaceToWorking;
TSL.colorToDirection;
TSL.compute;
TSL.computeKernel;
TSL.computeSkinning;
TSL.context;
TSL.convert;
TSL.convertColorSpace;
TSL.convertToTexture;
TSL.cos;
TSL.cross;
TSL.cubeTexture;
TSL.cubeTextureBase;
TSL.cubeToUV;
TSL.dFdx;
TSL.dFdy;
TSL.dashSize;
TSL.debug;
TSL.decrement;
TSL.decrementBefore;
TSL.defaultBuildStages;
TSL.defaultShaderStages;
TSL.defined;
TSL.degrees;
TSL.deltaTime;
TSL.densityFog;
TSL.densityFogFactor;
TSL.depth;
TSL.depthPass;
TSL.determinant;
TSL.difference;
TSL.diffuseColor;
TSL.directPointLight;
TSL.directionToColor;
TSL.directionToFaceDirection;
TSL.dispersion;
TSL.distance;
TSL.div;
TSL.dodge;
TSL.dot;
TSL.drawIndex;
TSL.dynamicBufferAttribute;
TSL.element;
TSL.emissive;
TSL.equal;
TSL.equals;
TSL.equirectUV;
TSL.exp;
TSL.exp2;
TSL.expression;
TSL.faceDirection;
TSL.faceForward;
TSL.faceforward;
TSL.float;
TSL.floor;
TSL.fog;
TSL.fract;
TSL.frameGroup;
TSL.frameId;
TSL.frontFacing;
TSL.fwidth;
TSL.gain;
TSL.gapSize;
TSL.getConstNodeType;
TSL.getCurrentStack;
TSL.getDirection;
TSL.getDistanceAttenuation;
TSL.getGeometryRoughness;
TSL.getNormalFromDepth;
TSL.getParallaxCorrectNormal;
TSL.getRoughness;
TSL.getScreenPosition;
TSL.getShIrradianceAt;
TSL.getShadowMaterial;
TSL.getShadowRenderObjectFunction;
TSL.getTextureIndex;
TSL.getViewPosition;
TSL.globalId;
TSL.glsl;
TSL.glslFn;
TSL.grayscale;
TSL.greaterThan;
TSL.greaterThanEqual;
TSL.hash;
TSL.highpModelNormalViewMatrix;
TSL.highpModelViewMatrix;
TSL.hue;
TSL.increment;
TSL.incrementBefore;
TSL.instance;
TSL.instanceIndex;
TSL.instancedArray;
TSL.instancedBufferAttribute;
TSL.instancedDynamicBufferAttribute;
TSL.instancedMesh;
TSL.int;
TSL.inverse;
TSL.inverseSqrt;
TSL.inversesqrt;
TSL.invocationLocalIndex;
TSL.invocationSubgroupIndex;
TSL.ior;
TSL.iridescence;
TSL.iridescenceIOR;
TSL.iridescenceThickness;
TSL.ivec2;
TSL.ivec3;
TSL.ivec4;
TSL.js;
TSL.label;
TSL.length;
TSL.lengthSq;
TSL.lessThan;
TSL.lessThanEqual;
TSL.lightPosition;
TSL.lightProjectionUV;
TSL.lightShadowMatrix;
TSL.lightTargetDirection;
TSL.lightTargetPosition;
TSL.lightViewPosition;
TSL.lightingContext;
TSL.lights;
TSL.linearDepth;
TSL.linearToneMapping;
TSL.localId;
TSL.log;
TSL.log2;
TSL.logarithmicDepthToViewZ;
TSL.luminance;
TSL.mat2;
TSL.mat3;
TSL.mat4;
TSL.matcapUV;
TSL.materialAO;
TSL.materialAlphaTest;
TSL.materialAnisotropy;
TSL.materialAnisotropyVector;
TSL.materialAttenuationColor;
TSL.materialAttenuationDistance;
TSL.materialClearcoat;
TSL.materialClearcoatNormal;
TSL.materialClearcoatRoughness;
TSL.materialColor;
TSL.materialDispersion;
TSL.materialEmissive;
TSL.materialEnvIntensity;
TSL.materialEnvRotation;
TSL.materialIOR;
TSL.materialIridescence;
TSL.materialIridescenceIOR;
TSL.materialIridescenceThickness;
TSL.materialLightMap;
TSL.materialLineDashOffset;
TSL.materialLineDashSize;
TSL.materialLineGapSize;
TSL.materialLineScale;
TSL.materialLineWidth;
TSL.materialMetalness;
TSL.materialNormal;
TSL.materialOpacity;
TSL.materialPointSize;
TSL.materialReference;
TSL.materialReflectivity;
TSL.materialRefractionRatio;
TSL.materialRotation;
TSL.materialRoughness;
TSL.materialSheen;
TSL.materialSheenRoughness;
TSL.materialShininess;
TSL.materialSpecular;
TSL.materialSpecularColor;
TSL.materialSpecularIntensity;
TSL.materialSpecularStrength;
TSL.materialThickness;
TSL.materialTransmission;
TSL.max;
TSL.maxMipLevel;
TSL.mediumpModelViewMatrix;
TSL.metalness;
TSL.min;
const mix = TSL.mix;
TSL.mixElement;
TSL.mod;
TSL.modInt;
TSL.modelDirection;
TSL.modelNormalMatrix;
TSL.modelPosition;
TSL.modelRadius;
TSL.modelScale;
TSL.modelViewMatrix;
TSL.modelViewPosition;
TSL.modelViewProjection;
TSL.modelWorldMatrix;
TSL.modelWorldMatrixInverse;
TSL.morphReference;
TSL.mrt;
TSL.mul;
TSL.mx_aastep;
TSL.mx_add;
TSL.mx_atan2;
TSL.mx_cell_noise_float;
TSL.mx_contrast;
TSL.mx_divide;
TSL.mx_fractal_noise_float;
TSL.mx_fractal_noise_vec2;
TSL.mx_fractal_noise_vec3;
TSL.mx_fractal_noise_vec4;
TSL.mx_frame;
TSL.mx_heighttonormal;
TSL.mx_hsvtorgb;
TSL.mx_ifequal;
TSL.mx_ifgreater;
TSL.mx_ifgreatereq;
TSL.mx_invert;
TSL.mx_modulo;
TSL.mx_multiply;
TSL.mx_noise_float;
TSL.mx_noise_vec3;
TSL.mx_noise_vec4;
TSL.mx_place2d;
TSL.mx_power;
TSL.mx_ramp4;
TSL.mx_ramplr;
TSL.mx_ramptb;
TSL.mx_rgbtohsv;
TSL.mx_rotate2d;
TSL.mx_rotate3d;
TSL.mx_safepower;
TSL.mx_separate;
TSL.mx_splitlr;
TSL.mx_splittb;
TSL.mx_srgb_texture_to_lin_rec709;
TSL.mx_subtract;
TSL.mx_timer;
TSL.mx_transform_uv;
TSL.mx_unifiednoise2d;
TSL.mx_unifiednoise3d;
TSL.mx_worley_noise_float;
TSL.mx_worley_noise_vec2;
TSL.mx_worley_noise_vec3;
TSL.negate;
TSL.neutralToneMapping;
TSL.nodeArray;
TSL.nodeImmutable;
TSL.nodeObject;
TSL.nodeObjectIntent;
TSL.nodeObjects;
TSL.nodeProxy;
TSL.nodeProxyIntent;
TSL.normalFlat;
TSL.normalGeometry;
TSL.normalLocal;
TSL.normalMap;
TSL.normalView;
TSL.normalViewGeometry;
TSL.normalWorld;
TSL.normalWorldGeometry;
TSL.normalize;
TSL.not;
TSL.notEqual;
TSL.numWorkgroups;
TSL.objectDirection;
TSL.objectGroup;
TSL.objectPosition;
TSL.objectRadius;
TSL.objectScale;
TSL.objectViewPosition;
TSL.objectWorldMatrix;
TSL.OnObjectUpdate;
TSL.OnMaterialUpdate;
TSL.oneMinus;
TSL.or;
TSL.orthographicDepthToViewZ;
TSL.oscSawtooth;
TSL.oscSine;
TSL.oscSquare;
TSL.oscTriangle;
TSL.output;
TSL.outputStruct;
TSL.overlay;
TSL.overloadingFn;
TSL.parabola;
TSL.parallaxDirection;
TSL.parallaxUV;
TSL.parameter;
TSL.pass;
TSL.passTexture;
TSL.pcurve;
TSL.perspectiveDepthToViewZ;
TSL.pmremTexture;
TSL.pointShadow;
TSL.pointUV;
TSL.pointWidth;
TSL.positionGeometry;
const positionLocal = TSL.positionLocal;
TSL.positionPrevious;
TSL.positionView;
TSL.positionViewDirection;
TSL.positionWorld;
TSL.positionWorldDirection;
TSL.posterize;
TSL.pow;
TSL.pow2;
TSL.pow3;
TSL.pow4;
TSL.premultiplyAlpha;
TSL.property;
TSL.radians;
TSL.rand;
const range = TSL.range;
TSL.rangeFog;
TSL.rangeFogFactor;
TSL.reciprocal;
TSL.reference;
TSL.referenceBuffer;
TSL.reflect;
TSL.reflectVector;
TSL.reflectView;
TSL.reflector;
TSL.refract;
TSL.refractVector;
TSL.refractView;
TSL.reinhardToneMapping;
TSL.remap;
TSL.remapClamp;
TSL.renderGroup;
TSL.renderOutput;
TSL.rendererReference;
TSL.rotate;
const rotateUV = TSL.rotateUV;
TSL.roughness;
TSL.round;
TSL.rtt;
TSL.sRGBTransferEOTF;
TSL.sRGBTransferOETF;
TSL.sample;
TSL.sampler;
TSL.samplerComparison;
TSL.saturate;
TSL.saturation;
TSL.screen;
TSL.screenCoordinate;
TSL.screenSize;
TSL.screenUV;
TSL.scriptable;
TSL.scriptableValue;
TSL.select;
TSL.setCurrentStack;
TSL.setName;
TSL.shaderStages;
TSL.shadow;
TSL.shadowPositionWorld;
TSL.shapeCircle;
TSL.sharedUniformGroup;
TSL.sheen;
TSL.sheenRoughness;
TSL.shiftLeft;
TSL.shiftRight;
TSL.shininess;
TSL.sign;
TSL.sin;
TSL.sinc;
TSL.skinning;
TSL.smoothstep;
TSL.smoothstepElement;
TSL.specularColor;
TSL.specularF90;
TSL.spherizeUV;
TSL.split;
TSL.spritesheetUV;
TSL.sqrt;
TSL.stack;
TSL.step;
TSL.stepElement;
TSL.storage;
TSL.storageBarrier;
TSL.storageObject;
TSL.storageTexture;
TSL.string;
TSL.struct;
TSL.sub;
TSL.subBuild;
TSL.subgroupIndex;
TSL.subgroupSize;
TSL.tan;
TSL.tangentGeometry;
TSL.tangentLocal;
TSL.tangentView;
TSL.tangentWorld;
TSL.temp;
const texture = TSL.texture;
TSL.texture3D;
TSL.textureBarrier;
TSL.textureBicubic;
TSL.textureBicubicLevel;
TSL.textureCubeUV;
TSL.textureLoad;
TSL.textureSize;
TSL.textureStore;
TSL.thickness;
const time = TSL.time;
TSL.timerDelta;
TSL.timerGlobal;
TSL.timerLocal;
TSL.toneMapping;
TSL.toneMappingExposure;
TSL.toonOutlinePass;
TSL.transformDirection;
TSL.transformNormal;
TSL.transformNormalToView;
TSL.transformedClearcoatNormalView;
TSL.transformedNormalView;
TSL.transformedNormalWorld;
TSL.transmission;
TSL.transpose;
TSL.triNoise3D;
TSL.triplanarTexture;
TSL.triplanarTextures;
TSL.trunc;
TSL.uint;
const uniform = TSL.uniform;
TSL.uniformArray;
TSL.uniformCubeTexture;
TSL.uniformGroup;
TSL.uniformTexture;
TSL.unpremultiplyAlpha;
TSL.userData;
const uv = TSL.uv;
TSL.uvec2;
TSL.uvec3;
TSL.uvec4;
TSL.varying;
TSL.varyingProperty;
TSL.vec2;
TSL.vec3;
TSL.vec4;
TSL.vectorComponents;
TSL.velocity;
TSL.vertexColor;
TSL.vertexIndex;
TSL.vertexStage;
TSL.vibrance;
TSL.viewZToLogarithmicDepth;
TSL.viewZToOrthographicDepth;
TSL.viewZToPerspectiveDepth;
TSL.viewport;
TSL.viewportCoordinate;
TSL.viewportDepthTexture;
TSL.viewportLinearDepth;
TSL.viewportMipTexture;
TSL.viewportResolution;
TSL.viewportSafeUV;
TSL.viewportSharedTexture;
TSL.viewportSize;
TSL.viewportTexture;
TSL.viewportUV;
TSL.wgsl;
TSL.wgslFn;
TSL.workgroupArray;
TSL.workgroupBarrier;
TSL.workgroupId;
TSL.workingToColorSpace;
TSL.xor;
/**
 * lil-gui
 * https://lil-gui.georgealways.com
 * @version 0.17.0
 * @author George Michael Brower
 * @license MIT
 */
class t {
  constructor(i2, e2, s2, n2, l2 = "div") {
    (this.parent = i2),
      (this.object = e2),
      (this.property = s2),
      (this._disabled = false),
      (this._hidden = false),
      (this.initialValue = this.getValue()),
      (this.domElement = document.createElement("div")),
      this.domElement.classList.add("controller"),
      this.domElement.classList.add(n2),
      (this.$name = document.createElement("div")),
      this.$name.classList.add("name"),
      (t.nextNameID = t.nextNameID || 0),
      (this.$name.id = "lil-gui-name-" + ++t.nextNameID),
      (this.$widget = document.createElement(l2)),
      this.$widget.classList.add("widget"),
      (this.$disable = this.$widget),
      this.domElement.appendChild(this.$name),
      this.domElement.appendChild(this.$widget),
      this.parent.children.push(this),
      this.parent.controllers.push(this),
      this.parent.$children.appendChild(this.domElement),
      (this._listenCallback = this._listenCallback.bind(this)),
      this.name(s2);
  }
  name(t2) {
    return (this._name = t2), (this.$name.innerHTML = t2), this;
  }
  onChange(t2) {
    return (this._onChange = t2), this;
  }
  _callOnChange() {
    this.parent._callOnChange(this),
      void 0 !== this._onChange && this._onChange.call(this, this.getValue()),
      (this._changed = true);
  }
  onFinishChange(t2) {
    return (this._onFinishChange = t2), this;
  }
  _callOnFinishChange() {
    this._changed &&
      (this.parent._callOnFinishChange(this),
      void 0 !== this._onFinishChange &&
        this._onFinishChange.call(this, this.getValue())),
      (this._changed = false);
  }
  reset() {
    return this.setValue(this.initialValue), this._callOnFinishChange(), this;
  }
  enable(t2 = true) {
    return this.disable(!t2);
  }
  disable(t2 = true) {
    return (
      t2 === this._disabled ||
        ((this._disabled = t2),
        this.domElement.classList.toggle("disabled", t2),
        this.$disable.toggleAttribute("disabled", t2)),
      this
    );
  }
  show(t2 = true) {
    return (
      (this._hidden = !t2),
      (this.domElement.style.display = this._hidden ? "none" : ""),
      this
    );
  }
  hide() {
    return this.show(false);
  }
  options(t2) {
    const i2 = this.parent.add(this.object, this.property, t2);
    return i2.name(this._name), this.destroy(), i2;
  }
  min(t2) {
    return this;
  }
  max(t2) {
    return this;
  }
  step(t2) {
    return this;
  }
  decimals(t2) {
    return this;
  }
  listen(t2 = true) {
    return (
      (this._listening = t2),
      void 0 !== this._listenCallbackID &&
        (cancelAnimationFrame(this._listenCallbackID),
        (this._listenCallbackID = void 0)),
      this._listening && this._listenCallback(),
      this
    );
  }
  _listenCallback() {
    this._listenCallbackID = requestAnimationFrame(this._listenCallback);
    const t2 = this.save();
    t2 !== this._listenPrevValue && this.updateDisplay(),
      (this._listenPrevValue = t2);
  }
  getValue() {
    return this.object[this.property];
  }
  setValue(t2) {
    return (
      (this.object[this.property] = t2),
      this._callOnChange(),
      this.updateDisplay(),
      this
    );
  }
  updateDisplay() {
    return this;
  }
  load(t2) {
    return this.setValue(t2), this._callOnFinishChange(), this;
  }
  save() {
    return this.getValue();
  }
  destroy() {
    this.listen(false),
      this.parent.children.splice(this.parent.children.indexOf(this), 1),
      this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1),
      this.parent.$children.removeChild(this.domElement);
  }
}
class i extends t {
  constructor(t2, i2, e2) {
    super(t2, i2, e2, "boolean", "label"),
      (this.$input = document.createElement("input")),
      this.$input.setAttribute("type", "checkbox"),
      this.$input.setAttribute("aria-labelledby", this.$name.id),
      this.$widget.appendChild(this.$input),
      this.$input.addEventListener("change", () => {
        this.setValue(this.$input.checked), this._callOnFinishChange();
      }),
      (this.$disable = this.$input),
      this.updateDisplay();
  }
  updateDisplay() {
    return (this.$input.checked = this.getValue()), this;
  }
}
function e(t2) {
  let i2, e2;
  return (
    (i2 = t2.match(/(#|0x)?([a-f0-9]{6})/i))
      ? (e2 = i2[2])
      : (i2 = t2.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))
      ? (e2 =
          parseInt(i2[1]).toString(16).padStart(2, 0) +
          parseInt(i2[2]).toString(16).padStart(2, 0) +
          parseInt(i2[3]).toString(16).padStart(2, 0))
      : (i2 = t2.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) &&
        (e2 = i2[1] + i2[1] + i2[2] + i2[2] + i2[3] + i2[3]),
    !!e2 && "#" + e2
  );
}
const s = {
    isPrimitive: true,
    match: (t2) => "string" == typeof t2,
    fromHexString: e,
    toHexString: e,
  },
  n = {
    isPrimitive: true,
    match: (t2) => "number" == typeof t2,
    fromHexString: (t2) => parseInt(t2.substring(1), 16),
    toHexString: (t2) => "#" + t2.toString(16).padStart(6, 0),
  },
  l = {
    isPrimitive: false,
    match: Array.isArray,
    fromHexString(t2, i2, e2 = 1) {
      const s2 = n.fromHexString(t2);
      (i2[0] = (((s2 >> 16) & 255) / 255) * e2),
        (i2[1] = (((s2 >> 8) & 255) / 255) * e2),
        (i2[2] = ((255 & s2) / 255) * e2);
    },
    toHexString: ([t2, i2, e2], s2 = 1) =>
      n.toHexString(
        ((t2 * (s2 = 255 / s2)) << 16) ^ ((i2 * s2) << 8) ^ ((e2 * s2) << 0)
      ),
  },
  r = {
    isPrimitive: false,
    match: (t2) => Object(t2) === t2,
    fromHexString(t2, i2, e2 = 1) {
      const s2 = n.fromHexString(t2);
      (i2.r = (((s2 >> 16) & 255) / 255) * e2),
        (i2.g = (((s2 >> 8) & 255) / 255) * e2),
        (i2.b = ((255 & s2) / 255) * e2);
    },
    toHexString: ({ r: t2, g: i2, b: e2 }, s2 = 1) =>
      n.toHexString(
        ((t2 * (s2 = 255 / s2)) << 16) ^ ((i2 * s2) << 8) ^ ((e2 * s2) << 0)
      ),
  },
  o = [s, n, l, r];
class a extends t {
  constructor(t2, i2, s2, n2) {
    var l2;
    super(t2, i2, s2, "color"),
      (this.$input = document.createElement("input")),
      this.$input.setAttribute("type", "color"),
      this.$input.setAttribute("tabindex", -1),
      this.$input.setAttribute("aria-labelledby", this.$name.id),
      (this.$text = document.createElement("input")),
      this.$text.setAttribute("type", "text"),
      this.$text.setAttribute("spellcheck", "false"),
      this.$text.setAttribute("aria-labelledby", this.$name.id),
      (this.$display = document.createElement("div")),
      this.$display.classList.add("display"),
      this.$display.appendChild(this.$input),
      this.$widget.appendChild(this.$display),
      this.$widget.appendChild(this.$text),
      (this._format = ((l2 = this.initialValue), o.find((t3) => t3.match(l2)))),
      (this._rgbScale = n2),
      (this._initialValueHexString = this.save()),
      (this._textFocused = false),
      this.$input.addEventListener("input", () => {
        this._setValueFromHexString(this.$input.value);
      }),
      this.$input.addEventListener("blur", () => {
        this._callOnFinishChange();
      }),
      this.$text.addEventListener("input", () => {
        const t3 = e(this.$text.value);
        t3 && this._setValueFromHexString(t3);
      }),
      this.$text.addEventListener("focus", () => {
        (this._textFocused = true), this.$text.select();
      }),
      this.$text.addEventListener("blur", () => {
        (this._textFocused = false),
          this.updateDisplay(),
          this._callOnFinishChange();
      }),
      (this.$disable = this.$text),
      this.updateDisplay();
  }
  reset() {
    return this._setValueFromHexString(this._initialValueHexString), this;
  }
  _setValueFromHexString(t2) {
    if (this._format.isPrimitive) {
      const i2 = this._format.fromHexString(t2);
      this.setValue(i2);
    } else
      this._format.fromHexString(t2, this.getValue(), this._rgbScale),
        this._callOnChange(),
        this.updateDisplay();
  }
  save() {
    return this._format.toHexString(this.getValue(), this._rgbScale);
  }
  load(t2) {
    return this._setValueFromHexString(t2), this._callOnFinishChange(), this;
  }
  updateDisplay() {
    return (
      (this.$input.value = this._format.toHexString(
        this.getValue(),
        this._rgbScale
      )),
      this._textFocused || (this.$text.value = this.$input.value.substring(1)),
      (this.$display.style.backgroundColor = this.$input.value),
      this
    );
  }
}
class h extends t {
  constructor(t2, i2, e2) {
    super(t2, i2, e2, "function"),
      (this.$button = document.createElement("button")),
      this.$button.appendChild(this.$name),
      this.$widget.appendChild(this.$button),
      this.$button.addEventListener("click", (t3) => {
        t3.preventDefault(), this.getValue().call(this.object);
      }),
      this.$button.addEventListener("touchstart", () => {}, { passive: true }),
      (this.$disable = this.$button);
  }
}
class d extends t {
  constructor(t2, i2, e2, s2, n2, l2) {
    super(t2, i2, e2, "number"), this._initInput(), this.min(s2), this.max(n2);
    const r2 = void 0 !== l2;
    this.step(r2 ? l2 : this._getImplicitStep(), r2), this.updateDisplay();
  }
  decimals(t2) {
    return (this._decimals = t2), this.updateDisplay(), this;
  }
  min(t2) {
    return (this._min = t2), this._onUpdateMinMax(), this;
  }
  max(t2) {
    return (this._max = t2), this._onUpdateMinMax(), this;
  }
  step(t2, i2 = true) {
    return (this._step = t2), (this._stepExplicit = i2), this;
  }
  updateDisplay() {
    const t2 = this.getValue();
    if (this._hasSlider) {
      let i2 = (t2 - this._min) / (this._max - this._min);
      (i2 = Math.max(0, Math.min(i2, 1))),
        (this.$fill.style.width = 100 * i2 + "%");
    }
    return (
      this._inputFocused ||
        (this.$input.value =
          void 0 === this._decimals ? t2 : t2.toFixed(this._decimals)),
      this
    );
  }
  _initInput() {
    (this.$input = document.createElement("input")),
      this.$input.setAttribute("type", "number"),
      this.$input.setAttribute("step", "any"),
      this.$input.setAttribute("aria-labelledby", this.$name.id),
      this.$widget.appendChild(this.$input),
      (this.$disable = this.$input);
    const t2 = (t3) => {
      const i3 = parseFloat(this.$input.value);
      isNaN(i3) ||
        (this._snapClampSetValue(i3 + t3),
        (this.$input.value = this.getValue()));
    };
    let i2,
      e2,
      s2,
      n2,
      l2,
      r2 = false;
    const o2 = (t3) => {
        if (r2) {
          const s3 = t3.clientX - i2,
            n3 = t3.clientY - e2;
          Math.abs(n3) > 5
            ? (t3.preventDefault(),
              this.$input.blur(),
              (r2 = false),
              this._setDraggingStyle(true, "vertical"))
            : Math.abs(s3) > 5 && a2();
        }
        if (!r2) {
          const i3 = t3.clientY - s2;
          (l2 -= i3 * this._step * this._arrowKeyMultiplier(t3)),
            n2 + l2 > this._max
              ? (l2 = this._max - n2)
              : n2 + l2 < this._min && (l2 = this._min - n2),
            this._snapClampSetValue(n2 + l2);
        }
        s2 = t3.clientY;
      },
      a2 = () => {
        this._setDraggingStyle(false, "vertical"),
          this._callOnFinishChange(),
          window.removeEventListener("mousemove", o2),
          window.removeEventListener("mouseup", a2);
      };
    this.$input.addEventListener("input", () => {
      let t3 = parseFloat(this.$input.value);
      isNaN(t3) ||
        (this._stepExplicit && (t3 = this._snap(t3)),
        this.setValue(this._clamp(t3)));
    }),
      this.$input.addEventListener("keydown", (i3) => {
        "Enter" === i3.code && this.$input.blur(),
          "ArrowUp" === i3.code &&
            (i3.preventDefault(),
            t2(this._step * this._arrowKeyMultiplier(i3))),
          "ArrowDown" === i3.code &&
            (i3.preventDefault(),
            t2(this._step * this._arrowKeyMultiplier(i3) * -1));
      }),
      this.$input.addEventListener(
        "wheel",
        (i3) => {
          this._inputFocused &&
            (i3.preventDefault(),
            t2(this._step * this._normalizeMouseWheel(i3)));
        },
        { passive: false }
      ),
      this.$input.addEventListener("mousedown", (t3) => {
        (i2 = t3.clientX),
          (e2 = s2 = t3.clientY),
          (r2 = true),
          (n2 = this.getValue()),
          (l2 = 0),
          window.addEventListener("mousemove", o2),
          window.addEventListener("mouseup", a2);
      }),
      this.$input.addEventListener("focus", () => {
        this._inputFocused = true;
      }),
      this.$input.addEventListener("blur", () => {
        (this._inputFocused = false),
          this.updateDisplay(),
          this._callOnFinishChange();
      });
  }
  _initSlider() {
    (this._hasSlider = true),
      (this.$slider = document.createElement("div")),
      this.$slider.classList.add("slider"),
      (this.$fill = document.createElement("div")),
      this.$fill.classList.add("fill"),
      this.$slider.appendChild(this.$fill),
      this.$widget.insertBefore(this.$slider, this.$input),
      this.domElement.classList.add("hasSlider");
    const t2 = (t3) => {
        const i3 = this.$slider.getBoundingClientRect();
        let e3 =
          ((s3 = t3),
          (n3 = i3.left),
          (l3 = i3.right),
          (r3 = this._min),
          (o3 = this._max),
          ((s3 - n3) / (l3 - n3)) * (o3 - r3) + r3);
        var s3, n3, l3, r3, o3;
        this._snapClampSetValue(e3);
      },
      i2 = (i3) => {
        t2(i3.clientX);
      },
      e2 = () => {
        this._callOnFinishChange(),
          this._setDraggingStyle(false),
          window.removeEventListener("mousemove", i2),
          window.removeEventListener("mouseup", e2);
      };
    let s2,
      n2,
      l2 = false;
    const r2 = (i3) => {
        i3.preventDefault(),
          this._setDraggingStyle(true),
          t2(i3.touches[0].clientX),
          (l2 = false);
      },
      o2 = (i3) => {
        if (l2) {
          const t3 = i3.touches[0].clientX - s2,
            e3 = i3.touches[0].clientY - n2;
          Math.abs(t3) > Math.abs(e3)
            ? r2(i3)
            : (window.removeEventListener("touchmove", o2),
              window.removeEventListener("touchend", a2));
        } else i3.preventDefault(), t2(i3.touches[0].clientX);
      },
      a2 = () => {
        this._callOnFinishChange(),
          this._setDraggingStyle(false),
          window.removeEventListener("touchmove", o2),
          window.removeEventListener("touchend", a2);
      },
      h2 = this._callOnFinishChange.bind(this);
    let d2;
    this.$slider.addEventListener("mousedown", (s3) => {
      this._setDraggingStyle(true),
        t2(s3.clientX),
        window.addEventListener("mousemove", i2),
        window.addEventListener("mouseup", e2);
    }),
      this.$slider.addEventListener(
        "touchstart",
        (t3) => {
          t3.touches.length > 1 ||
            (this._hasScrollBar
              ? ((s2 = t3.touches[0].clientX),
                (n2 = t3.touches[0].clientY),
                (l2 = true))
              : r2(t3),
            window.addEventListener("touchmove", o2, { passive: false }),
            window.addEventListener("touchend", a2));
        },
        { passive: false }
      ),
      this.$slider.addEventListener(
        "wheel",
        (t3) => {
          if (Math.abs(t3.deltaX) < Math.abs(t3.deltaY) && this._hasScrollBar)
            return;
          t3.preventDefault();
          const i3 = this._normalizeMouseWheel(t3) * this._step;
          this._snapClampSetValue(this.getValue() + i3),
            (this.$input.value = this.getValue()),
            clearTimeout(d2),
            (d2 = setTimeout(h2, 400));
        },
        { passive: false }
      );
  }
  _setDraggingStyle(t2, i2 = "horizontal") {
    this.$slider && this.$slider.classList.toggle("active", t2),
      document.body.classList.toggle("lil-gui-dragging", t2),
      document.body.classList.toggle("lil-gui-" + i2, t2);
  }
  _getImplicitStep() {
    return this._hasMin && this._hasMax ? (this._max - this._min) / 1e3 : 0.1;
  }
  _onUpdateMinMax() {
    !this._hasSlider &&
      this._hasMin &&
      this._hasMax &&
      (this._stepExplicit || this.step(this._getImplicitStep(), false),
      this._initSlider(),
      this.updateDisplay());
  }
  _normalizeMouseWheel(t2) {
    let { deltaX: i2, deltaY: e2 } = t2;
    Math.floor(t2.deltaY) !== t2.deltaY &&
      t2.wheelDelta &&
      ((i2 = 0),
      (e2 = -t2.wheelDelta / 120),
      (e2 *= this._stepExplicit ? 1 : 10));
    return i2 + -e2;
  }
  _arrowKeyMultiplier(t2) {
    let i2 = this._stepExplicit ? 1 : 10;
    return t2.shiftKey ? (i2 *= 10) : t2.altKey && (i2 /= 10), i2;
  }
  _snap(t2) {
    const i2 = Math.round(t2 / this._step) * this._step;
    return parseFloat(i2.toPrecision(15));
  }
  _clamp(t2) {
    return (
      t2 < this._min && (t2 = this._min), t2 > this._max && (t2 = this._max), t2
    );
  }
  _snapClampSetValue(t2) {
    this.setValue(this._clamp(this._snap(t2)));
  }
  get _hasScrollBar() {
    const t2 = this.parent.root.$children;
    return t2.scrollHeight > t2.clientHeight;
  }
  get _hasMin() {
    return void 0 !== this._min;
  }
  get _hasMax() {
    return void 0 !== this._max;
  }
}
class c extends t {
  constructor(t2, i2, e2, s2) {
    super(t2, i2, e2, "option"),
      (this.$select = document.createElement("select")),
      this.$select.setAttribute("aria-labelledby", this.$name.id),
      (this.$display = document.createElement("div")),
      this.$display.classList.add("display"),
      (this._values = Array.isArray(s2) ? s2 : Object.values(s2)),
      (this._names = Array.isArray(s2) ? s2 : Object.keys(s2)),
      this._names.forEach((t3) => {
        const i3 = document.createElement("option");
        (i3.innerHTML = t3), this.$select.appendChild(i3);
      }),
      this.$select.addEventListener("change", () => {
        this.setValue(this._values[this.$select.selectedIndex]),
          this._callOnFinishChange();
      }),
      this.$select.addEventListener("focus", () => {
        this.$display.classList.add("focus");
      }),
      this.$select.addEventListener("blur", () => {
        this.$display.classList.remove("focus");
      }),
      this.$widget.appendChild(this.$select),
      this.$widget.appendChild(this.$display),
      (this.$disable = this.$select),
      this.updateDisplay();
  }
  updateDisplay() {
    const t2 = this.getValue(),
      i2 = this._values.indexOf(t2);
    return (
      (this.$select.selectedIndex = i2),
      (this.$display.innerHTML = -1 === i2 ? t2 : this._names[i2]),
      this
    );
  }
}
class u extends t {
  constructor(t2, i2, e2) {
    super(t2, i2, e2, "string"),
      (this.$input = document.createElement("input")),
      this.$input.setAttribute("type", "text"),
      this.$input.setAttribute("aria-labelledby", this.$name.id),
      this.$input.addEventListener("input", () => {
        this.setValue(this.$input.value);
      }),
      this.$input.addEventListener("keydown", (t3) => {
        "Enter" === t3.code && this.$input.blur();
      }),
      this.$input.addEventListener("blur", () => {
        this._callOnFinishChange();
      }),
      this.$widget.appendChild(this.$input),
      (this.$disable = this.$input),
      this.updateDisplay();
  }
  updateDisplay() {
    return (this.$input.value = this.getValue()), this;
  }
}
let p = false;
class g {
  constructor({
    parent: t2,
    autoPlace: i2 = void 0 === t2,
    container: e2,
    width: s2,
    title: n2 = "Controls",
    injectStyles: l2 = true,
    touchStyles: r2 = true,
  } = {}) {
    if (
      ((this.parent = t2),
      (this.root = t2 ? t2.root : this),
      (this.children = []),
      (this.controllers = []),
      (this.folders = []),
      (this._closed = false),
      (this._hidden = false),
      (this.domElement = document.createElement("div")),
      this.domElement.classList.add("lil-gui"),
      (this.$title = document.createElement("div")),
      this.$title.classList.add("title"),
      this.$title.setAttribute("role", "button"),
      this.$title.setAttribute("aria-expanded", true),
      this.$title.setAttribute("tabindex", 0),
      this.$title.addEventListener("click", () =>
        this.openAnimated(this._closed)
      ),
      this.$title.addEventListener("keydown", (t3) => {
        ("Enter" !== t3.code && "Space" !== t3.code) ||
          (t3.preventDefault(), this.$title.click());
      }),
      this.$title.addEventListener("touchstart", () => {}, { passive: true }),
      (this.$children = document.createElement("div")),
      this.$children.classList.add("children"),
      this.domElement.appendChild(this.$title),
      this.domElement.appendChild(this.$children),
      this.title(n2),
      r2 && this.domElement.classList.add("allow-touch-styles"),
      this.parent)
    )
      return (
        this.parent.children.push(this),
        this.parent.folders.push(this),
        void this.parent.$children.appendChild(this.domElement)
      );
    this.domElement.classList.add("root"),
      !p &&
        l2 &&
        (!(function (t3) {
          const i3 = document.createElement("style");
          i3.innerHTML = t3;
          const e3 = document.querySelector(
            "head link[rel=stylesheet], head style"
          );
          e3
            ? document.head.insertBefore(i3, e3)
            : document.head.appendChild(i3);
        })(
          '.lil-gui{--background-color:#1f1f1f;--text-color:#ebebeb;--title-background-color:#111;--title-text-color:#ebebeb;--widget-color:#424242;--hover-color:#4f4f4f;--focus-color:#595959;--number-color:#2cc9ff;--string-color:#a2db3c;--font-size:11px;--input-font-size:11px;--font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;--font-family-mono:Menlo,Monaco,Consolas,"Droid Sans Mono",monospace;--padding:4px;--spacing:4px;--widget-height:20px;--name-width:45%;--slider-knob-width:2px;--slider-input-width:27%;--color-input-width:27%;--slider-input-min-width:45px;--color-input-min-width:45px;--folder-indent:7px;--widget-padding:0 0 0 3px;--widget-border-radius:2px;--checkbox-size:calc(var(--widget-height)*0.75);--scrollbar-width:5px;background-color:var(--background-color);color:var(--text-color);font-family:var(--font-family);font-size:var(--font-size);font-style:normal;font-weight:400;line-height:1;text-align:left;touch-action:manipulation;user-select:none;-webkit-user-select:none}.lil-gui,.lil-gui *{box-sizing:border-box;margin:0;padding:0}.lil-gui.root{display:flex;flex-direction:column;width:var(--width,245px)}.lil-gui.root>.title{background:var(--title-background-color);color:var(--title-text-color)}.lil-gui.root>.children{overflow-x:hidden;overflow-y:auto}.lil-gui.root>.children::-webkit-scrollbar{background:var(--background-color);height:var(--scrollbar-width);width:var(--scrollbar-width)}.lil-gui.root>.children::-webkit-scrollbar-thumb{background:var(--focus-color);border-radius:var(--scrollbar-width)}.lil-gui.force-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}.lil-gui.autoPlace{max-height:100%;position:fixed;right:15px;top:0;z-index:1001}.lil-gui .controller{align-items:center;display:flex;margin:var(--spacing) 0;padding:0 var(--padding)}.lil-gui .controller.disabled{opacity:.5}.lil-gui .controller.disabled,.lil-gui .controller.disabled *{pointer-events:none!important}.lil-gui .controller>.name{flex-shrink:0;line-height:var(--widget-height);min-width:var(--name-width);padding-right:var(--spacing);white-space:pre}.lil-gui .controller .widget{align-items:center;display:flex;min-height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.string input{color:var(--string-color)}.lil-gui .controller.boolean .widget{cursor:pointer}.lil-gui .controller.color .display{border-radius:var(--widget-border-radius);height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.color input[type=color]{cursor:pointer;height:100%;opacity:0;width:100%}.lil-gui .controller.color input[type=text]{flex-shrink:0;font-family:var(--font-family-mono);margin-left:var(--spacing);min-width:var(--color-input-min-width);width:var(--color-input-width)}.lil-gui .controller.option select{max-width:100%;opacity:0;position:absolute;width:100%}.lil-gui .controller.option .display{background:var(--widget-color);border-radius:var(--widget-border-radius);height:var(--widget-height);line-height:var(--widget-height);max-width:100%;overflow:hidden;padding-left:.55em;padding-right:1.75em;pointer-events:none;position:relative;word-break:break-all}.lil-gui .controller.option .display.active{background:var(--focus-color)}.lil-gui .controller.option .display:after{bottom:0;content:"";font-family:lil-gui;padding-right:.375em;position:absolute;right:0;top:0}.lil-gui .controller.option .widget,.lil-gui .controller.option select{cursor:pointer}.lil-gui .controller.number input{color:var(--number-color)}.lil-gui .controller.number.hasSlider input{flex-shrink:0;margin-left:var(--spacing);min-width:var(--slider-input-min-width);width:var(--slider-input-width)}.lil-gui .controller.number .slider{background-color:var(--widget-color);border-radius:var(--widget-border-radius);cursor:ew-resize;height:var(--widget-height);overflow:hidden;padding-right:var(--slider-knob-width);touch-action:pan-y;width:100%}.lil-gui .controller.number .slider.active{background-color:var(--focus-color)}.lil-gui .controller.number .slider.active .fill{opacity:.95}.lil-gui .controller.number .fill{border-right:var(--slider-knob-width) solid var(--number-color);box-sizing:content-box;height:100%}.lil-gui-dragging .lil-gui{--hover-color:var(--widget-color)}.lil-gui-dragging *{cursor:ew-resize!important}.lil-gui-dragging.lil-gui-vertical *{cursor:ns-resize!important}.lil-gui .title{--title-height:calc(var(--widget-height) + var(--spacing)*1.25);-webkit-tap-highlight-color:transparent;text-decoration-skip:objects;cursor:pointer;font-weight:600;height:var(--title-height);line-height:calc(var(--title-height) - 4px);outline:none;padding:0 var(--padding)}.lil-gui .title:before{content:"";display:inline-block;font-family:lil-gui;padding-right:2px}.lil-gui .title:active{background:var(--title-background-color);opacity:.75}.lil-gui.root>.title:focus{text-decoration:none!important}.lil-gui.closed>.title:before{content:""}.lil-gui.closed>.children{opacity:0;transform:translateY(-7px)}.lil-gui.closed:not(.transition)>.children{display:none}.lil-gui.transition>.children{overflow:hidden;pointer-events:none;transition-duration:.3s;transition-property:height,opacity,transform;transition-timing-function:cubic-bezier(.2,.6,.35,1)}.lil-gui .children:empty:before{content:"Empty";display:block;font-style:italic;height:var(--widget-height);line-height:var(--widget-height);margin:var(--spacing) 0;opacity:.5;padding:0 var(--padding)}.lil-gui.root>.children>.lil-gui>.title{border-width:0;border-bottom:1px solid var(--widget-color);border-left:0 solid var(--widget-color);border-right:0 solid var(--widget-color);border-top:1px solid var(--widget-color);transition:border-color .3s}.lil-gui.root>.children>.lil-gui.closed>.title{border-bottom-color:transparent}.lil-gui+.controller{border-top:1px solid var(--widget-color);margin-top:0;padding-top:var(--spacing)}.lil-gui .lil-gui .lil-gui>.title{border:none}.lil-gui .lil-gui .lil-gui>.children{border:none;border-left:2px solid var(--widget-color);margin-left:var(--folder-indent)}.lil-gui .lil-gui .controller{border:none}.lil-gui input{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:0;border-radius:var(--widget-border-radius);color:var(--text-color);font-family:var(--font-family);font-size:var(--input-font-size);height:var(--widget-height);outline:none;width:100%}.lil-gui input:disabled{opacity:1}.lil-gui input[type=number],.lil-gui input[type=text]{padding:var(--widget-padding)}.lil-gui input[type=number]:focus,.lil-gui input[type=text]:focus{background:var(--focus-color)}.lil-gui input::-webkit-inner-spin-button,.lil-gui input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.lil-gui input[type=number]{-moz-appearance:textfield}.lil-gui input[type=checkbox]{appearance:none;-webkit-appearance:none;border-radius:var(--widget-border-radius);cursor:pointer;height:var(--checkbox-size);text-align:center;width:var(--checkbox-size)}.lil-gui input[type=checkbox]:checked:before{content:"";font-family:lil-gui;font-size:var(--checkbox-size);line-height:var(--checkbox-size)}.lil-gui button{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:1px solid var(--widget-color);border-radius:var(--widget-border-radius);color:var(--text-color);cursor:pointer;font-family:var(--font-family);font-size:var(--font-size);height:var(--widget-height);line-height:calc(var(--widget-height) - 4px);outline:none;text-align:center;text-transform:none;width:100%}.lil-gui button:active{background:var(--focus-color)}@font-face{font-family:lil-gui;src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff")}@media (pointer:coarse){.lil-gui.allow-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}}@media (hover:hover){.lil-gui .controller.color .display:hover:before{border:1px solid #fff9;border-radius:var(--widget-border-radius);bottom:0;content:" ";display:block;left:0;position:absolute;right:0;top:0}.lil-gui .controller.option .display.focus{background:var(--focus-color)}.lil-gui .controller.option .widget:hover .display{background:var(--hover-color)}.lil-gui .controller.number .slider:hover{background-color:var(--hover-color)}body:not(.lil-gui-dragging) .lil-gui .title:hover{background:var(--title-background-color);opacity:.85}.lil-gui .title:focus{text-decoration:underline var(--focus-color)}.lil-gui input:hover{background:var(--hover-color)}.lil-gui input:active{background:var(--focus-color)}.lil-gui input[type=checkbox]:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}.lil-gui button:hover{background:var(--hover-color);border-color:var(--hover-color)}.lil-gui button:focus{border-color:var(--focus-color)}}'
        ),
        (p = true)),
      e2
        ? e2.appendChild(this.domElement)
        : i2 &&
          (this.domElement.classList.add("autoPlace"),
          document.body.appendChild(this.domElement)),
      s2 && this.domElement.style.setProperty("--width", s2 + "px"),
      this.domElement.addEventListener("keydown", (t3) => t3.stopPropagation()),
      this.domElement.addEventListener("keyup", (t3) => t3.stopPropagation());
  }
  add(t2, e2, s2, n2, l2) {
    if (Object(s2) === s2) return new c(this, t2, e2, s2);
    const r2 = t2[e2];
    switch (typeof r2) {
      case "number":
        return new d(this, t2, e2, s2, n2, l2);
      case "boolean":
        return new i(this, t2, e2);
      case "string":
        return new u(this, t2, e2);
      case "function":
        return new h(this, t2, e2);
    }
    console.error(
      "gui.add failed\n	property:",
      e2,
      "\n	object:",
      t2,
      "\n	value:",
      r2
    );
  }
  addColor(t2, i2, e2 = 1) {
    return new a(this, t2, i2, e2);
  }
  addFolder(t2) {
    return new g({ parent: this, title: t2 });
  }
  load(t2, i2 = true) {
    return (
      t2.controllers &&
        this.controllers.forEach((i3) => {
          i3 instanceof h ||
            (i3._name in t2.controllers && i3.load(t2.controllers[i3._name]));
        }),
      i2 &&
        t2.folders &&
        this.folders.forEach((i3) => {
          i3._title in t2.folders && i3.load(t2.folders[i3._title]);
        }),
      this
    );
  }
  save(t2 = true) {
    const i2 = { controllers: {}, folders: {} };
    return (
      this.controllers.forEach((t3) => {
        if (!(t3 instanceof h)) {
          if (t3._name in i2.controllers)
            throw new Error(
              `Cannot save GUI with duplicate property "${t3._name}"`
            );
          i2.controllers[t3._name] = t3.save();
        }
      }),
      t2 &&
        this.folders.forEach((t3) => {
          if (t3._title in i2.folders)
            throw new Error(
              `Cannot save GUI with duplicate folder "${t3._title}"`
            );
          i2.folders[t3._title] = t3.save();
        }),
      i2
    );
  }
  open(t2 = true) {
    return (
      (this._closed = !t2),
      this.$title.setAttribute("aria-expanded", !this._closed),
      this.domElement.classList.toggle("closed", this._closed),
      this
    );
  }
  close() {
    return this.open(false);
  }
  show(t2 = true) {
    return (
      (this._hidden = !t2),
      (this.domElement.style.display = this._hidden ? "none" : ""),
      this
    );
  }
  hide() {
    return this.show(false);
  }
  openAnimated(t2 = true) {
    return (
      (this._closed = !t2),
      this.$title.setAttribute("aria-expanded", !this._closed),
      requestAnimationFrame(() => {
        const i2 = this.$children.clientHeight;
        (this.$children.style.height = i2 + "px"),
          this.domElement.classList.add("transition");
        const e2 = (t3) => {
          t3.target === this.$children &&
            ((this.$children.style.height = ""),
            this.domElement.classList.remove("transition"),
            this.$children.removeEventListener("transitionend", e2));
        };
        this.$children.addEventListener("transitionend", e2);
        const s2 = t2 ? this.$children.scrollHeight : 0;
        this.domElement.classList.toggle("closed", !t2),
          requestAnimationFrame(() => {
            this.$children.style.height = s2 + "px";
          });
      }),
      this
    );
  }
  title(t2) {
    return (this._title = t2), (this.$title.innerHTML = t2), this;
  }
  reset(t2 = true) {
    return (
      (t2 ? this.controllersRecursive() : this.controllers).forEach((t3) =>
        t3.reset()
      ),
      this
    );
  }
  onChange(t2) {
    return (this._onChange = t2), this;
  }
  _callOnChange(t2) {
    this.parent && this.parent._callOnChange(t2),
      void 0 !== this._onChange &&
        this._onChange.call(this, {
          object: t2.object,
          property: t2.property,
          value: t2.getValue(),
          controller: t2,
        });
  }
  onFinishChange(t2) {
    return (this._onFinishChange = t2), this;
  }
  _callOnFinishChange(t2) {
    this.parent && this.parent._callOnFinishChange(t2),
      void 0 !== this._onFinishChange &&
        this._onFinishChange.call(this, {
          object: t2.object,
          property: t2.property,
          value: t2.getValue(),
          controller: t2,
        });
  }
  destroy() {
    this.parent &&
      (this.parent.children.splice(this.parent.children.indexOf(this), 1),
      this.parent.folders.splice(this.parent.folders.indexOf(this), 1)),
      this.domElement.parentElement &&
        this.domElement.parentElement.removeChild(this.domElement),
      Array.from(this.children).forEach((t2) => t2.destroy());
  }
  controllersRecursive() {
    let t2 = Array.from(this.controllers);
    return (
      this.folders.forEach((i2) => {
        t2 = t2.concat(i2.controllersRecursive());
      }),
      t2
    );
  }
  foldersRecursive() {
    let t2 = Array.from(this.folders);
    return (
      this.folders.forEach((i2) => {
        t2 = t2.concat(i2.foldersRecursive());
      }),
      t2
    );
  }
}
const _changeEvent = { type: "change" };
const _startEvent = { type: "start" };
const _endEvent = { type: "end" };
const _ray = new Ray();
const _plane = new Plane();
const _TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);
const _v = new Vector3();
const _twoPI = 2 * Math.PI;
const _STATE = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6,
};
const _EPS = 1e-6;
class OrbitControls extends Controls {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
   */
  constructor(object, domElement = null) {
    super(object, domElement);
    this.state = _STATE.NONE;
    this.target = new Vector3();
    this.cursor = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minTargetRadius = 0;
    this.maxTargetRadius = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.keyRotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.zoomToCursor = false;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = {
      LEFT: "ArrowLeft",
      UP: "ArrowUp",
      RIGHT: "ArrowRight",
      BOTTOM: "ArrowDown",
    };
    this.mouseButtons = {
      LEFT: MOUSE.ROTATE,
      MIDDLE: MOUSE.DOLLY,
      RIGHT: MOUSE.PAN,
    };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this._lastPosition = new Vector3();
    this._lastQuaternion = new Quaternion();
    this._lastTargetPosition = new Vector3();
    this._quat = new Quaternion().setFromUnitVectors(
      object.up,
      new Vector3(0, 1, 0)
    );
    this._quatInverse = this._quat.clone().invert();
    this._spherical = new Spherical();
    this._sphericalDelta = new Spherical();
    this._scale = 1;
    this._panOffset = new Vector3();
    this._rotateStart = new Vector2();
    this._rotateEnd = new Vector2();
    this._rotateDelta = new Vector2();
    this._panStart = new Vector2();
    this._panEnd = new Vector2();
    this._panDelta = new Vector2();
    this._dollyStart = new Vector2();
    this._dollyEnd = new Vector2();
    this._dollyDelta = new Vector2();
    this._dollyDirection = new Vector3();
    this._mouse = new Vector2();
    this._performCursorZoom = false;
    this._pointers = [];
    this._pointerPositions = {};
    this._controlActive = false;
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    this._onContextMenu = onContextMenu.bind(this);
    this._onMouseWheel = onMouseWheel.bind(this);
    this._onKeyDown = onKeyDown.bind(this);
    this._onTouchStart = onTouchStart.bind(this);
    this._onTouchMove = onTouchMove.bind(this);
    this._onMouseDown = onMouseDown.bind(this);
    this._onMouseMove = onMouseMove.bind(this);
    this._interceptControlDown = interceptControlDown.bind(this);
    this._interceptControlUp = interceptControlUp.bind(this);
    if (this.domElement !== null) {
      this.connect(this.domElement);
    }
    this.update();
  }
  connect(element2) {
    super.connect(element2);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointercancel", this._onPointerUp);
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
    this.domElement.addEventListener("wheel", this._onMouseWheel, {
      passive: false,
    });
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keydown", this._interceptControlDown, {
      passive: true,
      capture: true,
    });
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.removeEventListener("pointercancel", this._onPointerUp);
    this.domElement.removeEventListener("wheel", this._onMouseWheel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
    this.stopListenToKeyEvents();
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keydown", this._interceptControlDown, {
      capture: true,
    });
    this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  /**
   * Get the current vertical rotation, in radians.
   *
   * @return {number} The current vertical rotation, in radians.
   */
  getPolarAngle() {
    return this._spherical.phi;
  }
  /**
   * Get the current horizontal rotation, in radians.
   *
   * @return {number} The current horizontal rotation, in radians.
   */
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  /**
   * Returns the distance from the camera to the target.
   *
   * @return {number} The distance from the camera to the target.
   */
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  /**
   * Adds key event listeners to the given DOM element.
   * `window` is a recommended argument for using this method.
   *
   * @param {HTMLDOMElement} domElement - The DOM element
   */
  listenToKeyEvents(domElement) {
    domElement.addEventListener("keydown", this._onKeyDown);
    this._domElementKeyEvents = domElement;
  }
  /**
   * Removes the key event listener previously defined with `listenToKeyEvents()`.
   */
  stopListenToKeyEvents() {
    if (this._domElementKeyEvents !== null) {
      this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown);
      this._domElementKeyEvents = null;
    }
  }
  /**
   * Save the current state of the controls. This can later be recovered with `reset()`.
   */
  saveState() {
    this.target0.copy(this.target);
    this.position0.copy(this.object.position);
    this.zoom0 = this.object.zoom;
  }
  /**
   * Reset the controls to their state from either the last time the `saveState()`
   * was called, or the initial state.
   */
  reset() {
    this.target.copy(this.target0);
    this.object.position.copy(this.position0);
    this.object.zoom = this.zoom0;
    this.object.updateProjectionMatrix();
    this.dispatchEvent(_changeEvent);
    this.update();
    this.state = _STATE.NONE;
  }
  update(deltaTime2 = null) {
    const position = this.object.position;
    _v.copy(position).sub(this.target);
    _v.applyQuaternion(this._quat);
    this._spherical.setFromVector3(_v);
    if (this.autoRotate && this.state === _STATE.NONE) {
      this._rotateLeft(this._getAutoRotationAngle(deltaTime2));
    }
    if (this.enableDamping) {
      this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
      this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;
    } else {
      this._spherical.theta += this._sphericalDelta.theta;
      this._spherical.phi += this._sphericalDelta.phi;
    }
    let min2 = this.minAzimuthAngle;
    let max2 = this.maxAzimuthAngle;
    if (isFinite(min2) && isFinite(max2)) {
      if (min2 < -Math.PI) min2 += _twoPI;
      else if (min2 > Math.PI) min2 -= _twoPI;
      if (max2 < -Math.PI) max2 += _twoPI;
      else if (max2 > Math.PI) max2 -= _twoPI;
      if (min2 <= max2) {
        this._spherical.theta = Math.max(
          min2,
          Math.min(max2, this._spherical.theta)
        );
      } else {
        this._spherical.theta =
          this._spherical.theta > (min2 + max2) / 2
            ? Math.max(min2, this._spherical.theta)
            : Math.min(max2, this._spherical.theta);
      }
    }
    this._spherical.phi = Math.max(
      this.minPolarAngle,
      Math.min(this.maxPolarAngle, this._spherical.phi)
    );
    this._spherical.makeSafe();
    if (this.enableDamping === true) {
      this.target.addScaledVector(this._panOffset, this.dampingFactor);
    } else {
      this.target.add(this._panOffset);
    }
    this.target.sub(this.cursor);
    this.target.clampLength(this.minTargetRadius, this.maxTargetRadius);
    this.target.add(this.cursor);
    let zoomChanged = false;
    if (
      (this.zoomToCursor && this._performCursorZoom) ||
      this.object.isOrthographicCamera
    ) {
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    } else {
      const prevRadius = this._spherical.radius;
      this._spherical.radius = this._clampDistance(
        this._spherical.radius * this._scale
      );
      zoomChanged = prevRadius != this._spherical.radius;
    }
    _v.setFromSpherical(this._spherical);
    _v.applyQuaternion(this._quatInverse);
    position.copy(this.target).add(_v);
    this.object.lookAt(this.target);
    if (this.enableDamping === true) {
      this._sphericalDelta.theta *= 1 - this.dampingFactor;
      this._sphericalDelta.phi *= 1 - this.dampingFactor;
      this._panOffset.multiplyScalar(1 - this.dampingFactor);
    } else {
      this._sphericalDelta.set(0, 0, 0);
      this._panOffset.set(0, 0, 0);
    }
    if (this.zoomToCursor && this._performCursorZoom) {
      let newRadius = null;
      if (this.object.isPerspectiveCamera) {
        const prevRadius = _v.length();
        newRadius = this._clampDistance(prevRadius * this._scale);
        const radiusDelta = prevRadius - newRadius;
        this.object.position.addScaledVector(this._dollyDirection, radiusDelta);
        this.object.updateMatrixWorld();
        zoomChanged = !!radiusDelta;
      } else if (this.object.isOrthographicCamera) {
        const mouseBefore = new Vector3(this._mouse.x, this._mouse.y, 0);
        mouseBefore.unproject(this.object);
        const prevZoom = this.object.zoom;
        this.object.zoom = Math.max(
          this.minZoom,
          Math.min(this.maxZoom, this.object.zoom / this._scale)
        );
        this.object.updateProjectionMatrix();
        zoomChanged = prevZoom !== this.object.zoom;
        const mouseAfter = new Vector3(this._mouse.x, this._mouse.y, 0);
        mouseAfter.unproject(this.object);
        this.object.position.sub(mouseAfter).add(mouseBefore);
        this.object.updateMatrixWorld();
        newRadius = _v.length();
      } else {
        console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
        );
        this.zoomToCursor = false;
      }
      if (newRadius !== null) {
        if (this.screenSpacePanning) {
          this.target
            .set(0, 0, -1)
            .transformDirection(this.object.matrix)
            .multiplyScalar(newRadius)
            .add(this.object.position);
        } else {
          _ray.origin.copy(this.object.position);
          _ray.direction.set(0, 0, -1).transformDirection(this.object.matrix);
          if (Math.abs(this.object.up.dot(_ray.direction)) < _TILT_LIMIT) {
            this.object.lookAt(this.target);
          } else {
            _plane.setFromNormalAndCoplanarPoint(this.object.up, this.target);
            _ray.intersectPlane(_plane, this.target);
          }
        }
      }
    } else if (this.object.isOrthographicCamera) {
      const prevZoom = this.object.zoom;
      this.object.zoom = Math.max(
        this.minZoom,
        Math.min(this.maxZoom, this.object.zoom / this._scale)
      );
      if (prevZoom !== this.object.zoom) {
        this.object.updateProjectionMatrix();
        zoomChanged = true;
      }
    }
    this._scale = 1;
    this._performCursorZoom = false;
    if (
      zoomChanged ||
      this._lastPosition.distanceToSquared(this.object.position) > _EPS ||
      8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > _EPS ||
      this._lastTargetPosition.distanceToSquared(this.target) > _EPS
    ) {
      this.dispatchEvent(_changeEvent);
      this._lastPosition.copy(this.object.position);
      this._lastQuaternion.copy(this.object.quaternion);
      this._lastTargetPosition.copy(this.target);
      return true;
    }
    return false;
  }
  _getAutoRotationAngle(deltaTime2) {
    if (deltaTime2 !== null) {
      return (_twoPI / 60) * this.autoRotateSpeed * deltaTime2;
    } else {
      return (_twoPI / 60 / 60) * this.autoRotateSpeed;
    }
  }
  _getZoomScale(delta) {
    const normalizedDelta = Math.abs(delta * 0.01);
    return Math.pow(0.95, this.zoomSpeed * normalizedDelta);
  }
  _rotateLeft(angle) {
    this._sphericalDelta.theta -= angle;
  }
  _rotateUp(angle) {
    this._sphericalDelta.phi -= angle;
  }
  _panLeft(distance2, objectMatrix) {
    _v.setFromMatrixColumn(objectMatrix, 0);
    _v.multiplyScalar(-distance2);
    this._panOffset.add(_v);
  }
  _panUp(distance2, objectMatrix) {
    if (this.screenSpacePanning === true) {
      _v.setFromMatrixColumn(objectMatrix, 1);
    } else {
      _v.setFromMatrixColumn(objectMatrix, 0);
      _v.crossVectors(this.object.up, _v);
    }
    _v.multiplyScalar(distance2);
    this._panOffset.add(_v);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(deltaX, deltaY) {
    const element2 = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const position = this.object.position;
      _v.copy(position).sub(this.target);
      let targetDistance = _v.length();
      targetDistance *= Math.tan(((this.object.fov / 2) * Math.PI) / 180);
      this._panLeft(
        (2 * deltaX * targetDistance) / element2.clientHeight,
        this.object.matrix
      );
      this._panUp(
        (2 * deltaY * targetDistance) / element2.clientHeight,
        this.object.matrix
      );
    } else if (this.object.isOrthographicCamera) {
      this._panLeft(
        (deltaX * (this.object.right - this.object.left)) /
          this.object.zoom /
          element2.clientWidth,
        this.object.matrix
      );
      this._panUp(
        (deltaY * (this.object.top - this.object.bottom)) /
          this.object.zoom /
          element2.clientHeight,
        this.object.matrix
      );
    } else {
      console.warn(
        "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
      );
      this.enablePan = false;
    }
  }
  _dollyOut(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale /= dollyScale;
    } else {
      console.warn(
        "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
      );
      this.enableZoom = false;
    }
  }
  _dollyIn(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale *= dollyScale;
    } else {
      console.warn(
        "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
      );
      this.enableZoom = false;
    }
  }
  _updateZoomParameters(x, y) {
    if (!this.zoomToCursor) {
      return;
    }
    this._performCursorZoom = true;
    const rect = this.domElement.getBoundingClientRect();
    const dx = x - rect.left;
    const dy = y - rect.top;
    const w = rect.width;
    const h2 = rect.height;
    this._mouse.x = (dx / w) * 2 - 1;
    this._mouse.y = -(dy / h2) * 2 + 1;
    this._dollyDirection
      .set(this._mouse.x, this._mouse.y, 1)
      .unproject(this.object)
      .sub(this.object.position)
      .normalize();
  }
  _clampDistance(dist) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, dist));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(event) {
    this._rotateStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownDolly(event) {
    this._updateZoomParameters(event.clientX, event.clientX);
    this._dollyStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownPan(event) {
    this._panStart.set(event.clientX, event.clientY);
  }
  _handleMouseMoveRotate(event) {
    this._rotateEnd.set(event.clientX, event.clientY);
    this._rotateDelta
      .subVectors(this._rotateEnd, this._rotateStart)
      .multiplyScalar(this.rotateSpeed);
    const element2 = this.domElement;
    this._rotateLeft((_twoPI * this._rotateDelta.x) / element2.clientHeight);
    this._rotateUp((_twoPI * this._rotateDelta.y) / element2.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
    this.update();
  }
  _handleMouseMoveDolly(event) {
    this._dollyEnd.set(event.clientX, event.clientY);
    this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);
    if (this._dollyDelta.y > 0) {
      this._dollyOut(this._getZoomScale(this._dollyDelta.y));
    } else if (this._dollyDelta.y < 0) {
      this._dollyIn(this._getZoomScale(this._dollyDelta.y));
    }
    this._dollyStart.copy(this._dollyEnd);
    this.update();
  }
  _handleMouseMovePan(event) {
    this._panEnd.set(event.clientX, event.clientY);
    this._panDelta
      .subVectors(this._panEnd, this._panStart)
      .multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
    this.update();
  }
  _handleMouseWheel(event) {
    this._updateZoomParameters(event.clientX, event.clientY);
    if (event.deltaY < 0) {
      this._dollyIn(this._getZoomScale(event.deltaY));
    } else if (event.deltaY > 0) {
      this._dollyOut(this._getZoomScale(event.deltaY));
    }
    this.update();
  }
  _handleKeyDown(event) {
    let needsUpdate = false;
    switch (event.code) {
      case this.keys.UP:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateUp(
              (_twoPI * this.keyRotateSpeed) / this.domElement.clientHeight
            );
          }
        } else {
          if (this.enablePan) {
            this._pan(0, this.keyPanSpeed);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.BOTTOM:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateUp(
              (-_twoPI * this.keyRotateSpeed) / this.domElement.clientHeight
            );
          }
        } else {
          if (this.enablePan) {
            this._pan(0, -this.keyPanSpeed);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.LEFT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateLeft(
              (_twoPI * this.keyRotateSpeed) / this.domElement.clientHeight
            );
          }
        } else {
          if (this.enablePan) {
            this._pan(this.keyPanSpeed, 0);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.RIGHT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateLeft(
              (-_twoPI * this.keyRotateSpeed) / this.domElement.clientHeight
            );
          }
        } else {
          if (this.enablePan) {
            this._pan(-this.keyPanSpeed, 0);
          }
        }
        needsUpdate = true;
        break;
    }
    if (needsUpdate) {
      event.preventDefault();
      this.update();
    }
  }
  _handleTouchStartRotate(event) {
    if (this._pointers.length === 1) {
      this._rotateStart.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._rotateStart.set(x, y);
    }
  }
  _handleTouchStartPan(event) {
    if (this._pointers.length === 1) {
      this._panStart.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._panStart.set(x, y);
    }
  }
  _handleTouchStartDolly(event) {
    const position = this._getSecondPointerPosition(event);
    const dx = event.pageX - position.x;
    const dy = event.pageY - position.y;
    const distance2 = Math.sqrt(dx * dx + dy * dy);
    this._dollyStart.set(0, distance2);
  }
  _handleTouchStartDollyPan(event) {
    if (this.enableZoom) this._handleTouchStartDolly(event);
    if (this.enablePan) this._handleTouchStartPan(event);
  }
  _handleTouchStartDollyRotate(event) {
    if (this.enableZoom) this._handleTouchStartDolly(event);
    if (this.enableRotate) this._handleTouchStartRotate(event);
  }
  _handleTouchMoveRotate(event) {
    if (this._pointers.length == 1) {
      this._rotateEnd.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._rotateEnd.set(x, y);
    }
    this._rotateDelta
      .subVectors(this._rotateEnd, this._rotateStart)
      .multiplyScalar(this.rotateSpeed);
    const element2 = this.domElement;
    this._rotateLeft((_twoPI * this._rotateDelta.x) / element2.clientHeight);
    this._rotateUp((_twoPI * this._rotateDelta.y) / element2.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(event) {
    if (this._pointers.length === 1) {
      this._panEnd.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._panEnd.set(x, y);
    }
    this._panDelta
      .subVectors(this._panEnd, this._panStart)
      .multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(event) {
    const position = this._getSecondPointerPosition(event);
    const dx = event.pageX - position.x;
    const dy = event.pageY - position.y;
    const distance2 = Math.sqrt(dx * dx + dy * dy);
    this._dollyEnd.set(0, distance2);
    this._dollyDelta.set(
      0,
      Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)
    );
    this._dollyOut(this._dollyDelta.y);
    this._dollyStart.copy(this._dollyEnd);
    const centerX = (event.pageX + position.x) * 0.5;
    const centerY = (event.pageY + position.y) * 0.5;
    this._updateZoomParameters(centerX, centerY);
  }
  _handleTouchMoveDollyPan(event) {
    if (this.enableZoom) this._handleTouchMoveDolly(event);
    if (this.enablePan) this._handleTouchMovePan(event);
  }
  _handleTouchMoveDollyRotate(event) {
    if (this.enableZoom) this._handleTouchMoveDolly(event);
    if (this.enableRotate) this._handleTouchMoveRotate(event);
  }
  // pointers
  _addPointer(event) {
    this._pointers.push(event.pointerId);
  }
  _removePointer(event) {
    delete this._pointerPositions[event.pointerId];
    for (let i2 = 0; i2 < this._pointers.length; i2++) {
      if (this._pointers[i2] == event.pointerId) {
        this._pointers.splice(i2, 1);
        return;
      }
    }
  }
  _isTrackingPointer(event) {
    for (let i2 = 0; i2 < this._pointers.length; i2++) {
      if (this._pointers[i2] == event.pointerId) return true;
    }
    return false;
  }
  _trackPointer(event) {
    let position = this._pointerPositions[event.pointerId];
    if (position === void 0) {
      position = new Vector2();
      this._pointerPositions[event.pointerId] = position;
    }
    position.set(event.pageX, event.pageY);
  }
  _getSecondPointerPosition(event) {
    const pointerId =
      event.pointerId === this._pointers[0]
        ? this._pointers[1]
        : this._pointers[0];
    return this._pointerPositions[pointerId];
  }
  //
  _customWheelEvent(event) {
    const mode = event.deltaMode;
    const newEvent = {
      clientX: event.clientX,
      clientY: event.clientY,
      deltaY: event.deltaY,
    };
    switch (mode) {
      case 1:
        newEvent.deltaY *= 16;
        break;
      case 2:
        newEvent.deltaY *= 100;
        break;
    }
    if (event.ctrlKey && !this._controlActive) {
      newEvent.deltaY *= 10;
    }
    return newEvent;
  }
}
function onPointerDown(event) {
  if (this.enabled === false) return;
  if (this._pointers.length === 0) {
    this.domElement.setPointerCapture(event.pointerId);
    this.domElement.addEventListener("pointermove", this._onPointerMove);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  if (this._isTrackingPointer(event)) return;
  this._addPointer(event);
  if (event.pointerType === "touch") {
    this._onTouchStart(event);
  } else {
    this._onMouseDown(event);
  }
}
function onPointerMove(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchMove(event);
  } else {
    this._onMouseMove(event);
  }
}
function onPointerUp(event) {
  this._removePointer(event);
  switch (this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(event.pointerId);
      this.domElement.removeEventListener("pointermove", this._onPointerMove);
      this.domElement.removeEventListener("pointerup", this._onPointerUp);
      this.dispatchEvent(_endEvent);
      this.state = _STATE.NONE;
      break;
    case 1:
      const pointerId = this._pointers[0];
      const position = this._pointerPositions[pointerId];
      this._onTouchStart({ pointerId, pageX: position.x, pageY: position.y });
      break;
  }
}
function onMouseDown(event) {
  let mouseAction;
  switch (event.button) {
    case 0:
      mouseAction = this.mouseButtons.LEFT;
      break;
    case 1:
      mouseAction = this.mouseButtons.MIDDLE;
      break;
    case 2:
      mouseAction = this.mouseButtons.RIGHT;
      break;
    default:
      mouseAction = -1;
  }
  switch (mouseAction) {
    case MOUSE.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseDownDolly(event);
      this.state = _STATE.DOLLY;
      break;
    case MOUSE.ROTATE:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(event);
        this.state = _STATE.PAN;
      } else {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(event);
        this.state = _STATE.ROTATE;
      }
      break;
    case MOUSE.PAN:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(event);
        this.state = _STATE.ROTATE;
      } else {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(event);
        this.state = _STATE.PAN;
      }
      break;
    default:
      this.state = _STATE.NONE;
  }
  if (this.state !== _STATE.NONE) {
    this.dispatchEvent(_startEvent);
  }
}
function onMouseMove(event) {
  switch (this.state) {
    case _STATE.ROTATE:
      if (this.enableRotate === false) return;
      this._handleMouseMoveRotate(event);
      break;
    case _STATE.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseMoveDolly(event);
      break;
    case _STATE.PAN:
      if (this.enablePan === false) return;
      this._handleMouseMovePan(event);
      break;
  }
}
function onMouseWheel(event) {
  if (
    this.enabled === false ||
    this.enableZoom === false ||
    this.state !== _STATE.NONE
  )
    return;
  event.preventDefault();
  this.dispatchEvent(_startEvent);
  this._handleMouseWheel(this._customWheelEvent(event));
  this.dispatchEvent(_endEvent);
}
function onKeyDown(event) {
  if (this.enabled === false) return;
  this._handleKeyDown(event);
}
function onTouchStart(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case TOUCH.ROTATE:
          if (this.enableRotate === false) return;
          this._handleTouchStartRotate(event);
          this.state = _STATE.TOUCH_ROTATE;
          break;
        case TOUCH.PAN:
          if (this.enablePan === false) return;
          this._handleTouchStartPan(event);
          this.state = _STATE.TOUCH_PAN;
          break;
        default:
          this.state = _STATE.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case TOUCH.DOLLY_PAN:
          if (this.enableZoom === false && this.enablePan === false) return;
          this._handleTouchStartDollyPan(event);
          this.state = _STATE.TOUCH_DOLLY_PAN;
          break;
        case TOUCH.DOLLY_ROTATE:
          if (this.enableZoom === false && this.enableRotate === false) return;
          this._handleTouchStartDollyRotate(event);
          this.state = _STATE.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = _STATE.NONE;
      }
      break;
    default:
      this.state = _STATE.NONE;
  }
  if (this.state !== _STATE.NONE) {
    this.dispatchEvent(_startEvent);
  }
}
function onTouchMove(event) {
  this._trackPointer(event);
  switch (this.state) {
    case _STATE.TOUCH_ROTATE:
      if (this.enableRotate === false) return;
      this._handleTouchMoveRotate(event);
      this.update();
      break;
    case _STATE.TOUCH_PAN:
      if (this.enablePan === false) return;
      this._handleTouchMovePan(event);
      this.update();
      break;
    case _STATE.TOUCH_DOLLY_PAN:
      if (this.enableZoom === false && this.enablePan === false) return;
      this._handleTouchMoveDollyPan(event);
      this.update();
      break;
    case _STATE.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === false && this.enableRotate === false) return;
      this._handleTouchMoveDollyRotate(event);
      this.update();
      break;
    default:
      this.state = _STATE.NONE;
  }
}
function onContextMenu(event) {
  if (this.enabled === false) return;
  event.preventDefault();
}
function interceptControlDown(event) {
  if (event.key === "Control") {
    this._controlActive = true;
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keyup", this._interceptControlUp, {
      passive: true,
      capture: true,
    });
  }
}
function interceptControlUp(event) {
  if (event.key === "Control") {
    this._controlActive = false;
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keyup", this._interceptControlUp, {
      passive: true,
      capture: true,
    });
  }
}
async function program({
  logger,
  navigator: navigator2,
  context: context2,
  canvas,
}) {
  camera = new PerspectiveCamera(60, 1.5, 1, 5e3);
  camera.position.set(1300, 500, 0);
  scene = new Scene();
  const textureLoader = new TextureLoader();
  const map = textureLoader.load("textures/opengameart/smoke1.png");
  const lifeRange = range(0.1, 1);
  const offsetRange = range(new Vector3(-2, 3, -2), new Vector3(2, 5, 2));
  const speed = uniform(0.2);
  const scaledTime = time.add(5).mul(speed);
  const lifeTime = scaledTime.mul(lifeRange).mod(1);
  const scaleRange = range(0.3, 2);
  const rotateRange = range(0.1, 4);
  const life = lifeTime.div(lifeRange);
  const fakeLightEffect = positionLocal.y.oneMinus().max(0.2);
  const textureNode = texture(map, rotateUV(uv(), scaledTime.mul(rotateRange)));
  const opacityNode = textureNode.a.mul(life.oneMinus());
  const smokeColor = mix(
    color(2888961),
    color(2236962),
    positionLocal.y.mul(3).clamp()
  );
  const smokeNodeMaterial = new SpriteNodeMaterial();
  smokeNodeMaterial.colorNode = mix(
    color(15891724),
    smokeColor,
    life.mul(2.5).min(1)
  ).mul(fakeLightEffect);
  smokeNodeMaterial.opacityNode = opacityNode;
  smokeNodeMaterial.positionNode = offsetRange.mul(lifeTime);
  smokeNodeMaterial.scaleNode = scaleRange.mul(lifeTime.max(0.3));
  smokeNodeMaterial.depthWrite = false;
  const smokeInstancedSprite = new Mesh(
    new PlaneGeometry(1, 1),
    smokeNodeMaterial
  );
  smokeInstancedSprite.scale.setScalar(400);
  smokeInstancedSprite.count = 2e3;
  scene.add(smokeInstancedSprite);
  const fireGeometry = new PlaneGeometry(1, 1);
  const fireCount = 1e3;
  const fireNodeMaterial = new SpriteNodeMaterial();
  fireNodeMaterial.colorNode = mix(color(12005143), color(12005143), life);
  fireNodeMaterial.positionNode = range(
    new Vector3(-1, 1, -1),
    new Vector3(1, 2, 1)
  ).mul(lifeTime);
  fireNodeMaterial.scaleNode = smokeNodeMaterial.scaleNode;
  fireNodeMaterial.opacityNode = opacityNode.mul(0.5);
  fireNodeMaterial.blending = AdditiveBlending;
  fireNodeMaterial.transparent = true;
  fireNodeMaterial.depthWrite = false;
  const fireInstancedSprite = new Mesh(fireGeometry, fireNodeMaterial);
  fireInstancedSprite.scale.setScalar(400);
  fireInstancedSprite.count = fireCount;
  fireInstancedSprite.position.y = -100;
  fireInstancedSprite.renderOrder = 1;
  scene.add(fireInstancedSprite);
  const indexCount = fireGeometry.index.array.length;
  const uint32 = new Uint32Array(5);
  uint32[0] = indexCount;
  uint32[1] = fireCount;
  uint32[2] = 0;
  uint32[3] = 0;
  uint32[4] = 0;
  const indirectAttribute = new IndirectStorageBufferAttribute(uint32, 5);
  fireGeometry.setIndirect(indirectAttribute);
  const helper = new GridHelper(3e3, 40, 3158064, 3158064);
  helper.position.y = -75;
  scene.add(helper);
  const adapter = await navigator2.gpu?.requestAdapter({
    featureLevel: "compatibility",
  });
  const device = await adapter?.requestDevice();
  renderer = new WebGPURenderer({
    antialias: true,
    canvas,
    device,
    context: context2,
  });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(canvas.width, canvas.height);
  controls = new OrbitControls(camera, canvas);
  controls.maxDistance = 2700;
  controls.target.set(0, 500, 0);
  controls.update();
  const gui = new g();
  gui.add(speed, "value", 0, 1, 0.01).name("speed");
  return async () => {
    await renderer.renderAsync(scene, camera);
  };
}
let camera, scene, renderer;
let controls;
export { program };
//# sourceMappingURL=main.js.map
